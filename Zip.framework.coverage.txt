/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/QuickZip.swift:
    1|       |//
    2|       |//  QuickZip.swift
    3|       |//  Zip
    4|       |//
    5|       |//  Created by Roy Marmelstein on 16/01/2016.
    6|       |//  Copyright © 2016 Roy Marmelstein. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Zip {
   12|       |    
   13|       |    //MARK: Quick Unzip
   14|       |    
   15|       |    /**
   16|       |     Quick unzip a file. Unzips to a new folder inside the app's documents folder with the zip file's name.
   17|       |     
   18|       |     - parameter path: Path of zipped file. NSURL.
   19|       |     
   20|       |     - throws: Error if unzipping fails or if file is not found. Can be printed with a description variable.
   21|       |     
   22|       |     - returns: NSURL of the destination folder.
   23|       |     */
   24|      0|    public class func quickUnzipFile(_ path: URL) throws -> URL {
   25|      0|        return try quickUnzipFile(path, progress: nil)
   26|      0|    }
   27|       |    
   28|       |    /**
   29|       |     Quick unzip a file. Unzips to a new folder inside the app's documents folder with the zip file's name.
   30|       |     
   31|       |     - parameter path: Path of zipped file. NSURL.
   32|       |     - parameter progress: A progress closure called after unzipping each file in the archive. Double value betweem 0 and 1.
   33|       |     
   34|       |     - throws: Error if unzipping fails or if file is not found. Can be printed with a description variable.
   35|       |     
   36|       |     - notes: Supports implicit progress composition
   37|       |     
   38|       |     - returns: NSURL of the destination folder.
   39|       |     */
   40|      0|    public class func quickUnzipFile(_ path: URL, progress: ((_ progress: Double) -> ())?) throws -> URL {
   41|      0|        let fileManager = FileManager.default
   42|      0|
   43|      0|        let fileExtension = path.pathExtension
   44|      0|        let fileName = path.lastPathComponent
   45|      0|
   46|      0|        let directoryName = fileName.replacingOccurrences(of: ".\(fileExtension)", with: "")
   47|      0|        let documentsUrl = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0] as URL
   48|      0|        do {
   49|      0|            let destinationUrl = documentsUrl.appendingPathComponent(directoryName, isDirectory: true)
   50|      0|            try self.unzipFile(path, destination: destinationUrl, overwrite: true, password: nil, progress: progress)
   51|      0|            return destinationUrl
   52|      0|        }catch{
   53|      0|            throw(ZipError.unzipFail)
   54|      0|        }
   55|      0|    }
   56|       |    
   57|       |    //MARK: Quick Zip
   58|       |    
   59|       |    /**
   60|       |     Quick zip files.
   61|       |     
   62|       |     - parameter paths: Array of NSURL filepaths.
   63|       |     - parameter fileName: File name for the resulting zip file.
   64|       |     
   65|       |     - throws: Error if zipping fails.
   66|       |     
   67|       |     - notes: Supports implicit progress composition
   68|       |     
   69|       |     - returns: NSURL of the destination folder.
   70|       |     */
   71|      0|    public class func quickZipFiles(_ paths: [URL], fileName: String) throws -> URL {
   72|      0|        return try quickZipFiles(paths, fileName: fileName, progress: nil)
   73|      0|    }
   74|       |    
   75|       |    /**
   76|       |     Quick zip files.
   77|       |     
   78|       |     - parameter paths: Array of NSURL filepaths.
   79|       |     - parameter fileName: File name for the resulting zip file.
   80|       |     - parameter progress: A progress closure called after unzipping each file in the archive. Double value betweem 0 and 1.
   81|       |     
   82|       |     - throws: Error if zipping fails.
   83|       |     
   84|       |     - notes: Supports implicit progress composition
   85|       |     
   86|       |     - returns: NSURL of the destination folder.
   87|       |     */
   88|      0|    public class func quickZipFiles(_ paths: [URL], fileName: String, progress: ((_ progress: Double) -> ())?) throws -> URL {
   89|      0|        let fileManager = FileManager.default
   90|      0|        let documentsUrl = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0] as URL
   91|      0|        let destinationUrl = documentsUrl.appendingPathComponent("\(fileName).zip")
   92|      0|        try self.zipFiles(paths: paths, zipFilePath: destinationUrl, password: nil, progress: progress)
   93|      0|        return destinationUrl
   94|      0|    }
   95|       |    
   96|       |    
   97|       |}

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/Zip.swift:
    1|       |//
    2|       |//  Zip.swift
    3|       |//  Zip
    4|       |//
    5|       |//  Created by Roy Marmelstein on 13/12/2015.
    6|       |//  Copyright © 2015 Roy Marmelstein. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import minizip
   11|       |
   12|       |/// Zip error type
   13|       |public enum ZipError: Error {
   14|       |    /// File not found
   15|       |    case fileNotFound
   16|       |    /// Unzip fail
   17|       |    case unzipFail
   18|       |    /// Zip fail
   19|       |    case zipFail
   20|       |    
   21|       |    /// User readable description
   22|      0|    public var description: String {
   23|      0|        switch self {
   24|      0|        case .fileNotFound: return NSLocalizedString("File not found.", comment: "")
   25|      0|        case .unzipFail: return NSLocalizedString("Failed to unzip file.", comment: "")
   26|      0|        case .zipFail: return NSLocalizedString("Failed to zip file.", comment: "")
   27|      0|        }
   28|      0|    }
   29|       |}
   30|       |
   31|       |public enum ZipCompression: Int {
   32|       |    case NoCompression
   33|       |    case BestSpeed
   34|       |    case DefaultCompression
   35|       |    case BestCompression
   36|       |
   37|      0|    internal var minizipCompression: Int32 {
   38|      0|        switch self {
   39|      0|        case .NoCompression:
   40|      0|            return Z_NO_COMPRESSION
   41|      0|        case .BestSpeed:
   42|      0|            return Z_BEST_SPEED
   43|      0|        case .DefaultCompression:
   44|      0|            return Z_DEFAULT_COMPRESSION
   45|      0|        case .BestCompression:
   46|      0|            return Z_BEST_COMPRESSION
   47|      0|        }
   48|      0|    }
   49|       |}
   50|       |
   51|       |/// Zip class
   52|       |public class Zip {
   53|       |    
   54|       |    /**
   55|       |     Set of vaild file extensions
   56|       |     */
   57|       |    internal static var customFileExtensions: Set<String> = []
   58|       |    
   59|       |    // MARK: Lifecycle
   60|       |    
   61|       |    /**
   62|       |     Init
   63|       |     
   64|       |     - returns: Zip object
   65|       |     */
   66|      0|    public init () {
   67|      0|    }
   68|       |    
   69|       |    // MARK: Unzip
   70|       |    
   71|       |    /**
   72|       |     Unzip file
   73|       |     
   74|       |     - parameter zipFilePath: Local file path of zipped file. NSURL.
   75|       |     - parameter destination: Local file path to unzip to. NSURL.
   76|       |     - parameter overwrite:   Overwrite bool.
   77|       |     - parameter password:    Optional password if file is protected.
   78|       |     - parameter progress: A progress closure called after unzipping each file in the archive. Double value betweem 0 and 1.
   79|       |     
   80|       |     - throws: Error if unzipping fails or if fail is not found. Can be printed with a description variable.
   81|       |     
   82|       |     - notes: Supports implicit progress composition
   83|       |     */
   84|       |    
   85|      0|    public class func unzipFile(_ zipFilePath: URL, destination: URL, overwrite: Bool, password: String?, progress: ((_ progress: Double) -> ())?) throws {
   86|      0|        
   87|      0|        // File manager
   88|      0|        let fileManager = FileManager.default
   89|      0|        
   90|      0|        // Check whether a zip file exists at path.
   91|      0|        let path = zipFilePath.path
   92|      0|        
   93|      0|        if fileManager.fileExists(atPath: path) == false || fileExtensionIsInvalid(zipFilePath.pathExtension) {
   94|      0|            throw ZipError.fileNotFound
   95|      0|        }
   96|      0|        
   97|      0|        // Unzip set up
   98|      0|        var ret: Int32 = 0
   99|      0|        var crc_ret: Int32 = 0
  100|      0|        let bufferSize: UInt32 = 4096
  101|      0|        var buffer = Array<CUnsignedChar>(repeating: 0, count: Int(bufferSize))
  102|      0|        
  103|      0|        // Progress handler set up
  104|      0|        var totalSize: Double = 0.0
  105|      0|        var currentPosition: Double = 0.0
  106|      0|        let fileAttributes = try fileManager.attributesOfItem(atPath: path)
  107|      0|        if let attributeFileSize = fileAttributes[FileAttributeKey.size] as? Double {
  108|      0|            totalSize += attributeFileSize
  109|      0|        }
  110|      0|        
  111|      0|        let progressTracker = Progress(totalUnitCount: Int64(totalSize))
  112|      0|        progressTracker.isCancellable = false
  113|      0|        progressTracker.isPausable = false
  114|      0|        progressTracker.kind = ProgressKind.file
  115|      0|        
  116|      0|        // Begin unzipping
  117|      0|        let zip = unzOpen64(path)
  118|      0|        defer {
  119|      0|            unzClose(zip)
  120|      0|        }
  121|      0|        if unzGoToFirstFile(zip) != UNZ_OK {
  122|      0|            throw ZipError.unzipFail
  123|      0|        }
  124|      0|        repeat {
  125|      0|            if let cPassword = password?.cString(using: String.Encoding.ascii) {
  126|      0|                ret = unzOpenCurrentFilePassword(zip, cPassword)
  127|      0|            }
  128|      0|            else {
  129|      0|                ret = unzOpenCurrentFile(zip);
  130|      0|            }
  131|      0|            if ret != UNZ_OK {
  132|      0|                throw ZipError.unzipFail
  133|      0|            }
  134|      0|            var fileInfo = unz_file_info64()
  135|      0|            memset(&fileInfo, 0, MemoryLayout<unz_file_info>.size)
  136|      0|            ret = unzGetCurrentFileInfo64(zip, &fileInfo, nil, 0, nil, 0, nil, 0)
  137|      0|            if ret != UNZ_OK {
  138|      0|                unzCloseCurrentFile(zip)
  139|      0|                throw ZipError.unzipFail
  140|      0|            }
  141|      0|            currentPosition += Double(fileInfo.compressed_size)
  142|      0|            let fileNameSize = Int(fileInfo.size_filename) + 1
  143|      0|            //let fileName = UnsafeMutablePointer<CChar>(allocatingCapacity: fileNameSize)
  144|      0|            let fileName = UnsafeMutablePointer<CChar>.allocate(capacity: fileNameSize)
  145|      0|
  146|      0|            unzGetCurrentFileInfo64(zip, &fileInfo, fileName, UInt(fileNameSize), nil, 0, nil, 0)
  147|      0|            fileName[Int(fileInfo.size_filename)] = 0
  148|      0|
  149|      0|            var pathString = String(cString: fileName)
  150|      0|            
  151|      0|            guard pathString.characters.count > 0 else {
  152|      0|                throw ZipError.unzipFail
  153|      0|            }
  154|      0|
  155|      0|            var isDirectory = false
  156|      0|            let fileInfoSizeFileName = Int(fileInfo.size_filename-1)
  157|      0|            if (fileName[fileInfoSizeFileName] == "/".cString(using: String.Encoding.utf8)?.first || fileName[fileInfoSizeFileName] == "\\".cString(using: String.Encoding.utf8)?.first) {
  158|      0|                isDirectory = true;
  159|      0|            }
  160|      0|            free(fileName)
  161|      0|            if pathString.rangeOfCharacter(from: CharacterSet(charactersIn: "/\\")) != nil {
  162|      0|                pathString = pathString.replacingOccurrences(of: "\\", with: "/")
  163|      0|            }
  164|      0|
  165|      0|            let fullPath = destination.appendingPathComponent(pathString).path
  166|      0|
  167|      0|            let creationDate = Date()
  168|      0|            let directoryAttributes = [FileAttributeKey.creationDate.rawValue : creationDate,
  169|      0|                                       FileAttributeKey.modificationDate.rawValue : creationDate]
  170|      0|            do {
  171|      0|                if isDirectory {
  172|      0|                    try fileManager.createDirectory(atPath: fullPath, withIntermediateDirectories: true, attributes: directoryAttributes)
  173|      0|                }
  174|      0|                else {
  175|      0|                    let parentDirectory = (fullPath as NSString).deletingLastPathComponent
  176|      0|                    try fileManager.createDirectory(atPath: parentDirectory, withIntermediateDirectories: true, attributes: directoryAttributes)
  177|      0|                }
  178|      0|            } catch {}
  179|      0|            if fileManager.fileExists(atPath: fullPath) && !isDirectory && !overwrite {
  180|      0|                unzCloseCurrentFile(zip)
  181|      0|                ret = unzGoToNextFile(zip)
  182|      0|            }
  183|      0|            var filePointer: UnsafeMutablePointer<FILE>?
  184|      0|            filePointer = fopen(fullPath, "wb")
  185|      0|            while filePointer != nil {
  186|      0|                let readBytes = unzReadCurrentFile(zip, &buffer, bufferSize)
  187|      0|                if readBytes > 0 {
  188|      0|                    fwrite(buffer, Int(readBytes), 1, filePointer)
  189|      0|                }
  190|      0|                else {
  191|      0|                    break
  192|      0|                }
  193|      0|            }
  194|      0|
  195|      0|            fclose(filePointer)
  196|      0|            crc_ret = unzCloseCurrentFile(zip)
  197|      0|            if crc_ret == UNZ_CRCERROR {
  198|      0|                throw ZipError.unzipFail
  199|      0|            }
  200|      0|
  201|      0|            //Set file permissions from current fileInfo
  202|      0|            if fileInfo.external_fa != 0 {
  203|      0|                let permissions = (fileInfo.external_fa >> 16) & 0x1FF
  204|      0|                //We will devifne a valid permission range between Owner read only to full access
  205|      0|                if permissions >= 0o400 && permissions <= 0o777 {
  206|      0|                    do {
  207|      0|                        try fileManager.setAttributes([.posixPermissions : permissions], ofItemAtPath: fullPath)
  208|      0|                    } catch {
  209|      0|                        print("Failed to set permissions to file \(fullPath), error: \(error)")
  210|      0|                    }
  211|      0|                }
  212|      0|            }
  213|      0|
  214|      0|            ret = unzGoToNextFile(zip)
  215|      0|            
  216|      0|            // Update progress handler
  217|      0|            if let progressHandler = progress{
  218|      0|                progressHandler((currentPosition/totalSize))
  219|      0|            }
  220|      0|            
  221|      0|            progressTracker.completedUnitCount = Int64(currentPosition)
  222|      0|            
  223|      0|        } while (ret == UNZ_OK && ret != UNZ_END_OF_LIST_OF_FILE)
  224|      0|        
  225|      0|        // Completed. Update progress handler.
  226|      0|        if let progressHandler = progress{
  227|      0|            progressHandler(1.0)
  228|      0|        }
  229|      0|        
  230|      0|        progressTracker.completedUnitCount = Int64(totalSize)
  231|      0|        
  232|      0|    }
  233|       |    
  234|       |    // MARK: Zip
  235|       |    
  236|       |    
  237|       |    /**
  238|       |     Zip files.
  239|       |     
  240|       |     - parameter paths:       Array of NSURL filepaths.
  241|       |     - parameter zipFilePath: Destination NSURL, should lead to a .zip filepath.
  242|       |     - parameter password:    Password string. Optional.
  243|       |     - parameter compression: Compression strategy
  244|       |     - parameter progress: A progress closure called after unzipping each file in the archive. Double value betweem 0 and 1.
  245|       |     
  246|       |     - throws: Error if zipping fails.
  247|       |     
  248|       |     - notes: Supports implicit progress composition
  249|       |     */
  250|      0|    public class func zipFiles(paths: [URL], zipFilePath: URL, password: String?, compression: ZipCompression = .DefaultCompression, progress: ((_ progress: Double) -> ())?) throws {
  251|      0|        
  252|      0|        // File manager
  253|      0|        let fileManager = FileManager.default
  254|      0|        
  255|      0|        // Check whether a zip file exists at path.
  256|      0|        let destinationPath = zipFilePath.path
  257|      0|        
  258|      0|        // Process zip paths
  259|      0|        let processedPaths = ZipUtilities().processZipPaths(paths)
  260|      0|        
  261|      0|        // Zip set up
  262|      0|        let chunkSize: Int = 16384
  263|      0|        
  264|      0|        // Progress handler set up
  265|      0|        var currentPosition: Double = 0.0
  266|      0|        var totalSize: Double = 0.0
  267|      0|        // Get totalSize for progress handler
  268|      0|        for path in processedPaths {
  269|      0|            do {
  270|      0|                let filePath = path.filePath()
  271|      0|                let fileAttributes = try fileManager.attributesOfItem(atPath: filePath)
  272|      0|                let fileSize = fileAttributes[FileAttributeKey.size] as? Double
  273|      0|                if let fileSize = fileSize {
  274|      0|                    totalSize += fileSize
  275|      0|                }
  276|      0|            }
  277|      0|            catch {}
  278|      0|        }
  279|      0|        
  280|      0|        let progressTracker = Progress(totalUnitCount: Int64(totalSize))
  281|      0|        progressTracker.isCancellable = false
  282|      0|        progressTracker.isPausable = false
  283|      0|        progressTracker.kind = ProgressKind.file
  284|      0|        
  285|      0|        // Begin Zipping
  286|      0|        let zip = zipOpen(destinationPath, APPEND_STATUS_CREATE)
  287|      0|        for path in processedPaths {
  288|      0|            let filePath = path.filePath()
  289|      0|            var isDirectory: ObjCBool = false
  290|      0|            fileManager.fileExists(atPath: filePath, isDirectory: &isDirectory)
  291|      0|            if !isDirectory.boolValue {
  292|      0|                let input = fopen(filePath, "r")
  293|      0|                if input == nil {
  294|      0|                    throw ZipError.zipFail
  295|      0|                }
  296|      0|                let fileName = path.fileName
  297|      0|                var zipInfo: zip_fileinfo = zip_fileinfo(tmz_date: tm_zip(tm_sec: 0, tm_min: 0, tm_hour: 0, tm_mday: 0, tm_mon: 0, tm_year: 0), dosDate: 0, internal_fa: 0, external_fa: 0)
  298|      0|                do {
  299|      0|                    let fileAttributes = try fileManager.attributesOfItem(atPath: filePath)
  300|      0|                    if let fileDate = fileAttributes[FileAttributeKey.modificationDate] as? Date {
  301|      0|                        let components = Calendar.current.dateComponents([.year, .month, .day, .hour, .minute, .second], from: fileDate)
  302|      0|                        zipInfo.tmz_date.tm_sec = UInt32(components.second!)
  303|      0|                        zipInfo.tmz_date.tm_min = UInt32(components.minute!)
  304|      0|                        zipInfo.tmz_date.tm_hour = UInt32(components.hour!)
  305|      0|                        zipInfo.tmz_date.tm_mday = UInt32(components.day!)
  306|      0|                        zipInfo.tmz_date.tm_mon = UInt32(components.month!) - 1
  307|      0|                        zipInfo.tmz_date.tm_year = UInt32(components.year!)
  308|      0|                    }
  309|      0|                    if let fileSize = fileAttributes[FileAttributeKey.size] as? Double {
  310|      0|                        currentPosition += fileSize
  311|      0|                    }
  312|      0|                }
  313|      0|                catch {}
  314|      0|                let buffer = malloc(chunkSize)
  315|      0|                if let password = password, let fileName = fileName {
  316|      0|                    zipOpenNewFileInZip3(zip, fileName, &zipInfo, nil, 0, nil, 0, nil,Z_DEFLATED, compression.minizipCompression, 0, -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, password, 0)
  317|      0|                }
  318|      0|                else if let fileName = fileName {
  319|      0|                    zipOpenNewFileInZip3(zip, fileName, &zipInfo, nil, 0, nil, 0, nil,Z_DEFLATED, compression.minizipCompression, 0, -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY, nil, 0)
  320|      0|                }
  321|      0|                else {
  322|      0|                    throw ZipError.zipFail
  323|      0|                }
  324|      0|                var length: Int = 0
  325|      0|                while (feof(input) == 0) {
  326|      0|                    length = fread(buffer, 1, chunkSize, input)
  327|      0|                    zipWriteInFileInZip(zip, buffer, UInt32(length))
  328|      0|                }
  329|      0|                
  330|      0|                // Update progress handler
  331|      0|                if let progressHandler = progress{
  332|      0|                    progressHandler((currentPosition/totalSize))
  333|      0|                }
  334|      0|                
  335|      0|                progressTracker.completedUnitCount = Int64(currentPosition)
  336|      0|                
  337|      0|                zipCloseFileInZip(zip)
  338|      0|                free(buffer)
  339|      0|                fclose(input)
  340|      0|            }
  341|      0|        }
  342|      0|        zipClose(zip, nil)
  343|      0|        
  344|      0|        // Completed. Update progress handler.
  345|      0|        if let progressHandler = progress{
  346|      0|            progressHandler(1.0)
  347|      0|        }
  348|      0|        
  349|      0|        progressTracker.completedUnitCount = Int64(totalSize)
  350|      0|    }
  351|       |    
  352|       |    /**
  353|       |     Check if file extension is invalid.
  354|       |     
  355|       |     - parameter fileExtension: A file extension.
  356|       |     
  357|       |     - returns: false if the extension is a valid file extension, otherwise true.
  358|       |     */
  359|      0|    internal class func fileExtensionIsInvalid(_ fileExtension: String?) -> Bool {
  360|      0|        
  361|      0|        guard let fileExtension = fileExtension else { return true }
  362|      0|        
  363|      0|        return !isValidFileExtension(fileExtension)
  364|      0|    }
  365|       |    
  366|       |    /**
  367|       |     Add a file extension to the set of custom file extensions
  368|       |     
  369|       |     - parameter fileExtension: A file extension.
  370|       |     */
  371|      0|    public class func addCustomFileExtension(_ fileExtension: String) {
  372|      0|        customFileExtensions.insert(fileExtension)
  373|      0|    }
  374|       |    
  375|       |    /**
  376|       |     Remove a file extension from the set of custom file extensions
  377|       |     
  378|       |     - parameter fileExtension: A file extension.
  379|       |     */
  380|      0|    public class func removeCustomFileExtension(_ fileExtension: String) {
  381|      0|        customFileExtensions.remove(fileExtension)
  382|      0|    }
  383|       |    
  384|       |    /**
  385|       |     Check if a specific file extension is valid
  386|       |     
  387|       |     - parameter fileExtension: A file extension.
  388|       |     
  389|       |     - returns: true if the extension valid, otherwise false.
  390|       |     */
  391|      0|    public class func isValidFileExtension(_ fileExtension: String) -> Bool {
  392|      0|        
  393|      0|        let validFileExtensions: Set<String> = customFileExtensions.union(["zip", "cbz"])
  394|      0|        
  395|      0|        return validFileExtensions.contains(fileExtension)
  396|      0|    }
  397|       |    
  398|       |}

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/ZipUtilities.swift:
    1|       |//
    2|       |//  ZipUtilities.swift
    3|       |//  Zip
    4|       |//
    5|       |//  Created by Roy Marmelstein on 26/01/2016.
    6|       |//  Copyright © 2016 Roy Marmelstein. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |internal class ZipUtilities {
   12|       |    
   13|       |    // File manager
   14|       |    let fileManager = FileManager.default
   15|       |
   16|       |    /**
   17|       |     *  ProcessedFilePath struct
   18|       |     */
   19|       |    internal struct ProcessedFilePath {
   20|       |        let filePathURL: URL
   21|       |        let fileName: String?
   22|       |        
   23|      0|        func filePath() -> String {
   24|      0|            return filePathURL.path
   25|      0|        }
   26|       |    }
   27|       |    
   28|       |    //MARK: Path processing
   29|       |    
   30|       |    /**
   31|       |    Process zip paths
   32|       |    
   33|       |    - parameter paths: Paths as NSURL.
   34|       |    
   35|       |    - returns: Array of ProcessedFilePath structs.
   36|       |    */
   37|      0|    internal func processZipPaths(_ paths: [URL]) -> [ProcessedFilePath]{
   38|      0|        var processedFilePaths = [ProcessedFilePath]()
   39|      0|        for path in paths {
   40|      0|            let filePath = path.path
   41|      0|            var isDirectory: ObjCBool = false
   42|      0|            fileManager.fileExists(atPath: filePath, isDirectory: &isDirectory)
   43|      0|            if !isDirectory.boolValue {
   44|      0|                let processedPath = ProcessedFilePath(filePathURL: path, fileName: path.lastPathComponent)
   45|      0|                processedFilePaths.append(processedPath)
   46|      0|            }
   47|      0|            else {
   48|      0|                let directoryContents = expandDirectoryFilePath(path)
   49|      0|                processedFilePaths.append(contentsOf: directoryContents)
   50|      0|            }
   51|      0|        }
   52|      0|        return processedFilePaths
   53|      0|    }
   54|       |    
   55|       |    
   56|       |    /**
   57|       |     Recursive function to expand directory contents and parse them into ProcessedFilePath structs.
   58|       |     
   59|       |     - parameter directory: Path of folder as NSURL.
   60|       |     
   61|       |     - returns: Array of ProcessedFilePath structs.
   62|       |     */
   63|      0|    internal func expandDirectoryFilePath(_ directory: URL) -> [ProcessedFilePath] {
   64|      0|        var processedFilePaths = [ProcessedFilePath]()
   65|      0|        let directoryPath = directory.path
   66|      0|        if let enumerator = fileManager.enumerator(atPath: directoryPath) {
   67|      0|            while let filePathComponent = enumerator.nextObject() as? String {
   68|      0|                let path = directory.appendingPathComponent(filePathComponent)
   69|      0|                let filePath = path.path
   70|      0|                let directoryName = directory.lastPathComponent
   71|      0|
   72|      0|                var isDirectory: ObjCBool = false
   73|      0|                fileManager.fileExists(atPath: filePath, isDirectory: &isDirectory)
   74|      0|                if !isDirectory.boolValue {
   75|      0|                    let fileName = (directoryName as NSString).appendingPathComponent(filePathComponent)
   76|      0|                    let processedPath = ProcessedFilePath(filePathURL: path, fileName: fileName)
   77|      0|                    processedFilePaths.append(processedPath)
   78|      0|                }
   79|      0|            }
   80|      0|        }
   81|      0|        return processedFilePaths
   82|      0|    }
   83|       |
   84|       |}

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/minizip/crypt.h:
    1|       |/* crypt.h -- base code for traditional PKWARE encryption
    2|       |   Version 1.01e, February 12th, 2005
    3|       |
    4|       |   Copyright (C) 1998-2005 Gilles Vollant
    5|       |   Modifications for Info-ZIP crypting
    6|       |     Copyright (C) 2003 Terry Thorsen
    7|       |
    8|       |   This code is a modified version of crypting code in Info-ZIP distribution
    9|       |
   10|       |   Copyright (C) 1990-2000 Info-ZIP.  All rights reserved.
   11|       |
   12|       |   See the Info-ZIP LICENSE file version 2000-Apr-09 or later for terms of use
   13|       |   which also may be found at: ftp://ftp.info-zip.org/pub/infozip/license.html
   14|       |
   15|       |   The encryption/decryption parts of this source code (as opposed to the
   16|       |   non-echoing password parts) were originally written in Europe. The
   17|       |   whole source package can be freely distributed, including from the USA.
   18|       |   (Prior to January 2000, re-export from the US was a violation of US law.)
   19|       |
   20|       |   This encryption code is a direct transcription of the algorithm from
   21|       |   Roger Schlafly, described by Phil Katz in the file appnote.txt. This
   22|       |   file (appnote.txt) is distributed with the PKZIP program (even in the
   23|       |   version without encryption capabilities).
   24|       |
   25|       |   If you don't need crypting in your application, just define symbols
   26|       |   NOCRYPT and NOUNCRYPT.
   27|       |*/
   28|       |
   29|      0|#define CRC32(c, b) ((*(pcrc_32_tab+(((int)(c) ^ (b)) & 0xff))) ^ ((c) >> 8))
   30|       |
   31|       |/***********************************************************************
   32|       | * Return the next byte in the pseudo-random sequence
   33|       | */
   34|       |static int decrypt_byte(unsigned long* pkeys)
   35|      0|{
   36|      0|    unsigned temp;  /* POTENTIAL BUG:  temp*(temp^1) may overflow in an
   37|      0|                     * unpredictable manner on 16-bit systems; not a problem
   38|      0|                     * with any known compiler so far, though */
   39|      0|
   40|      0|    temp = ((unsigned)(*(pkeys+2)) & 0xffff) | 2;
   41|      0|    return (int)(((temp * (temp ^ 1)) >> 8) & 0xff);
   42|      0|}
  ------------------
  | Unexecuted instantiation: unzip.c:decrypt_byte
  ------------------
  | Unexecuted instantiation: zip.c:decrypt_byte
  ------------------
   43|       |
   44|       |/***********************************************************************
   45|       | * Update the encryption keys with the next byte of plain text
   46|       | */
   47|       |static int update_keys(unsigned long* pkeys, const unsigned long* pcrc_32_tab, int c)
   48|      0|{
   49|      0|    (*(pkeys+0)) = CRC32((*(pkeys+0)), c);
   50|      0|    (*(pkeys+1)) += (*(pkeys+0)) & 0xff;
   51|      0|    (*(pkeys+1)) = (*(pkeys+1)) * 134775813L + 1;
   52|      0|    {
   53|      0|        register int keyshift = (int)((*(pkeys+1)) >> 24);
   54|      0|        (*(pkeys+2)) = CRC32((*(pkeys+2)), keyshift);
   55|      0|    }
   56|      0|    return c;
   57|      0|}
  ------------------
  | Unexecuted instantiation: unzip.c:update_keys
  ------------------
  | Unexecuted instantiation: zip.c:update_keys
  ------------------
   58|       |
   59|       |
   60|       |/***********************************************************************
   61|       | * Initialize the encryption keys and the random header according to
   62|       | * the given password.
   63|       | */
   64|       |static void init_keys(const char* passwd, unsigned long* pkeys, const unsigned long* pcrc_32_tab)
   65|      0|{
   66|      0|    *(pkeys+0) = 305419896L;
   67|      0|    *(pkeys+1) = 591751049L;
   68|      0|    *(pkeys+2) = 878082192L;
   69|      0|    while (*passwd != 0)
   70|      0|    {
   71|      0|        update_keys(pkeys,pcrc_32_tab,(int)*passwd);
   72|      0|        passwd++;
   73|      0|    }
   74|      0|}
  ------------------
  | Unexecuted instantiation: unzip.c:init_keys
  ------------------
  | Unexecuted instantiation: zip.c:init_keys
  ------------------
   75|       |
   76|       |#define zdecode(pkeys,pcrc_32_tab,c) \
   77|      0|    (update_keys(pkeys,pcrc_32_tab,c ^= decrypt_byte(pkeys)))
   78|       |
   79|       |#define zencode(pkeys,pcrc_32_tab,c,t) \
   80|      0|    (t=decrypt_byte(pkeys), update_keys(pkeys,pcrc_32_tab,c), t^(c))
   81|       |
   82|       |#ifdef INCLUDECRYPTINGCODE_IFCRYPTALLOWED
   83|       |
   84|      0|#define RAND_HEAD_LEN  12
   85|       |   /* "last resort" source for second part of crypt seed pattern */
   86|       |#  ifndef ZCR_SEED2
   87|      0|#    define ZCR_SEED2 3141592654UL     /* use PI as default pattern */
   88|       |#  endif
   89|       |
   90|       |static int crypthead(const char* passwd,      /* password string */
   91|       |                     unsigned char* buf,      /* where to write header */
   92|       |                     int bufSize,
   93|       |                     unsigned long* pkeys,
   94|       |                     const unsigned long* pcrc_32_tab,
   95|       |                     unsigned long crcForCrypting)
   96|      0|{
   97|      0|    int n;                                  /* index in random header */
   98|      0|    int t;                                  /* temporary */
   99|      0|    int c;                                  /* random byte */
  100|      0|    unsigned char header[RAND_HEAD_LEN-2];  /* random header */
  101|      0|    static unsigned calls = 0;              /* ensure different random header each time */
  102|      0|
  103|      0|    if (bufSize < RAND_HEAD_LEN)
  104|      0|        return 0;
  105|      0|
  106|      0|    /* First generate RAND_HEAD_LEN-2 random bytes. We encrypt the
  107|      0|     * output of rand() to get less predictability, since rand() is
  108|      0|     * often poorly implemented.
  109|      0|     */
  110|      0|    if (++calls == 1)
  111|      0|    {
  112|      0|        srand((unsigned)(time(NULL) ^ ZCR_SEED2));
  113|      0|    }
  114|      0|    init_keys(passwd, pkeys, pcrc_32_tab);
  115|      0|    for (n = 0; n < RAND_HEAD_LEN-2; n++)
  116|      0|    {
  117|      0|        c = (rand() >> 7) & 0xff;
  118|      0|        header[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, c, t);
  119|      0|    }
  120|      0|    /* Encrypt random header (last two bytes is high word of crc) */
  121|      0|    init_keys(passwd, pkeys, pcrc_32_tab);
  122|      0|    for (n = 0; n < RAND_HEAD_LEN-2; n++)
  123|      0|    {
  124|      0|        buf[n] = (unsigned char)zencode(pkeys, pcrc_32_tab, header[n], t);
  125|      0|    }
  126|      0|    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 16) & 0xff, t);
  127|      0|    buf[n++] = (unsigned char)zencode(pkeys, pcrc_32_tab, (int)(crcForCrypting >> 24) & 0xff, t);
  128|      0|    return n;
  129|      0|}
  130|       |
  131|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/minizip/ioapi.c:
    1|       |/* ioapi.h -- IO base function header for compress/uncompress .zip
    2|       |   part of the MiniZip project
    3|       |
    4|       |   Copyright (C) 1998-2010 Gilles Vollant
    5|       |     http://www.winimage.com/zLibDll/minizip.html
    6|       |   Modifications for Zip64 support
    7|       |     Copyright (C) 2009-2010 Mathias Svensson
    8|       |     http://result42.com
    9|       |
   10|       |   This program is distributed under the terms of the same license as zlib.
   11|       |   See the accompanying LICENSE file for the full text of the license.
   12|       |*/
   13|       |
   14|       |#include <stdlib.h>
   15|       |#include <string.h>
   16|       |
   17|       |#include "ioapi.h"
   18|       |
   19|       |#if defined(_WIN32)
   20|       |#  define snprintf _snprintf
   21|       |#endif
   22|       |
   23|       |#ifdef __APPLE__
   24|       |/* In darwin and perhaps other BSD variants off_t is a 64 bit value, hence no need for specific 64 bit functions */
   25|      0|#  define FOPEN_FUNC(filename, mode) fopen(filename, mode)
   26|      0|#  define FTELLO_FUNC(stream) ftello(stream)
   27|      0|#  define FSEEKO_FUNC(stream, offset, origin) fseeko(stream, offset, origin)
   28|       |#else
   29|       |#  define FOPEN_FUNC(filename, mode) fopen64(filename, mode)
   30|       |#  define FTELLO_FUNC(stream) ftello64(stream)
   31|       |#  define FSEEKO_FUNC(stream, offset, origin) fseeko64(stream, offset, origin)
   32|       |#endif
   33|       |
   34|       |/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */
   35|       |#ifndef SEEK_CUR
   36|       |#  define SEEK_CUR    1
   37|       |#endif
   38|       |#ifndef SEEK_END
   39|       |#  define SEEK_END    2
   40|       |#endif
   41|       |#ifndef SEEK_SET
   42|       |#  define SEEK_SET    0
   43|       |#endif
   44|       |
   45|       |voidpf call_zopen64 (const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode)
   46|      0|{
   47|      0|    if (pfilefunc->zfile_func64.zopen64_file != NULL)
   48|      0|        return (*(pfilefunc->zfile_func64.zopen64_file)) (pfilefunc->zfile_func64.opaque,filename,mode);
   49|      0|    return (*(pfilefunc->zopen32_file))(pfilefunc->zfile_func64.opaque,(const char*)filename,mode);
   50|      0|}
   51|       |
   52|       |voidpf call_zopendisk64 OF((const zlib_filefunc64_32_def* pfilefunc, voidpf filestream, int number_disk, int mode))
   53|      0|{
   54|      0|    if (pfilefunc->zfile_func64.zopendisk64_file != NULL)
   55|      0|        return (*(pfilefunc->zfile_func64.zopendisk64_file)) (pfilefunc->zfile_func64.opaque,filestream,number_disk,mode);
   56|      0|    return (*(pfilefunc->zopendisk32_file))(pfilefunc->zfile_func64.opaque,filestream,number_disk,mode);
   57|      0|}
   58|       |
   59|       |long call_zseek64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin)
   60|      0|{
   61|      0|    uLong offsetTruncated;
   62|      0|    if (pfilefunc->zfile_func64.zseek64_file != NULL)
   63|      0|        return (*(pfilefunc->zfile_func64.zseek64_file)) (pfilefunc->zfile_func64.opaque,filestream,offset,origin);
   64|      0|    offsetTruncated = (uLong)offset;
   65|      0|    if (offsetTruncated != offset)
   66|      0|        return -1;
   67|      0|    return (*(pfilefunc->zseek32_file))(pfilefunc->zfile_func64.opaque,filestream,offsetTruncated,origin);
   68|      0|}
   69|       |
   70|       |ZPOS64_T call_ztell64 (const zlib_filefunc64_32_def* pfilefunc,voidpf filestream)
   71|      0|{
   72|      0|    uLong tell_uLong;
   73|      0|    if (pfilefunc->zfile_func64.zseek64_file != NULL)
   74|      0|        return (*(pfilefunc->zfile_func64.ztell64_file)) (pfilefunc->zfile_func64.opaque,filestream);
   75|      0|    tell_uLong = (*(pfilefunc->ztell32_file))(pfilefunc->zfile_func64.opaque,filestream);
   76|      0|    if ((tell_uLong) == 0xffffffff)
   77|      0|        return (ZPOS64_T)-1;
   78|      0|    return tell_uLong;
   79|      0|}
   80|       |
   81|       |void fill_zlib_filefunc64_32_def_from_filefunc32(zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32)
   82|      0|{
   83|      0|    p_filefunc64_32->zfile_func64.zopen64_file = NULL;
   84|      0|    p_filefunc64_32->zfile_func64.zopendisk64_file = NULL;
   85|      0|    p_filefunc64_32->zopen32_file = p_filefunc32->zopen_file;
   86|      0|    p_filefunc64_32->zopendisk32_file = p_filefunc32->zopendisk_file;
   87|      0|    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
   88|      0|    p_filefunc64_32->zfile_func64.zread_file = p_filefunc32->zread_file;
   89|      0|    p_filefunc64_32->zfile_func64.zwrite_file = p_filefunc32->zwrite_file;
   90|      0|    p_filefunc64_32->zfile_func64.ztell64_file = NULL;
   91|      0|    p_filefunc64_32->zfile_func64.zseek64_file = NULL;
   92|      0|    p_filefunc64_32->zfile_func64.zclose_file = p_filefunc32->zclose_file;
   93|      0|    p_filefunc64_32->zfile_func64.zerror_file = p_filefunc32->zerror_file;
   94|      0|    p_filefunc64_32->zfile_func64.opaque = p_filefunc32->opaque;
   95|      0|    p_filefunc64_32->zseek32_file = p_filefunc32->zseek_file;
   96|      0|    p_filefunc64_32->ztell32_file = p_filefunc32->ztell_file;
   97|      0|}
   98|       |
   99|       |static voidpf  ZCALLBACK fopen_file_func OF((voidpf opaque, const char* filename, int mode));
  100|       |static uLong   ZCALLBACK fread_file_func OF((voidpf opaque, voidpf stream, void* buf, uLong size));
  101|       |static uLong   ZCALLBACK fwrite_file_func OF((voidpf opaque, voidpf stream, const void* buf,uLong size));
  102|       |static ZPOS64_T ZCALLBACK ftell64_file_func OF((voidpf opaque, voidpf stream));
  103|       |static long    ZCALLBACK fseek64_file_func OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
  104|       |static int     ZCALLBACK fclose_file_func OF((voidpf opaque, voidpf stream));
  105|       |static int     ZCALLBACK ferror_file_func OF((voidpf opaque, voidpf stream));
  106|       |
  107|       |typedef struct 
  108|       |{
  109|       |    FILE *file;
  110|       |    int filenameLength;
  111|       |    void *filename;
  112|       |} FILE_IOPOSIX;
  113|       |
  114|       |static voidpf file_build_ioposix(FILE *file, const char *filename)
  115|      0|{
  116|      0|    FILE_IOPOSIX *ioposix = NULL;
  117|      0|    if (file == NULL)
  118|      0|        return NULL;
  119|      0|    ioposix = (FILE_IOPOSIX*)malloc(sizeof(FILE_IOPOSIX));
  120|      0|    ioposix->file = file;
  121|      0|    ioposix->filenameLength = (int)strlen(filename) + 1;
  122|      0|    ioposix->filename = (char*)malloc(ioposix->filenameLength * sizeof(char));
  123|      0|    strncpy(ioposix->filename, filename, ioposix->filenameLength);
  124|      0|    return (voidpf)ioposix;
  125|      0|}
  126|       |
  127|       |static voidpf ZCALLBACK fopen_file_func (voidpf opaque, const char* filename, int mode)
  128|      0|{
  129|      0|    FILE* file = NULL;
  130|      0|    const char* mode_fopen = NULL;
  131|      0|    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER) == ZLIB_FILEFUNC_MODE_READ)
  132|      0|        mode_fopen = "rb";
  133|      0|    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
  134|      0|        mode_fopen = "r+b";
  135|      0|    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
  136|      0|        mode_fopen = "wb";
  137|      0|
  138|      0|    if ((filename != NULL) && (mode_fopen != NULL))
  139|      0|    {
  140|      0|        file = fopen(filename, mode_fopen);
  141|      0|        return file_build_ioposix(file, filename);
  142|      0|    }
  143|      0|    return file;
  144|      0|}
  145|       |
  146|       |static voidpf ZCALLBACK fopen64_file_func (voidpf opaque, const void* filename, int mode)
  147|      0|{
  148|      0|    FILE* file = NULL;
  149|      0|    const char* mode_fopen = NULL;
  150|      0|    if ((mode & ZLIB_FILEFUNC_MODE_READWRITEFILTER) == ZLIB_FILEFUNC_MODE_READ)
  151|      0|        mode_fopen = "rb";
  152|      0|    else if (mode & ZLIB_FILEFUNC_MODE_EXISTING)
  153|      0|        mode_fopen = "r+b";
  154|      0|    else if (mode & ZLIB_FILEFUNC_MODE_CREATE)
  155|      0|        mode_fopen = "wb";
  156|      0|
  157|      0|    if ((filename != NULL) && (mode_fopen != NULL))
  158|      0|    {
  159|      0|        file = FOPEN_FUNC((const char*)filename, mode_fopen);
  160|      0|        return file_build_ioposix(file, (const char*)filename);
  161|      0|    }
  162|      0|    return file;
  163|      0|}
  164|       |
  165|       |static voidpf ZCALLBACK fopendisk64_file_func (voidpf opaque, voidpf stream, int number_disk, int mode)
  166|      0|{
  167|      0|    FILE_IOPOSIX *ioposix = NULL;
  168|      0|    char *diskFilename = NULL;
  169|      0|    voidpf ret = NULL;
  170|      0|    int i = 0;
  171|      0|
  172|      0|    if (stream == NULL)
  173|      0|        return NULL;
  174|      0|    ioposix = (FILE_IOPOSIX*)stream;
  175|      0|    diskFilename = (char*)malloc(ioposix->filenameLength * sizeof(char));
  176|      0|    strncpy(diskFilename, ioposix->filename, ioposix->filenameLength);
  177|      0|    for (i = ioposix->filenameLength - 1; i >= 0; i -= 1)
  178|      0|    {
  179|      0|        if (diskFilename[i] != '.')
  180|      0|            continue;
  181|      0|        snprintf(&diskFilename[i], ioposix->filenameLength - i, ".z%02d", number_disk + 1);
  182|      0|        break;
  183|      0|    }
  184|      0|    if (i >= 0)
  185|      0|        ret = fopen64_file_func(opaque, diskFilename, mode);
  186|      0|    free(diskFilename);
  187|      0|    return ret;
  188|      0|}
  189|       |
  190|       |static voidpf ZCALLBACK fopendisk_file_func (voidpf opaque, voidpf stream, int number_disk, int mode)
  191|      0|{
  192|      0|    FILE_IOPOSIX *ioposix = NULL;
  193|      0|    char *diskFilename = NULL;
  194|      0|    voidpf ret = NULL;
  195|      0|    int i = 0;
  196|      0|
  197|      0|    if (stream == NULL)
  198|      0|        return NULL;
  199|      0|    ioposix = (FILE_IOPOSIX*)stream;
  200|      0|    diskFilename = (char*)malloc(ioposix->filenameLength * sizeof(char));
  201|      0|    strncpy(diskFilename, ioposix->filename, ioposix->filenameLength);
  202|      0|    for (i = ioposix->filenameLength - 1; i >= 0; i -= 1)
  203|      0|    {
  204|      0|        if (diskFilename[i] != '.')
  205|      0|            continue;
  206|      0|        snprintf(&diskFilename[i], ioposix->filenameLength - i, ".z%02d", number_disk + 1);
  207|      0|        break;
  208|      0|    }
  209|      0|    if (i >= 0)
  210|      0|        ret = fopen_file_func(opaque, diskFilename, mode);
  211|      0|    free(diskFilename);
  212|      0|    return ret;
  213|      0|}
  214|       |
  215|       |static uLong ZCALLBACK fread_file_func (voidpf opaque, voidpf stream, void* buf, uLong size)
  216|      0|{
  217|      0|    FILE_IOPOSIX *ioposix = NULL;
  218|      0|    uLong ret;
  219|      0|    if (stream == NULL)
  220|      0|        return -1;
  221|      0|    ioposix = (FILE_IOPOSIX*)stream;
  222|      0|    ret = (uLong)fread(buf, 1, (size_t)size, ioposix->file);
  223|      0|    return ret;
  224|      0|}
  225|       |
  226|       |static uLong ZCALLBACK fwrite_file_func (voidpf opaque, voidpf stream, const void* buf, uLong size)
  227|      0|{
  228|      0|    FILE_IOPOSIX *ioposix = NULL;
  229|      0|    uLong ret;
  230|      0|    if (stream == NULL)
  231|      0|        return -1;
  232|      0|    ioposix = (FILE_IOPOSIX*)stream;
  233|      0|    ret = (uLong)fwrite(buf, 1, (size_t)size, ioposix->file);
  234|      0|    return ret;
  235|      0|}
  236|       |
  237|       |static long ZCALLBACK ftell_file_func (voidpf opaque, voidpf stream)
  238|      0|{
  239|      0|    FILE_IOPOSIX *ioposix = NULL;
  240|      0|    long ret = -1;
  241|      0|    if (stream == NULL)
  242|      0|        return ret;
  243|      0|    ioposix = (FILE_IOPOSIX*)stream;
  244|      0|    ret = ftell(ioposix->file);
  245|      0|    return ret;
  246|      0|}
  247|       |
  248|       |static ZPOS64_T ZCALLBACK ftell64_file_func (voidpf opaque, voidpf stream)
  249|      0|{
  250|      0|    FILE_IOPOSIX *ioposix = NULL;
  251|      0|    ZPOS64_T ret = -1;
  252|      0|    if (stream == NULL)
  253|      0|        return ret;
  254|      0|    ioposix = (FILE_IOPOSIX*)stream;
  255|      0|    ret = FTELLO_FUNC(ioposix->file);
  256|      0|    return ret;
  257|      0|}
  258|       |
  259|       |static long ZCALLBACK fseek_file_func (voidpf opaque, voidpf stream, uLong offset, int origin)
  260|      0|{
  261|      0|    FILE_IOPOSIX *ioposix = NULL;
  262|      0|    int fseek_origin = 0;
  263|      0|    long ret = 0;
  264|      0|
  265|      0|    if (stream == NULL)
  266|      0|        return -1;
  267|      0|    ioposix = (FILE_IOPOSIX*)stream;
  268|      0|
  269|      0|    switch (origin)
  270|      0|    {
  271|      0|        case ZLIB_FILEFUNC_SEEK_CUR:
  272|      0|            fseek_origin = SEEK_CUR;
  273|      0|            break;
  274|      0|        case ZLIB_FILEFUNC_SEEK_END:
  275|      0|            fseek_origin = SEEK_END;
  276|      0|            break;
  277|      0|        case ZLIB_FILEFUNC_SEEK_SET:
  278|      0|            fseek_origin = SEEK_SET;
  279|      0|            break;
  280|      0|        default:
  281|      0|            return -1;
  282|      0|    }
  283|      0|    if (fseek(ioposix->file, offset, fseek_origin) != 0)
  284|      0|        ret = -1;
  285|      0|    return ret;
  286|      0|}
  287|       |
  288|       |static long ZCALLBACK fseek64_file_func (voidpf opaque, voidpf stream, ZPOS64_T offset, int origin)
  289|      0|{
  290|      0|    FILE_IOPOSIX *ioposix = NULL;
  291|      0|    int fseek_origin = 0;
  292|      0|    long ret = 0;
  293|      0|
  294|      0|    if (stream == NULL)
  295|      0|        return -1;
  296|      0|    ioposix = (FILE_IOPOSIX*)stream;
  297|      0|
  298|      0|    switch (origin)
  299|      0|    {
  300|      0|        case ZLIB_FILEFUNC_SEEK_CUR:
  301|      0|            fseek_origin = SEEK_CUR;
  302|      0|            break;
  303|      0|        case ZLIB_FILEFUNC_SEEK_END:
  304|      0|            fseek_origin = SEEK_END;
  305|      0|            break;
  306|      0|        case ZLIB_FILEFUNC_SEEK_SET:
  307|      0|            fseek_origin = SEEK_SET;
  308|      0|            break;
  309|      0|        default:
  310|      0|            return -1;
  311|      0|    }
  312|      0|
  313|      0|    if(FSEEKO_FUNC(ioposix->file, offset, fseek_origin) != 0)
  314|      0|        ret = -1;
  315|      0|
  316|      0|    return ret;
  317|      0|}
  318|       |
  319|       |
  320|       |static int ZCALLBACK fclose_file_func (voidpf opaque, voidpf stream)
  321|      0|{
  322|      0|    FILE_IOPOSIX *ioposix = NULL;
  323|      0|    int ret = -1;
  324|      0|    if (stream == NULL)
  325|      0|        return ret;
  326|      0|    ioposix = (FILE_IOPOSIX*)stream;
  327|      0|    if (ioposix->filename != NULL)
  328|      0|        free(ioposix->filename);
  329|      0|    ret = fclose(ioposix->file);
  330|      0|    free(ioposix);
  331|      0|    return ret;
  332|      0|}
  333|       |
  334|       |static int ZCALLBACK ferror_file_func (voidpf opaque, voidpf stream)
  335|      0|{
  336|      0|    FILE_IOPOSIX *ioposix = NULL;
  337|      0|    int ret = -1;
  338|      0|    if (stream == NULL)
  339|      0|        return ret;
  340|      0|    ioposix = (FILE_IOPOSIX*)stream;
  341|      0|    ret = ferror(ioposix->file);
  342|      0|    return ret;
  343|      0|}
  344|       |
  345|       |void fill_fopen_filefunc (zlib_filefunc_def* pzlib_filefunc_def)
  346|      0|{
  347|      0|    pzlib_filefunc_def->zopen_file = fopen_file_func;
  348|      0|    pzlib_filefunc_def->zopendisk_file = fopendisk_file_func;
  349|      0|    pzlib_filefunc_def->zread_file = fread_file_func;
  350|      0|    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
  351|      0|    pzlib_filefunc_def->ztell_file = ftell_file_func;
  352|      0|    pzlib_filefunc_def->zseek_file = fseek_file_func;
  353|      0|    pzlib_filefunc_def->zclose_file = fclose_file_func;
  354|      0|    pzlib_filefunc_def->zerror_file = ferror_file_func;
  355|      0|    pzlib_filefunc_def->opaque = NULL;
  356|      0|}
  357|       |
  358|       |void fill_fopen64_filefunc (zlib_filefunc64_def* pzlib_filefunc_def)
  359|      0|{
  360|      0|    pzlib_filefunc_def->zopen64_file = fopen64_file_func;
  361|      0|    pzlib_filefunc_def->zopendisk64_file = fopendisk64_file_func;
  362|      0|    pzlib_filefunc_def->zread_file = fread_file_func;
  363|      0|    pzlib_filefunc_def->zwrite_file = fwrite_file_func;
  364|      0|    pzlib_filefunc_def->ztell64_file = ftell64_file_func;
  365|      0|    pzlib_filefunc_def->zseek64_file = fseek64_file_func;
  366|      0|    pzlib_filefunc_def->zclose_file = fclose_file_func;
  367|      0|    pzlib_filefunc_def->zerror_file = ferror_file_func;
  368|      0|    pzlib_filefunc_def->opaque = NULL;
  369|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/minizip/ioapi.h:
    1|       |/* ioapi.h -- IO base function header for compress/uncompress .zip
    2|       |   part of the MiniZip project
    3|       |
    4|       |   Copyright (C) 1998-2010 Gilles Vollant
    5|       |     http://www.winimage.com/zLibDll/minizip.html
    6|       |   Modifications for Zip64 support
    7|       |     Copyright (C) 2009-2010 Mathias Svensson
    8|       |     http://result42.com
    9|       |
   10|       |   This program is distributed under the terms of the same license as zlib.
   11|       |   See the accompanying LICENSE file for the full text of the license.
   12|       |*/
   13|       |
   14|       |#ifndef _ZLIBIOAPI64_H
   15|       |#define _ZLIBIOAPI64_H
   16|       |
   17|       |#if (!defined(_WIN32)) && (!defined(WIN32)) && (!defined(__APPLE__))
   18|       |#  ifndef __USE_FILE_OFFSET64
   19|       |#    define __USE_FILE_OFFSET64
   20|       |#  endif
   21|       |#  ifndef __USE_LARGEFILE64
   22|       |#    define __USE_LARGEFILE64
   23|       |#  endif
   24|       |#  ifndef _LARGEFILE64_SOURCE
   25|       |#    define _LARGEFILE64_SOURCE
   26|       |#  endif
   27|       |#  ifndef _FILE_OFFSET_BIT
   28|       |#    define _FILE_OFFSET_BIT 64
   29|       |#  endif
   30|       |#endif
   31|       |
   32|       |#include <stdio.h>
   33|       |#include <stdlib.h>
   34|       |#include "zlib.h"
   35|       |
   36|       |#if defined(USE_FILE32API)
   37|       |#  define fopen64 fopen
   38|       |#  define ftello64 ftell
   39|       |#  define fseeko64 fseek
   40|       |#else
   41|       |#  if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__OpenBSD__)
   42|       |#    define fopen64 fopen
   43|       |#    define ftello64 ftello
   44|       |#    define fseeko64 fseeko
   45|       |#  endif
   46|       |#  ifdef _MSC_VER
   47|       |#    define fopen64 fopen
   48|       |#    if (_MSC_VER >= 1400) && (!(defined(NO_MSCVER_FILE64_FUNC)))
   49|       |#      define ftello64 _ftelli64
   50|       |#      define fseeko64 _fseeki64
   51|       |#    else /* old MSC */
   52|       |#      define ftello64 ftell
   53|       |#      define fseeko64 fseek
   54|       |#    endif
   55|       |#  endif
   56|       |#endif
   57|       |
   58|       |/* a type choosen by DEFINE */
   59|       |#ifdef HAVE_64BIT_INT_CUSTOM
   60|       |typedef 64BIT_INT_CUSTOM_TYPE ZPOS64_T;
   61|       |#else
   62|       |#  ifdef HAVE_STDINT_H
   63|       |#    include "stdint.h"
   64|       |     typedef uint64_t ZPOS64_T;
   65|       |#  else
   66|       |#    if defined(_MSC_VER) || defined(__BORLANDC__)
   67|       |       typedef unsigned __int64 ZPOS64_T;
   68|       |#    else
   69|       |       typedef unsigned long long int ZPOS64_T;
   70|       |#    endif
   71|       |#  endif
   72|       |#endif
   73|       |
   74|       |#ifdef __cplusplus
   75|       |extern "C" {
   76|       |#endif
   77|       |
   78|      0|#define ZLIB_FILEFUNC_SEEK_CUR (1)
   79|      0|#define ZLIB_FILEFUNC_SEEK_END (2)
   80|      0|#define ZLIB_FILEFUNC_SEEK_SET (0)
   81|       |
   82|      0|#define ZLIB_FILEFUNC_MODE_READ             (1)
   83|       |#define ZLIB_FILEFUNC_MODE_WRITE            (2)
   84|      0|#define ZLIB_FILEFUNC_MODE_READWRITEFILTER  (3)
   85|      0|#define ZLIB_FILEFUNC_MODE_EXISTING         (4)
   86|      0|#define ZLIB_FILEFUNC_MODE_CREATE           (8)
   87|       |
   88|       |#ifndef ZCALLBACK
   89|       |#  if (defined(WIN32) || defined(_WIN32) || defined (WINDOWS) || \
   90|       |       defined (_WINDOWS)) && defined(CALLBACK) && defined (USEWINDOWS_CALLBACK)
   91|       |#    define ZCALLBACK CALLBACK
   92|       |#  else
   93|       |#    define ZCALLBACK
   94|       |#  endif
   95|       |#endif
   96|       |
   97|       |typedef voidpf   (ZCALLBACK *open_file_func)      OF((voidpf opaque, const char* filename, int mode));
   98|       |typedef voidpf   (ZCALLBACK *opendisk_file_func)  OF((voidpf opaque, voidpf stream, int number_disk, int mode));
   99|       |typedef uLong    (ZCALLBACK *read_file_func)      OF((voidpf opaque, voidpf stream, void* buf, uLong size));
  100|       |typedef uLong    (ZCALLBACK *write_file_func)     OF((voidpf opaque, voidpf stream, const void* buf, uLong size));
  101|       |typedef int      (ZCALLBACK *close_file_func)     OF((voidpf opaque, voidpf stream));
  102|       |typedef int      (ZCALLBACK *testerror_file_func) OF((voidpf opaque, voidpf stream));
  103|       |
  104|       |typedef long     (ZCALLBACK *tell_file_func)      OF((voidpf opaque, voidpf stream));
  105|       |typedef long     (ZCALLBACK *seek_file_func)      OF((voidpf opaque, voidpf stream, uLong offset, int origin));
  106|       |
  107|       |/* here is the "old" 32 bits structure structure */
  108|       |typedef struct zlib_filefunc_def_s
  109|       |{
  110|       |    open_file_func      zopen_file;
  111|       |    opendisk_file_func  zopendisk_file;
  112|       |    read_file_func      zread_file;
  113|       |    write_file_func     zwrite_file;
  114|       |    tell_file_func      ztell_file;
  115|       |    seek_file_func      zseek_file;
  116|       |    close_file_func     zclose_file;
  117|       |    testerror_file_func zerror_file;
  118|       |    voidpf              opaque;
  119|       |} zlib_filefunc_def;
  120|       |
  121|       |typedef ZPOS64_T (ZCALLBACK *tell64_file_func)    OF((voidpf opaque, voidpf stream));
  122|       |typedef long     (ZCALLBACK *seek64_file_func)    OF((voidpf opaque, voidpf stream, ZPOS64_T offset, int origin));
  123|       |typedef voidpf   (ZCALLBACK *open64_file_func)    OF((voidpf opaque, const void* filename, int mode));
  124|       |typedef voidpf   (ZCALLBACK *opendisk64_file_func)OF((voidpf opaque, voidpf stream, int number_disk, int mode));
  125|       |
  126|       |typedef struct zlib_filefunc64_def_s
  127|       |{
  128|       |    open64_file_func     zopen64_file;
  129|       |    opendisk64_file_func zopendisk64_file;
  130|       |    read_file_func       zread_file;
  131|       |    write_file_func      zwrite_file;
  132|       |    tell64_file_func     ztell64_file;
  133|       |    seek64_file_func     zseek64_file;
  134|       |    close_file_func      zclose_file;
  135|       |    testerror_file_func  zerror_file;
  136|       |    voidpf               opaque;
  137|       |} zlib_filefunc64_def;
  138|       |
  139|       |void fill_fopen_filefunc OF((zlib_filefunc_def* pzlib_filefunc_def));
  140|       |void fill_fopen64_filefunc OF((zlib_filefunc64_def* pzlib_filefunc_def));
  141|       |
  142|       |/* now internal definition, only for zip.c and unzip.h */
  143|       |typedef struct zlib_filefunc64_32_def_s
  144|       |{
  145|       |    zlib_filefunc64_def zfile_func64;
  146|       |    open_file_func      zopen32_file;
  147|       |    opendisk_file_func  zopendisk32_file;
  148|       |    tell_file_func      ztell32_file;
  149|       |    seek_file_func      zseek32_file;
  150|       |} zlib_filefunc64_32_def;
  151|       |
  152|       |#define ZREAD64(filefunc,filestream,buf,size)       ((*((filefunc).zfile_func64.zread_file))        ((filefunc).zfile_func64.opaque,filestream,buf,size))
  153|       |#define ZWRITE64(filefunc,filestream,buf,size)      ((*((filefunc).zfile_func64.zwrite_file))       ((filefunc).zfile_func64.opaque,filestream,buf,size))
  154|       |/*#define ZTELL64(filefunc,filestream)                ((*((filefunc).ztell64_file))                   ((filefunc).opaque,filestream))*/
  155|       |/*#define ZSEEK64(filefunc,filestream,pos,mode)       ((*((filefunc).zseek64_file))                   ((filefunc).opaque,filestream,pos,mode))*/
  156|       |#define ZCLOSE64(filefunc,filestream)               ((*((filefunc).zfile_func64.zclose_file))       ((filefunc).zfile_func64.opaque,filestream))
  157|       |#define ZERROR64(filefunc,filestream)               ((*((filefunc).zfile_func64.zerror_file))       ((filefunc).zfile_func64.opaque,filestream))
  158|       |
  159|       |voidpf   call_zopen64 OF((const zlib_filefunc64_32_def* pfilefunc,const void*filename,int mode));
  160|       |voidpf   call_zopendisk64 OF((const zlib_filefunc64_32_def* pfilefunc, voidpf filestream, int number_disk, int mode));
  161|       |long     call_zseek64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream, ZPOS64_T offset, int origin));
  162|       |ZPOS64_T call_ztell64 OF((const zlib_filefunc64_32_def* pfilefunc,voidpf filestream));
  163|       |
  164|       |void fill_zlib_filefunc64_32_def_from_filefunc32 OF((zlib_filefunc64_32_def* p_filefunc64_32,const zlib_filefunc_def* p_filefunc32));
  165|       |
  166|       |#define ZOPEN64(filefunc,filename,mode)             (call_zopen64((&(filefunc)),(filename),(mode)))
  167|       |#define ZOPENDISK64(filefunc,filestream,diskn,mode) (call_zopendisk64((&(filefunc)),(filestream),(diskn),(mode)))
  168|       |#define ZTELL64(filefunc,filestream)                (call_ztell64((&(filefunc)),(filestream)))
  169|       |#define ZSEEK64(filefunc,filestream,pos,mode)       (call_zseek64((&(filefunc)),(filestream),(pos),(mode)))
  170|       |
  171|       |#ifdef __cplusplus
  172|       |}
  173|       |#endif
  174|       |
  175|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/minizip/unzip.c:
    1|       |/* unzip.c -- IO for uncompress .zip files using zlib
    2|       |   Version 1.1, February 14h, 2010
    3|       |   part of the MiniZip project
    4|       |
    5|       |   Copyright (C) 1998-2010 Gilles Vollant
    6|       |     http://www.winimage.com/zLibDll/minizip.html
    7|       |   Modifications of Unzip for Zip64
    8|       |     Copyright (C) 2007-2008 Even Rouault
    9|       |   Modifications for Zip64 support on both zip and unzip
   10|       |     Copyright (C) 2009-2010 Mathias Svensson
   11|       |     http://result42.com
   12|       |   Modifications for AES, PKWARE disk spanning
   13|       |     Copyright (C) 2010-2014 Nathan Moinvaziri
   14|       |
   15|       |   This program is distributed under the terms of the same license as zlib.
   16|       |   See the accompanying LICENSE file for the full text of the license.
   17|       |*/
   18|       |
   19|       |#include <stdio.h>
   20|       |#include <stdlib.h>
   21|       |#include <string.h>
   22|       |
   23|       |/*#ifndef NOUNCRYPT
   24|       |#  define NOUNCRYPT
   25|       |#endif*/
   26|       |
   27|       |#include "zlib.h"
   28|       |#include "unzip.h"
   29|       |
   30|       |#ifdef STDC
   31|       |#  include <stddef.h>
   32|       |#  include <string.h>
   33|       |#  include <stdlib.h>
   34|       |#endif
   35|       |#ifdef NO_ERRNO_H
   36|       |   extern int errno;
   37|       |#else
   38|       |#  include <errno.h>
   39|       |#endif
   40|       |
   41|       |#ifdef HAVE_AES
   42|       |#  define AES_METHOD          (99)
   43|       |#  define AES_PWVERIFYSIZE    (2)
   44|       |#  define AES_MAXSALTLENGTH   (16)
   45|       |#  define AES_AUTHCODESIZE    (10)
   46|       |#  define AES_HEADERSIZE      (11)
   47|       |#  define AES_KEYSIZE(mode)   (64 + (mode * 64))
   48|       |
   49|       |#  include "aes/aes.h"
   50|       |#  include "aes/fileenc.h"
   51|       |#endif
   52|       |#ifndef NOUNCRYPT
   53|       |#  include "crypt.h"
   54|       |#endif
   55|       |
   56|       |#ifndef local
   57|       |#  define local static
   58|       |#endif
   59|       |/* compile with -Dlocal if your debugger can't find static symbols */
   60|       |
   61|       |#define DISKHEADERMAGIC          (0x08074b50)
   62|      0|#define LOCALHEADERMAGIC         (0x04034b50)
   63|      0|#define CENTRALHEADERMAGIC       (0x02014b50)
   64|      0|#define ENDHEADERMAGIC           (0x06054b50)
   65|      0|#define ZIP64ENDHEADERMAGIC      (0x06064b50)
   66|      0|#define ZIP64ENDLOCHEADERMAGIC   (0x07064b50)
   67|       |
   68|      0|#define SIZECENTRALDIRITEM       (0x2e)
   69|       |#define SIZECENTRALHEADERLOCATOR (0x14) /* 20 */
   70|      0|#define SIZEZIPLOCALHEADER       (0x1e)
   71|       |
   72|       |#ifndef BUFREADCOMMENT
   73|      0|#  define BUFREADCOMMENT (0x400)
   74|       |#endif
   75|       |
   76|       |#ifndef UNZ_BUFSIZE
   77|      0|#  define UNZ_BUFSIZE (64 * 1024)
   78|       |#endif
   79|       |#ifndef UNZ_MAXFILENAMEINZIP
   80|      0|#  define UNZ_MAXFILENAMEINZIP (256)
   81|       |#endif
   82|       |
   83|       |#ifndef ALLOC
   84|      0|#  define ALLOC(size) (malloc(size))
   85|       |#endif
   86|       |#ifndef TRYFREE
   87|      0|#  define TRYFREE(p) {if (p) free(p);}
   88|       |#endif
   89|       |
   90|       |const char unz_copyright[] =
   91|       |   " unzip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
   92|       |
   93|       |/* unz_file_info_interntal contain internal info about a file in zipfile*/
   94|       |typedef struct unz_file_info64_internal_s
   95|       |{
   96|       |    ZPOS64_T offset_curfile;            /* relative offset of local header 8 bytes */
   97|       |    ZPOS64_T byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx) */
   98|       |#ifdef HAVE_AES
   99|       |    uLong aes_encryption_mode;
  100|       |    uLong aes_compression_method;
  101|       |    uLong aes_version;
  102|       |#endif
  103|       |} unz_file_info64_internal;
  104|       |
  105|       |/* file_in_zip_read_info_s contain internal information about a file in zipfile */
  106|       |typedef struct
  107|       |{
  108|       |    Bytef *read_buffer;                 /* internal buffer for compressed data */
  109|       |    z_stream stream;                    /* zLib stream structure for inflate */
  110|       |
  111|       |#ifdef HAVE_BZIP2
  112|       |    bz_stream bstream;                  /* bzLib stream structure for bziped */
  113|       |#endif
  114|       |#ifdef HAVE_AES
  115|       |    fcrypt_ctx aes_ctx;
  116|       |#endif
  117|       |
  118|       |    ZPOS64_T pos_in_zipfile;            /* position in byte on the zipfile, for fseek */
  119|       |    uLong stream_initialised;           /* flag set if stream structure is initialised */
  120|       |
  121|       |    ZPOS64_T offset_local_extrafield;   /* offset of the local extra field */
  122|       |    uInt size_local_extrafield;         /* size of the local extra field */
  123|       |    ZPOS64_T pos_local_extrafield;      /* position in the local extra field in read */
  124|       |    ZPOS64_T total_out_64;
  125|       |
  126|       |    uLong crc32;                        /* crc32 of all data uncompressed */
  127|       |    uLong crc32_wait;                   /* crc32 we must obtain after decompress all */
  128|       |    ZPOS64_T rest_read_compressed;      /* number of byte to be decompressed */
  129|       |    ZPOS64_T rest_read_uncompressed;    /* number of byte to be obtained after decomp */
  130|       |
  131|       |    zlib_filefunc64_32_def z_filefunc;
  132|       |
  133|       |    voidpf filestream;                  /* io structore of the zipfile */
  134|       |    uLong compression_method;           /* compression method (0==store) */
  135|       |    ZPOS64_T byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx) */
  136|       |    int raw;
  137|       |} file_in_zip64_read_info_s;
  138|       |
  139|       |/* unz64_s contain internal information about the zipfile */
  140|       |typedef struct
  141|       |{
  142|       |    zlib_filefunc64_32_def z_filefunc;
  143|       |    voidpf filestream;                  /* io structure of the current zipfile */
  144|       |    voidpf filestream_with_CD;          /* io structure of the disk with the central directory */
  145|       |    unz_global_info64 gi;               /* public global information */
  146|       |    ZPOS64_T byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx)*/
  147|       |    ZPOS64_T num_file;                  /* number of the current file in the zipfile*/
  148|       |    ZPOS64_T pos_in_central_dir;        /* pos of the current file in the central dir*/
  149|       |    ZPOS64_T current_file_ok;           /* flag about the usability of the current file*/
  150|       |    ZPOS64_T central_pos;               /* position of the beginning of the central dir*/
  151|       |    uLong number_disk;                  /* number of the current disk, used for spanning ZIP*/
  152|       |    ZPOS64_T size_central_dir;          /* size of the central directory  */
  153|       |    ZPOS64_T offset_central_dir;        /* offset of start of central directory with
  154|       |                                           respect to the starting disk number */
  155|       |
  156|       |    unz_file_info64 cur_file_info;      /* public info about the current file in zip*/
  157|       |    unz_file_info64_internal cur_file_info_internal;
  158|       |                                        /* private info about it*/
  159|       |    file_in_zip64_read_info_s* pfile_in_zip_read;
  160|       |                                        /* structure about the current file if we are decompressing it */
  161|       |    int isZip64;                        /* is the current file zip64 */
  162|       |#ifndef NOUNCRYPT
  163|       |    unsigned long keys[3];              /* keys defining the pseudo-random sequence */
  164|       |    const unsigned long* pcrc_32_tab;
  165|       |#endif
  166|       |} unz64_s;
  167|       |
  168|       |/* Translate date/time from Dos format to tm_unz (readable more easily) */
  169|       |local void unz64local_DosDateToTmuDate (ZPOS64_T ulDosDate, tm_unz* ptm)
  170|      0|{
  171|      0|    ZPOS64_T uDate = (ZPOS64_T)(ulDosDate>>16);
  172|      0|
  173|      0|    ptm->tm_mday = (uInt)(uDate&0x1f);
  174|      0|    ptm->tm_mon  = (uInt)((((uDate)&0x1E0)/0x20)-1);
  175|      0|    ptm->tm_year = (uInt)(((uDate&0x0FE00)/0x0200)+1980);
  176|      0|    ptm->tm_hour = (uInt)((ulDosDate &0xF800)/0x800);
  177|      0|    ptm->tm_min  = (uInt)((ulDosDate&0x7E0)/0x20);
  178|      0|    ptm->tm_sec  = (uInt)(2*(ulDosDate&0x1f));
  179|      0|
  180|      0|#define unz64local_in_range(min, max, value) ((min) <= (value) && (value) <= (max))
  181|      0|    if (!unz64local_in_range(0, 11, ptm->tm_mon) ||
  182|      0|        !unz64local_in_range(1, 31, ptm->tm_mday) ||
  183|      0|        !unz64local_in_range(0, 23, ptm->tm_hour) ||
  184|      0|        !unz64local_in_range(0, 59, ptm->tm_min) ||
  185|      0|        !unz64local_in_range(0, 59, ptm->tm_sec))
  186|      0|      /* Invalid date stored, so don't return it. */
  187|      0|      memset(ptm, 0, sizeof(tm_unz));
  188|      0|#undef unz64local_in_range
  189|      0|}
  190|       |
  191|       |/* Read a byte from a gz_stream; Return EOF for end of file. */
  192|       |local int unz64local_getByte OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi));
  193|       |local int unz64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi)
  194|      0|{
  195|      0|    unsigned char c;
  196|      0|    int err = (int)ZREAD64(*pzlib_filefunc_def, filestream, &c, 1);
  197|      0|    if (err == 1)
  198|      0|    {
  199|      0|        *pi = (int)c;
  200|      0|        return UNZ_OK;
  201|      0|    }
  202|      0|    *pi = 0;
  203|      0|    if (ZERROR64(*pzlib_filefunc_def, filestream))
  204|      0|        return UNZ_ERRNO;
  205|      0|    return UNZ_EOF;
  206|      0|}
  207|       |
  208|       |local int unz64local_getShort OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
  209|       |local int unz64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX)
  210|      0|{
  211|      0|    uLong x;
  212|      0|    int i = 0;
  213|      0|    int err;
  214|      0|
  215|      0|    err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  216|      0|    x = (uLong)i;
  217|      0|    if (err == UNZ_OK)
  218|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  219|      0|    x |= ((uLong)i)<<8;
  220|      0|
  221|      0|    if (err == UNZ_OK)
  222|      0|        *pX = x;
  223|      0|    else
  224|      0|        *pX = 0;
  225|      0|    return err;
  226|      0|}
  227|       |
  228|       |local int unz64local_getLong OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
  229|       |local int unz64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX)
  230|      0|{
  231|      0|    uLong x;
  232|      0|    int i = 0;
  233|      0|    int err;
  234|      0|
  235|      0|    err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  236|      0|    x = (uLong)i;
  237|      0|    if (err == UNZ_OK)
  238|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  239|      0|    x |= ((uLong)i)<<8;
  240|      0|    if (err == UNZ_OK)
  241|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  242|      0|    x |= ((uLong)i)<<16;
  243|      0|    if (err == UNZ_OK)
  244|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  245|      0|    x += ((uLong)i)<<24;
  246|      0|
  247|      0|    if (err == UNZ_OK)
  248|      0|        *pX = x;
  249|      0|    else
  250|      0|        *pX = 0;
  251|      0|    return err;
  252|      0|}
  253|       |
  254|       |local int unz64local_getLong64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX));
  255|       |local int unz64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)
  256|      0|{
  257|      0|    ZPOS64_T x;
  258|      0|    int i = 0;
  259|      0|    int err;
  260|      0|
  261|      0|    err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  262|      0|    x = (ZPOS64_T)i;
  263|      0|    if (err == UNZ_OK)
  264|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  265|      0|    x |= ((ZPOS64_T)i)<<8;
  266|      0|    if (err == UNZ_OK)
  267|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  268|      0|    x |= ((ZPOS64_T)i)<<16;
  269|      0|    if (err == UNZ_OK)
  270|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  271|      0|    x |= ((ZPOS64_T)i)<<24;
  272|      0|    if (err == UNZ_OK)
  273|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  274|      0|    x |= ((ZPOS64_T)i)<<32;
  275|      0|    if (err == UNZ_OK)
  276|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  277|      0|    x |= ((ZPOS64_T)i)<<40;
  278|      0|    if (err == UNZ_OK)
  279|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  280|      0|    x |= ((ZPOS64_T)i)<<48;
  281|      0|    if (err == UNZ_OK)
  282|      0|        err = unz64local_getByte(pzlib_filefunc_def, filestream, &i);
  283|      0|    x |= ((ZPOS64_T)i)<<56;
  284|      0|
  285|      0|    if (err == UNZ_OK)
  286|      0|        *pX = x;
  287|      0|    else
  288|      0|        *pX = 0;
  289|      0|    return err;
  290|      0|}
  291|       |
  292|       |/* Locate the Central directory of a zip file (at the end, just before the global comment) */
  293|       |local ZPOS64_T unz64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
  294|       |local ZPOS64_T unz64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
  295|      0|{
  296|      0|    unsigned char* buf;
  297|      0|    ZPOS64_T file_size;
  298|      0|    ZPOS64_T back_read = 4;
  299|      0|    ZPOS64_T max_back = 0xffff; /* maximum size of global comment */
  300|      0|    ZPOS64_T pos_found = 0;
  301|      0|    uLong read_size;
  302|      0|    ZPOS64_T read_pos;
  303|      0|    int i;
  304|      0|
  305|      0|    buf = (unsigned char*)ALLOC(BUFREADCOMMENT + 4);
  306|      0|    if (buf == NULL)
  307|      0|        return 0;
  308|      0|
  309|      0|    if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
  310|      0|    {
  311|      0|        TRYFREE(buf);
  312|      0|        return 0;
  313|      0|    }
  314|      0|
  315|      0|    file_size = ZTELL64(*pzlib_filefunc_def, filestream);
  316|      0|
  317|      0|    if (max_back > file_size)
  318|      0|        max_back = file_size;
  319|      0|
  320|      0|    while (back_read < max_back)
  321|      0|    {
  322|      0|        if (back_read + BUFREADCOMMENT > max_back)
  323|      0|            back_read = max_back;
  324|      0|        else
  325|      0|            back_read += BUFREADCOMMENT;
  326|      0|
  327|      0|        read_pos = file_size - back_read;
  328|      0|        read_size = ((BUFREADCOMMENT + 4) < (file_size - read_pos)) ?
  329|      0|                     (BUFREADCOMMENT + 4) : (uLong)(file_size - read_pos);
  330|      0|
  331|      0|        if (ZSEEK64(*pzlib_filefunc_def, filestream, read_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
  332|      0|            break;
  333|      0|        if (ZREAD64(*pzlib_filefunc_def, filestream, buf, read_size) != read_size)
  334|      0|            break;
  335|      0|
  336|      0|        for (i = (int)read_size-3; (i--) > 0;)
  337|      0|            if (((*(buf+i)) == (ENDHEADERMAGIC & 0xff)) &&
  338|      0|                ((*(buf+i+1)) == (ENDHEADERMAGIC >> 8 & 0xff)) &&
  339|      0|                ((*(buf+i+2)) == (ENDHEADERMAGIC >> 16 & 0xff)) &&
  340|      0|                ((*(buf+i+3)) == (ENDHEADERMAGIC >> 24 & 0xff)))
  341|      0|            {
  342|      0|                pos_found = read_pos+i;
  343|      0|                break;
  344|      0|            }
  345|      0|
  346|      0|        if (pos_found != 0)
  347|      0|            break;
  348|      0|    }
  349|      0|    TRYFREE(buf);
  350|      0|    return pos_found;
  351|      0|}
  352|       |
  353|       |/* Locate the Central directory 64 of a zipfile (at the end, just before the global comment) */
  354|       |local ZPOS64_T unz64local_SearchCentralDir64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream,
  355|       |    const ZPOS64_T endcentraloffset));
  356|       |local ZPOS64_T unz64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream,
  357|       |    const ZPOS64_T endcentraloffset)
  358|      0|{
  359|      0|    ZPOS64_T offset;
  360|      0|    uLong uL;
  361|      0|
  362|      0|    /* Zip64 end of central directory locator */
  363|      0|    if (ZSEEK64(*pzlib_filefunc_def, filestream, endcentraloffset - SIZECENTRALHEADERLOCATOR, ZLIB_FILEFUNC_SEEK_SET) != 0)
  364|      0|        return 0;
  365|      0|
  366|      0|    /* read locator signature */
  367|      0|    if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
  368|      0|        return 0;
  369|      0|    if (uL != ZIP64ENDLOCHEADERMAGIC)
  370|      0|        return 0;
  371|      0|    /* number of the disk with the start of the zip64 end of  central directory */
  372|      0|    if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
  373|      0|        return 0;
  374|      0|    /* relative offset of the zip64 end of central directory record */
  375|      0|    if (unz64local_getLong64(pzlib_filefunc_def, filestream, &offset) != UNZ_OK)
  376|      0|        return 0;
  377|      0|    /* total number of disks */
  378|      0|    if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
  379|      0|        return 0;
  380|      0|    /* Goto end of central directory record */
  381|      0|    if (ZSEEK64(*pzlib_filefunc_def, filestream, offset, ZLIB_FILEFUNC_SEEK_SET) != 0)
  382|      0|        return 0;
  383|      0|     /* the signature */
  384|      0|    if (unz64local_getLong(pzlib_filefunc_def, filestream, &uL) != UNZ_OK)
  385|      0|        return 0;
  386|      0|    if (uL != ZIP64ENDHEADERMAGIC)
  387|      0|        return 0;
  388|      0|
  389|      0|    return offset;
  390|      0|}
  391|       |
  392|       |local unzFile unzOpenInternal(const void *path, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)
  393|      0|{
  394|      0|    unz64_s us;
  395|      0|    unz64_s *s;
  396|      0|    ZPOS64_T central_pos;
  397|      0|    uLong uL;
  398|      0|    voidpf filestream = NULL;
  399|      0|    ZPOS64_T number_entry_CD;
  400|      0|    int err = UNZ_OK;
  401|      0|
  402|      0|    if (unz_copyright[0]!=' ')
  403|      0|        return NULL;
  404|      0|
  405|      0|    us.filestream = NULL;
  406|      0|    us.filestream_with_CD = NULL;
  407|      0|    us.z_filefunc.zseek32_file = NULL;
  408|      0|    us.z_filefunc.ztell32_file = NULL;
  409|      0|    if (pzlib_filefunc64_32_def == NULL)
  410|      0|        fill_fopen64_filefunc(&us.z_filefunc.zfile_func64);
  411|      0|    else
  412|      0|        us.z_filefunc = *pzlib_filefunc64_32_def;
  413|      0|
  414|      0|    us.filestream = ZOPEN64(us.z_filefunc, path, ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING);
  415|      0|
  416|      0|    if (us.filestream == NULL)
  417|      0|        return NULL;
  418|      0|
  419|      0|    us.filestream_with_CD = us.filestream;
  420|      0|    us.isZip64 = 0;
  421|      0|
  422|      0|    /* Use unz64local_SearchCentralDir first. Only based on the result
  423|      0|       is it necessary to locate the unz64local_SearchCentralDir64 */
  424|      0|    central_pos = unz64local_SearchCentralDir(&us.z_filefunc, us.filestream);
  425|      0|    if (central_pos)
  426|      0|    {
  427|      0|        if (ZSEEK64(us.z_filefunc, us.filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
  428|      0|            err = UNZ_ERRNO;
  429|      0|
  430|      0|        /* the signature, already checked */
  431|      0|        if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  432|      0|            err = UNZ_ERRNO;
  433|      0|        /* number of this disk */
  434|      0|        if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  435|      0|            err = UNZ_ERRNO;
  436|      0|        us.number_disk = uL;
  437|      0|        /* number of the disk with the start of the central directory */
  438|      0|        if (unz64local_getShort(&us.z_filefunc, us.filestream,& uL) != UNZ_OK)
  439|      0|            err = UNZ_ERRNO;
  440|      0|        us.gi.number_disk_with_CD = uL;
  441|      0|        /* total number of entries in the central directory on this disk */
  442|      0|        if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  443|      0|            err = UNZ_ERRNO;
  444|      0|        us.gi.number_entry = uL;
  445|      0|        /* total number of entries in the central directory */
  446|      0|        if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  447|      0|            err = UNZ_ERRNO;
  448|      0|        number_entry_CD = uL;
  449|      0|        if (number_entry_CD != us.gi.number_entry)
  450|      0|            err = UNZ_BADZIPFILE;
  451|      0|        /* size of the central directory */
  452|      0|        if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  453|      0|            err = UNZ_ERRNO;
  454|      0|        us.size_central_dir = uL;
  455|      0|        /* offset of start of central directory with respect to the starting disk number */
  456|      0|        if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  457|      0|            err = UNZ_ERRNO;
  458|      0|        us.offset_central_dir = uL;
  459|      0|        /* zipfile comment length */
  460|      0|        if (unz64local_getShort(&us.z_filefunc, us.filestream, &us.gi.size_comment) != UNZ_OK)
  461|      0|            err = UNZ_ERRNO;
  462|      0|
  463|      0|        if ((err == UNZ_OK) &&
  464|      0|            ((us.gi.number_entry == 0xffff) || (us.size_central_dir == 0xffff) || (us.offset_central_dir == 0xffffffff)))
  465|      0|        {
  466|      0|            /* Format should be Zip64, as the central directory or file size is too large */
  467|      0|            central_pos = unz64local_SearchCentralDir64(&us.z_filefunc, us.filestream, central_pos);
  468|      0|            if (central_pos)
  469|      0|            {
  470|      0|                ZPOS64_T uL64;
  471|      0|
  472|      0|                us.isZip64 = 1;
  473|      0|
  474|      0|                if (ZSEEK64(us.z_filefunc, us.filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
  475|      0|                    err = UNZ_ERRNO;
  476|      0|
  477|      0|                /* the signature, already checked */
  478|      0|                if (unz64local_getLong(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  479|      0|                    err = UNZ_ERRNO;
  480|      0|                /* size of zip64 end of central directory record */
  481|      0|                if (unz64local_getLong64(&us.z_filefunc, us.filestream, &uL64) != UNZ_OK)
  482|      0|                    err = UNZ_ERRNO;
  483|      0|                /* version made by */
  484|      0|                if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  485|      0|                    err = UNZ_ERRNO;
  486|      0|                /* version needed to extract */
  487|      0|                if (unz64local_getShort(&us.z_filefunc, us.filestream, &uL) != UNZ_OK)
  488|      0|                    err = UNZ_ERRNO;
  489|      0|                /* number of this disk */
  490|      0|                if (unz64local_getLong(&us.z_filefunc, us.filestream, &us.number_disk) != UNZ_OK)
  491|      0|                    err = UNZ_ERRNO;
  492|      0|                /* number of the disk with the start of the central directory */
  493|      0|                if (unz64local_getLong(&us.z_filefunc, us.filestream, &us.gi.number_disk_with_CD) != UNZ_OK)
  494|      0|                    err = UNZ_ERRNO;
  495|      0|                /* total number of entries in the central directory on this disk */
  496|      0|                if (unz64local_getLong64(&us.z_filefunc, us.filestream, &us.gi.number_entry) != UNZ_OK)
  497|      0|                    err = UNZ_ERRNO;
  498|      0|                /* total number of entries in the central directory */
  499|      0|                if (unz64local_getLong64(&us.z_filefunc, us.filestream, &number_entry_CD) != UNZ_OK)
  500|      0|                    err = UNZ_ERRNO;
  501|      0|                if (number_entry_CD != us.gi.number_entry)
  502|      0|                    err = UNZ_BADZIPFILE;
  503|      0|                /* size of the central directory */
  504|      0|                if (unz64local_getLong64(&us.z_filefunc, us.filestream, &us.size_central_dir) != UNZ_OK)
  505|      0|                    err = UNZ_ERRNO;
  506|      0|                /* offset of start of central directory with respect to the starting disk number */
  507|      0|                if (unz64local_getLong64(&us.z_filefunc, us.filestream, &us.offset_central_dir) != UNZ_OK)
  508|      0|                    err = UNZ_ERRNO;
  509|      0|            }
  510|      0|            else
  511|      0|                err = UNZ_BADZIPFILE;
  512|      0|        }
  513|      0|    }
  514|      0|    else
  515|      0|        err = UNZ_ERRNO;
  516|      0|
  517|      0|    if ((err == UNZ_OK) && (central_pos < us.offset_central_dir + us.size_central_dir))
  518|      0|        err = UNZ_BADZIPFILE;
  519|      0|
  520|      0|    if (err != UNZ_OK)
  521|      0|    {
  522|      0|        ZCLOSE64(us.z_filefunc, us.filestream);
  523|      0|        return NULL;
  524|      0|    }
  525|      0|
  526|      0|    if (us.gi.number_disk_with_CD == 0)
  527|      0|    {
  528|      0|        /* If there is only one disk open another stream so we don't have to seek between the CD
  529|      0|           and the file headers constantly */
  530|      0|        filestream = ZOPEN64(us.z_filefunc, path, ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING);
  531|      0|        if (filestream != NULL)
  532|      0|            us.filestream = filestream;
  533|      0|    }
  534|      0|
  535|      0|    /* Hack for zip files that have no respect for zip64
  536|      0|    if ((central_pos > 0xffffffff) && (us.offset_central_dir < 0xffffffff))
  537|      0|        us.offset_central_dir = central_pos - us.size_central_dir;*/
  538|      0|
  539|      0|    us.byte_before_the_zipfile = central_pos - (us.offset_central_dir + us.size_central_dir);
  540|      0|    us.central_pos = central_pos;
  541|      0|    us.pfile_in_zip_read = NULL;
  542|      0|
  543|      0|    s = (unz64_s*)ALLOC(sizeof(unz64_s));
  544|      0|    if (s != NULL)
  545|      0|    {
  546|      0|        *s = us;
  547|      0|        unzGoToFirstFile((unzFile)s);
  548|      0|    }
  549|      0|    return (unzFile)s;
  550|      0|}
  551|       |
  552|       |extern unzFile ZEXPORT unzOpen2(const char *path, zlib_filefunc_def* pzlib_filefunc32_def)
  553|      0|{
  554|      0|    if (pzlib_filefunc32_def != NULL)
  555|      0|    {
  556|      0|        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
  557|      0|        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill, pzlib_filefunc32_def);
  558|      0|        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill);
  559|      0|    }
  560|      0|    return unzOpenInternal(path, NULL);
  561|      0|}
  562|       |
  563|       |extern unzFile ZEXPORT unzOpen2_64(const void *path, zlib_filefunc64_def* pzlib_filefunc_def)
  564|      0|{
  565|      0|    if (pzlib_filefunc_def != NULL)
  566|      0|    {
  567|      0|        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
  568|      0|        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
  569|      0|        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
  570|      0|        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
  571|      0|        return unzOpenInternal(path, &zlib_filefunc64_32_def_fill);
  572|      0|    }
  573|      0|    return unzOpenInternal(path, NULL);
  574|      0|}
  575|       |
  576|       |extern unzFile ZEXPORT unzOpen(const char *path)
  577|      0|{
  578|      0|    return unzOpenInternal(path, NULL);
  579|      0|}
  580|       |
  581|       |extern unzFile ZEXPORT unzOpen64(const void *path)
  582|      0|{
  583|      0|    return unzOpenInternal(path, NULL);
  584|      0|}
  585|       |
  586|       |extern int ZEXPORT unzClose(unzFile file)
  587|      0|{
  588|      0|    unz64_s* s;
  589|      0|    if (file == NULL)
  590|      0|        return UNZ_PARAMERROR;
  591|      0|    s = (unz64_s*)file;
  592|      0|
  593|      0|    if (s->pfile_in_zip_read != NULL)
  594|      0|        unzCloseCurrentFile(file);
  595|      0|
  596|      0|    if ((s->filestream != NULL) && (s->filestream != s->filestream_with_CD))
  597|      0|        ZCLOSE64(s->z_filefunc, s->filestream);
  598|      0|    if (s->filestream_with_CD != NULL)
  599|      0|        ZCLOSE64(s->z_filefunc, s->filestream_with_CD);
  600|      0|
  601|      0|    s->filestream = NULL;
  602|      0|    s->filestream_with_CD = NULL;
  603|      0|    TRYFREE(s);
  604|      0|    return UNZ_OK;
  605|      0|}
  606|       |
  607|       |/* Goto to the next available disk for spanned archives */
  608|       |local int unzGoToNextDisk OF((unzFile file));
  609|       |local int unzGoToNextDisk(unzFile file)
  610|      0|{
  611|      0|    unz64_s* s;
  612|      0|    uLong number_disk_next = 0;
  613|      0|
  614|      0|    s = (unz64_s*)file;
  615|      0|    if (s == NULL)
  616|      0|        return UNZ_PARAMERROR;
  617|      0|    number_disk_next = s->number_disk;
  618|      0|
  619|      0|    if ((s->pfile_in_zip_read != NULL) && (s->pfile_in_zip_read->rest_read_uncompressed > 0))
  620|      0|        /* We are currently reading a file and we need the next sequential disk */
  621|      0|        number_disk_next += 1;
  622|      0|    else
  623|      0|        /* Goto the disk for the current file */
  624|      0|        number_disk_next = s->cur_file_info.disk_num_start;
  625|      0|
  626|      0|    if (number_disk_next != s->number_disk)
  627|      0|    {
  628|      0|        /* Switch disks */
  629|      0|        if ((s->filestream != NULL) && (s->filestream != s->filestream_with_CD))
  630|      0|            ZCLOSE64(s->z_filefunc, s->filestream);
  631|      0|
  632|      0|        if (number_disk_next == s->gi.number_disk_with_CD)
  633|      0|        {
  634|      0|            s->filestream = s->filestream_with_CD;
  635|      0|        }
  636|      0|        else
  637|      0|        {
  638|      0|            s->filestream = ZOPENDISK64(s->z_filefunc, s->filestream_with_CD, number_disk_next,
  639|      0|                ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_EXISTING);
  640|      0|        }
  641|      0|
  642|      0|        if (s->filestream == NULL)
  643|      0|            return UNZ_ERRNO;
  644|      0|
  645|      0|        s->number_disk = number_disk_next;
  646|      0|    }
  647|      0|
  648|      0|    return UNZ_OK;
  649|      0|}
  650|       |
  651|       |extern int ZEXPORT unzGetGlobalInfo(unzFile file, unz_global_info* pglobal_info32)
  652|      0|{
  653|      0|    unz64_s* s;
  654|      0|    if (file == NULL)
  655|      0|        return UNZ_PARAMERROR;
  656|      0|    s = (unz64_s*)file;
  657|      0|    /* to do : check if number_entry is not truncated */
  658|      0|    pglobal_info32->number_entry = (uLong)s->gi.number_entry;
  659|      0|    pglobal_info32->size_comment = s->gi.size_comment;
  660|      0|    pglobal_info32->number_disk_with_CD = s->gi.number_disk_with_CD;
  661|      0|    return UNZ_OK;
  662|      0|}
  663|       |
  664|       |extern int ZEXPORT unzGetGlobalInfo64(unzFile file, unz_global_info64* pglobal_info)
  665|      0|{
  666|      0|    unz64_s* s;
  667|      0|    if (file == NULL)
  668|      0|        return UNZ_PARAMERROR;
  669|      0|    s = (unz64_s*)file;
  670|      0|    *pglobal_info = s->gi;
  671|      0|    return UNZ_OK;
  672|      0|}
  673|       |
  674|       |extern int ZEXPORT unzGetGlobalComment(unzFile file, char *comment, uLong comment_size)
  675|      0|{
  676|      0|    unz64_s* s;
  677|      0|    uLong bytes_to_read = comment_size;
  678|      0|    if (file == NULL)
  679|      0|        return (int)UNZ_PARAMERROR;
  680|      0|    s = (unz64_s*)file;
  681|      0|
  682|      0|    if (bytes_to_read > s->gi.size_comment)
  683|      0|        bytes_to_read = s->gi.size_comment;
  684|      0|
  685|      0|    if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, s->central_pos + 22, ZLIB_FILEFUNC_SEEK_SET) != 0)
  686|      0|        return UNZ_ERRNO;
  687|      0|
  688|      0|    if (bytes_to_read>0)
  689|      0|    {
  690|      0|        *comment = 0;
  691|      0|        if (ZREAD64(s->z_filefunc, s->filestream_with_CD, comment, bytes_to_read) != bytes_to_read)
  692|      0|            return UNZ_ERRNO;
  693|      0|    }
  694|      0|
  695|      0|    if ((comment != NULL) && (comment_size > s->gi.size_comment))
  696|      0|        *(comment+s->gi.size_comment) = 0;
  697|      0|    return (int)bytes_to_read;
  698|      0|}
  699|       |
  700|       |/* Get Info about the current file in the zipfile, with internal only info */
  701|       |local int unz64local_GetCurrentFileInfoInternal(unzFile file, unz_file_info64 *pfile_info,
  702|       |    unz_file_info64_internal *pfile_info_internal, char *filename, uLong filename_size, void *extrafield,
  703|       |    uLong extrafield_size, char *comment, uLong comment_size)
  704|      0|{
  705|      0|    unz64_s* s;
  706|      0|    unz_file_info64 file_info;
  707|      0|    unz_file_info64_internal file_info_internal;
  708|      0|    ZPOS64_T bytes_to_read;
  709|      0|    int err = UNZ_OK;
  710|      0|    uLong uMagic;
  711|      0|    long lSeek = 0;
  712|      0|    ZPOS64_T current_pos = 0;
  713|      0|    uLong acc = 0;
  714|      0|    uLong uL;
  715|      0|    ZPOS64_T uL64;
  716|      0|
  717|      0|    if (file == NULL)
  718|      0|        return UNZ_PARAMERROR;
  719|      0|    s = (unz64_s*)file;
  720|      0|
  721|      0|    if (ZSEEK64(s->z_filefunc, s->filestream_with_CD,
  722|      0|            s->pos_in_central_dir + s->byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
  723|      0|        err = UNZ_ERRNO;
  724|      0|
  725|      0|    /* Check the magic */
  726|      0|    if (err == UNZ_OK)
  727|      0|    {
  728|      0|        if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uMagic) != UNZ_OK)
  729|      0|            err = UNZ_ERRNO;
  730|      0|        else if (uMagic != CENTRALHEADERMAGIC)
  731|      0|            err = UNZ_BADZIPFILE;
  732|      0|    }
  733|      0|
  734|      0|    /* Read central directory header */
  735|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.version) != UNZ_OK)
  736|      0|        err = UNZ_ERRNO;
  737|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.version_needed) != UNZ_OK)
  738|      0|        err = UNZ_ERRNO;
  739|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.flag) != UNZ_OK)
  740|      0|        err = UNZ_ERRNO;
  741|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.compression_method) != UNZ_OK)
  742|      0|        err = UNZ_ERRNO;
  743|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.dosDate) != UNZ_OK)
  744|      0|        err = UNZ_ERRNO;
  745|      0|    unz64local_DosDateToTmuDate(file_info.dosDate, &file_info.tmu_date);
  746|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.crc) != UNZ_OK)
  747|      0|        err = UNZ_ERRNO;
  748|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  749|      0|        err = UNZ_ERRNO;
  750|      0|    file_info.compressed_size = uL;
  751|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  752|      0|        err = UNZ_ERRNO;
  753|      0|    file_info.uncompressed_size = uL;
  754|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.size_filename) != UNZ_OK)
  755|      0|        err = UNZ_ERRNO;
  756|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.size_file_extra) != UNZ_OK)
  757|      0|        err = UNZ_ERRNO;
  758|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.size_file_comment) != UNZ_OK)
  759|      0|        err = UNZ_ERRNO;
  760|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.disk_num_start) != UNZ_OK)
  761|      0|        err = UNZ_ERRNO;
  762|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &file_info.internal_fa) != UNZ_OK)
  763|      0|        err = UNZ_ERRNO;
  764|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.external_fa) != UNZ_OK)
  765|      0|        err = UNZ_ERRNO;
  766|      0|    /* Relative offset of local header */
  767|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  768|      0|        err = UNZ_ERRNO;
  769|      0|
  770|      0|    file_info.size_file_extra_internal = 0;
  771|      0|    file_info.disk_offset = uL;
  772|      0|    file_info_internal.offset_curfile = uL;
  773|      0|#ifdef HAVE_AES
  774|       |    file_info_internal.aes_compression_method = 0;
  775|       |    file_info_internal.aes_encryption_mode = 0;
  776|       |    file_info_internal.aes_version = 0;
  777|       |#endif
  778|      0|
  779|      0|    lSeek += file_info.size_filename;
  780|      0|
  781|      0|    if ((err == UNZ_OK) && (filename != NULL))
  782|      0|    {
  783|      0|        if (file_info.size_filename < filename_size)
  784|      0|        {
  785|      0|            *(filename+file_info.size_filename) = 0;
  786|      0|            bytes_to_read = file_info.size_filename;
  787|      0|        }
  788|      0|        else
  789|      0|            bytes_to_read = filename_size;
  790|      0|
  791|      0|        if ((file_info.size_filename > 0) && (filename_size > 0))
  792|      0|            if (ZREAD64(s->z_filefunc, s->filestream_with_CD,filename, (uLong)bytes_to_read) != bytes_to_read)
  793|      0|                err = UNZ_ERRNO;
  794|      0|        lSeek -= (uLong)bytes_to_read;
  795|      0|    }
  796|      0|
  797|      0|    /* Read extrafield */
  798|      0|    if ((err == UNZ_OK) && (extrafield != NULL))
  799|      0|    {
  800|      0|        if (file_info.size_file_extra < extrafield_size)
  801|      0|            bytes_to_read = file_info.size_file_extra;
  802|      0|        else
  803|      0|            bytes_to_read = extrafield_size;
  804|      0|
  805|      0|        if (lSeek != 0)
  806|      0|        {
  807|      0|            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
  808|      0|                lSeek=0;
  809|      0|            else
  810|      0|                err = UNZ_ERRNO;
  811|      0|        }
  812|      0|
  813|      0|        if ((file_info.size_file_extra > 0) && (extrafield_size > 0))
  814|      0|            if (ZREAD64(s->z_filefunc, s->filestream_with_CD, extrafield, (uLong)bytes_to_read) != bytes_to_read)
  815|      0|                err = UNZ_ERRNO;
  816|      0|        lSeek += file_info.size_file_extra - (uLong)bytes_to_read;
  817|      0|    }
  818|      0|    else
  819|      0|        lSeek += file_info.size_file_extra;
  820|      0|
  821|      0|    if ((err == UNZ_OK) && (file_info.size_file_extra != 0))
  822|      0|    {
  823|      0|        if (lSeek != 0)
  824|      0|        {
  825|      0|            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, lSeek, ZLIB_FILEFUNC_SEEK_CUR) == 0)
  826|      0|                lSeek=0;
  827|      0|            else
  828|      0|                err = UNZ_ERRNO;
  829|      0|        }
  830|      0|
  831|      0|        /* We are going to parse the extra field so we need to move back */
  832|      0|        current_pos = ZTELL64(s->z_filefunc, s->filestream_with_CD);
  833|      0|        if (current_pos < file_info.size_file_extra)
  834|      0|            err = UNZ_ERRNO;
  835|      0|        current_pos -= file_info.size_file_extra;
  836|      0|        if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, current_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
  837|      0|            err = UNZ_ERRNO;
  838|      0|
  839|      0|        while((err != UNZ_ERRNO) && (acc < file_info.size_file_extra))
  840|      0|        {
  841|      0|            uLong headerid;
  842|      0|            uLong datasize;
  843|      0|
  844|      0|            if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &headerid) != UNZ_OK)
  845|      0|                err = UNZ_ERRNO;
  846|      0|            if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &datasize) != UNZ_OK)
  847|      0|                err = UNZ_ERRNO;
  848|      0|
  849|      0|            /* ZIP64 extra fields */
  850|      0|            if (headerid == 0x0001)
  851|      0|            {
  852|      0|                /* Subtract size of ZIP64 field, since ZIP64 is handled internally */
  853|      0|                file_info.size_file_extra_internal += 2 + 2 + datasize;
  854|      0|
  855|      0|                if (file_info.uncompressed_size == 0xffffffff)
  856|      0|                {
  857|      0|                    if (unz64local_getLong64(&s->z_filefunc, s->filestream_with_CD, &file_info.uncompressed_size) != UNZ_OK)
  858|      0|                        err = UNZ_ERRNO;
  859|      0|                }
  860|      0|                if (file_info.compressed_size == 0xffffffff)
  861|      0|                {
  862|      0|                    if (unz64local_getLong64(&s->z_filefunc, s->filestream_with_CD, &file_info.compressed_size) != UNZ_OK)
  863|      0|                        err = UNZ_ERRNO;
  864|      0|                }
  865|      0|                if (file_info_internal.offset_curfile == 0xffffffff)
  866|      0|                {
  867|      0|                    /* Relative Header offset */
  868|      0|                    if (unz64local_getLong64(&s->z_filefunc, s->filestream_with_CD, &uL64) != UNZ_OK)
  869|      0|                        err = UNZ_ERRNO;
  870|      0|                    file_info_internal.offset_curfile = uL64;
  871|      0|                    file_info.disk_offset = uL64;
  872|      0|                }
  873|      0|                if (file_info.disk_num_start == 0xffffffff)
  874|      0|                {
  875|      0|                    /* Disk Start Number */
  876|      0|                    if (unz64local_getLong(&s->z_filefunc, s->filestream_with_CD, &file_info.disk_num_start) != UNZ_OK)
  877|      0|                        err = UNZ_ERRNO;
  878|      0|                }
  879|      0|            }
  880|      0|#ifdef HAVE_AES
  881|       |            /* AES header */
  882|       |            else if (headerid == 0x9901)
  883|       |            {
  884|       |                /* Subtract size of AES field, since AES is handled internally */
  885|       |                file_info.size_file_extra_internal += 2 + 2 + datasize;
  886|       |
  887|       |                /* Verify version info */
  888|       |                if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  889|       |                    err = UNZ_ERRNO;
  890|       |                /* Support AE-1 and AE-2 */
  891|       |                if (uL != 1 && uL != 2)
  892|       |                    err = UNZ_ERRNO;
  893|       |                file_info_internal.aes_version = uL;
  894|       |                if (unz64local_getByte(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  895|       |                    err = UNZ_ERRNO;
  896|       |                if ((char)uL != 'A')
  897|       |                    err = UNZ_ERRNO;
  898|       |                if (unz64local_getByte(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  899|       |                    err = UNZ_ERRNO;
  900|       |                if ((char)uL != 'E')
  901|       |                    err = UNZ_ERRNO;
  902|       |                /* Get AES encryption strength and actual compression method */
  903|       |                if (unz64local_getByte(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  904|       |                    err = UNZ_ERRNO;
  905|       |                file_info_internal.aes_encryption_mode = uL;
  906|       |                if (unz64local_getShort(&s->z_filefunc, s->filestream_with_CD, &uL) != UNZ_OK)
  907|       |                    err = UNZ_ERRNO;
  908|       |                file_info_internal.aes_compression_method = uL;
  909|       |            }
  910|       |#endif
  911|      0|            else
  912|      0|            {
  913|      0|                if (ZSEEK64(s->z_filefunc, s->filestream_with_CD,datasize, ZLIB_FILEFUNC_SEEK_CUR) != 0)
  914|      0|                    err = UNZ_ERRNO;
  915|      0|            }
  916|      0|
  917|      0|            acc += 2 + 2 + datasize;
  918|      0|        }
  919|      0|    }
  920|      0|
  921|      0|    if (file_info.disk_num_start == s->gi.number_disk_with_CD)
  922|      0|        file_info_internal.byte_before_the_zipfile = s->byte_before_the_zipfile;
  923|      0|    else
  924|      0|        file_info_internal.byte_before_the_zipfile = 0;
  925|      0|
  926|      0|    if ((err == UNZ_OK) && (comment != NULL))
  927|      0|    {
  928|      0|        if (file_info.size_file_comment < comment_size)
  929|      0|        {
  930|      0|            *(comment+file_info.size_file_comment) = 0;
  931|      0|            bytes_to_read = file_info.size_file_comment;
  932|      0|        }
  933|      0|        else
  934|      0|            bytes_to_read = comment_size;
  935|      0|
  936|      0|        if (lSeek != 0)
  937|      0|        {
  938|      0|            if (ZSEEK64(s->z_filefunc, s->filestream_with_CD, lSeek, ZLIB_FILEFUNC_SEEK_CUR) != 0)
  939|      0|                err = UNZ_ERRNO;
  940|      0|        }
  941|      0|
  942|      0|        if ((file_info.size_file_comment > 0) && (comment_size > 0))
  943|      0|            if (ZREAD64(s->z_filefunc, s->filestream_with_CD, comment, (uLong)bytes_to_read) != bytes_to_read)
  944|      0|                err = UNZ_ERRNO;
  945|      0|        lSeek += file_info.size_file_comment - (uLong)bytes_to_read;
  946|      0|    }
  947|      0|    else
  948|      0|        lSeek += file_info.size_file_comment;
  949|      0|
  950|      0|    if ((err == UNZ_OK) && (pfile_info != NULL))
  951|      0|        *pfile_info = file_info;
  952|      0|
  953|      0|    if ((err == UNZ_OK) && (pfile_info_internal != NULL))
  954|      0|        *pfile_info_internal = file_info_internal;
  955|      0|
  956|      0|    return err;
  957|      0|}
  958|       |
  959|       |extern int ZEXPORT unzGetCurrentFileInfo(unzFile file, unz_file_info * pfile_info, char *filename,
  960|       |    uLong filename_size, void *extrafield, uLong extrafield_size, char* comment, uLong comment_size)
  961|      0|{
  962|      0|    unz_file_info64 file_info64;
  963|      0|    int err;
  964|      0|
  965|      0|    err = unz64local_GetCurrentFileInfoInternal(file, &file_info64, NULL, filename, filename_size,
  966|      0|                extrafield, extrafield_size, comment, comment_size);
  967|      0|
  968|      0|    if ((err == UNZ_OK) && (pfile_info != NULL))
  969|      0|    {
  970|      0|        pfile_info->version = file_info64.version;
  971|      0|        pfile_info->version_needed = file_info64.version_needed;
  972|      0|        pfile_info->flag = file_info64.flag;
  973|      0|        pfile_info->compression_method = file_info64.compression_method;
  974|      0|        pfile_info->dosDate = file_info64.dosDate;
  975|      0|        pfile_info->crc = file_info64.crc;
  976|      0|
  977|      0|        pfile_info->size_filename = file_info64.size_filename;
  978|      0|        pfile_info->size_file_extra = file_info64.size_file_extra - file_info64.size_file_extra_internal;
  979|      0|        pfile_info->size_file_comment = file_info64.size_file_comment;
  980|      0|
  981|      0|        pfile_info->disk_num_start = file_info64.disk_num_start;
  982|      0|        pfile_info->internal_fa = file_info64.internal_fa;
  983|      0|        pfile_info->external_fa = file_info64.external_fa;
  984|      0|
  985|      0|        pfile_info->tmu_date = file_info64.tmu_date,
  986|      0|
  987|      0|        pfile_info->compressed_size = (uLong)file_info64.compressed_size;
  988|      0|        pfile_info->uncompressed_size = (uLong)file_info64.uncompressed_size;
  989|      0|
  990|      0|    }
  991|      0|    return err;
  992|      0|}
  993|       |
  994|       |extern int ZEXPORT unzGetCurrentFileInfo64(unzFile file, unz_file_info64 * pfile_info, char *filename,
  995|       |    uLong filename_size, void *extrafield, uLong extrafield_size, char* comment,  uLong comment_size)
  996|      0|{
  997|      0|    return unz64local_GetCurrentFileInfoInternal(file, pfile_info, NULL, filename, filename_size,
  998|      0|        extrafield, extrafield_size, comment,comment_size);
  999|      0|}
 1000|       |
 1001|       |/* Read the local header of the current zipfile. Check the coherency of the local header and info in the
 1002|       |   end of central directory about this file store in *piSizeVar the size of extra info in local header
 1003|       |   (filename and size of extra field data) */
 1004|       |local int unz64local_CheckCurrentFileCoherencyHeader(unz64_s* s, uInt* piSizeVar, ZPOS64_T *poffset_local_extrafield,
 1005|       |    uInt *psize_local_extrafield)
 1006|      0|{
 1007|      0|    uLong uMagic, uL, uFlags;
 1008|      0|    uLong size_filename;
 1009|      0|    uLong size_extra_field;
 1010|      0|    int err = UNZ_OK;
 1011|      0|    int compression_method = 0;
 1012|      0|
 1013|      0|    *piSizeVar = 0;
 1014|      0|    *poffset_local_extrafield = 0;
 1015|      0|    *psize_local_extrafield = 0;
 1016|      0|
 1017|      0|    err = unzGoToNextDisk((unzFile)s);
 1018|      0|    if (err != UNZ_OK)
 1019|      0|        return err;
 1020|      0|
 1021|      0|    if (ZSEEK64(s->z_filefunc, s->filestream, s->cur_file_info_internal.offset_curfile +
 1022|      0|            s->cur_file_info_internal.byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
 1023|      0|        return UNZ_ERRNO;
 1024|      0|
 1025|      0|    if (err == UNZ_OK)
 1026|      0|    {
 1027|      0|        if (unz64local_getLong(&s->z_filefunc, s->filestream, &uMagic) != UNZ_OK)
 1028|      0|            err = UNZ_ERRNO;
 1029|      0|        else if (uMagic != LOCALHEADERMAGIC)
 1030|      0|            err = UNZ_BADZIPFILE;
 1031|      0|    }
 1032|      0|
 1033|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream, &uL) != UNZ_OK)
 1034|      0|        err = UNZ_ERRNO;
 1035|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream, &uFlags) != UNZ_OK)
 1036|      0|        err = UNZ_ERRNO;
 1037|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream, &uL) != UNZ_OK)
 1038|      0|        err = UNZ_ERRNO;
 1039|      0|    else if ((err == UNZ_OK) && (uL != s->cur_file_info.compression_method))
 1040|      0|        err = UNZ_BADZIPFILE;
 1041|      0|
 1042|      0|    compression_method = (int)s->cur_file_info.compression_method;
 1043|      0|#ifdef HAVE_AES
 1044|       |    if (compression_method == AES_METHOD)
 1045|       |        compression_method = (int)s->cur_file_info_internal.aes_compression_method;
 1046|       |#endif
 1047|      0|
 1048|      0|    if ((err == UNZ_OK) && (compression_method != 0) &&
 1049|      0|#ifdef HAVE_BZIP2
 1050|       |        (compression_method != Z_BZIP2ED) &&
 1051|       |#endif
 1052|      0|        (compression_method != Z_DEFLATED))
 1053|      0|        err = UNZ_BADZIPFILE;
 1054|      0|
 1055|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK) /* date/time */
 1056|      0|        err = UNZ_ERRNO;
 1057|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK) /* crc */
 1058|      0|        err = UNZ_ERRNO;
 1059|      0|    else if ((err == UNZ_OK) && (uL != s->cur_file_info.crc) && ((uFlags & 8) == 0))
 1060|      0|        err = UNZ_BADZIPFILE;
 1061|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK) /* size compr */
 1062|      0|        err = UNZ_ERRNO;
 1063|      0|    else if ((uL != 0xffffffff) && (err == UNZ_OK) && (uL != s->cur_file_info.compressed_size) && ((uFlags & 8) == 0))
 1064|      0|        err = UNZ_BADZIPFILE;
 1065|      0|    if (unz64local_getLong(&s->z_filefunc, s->filestream, &uL) != UNZ_OK) /* size uncompr */
 1066|      0|        err = UNZ_ERRNO;
 1067|      0|    else if ((uL != 0xffffffff) && (err == UNZ_OK) && (uL != s->cur_file_info.uncompressed_size) && ((uFlags & 8) == 0))
 1068|      0|        err = UNZ_BADZIPFILE;
 1069|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream, &size_filename) != UNZ_OK)
 1070|      0|        err = UNZ_ERRNO;
 1071|      0|    else if ((err == UNZ_OK) && (size_filename != s->cur_file_info.size_filename))
 1072|      0|        err = UNZ_BADZIPFILE;
 1073|      0|
 1074|      0|    *piSizeVar += (uInt)size_filename;
 1075|      0|
 1076|      0|    if (unz64local_getShort(&s->z_filefunc, s->filestream, &size_extra_field) != UNZ_OK)
 1077|      0|        err = UNZ_ERRNO;
 1078|      0|    *poffset_local_extrafield = s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + size_filename;
 1079|      0|    *psize_local_extrafield = (uInt)size_extra_field;
 1080|      0|
 1081|      0|    *piSizeVar += (uInt)size_extra_field;
 1082|      0|
 1083|      0|    return err;
 1084|      0|}
 1085|       |
 1086|       |/*
 1087|       |  Open for reading data the current file in the zipfile.
 1088|       |  If there is no error and the file is opened, the return value is UNZ_OK.
 1089|       |*/
 1090|       |extern int ZEXPORT unzOpenCurrentFile3(unzFile file, int* method, int* level, int raw, const char* password)
 1091|      0|{
 1092|      0|    int err = UNZ_OK;
 1093|      0|    int compression_method;
 1094|      0|    uInt iSizeVar;
 1095|      0|    unz64_s* s;
 1096|      0|    file_in_zip64_read_info_s* pfile_in_zip_read_info;
 1097|      0|    ZPOS64_T offset_local_extrafield;
 1098|      0|    uInt  size_local_extrafield;
 1099|      0|#ifndef NOUNCRYPT
 1100|      0|    char source[12];
 1101|      0|#else
 1102|       |    if (password != NULL)
 1103|       |        return UNZ_PARAMERROR;
 1104|       |#endif
 1105|      0|    if (file == NULL)
 1106|      0|        return UNZ_PARAMERROR;
 1107|      0|    s = (unz64_s*)file;
 1108|      0|    if (!s->current_file_ok)
 1109|      0|        return UNZ_PARAMERROR;
 1110|      0|
 1111|      0|    if (s->pfile_in_zip_read != NULL)
 1112|      0|        unzCloseCurrentFile(file);
 1113|      0|
 1114|      0|    if (unz64local_CheckCurrentFileCoherencyHeader(s, &iSizeVar, &offset_local_extrafield, &size_local_extrafield) != UNZ_OK)
 1115|      0|        return UNZ_BADZIPFILE;
 1116|      0|
 1117|      0|    pfile_in_zip_read_info = (file_in_zip64_read_info_s*)ALLOC(sizeof(file_in_zip64_read_info_s));
 1118|      0|    if (pfile_in_zip_read_info == NULL)
 1119|      0|        return UNZ_INTERNALERROR;
 1120|      0|
 1121|      0|    pfile_in_zip_read_info->read_buffer = (Bytef*)ALLOC(UNZ_BUFSIZE);
 1122|      0|    pfile_in_zip_read_info->offset_local_extrafield = offset_local_extrafield;
 1123|      0|    pfile_in_zip_read_info->size_local_extrafield = size_local_extrafield;
 1124|      0|    pfile_in_zip_read_info->pos_local_extrafield = 0;
 1125|      0|    pfile_in_zip_read_info->raw = raw;
 1126|      0|
 1127|      0|    if (pfile_in_zip_read_info->read_buffer == NULL)
 1128|      0|    {
 1129|      0|        TRYFREE(pfile_in_zip_read_info);
 1130|      0|        return UNZ_INTERNALERROR;
 1131|      0|    }
 1132|      0|
 1133|      0|    pfile_in_zip_read_info->stream_initialised = 0;
 1134|      0|
 1135|      0|    compression_method = (int)s->cur_file_info.compression_method;
 1136|      0|#ifdef HAVE_AES
 1137|       |    if (compression_method == AES_METHOD)
 1138|       |        compression_method = (int)s->cur_file_info_internal.aes_compression_method;
 1139|       |#endif
 1140|      0|
 1141|      0|    if (method != NULL)
 1142|      0|        *method = compression_method;
 1143|      0|
 1144|      0|    if (level != NULL)
 1145|      0|    {
 1146|      0|        *level = 6;
 1147|      0|        switch (s->cur_file_info.flag & 0x06)
 1148|      0|        {
 1149|      0|          case 6 : *level = 1; break;
 1150|      0|          case 4 : *level = 2; break;
 1151|      0|          case 2 : *level = 9; break;
 1152|      0|        }
 1153|      0|    }
 1154|      0|
 1155|      0|    if ((compression_method != 0) &&
 1156|      0|#ifdef HAVE_BZIP2
 1157|       |        (compression_method != Z_BZIP2ED) &&
 1158|       |#endif
 1159|      0|        (compression_method != Z_DEFLATED))
 1160|      0|        err = UNZ_BADZIPFILE;
 1161|      0|
 1162|      0|    pfile_in_zip_read_info->crc32_wait = s->cur_file_info.crc;
 1163|      0|    pfile_in_zip_read_info->crc32 = 0;
 1164|      0|    pfile_in_zip_read_info->total_out_64 = 0;
 1165|      0|    pfile_in_zip_read_info->compression_method = compression_method;
 1166|      0|    pfile_in_zip_read_info->filestream = s->filestream;
 1167|      0|    pfile_in_zip_read_info->z_filefunc = s->z_filefunc;
 1168|      0|    if (s->number_disk == s->gi.number_disk_with_CD)
 1169|      0|        pfile_in_zip_read_info->byte_before_the_zipfile = s->byte_before_the_zipfile;
 1170|      0|    else
 1171|      0|        pfile_in_zip_read_info->byte_before_the_zipfile = 0;
 1172|      0|    pfile_in_zip_read_info->stream.total_out = 0;
 1173|      0|    pfile_in_zip_read_info->stream.total_in = 0;
 1174|      0|    pfile_in_zip_read_info->stream.next_in = NULL;
 1175|      0|
 1176|      0|    if (!raw)
 1177|      0|    {
 1178|      0|        if (compression_method == Z_BZIP2ED)
 1179|      0|        {
 1180|      0|#ifdef HAVE_BZIP2
 1181|       |            pfile_in_zip_read_info->bstream.bzalloc = (void *(*) (void *, int, int))0;
 1182|       |            pfile_in_zip_read_info->bstream.bzfree = (free_func)0;
 1183|       |            pfile_in_zip_read_info->bstream.opaque = (voidpf)0;
 1184|       |            pfile_in_zip_read_info->bstream.state = (voidpf)0;
 1185|       |
 1186|       |            pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
 1187|       |            pfile_in_zip_read_info->stream.zfree = (free_func)0;
 1188|       |            pfile_in_zip_read_info->stream.opaque = (voidpf)0;
 1189|       |            pfile_in_zip_read_info->stream.next_in = (voidpf)0;
 1190|       |            pfile_in_zip_read_info->stream.avail_in = 0;
 1191|       |
 1192|       |            err = BZ2_bzDecompressInit(&pfile_in_zip_read_info->bstream, 0, 0);
 1193|       |            if (err == Z_OK)
 1194|       |                pfile_in_zip_read_info->stream_initialised=Z_BZIP2ED;
 1195|       |            else
 1196|       |            {
 1197|       |                TRYFREE(pfile_in_zip_read_info);
 1198|       |                return err;
 1199|       |            }
 1200|       |#else
 1201|      0|            pfile_in_zip_read_info->raw = 1;
 1202|      0|#endif
 1203|      0|        }
 1204|      0|        else if (compression_method == Z_DEFLATED)
 1205|      0|        {
 1206|      0|            pfile_in_zip_read_info->stream.zalloc = (alloc_func)0;
 1207|      0|            pfile_in_zip_read_info->stream.zfree = (free_func)0;
 1208|      0|            pfile_in_zip_read_info->stream.opaque = (voidpf)s;
 1209|      0|            pfile_in_zip_read_info->stream.next_in = 0;
 1210|      0|            pfile_in_zip_read_info->stream.avail_in = 0;
 1211|      0|
 1212|      0|            err = inflateInit2(&pfile_in_zip_read_info->stream, -MAX_WBITS);
 1213|      0|            if (err == Z_OK)
 1214|      0|                pfile_in_zip_read_info->stream_initialised = Z_DEFLATED;
 1215|      0|            else
 1216|      0|            {
 1217|      0|                TRYFREE(pfile_in_zip_read_info);
 1218|      0|                return err;
 1219|      0|            }
 1220|      0|            /* windowBits is passed < 0 to tell that there is no zlib header.
 1221|      0|             * Note that in this case inflate *requires* an extra "dummy" byte
 1222|      0|             * after the compressed stream in order to complete decompression and
 1223|      0|             * return Z_STREAM_END.
 1224|      0|             * In unzip, i don't wait absolutely Z_STREAM_END because I known the
 1225|      0|             * size of both compressed and uncompressed data
 1226|      0|             */
 1227|      0|        }
 1228|      0|    }
 1229|      0|
 1230|      0|    pfile_in_zip_read_info->rest_read_compressed = s->cur_file_info.compressed_size;
 1231|      0|    pfile_in_zip_read_info->rest_read_uncompressed = s->cur_file_info.uncompressed_size;
 1232|      0|    pfile_in_zip_read_info->pos_in_zipfile = s->cur_file_info_internal.offset_curfile + SIZEZIPLOCALHEADER + iSizeVar;
 1233|      0|    pfile_in_zip_read_info->stream.avail_in = (uInt)0;
 1234|      0|
 1235|      0|    s->pfile_in_zip_read = pfile_in_zip_read_info;
 1236|      0|    s->pcrc_32_tab = NULL;
 1237|      0|
 1238|      0|#ifndef NOUNCRYPT
 1239|      0|    if ((password != NULL) && ((s->cur_file_info.flag & 1) != 0))
 1240|      0|    {
 1241|      0|        if (ZSEEK64(s->z_filefunc, s->filestream,
 1242|      0|                  s->pfile_in_zip_read->pos_in_zipfile + s->pfile_in_zip_read->byte_before_the_zipfile,
 1243|      0|                  ZLIB_FILEFUNC_SEEK_SET) != 0)
 1244|      0|            return UNZ_INTERNALERROR;
 1245|      0|#ifdef HAVE_AES
 1246|       |        if (s->cur_file_info.compression_method == AES_METHOD)
 1247|       |        {
 1248|       |            unsigned char passverify[AES_PWVERIFYSIZE];
 1249|       |            unsigned char saltvalue[AES_MAXSALTLENGTH];
 1250|       |            uInt saltlength;
 1251|       |
 1252|       |            if ((s->cur_file_info_internal.aes_encryption_mode < 1) ||
 1253|       |                (s->cur_file_info_internal.aes_encryption_mode > 3))
 1254|       |                return UNZ_INTERNALERROR;
 1255|       |
 1256|       |            saltlength = SALT_LENGTH(s->cur_file_info_internal.aes_encryption_mode);
 1257|       |
 1258|       |            if (ZREAD64(s->z_filefunc, s->filestream, saltvalue, saltlength) != saltlength)
 1259|       |                return UNZ_INTERNALERROR;
 1260|       |            if (ZREAD64(s->z_filefunc, s->filestream, passverify, AES_PWVERIFYSIZE) != AES_PWVERIFYSIZE)
 1261|       |                return UNZ_INTERNALERROR;
 1262|       |
 1263|       |            fcrypt_init(s->cur_file_info_internal.aes_encryption_mode, password, strlen(password), saltvalue,
 1264|       |                passverify, &s->pfile_in_zip_read->aes_ctx);
 1265|       |
 1266|       |            s->pfile_in_zip_read->rest_read_compressed -= saltlength + AES_PWVERIFYSIZE;
 1267|       |            s->pfile_in_zip_read->rest_read_compressed -= AES_AUTHCODESIZE;
 1268|       |
 1269|       |            s->pfile_in_zip_read->pos_in_zipfile += saltlength + AES_PWVERIFYSIZE;
 1270|       |        }
 1271|       |        else
 1272|       |#endif
 1273|      0|        {
 1274|      0|            int i;
 1275|      0|            s->pcrc_32_tab = (const unsigned long*)get_crc_table();
 1276|      0|            init_keys(password, s->keys, s->pcrc_32_tab);
 1277|      0|
 1278|      0|            if (ZREAD64(s->z_filefunc, s->filestream, source, 12) < 12)
 1279|      0|                return UNZ_INTERNALERROR;
 1280|      0|
 1281|      0|            for (i = 0; i < 12; i++)
 1282|      0|                zdecode(s->keys, s->pcrc_32_tab, source[i]);
 1283|      0|
 1284|      0|            s->pfile_in_zip_read->rest_read_compressed -= 12;
 1285|      0|
 1286|      0|            s->pfile_in_zip_read->pos_in_zipfile += 12;
 1287|      0|        }
 1288|      0|    }
 1289|      0|#endif
 1290|      0|
 1291|      0|    return UNZ_OK;
 1292|      0|}
 1293|       |
 1294|       |extern int ZEXPORT unzOpenCurrentFile(unzFile file)
 1295|      0|{
 1296|      0|    return unzOpenCurrentFile3(file, NULL, NULL, 0, NULL);
 1297|      0|}
 1298|       |
 1299|       |extern int ZEXPORT unzOpenCurrentFilePassword(unzFile file, const char* password)
 1300|      0|{
 1301|      0|    return unzOpenCurrentFile3(file, NULL, NULL, 0, password);
 1302|      0|}
 1303|       |
 1304|       |extern int ZEXPORT unzOpenCurrentFile2(unzFile file, int* method, int* level, int raw)
 1305|      0|{
 1306|      0|    return unzOpenCurrentFile3(file, method, level, raw, NULL);
 1307|      0|}
 1308|       |
 1309|       |/* Read bytes from the current file.
 1310|       |   buf contain buffer where data must be copied
 1311|       |   len the size of buf.
 1312|       |
 1313|       |   return the number of byte copied if some bytes are copied
 1314|       |   return 0 if the end of file was reached
 1315|       |   return <0 with error code if there is an error (UNZ_ERRNO for IO error, or zLib error for uncompress error) */
 1316|       |extern int ZEXPORT unzReadCurrentFile(unzFile file, voidp buf, unsigned len)
 1317|      0|{
 1318|      0|    int err = UNZ_OK;
 1319|      0|    uInt read = 0;
 1320|      0|    unz64_s* s;
 1321|      0|    if (file == NULL)
 1322|      0|        return UNZ_PARAMERROR;
 1323|      0|    s = (unz64_s*)file;
 1324|      0|
 1325|      0|    if (s->pfile_in_zip_read == NULL)
 1326|      0|        return UNZ_PARAMERROR;
 1327|      0|    if (s->pfile_in_zip_read->read_buffer == NULL)
 1328|      0|        return UNZ_END_OF_LIST_OF_FILE;
 1329|      0|    if (len == 0)
 1330|      0|        return 0;
 1331|      0|
 1332|      0|    s->pfile_in_zip_read->stream.next_out = (Bytef*)buf;
 1333|      0|    s->pfile_in_zip_read->stream.avail_out = (uInt)len;
 1334|      0|
 1335|      0|    if (s->pfile_in_zip_read->raw)
 1336|      0|    {
 1337|      0|        if (len > s->pfile_in_zip_read->rest_read_compressed + s->pfile_in_zip_read->stream.avail_in)
 1338|      0|            s->pfile_in_zip_read->stream.avail_out = (uInt)s->pfile_in_zip_read->rest_read_compressed +
 1339|      0|                s->pfile_in_zip_read->stream.avail_in;
 1340|      0|    }
 1341|      0|    else
 1342|      0|    {
 1343|      0|        if (len > s->pfile_in_zip_read->rest_read_uncompressed)
 1344|      0|            s->pfile_in_zip_read->stream.avail_out = (uInt)s->pfile_in_zip_read->rest_read_uncompressed;
 1345|      0|    }
 1346|      0|
 1347|      0|    while (s->pfile_in_zip_read->stream.avail_out > 0)
 1348|      0|    {
 1349|      0|        if (s->pfile_in_zip_read->stream.avail_in == 0)
 1350|      0|        {
 1351|      0|            uLong bytes_to_read = UNZ_BUFSIZE;
 1352|      0|            uLong bytes_not_read = 0;
 1353|      0|            uLong bytes_read = 0;
 1354|      0|            uLong total_bytes_read = 0;
 1355|      0|
 1356|      0|            if (s->pfile_in_zip_read->stream.next_in != NULL)
 1357|      0|                bytes_not_read = s->pfile_in_zip_read->read_buffer + UNZ_BUFSIZE -
 1358|      0|                    s->pfile_in_zip_read->stream.next_in;
 1359|      0|            bytes_to_read -= bytes_not_read;
 1360|      0|            if (bytes_not_read > 0)
 1361|      0|                memcpy(s->pfile_in_zip_read->read_buffer, s->pfile_in_zip_read->stream.next_in, bytes_not_read);
 1362|      0|            if (s->pfile_in_zip_read->rest_read_compressed < bytes_to_read)
 1363|      0|                bytes_to_read = (uInt)s->pfile_in_zip_read->rest_read_compressed;
 1364|      0|
 1365|      0|            while (total_bytes_read != bytes_to_read)
 1366|      0|            {
 1367|      0|                if (ZSEEK64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream,
 1368|      0|                        s->pfile_in_zip_read->pos_in_zipfile + s->pfile_in_zip_read->byte_before_the_zipfile,
 1369|      0|                        ZLIB_FILEFUNC_SEEK_SET) != 0)
 1370|      0|                    return UNZ_ERRNO;
 1371|      0|
 1372|      0|                bytes_read = ZREAD64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream,
 1373|      0|                          s->pfile_in_zip_read->read_buffer + bytes_not_read + total_bytes_read,
 1374|      0|                          bytes_to_read - total_bytes_read);
 1375|      0|
 1376|      0|                total_bytes_read += bytes_read;
 1377|      0|                s->pfile_in_zip_read->pos_in_zipfile += bytes_read;
 1378|      0|
 1379|      0|                if (bytes_read == 0)
 1380|      0|                {
 1381|      0|                    if (ZERROR64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream))
 1382|      0|                        return UNZ_ERRNO;
 1383|      0|
 1384|      0|                    err = unzGoToNextDisk(file);
 1385|      0|                    if (err != UNZ_OK)
 1386|      0|                        return err;
 1387|      0|
 1388|      0|                    s->pfile_in_zip_read->pos_in_zipfile = 0;
 1389|      0|                    s->pfile_in_zip_read->filestream = s->filestream;
 1390|      0|                }
 1391|      0|            }
 1392|      0|
 1393|      0|#ifndef NOUNCRYPT
 1394|      0|            if ((s->cur_file_info.flag & 1) != 0)
 1395|      0|            {
 1396|      0|#ifdef HAVE_AES
 1397|       |                if (s->cur_file_info.compression_method == AES_METHOD)
 1398|       |                {
 1399|       |                    fcrypt_decrypt(s->pfile_in_zip_read->read_buffer, bytes_to_read, &s->pfile_in_zip_read->aes_ctx);
 1400|       |                }
 1401|       |                else
 1402|       |#endif
 1403|      0|                if (s->pcrc_32_tab != NULL)
 1404|      0|                {
 1405|      0|                    uInt i;
 1406|      0|                    for(i = 0; i < total_bytes_read; i++)
 1407|      0|                      s->pfile_in_zip_read->read_buffer[i] =
 1408|      0|                          zdecode(s->keys, s->pcrc_32_tab, s->pfile_in_zip_read->read_buffer[i]);
 1409|      0|                }
 1410|      0|            }
 1411|      0|#endif
 1412|      0|
 1413|      0|            s->pfile_in_zip_read->rest_read_compressed -= total_bytes_read;
 1414|      0|            s->pfile_in_zip_read->stream.next_in = (Bytef*)s->pfile_in_zip_read->read_buffer;
 1415|      0|            s->pfile_in_zip_read->stream.avail_in = (uInt)(bytes_not_read + total_bytes_read);
 1416|      0|        }
 1417|      0|
 1418|      0|        if ((s->pfile_in_zip_read->compression_method == 0) || (s->pfile_in_zip_read->raw))
 1419|      0|        {
 1420|      0|            uInt copy, i;
 1421|      0|
 1422|      0|            if ((s->pfile_in_zip_read->stream.avail_in == 0) &&
 1423|      0|                (s->pfile_in_zip_read->rest_read_compressed == 0))
 1424|      0|                return (read == 0) ? UNZ_EOF : read;
 1425|      0|
 1426|      0|            if (s->pfile_in_zip_read->stream.avail_out < s->pfile_in_zip_read->stream.avail_in)
 1427|      0|                copy = s->pfile_in_zip_read->stream.avail_out;
 1428|      0|            else
 1429|      0|                copy = s->pfile_in_zip_read->stream.avail_in;
 1430|      0|
 1431|      0|            for (i = 0; i < copy; i++)
 1432|      0|                *(s->pfile_in_zip_read->stream.next_out+i) =
 1433|      0|                        *(s->pfile_in_zip_read->stream.next_in+i);
 1434|      0|
 1435|      0|            s->pfile_in_zip_read->total_out_64 = s->pfile_in_zip_read->total_out_64 + copy;
 1436|      0|            s->pfile_in_zip_read->rest_read_uncompressed -= copy;
 1437|      0|            s->pfile_in_zip_read->crc32 = crc32(s->pfile_in_zip_read->crc32,
 1438|      0|                                s->pfile_in_zip_read->stream.next_out, copy);
 1439|      0|
 1440|      0|            s->pfile_in_zip_read->stream.avail_in -= copy;
 1441|      0|            s->pfile_in_zip_read->stream.avail_out -= copy;
 1442|      0|            s->pfile_in_zip_read->stream.next_out += copy;
 1443|      0|            s->pfile_in_zip_read->stream.next_in += copy;
 1444|      0|            s->pfile_in_zip_read->stream.total_out += copy;
 1445|      0|            read += copy;
 1446|      0|        }
 1447|      0|        else if (s->pfile_in_zip_read->compression_method == Z_BZIP2ED)
 1448|      0|        {
 1449|      0|#ifdef HAVE_BZIP2
 1450|       |            uLong total_out_before, total_out_after;
 1451|       |            const Bytef *buf_before;
 1452|       |            uLong out_bytes;
 1453|       |
 1454|       |            s->pfile_in_zip_read->bstream.next_in        = (char*)s->pfile_in_zip_read->stream.next_in;
 1455|       |            s->pfile_in_zip_read->bstream.avail_in       = s->pfile_in_zip_read->stream.avail_in;
 1456|       |            s->pfile_in_zip_read->bstream.total_in_lo32  = (uInt)s->pfile_in_zip_read->stream.total_in;
 1457|       |            s->pfile_in_zip_read->bstream.total_in_hi32  = s->pfile_in_zip_read->stream.total_in >> 32;
 1458|       |            
 1459|       |            s->pfile_in_zip_read->bstream.next_out       = (char*)s->pfile_in_zip_read->stream.next_out;
 1460|       |            s->pfile_in_zip_read->bstream.avail_out      = s->pfile_in_zip_read->stream.avail_out;
 1461|       |            s->pfile_in_zip_read->bstream.total_out_lo32 = (uInt)s->pfile_in_zip_read->stream.total_out;
 1462|       |            s->pfile_in_zip_read->bstream.total_out_hi32 = s->pfile_in_zip_read->stream.total_out >> 32;
 1463|       |
 1464|       |            total_out_before = s->pfile_in_zip_read->bstream.total_out_lo32 + 
 1465|       |                (((uLong)s->pfile_in_zip_read->bstream.total_out_hi32) << 32);
 1466|       |            buf_before = (const Bytef *)s->pfile_in_zip_read->bstream.next_out;
 1467|       |
 1468|       |            err = BZ2_bzDecompress(&s->pfile_in_zip_read->bstream);
 1469|       |
 1470|       |            total_out_after = s->pfile_in_zip_read->bstream.total_out_lo32 + 
 1471|       |                (((uLong)s->pfile_in_zip_read->bstream.total_out_hi32) << 32);
 1472|       |
 1473|       |            out_bytes = total_out_after-total_out_before;
 1474|       |
 1475|       |            s->pfile_in_zip_read->total_out_64 = s->pfile_in_zip_read->total_out_64 + out_bytes;
 1476|       |            s->pfile_in_zip_read->rest_read_uncompressed -= out_bytes;
 1477|       |            s->pfile_in_zip_read->crc32 = crc32(s->pfile_in_zip_read->crc32,buf_before, (uInt)(out_bytes));
 1478|       |
 1479|       |            read += (uInt)(total_out_after - total_out_before);
 1480|       |
 1481|       |            s->pfile_in_zip_read->stream.next_in   = (Bytef*)s->pfile_in_zip_read->bstream.next_in;
 1482|       |            s->pfile_in_zip_read->stream.avail_in  = s->pfile_in_zip_read->bstream.avail_in;
 1483|       |            s->pfile_in_zip_read->stream.total_in  = s->pfile_in_zip_read->bstream.total_in_lo32;
 1484|       |            s->pfile_in_zip_read->stream.next_out  = (Bytef*)s->pfile_in_zip_read->bstream.next_out;
 1485|       |            s->pfile_in_zip_read->stream.avail_out = s->pfile_in_zip_read->bstream.avail_out;
 1486|       |            s->pfile_in_zip_read->stream.total_out = s->pfile_in_zip_read->bstream.total_out_lo32;
 1487|       |
 1488|       |            if (err == BZ_STREAM_END)
 1489|       |                return (read == 0) ? UNZ_EOF : read;
 1490|       |            if (err != BZ_OK)
 1491|       |                break;
 1492|       |#endif
 1493|      0|        }
 1494|      0|        else
 1495|      0|        {
 1496|      0|            ZPOS64_T total_out_before, total_out_after;
 1497|      0|            const Bytef *buf_before;
 1498|      0|            ZPOS64_T out_bytes;
 1499|      0|            int flush=Z_SYNC_FLUSH;
 1500|      0|
 1501|      0|            total_out_before = s->pfile_in_zip_read->stream.total_out;
 1502|      0|            buf_before = s->pfile_in_zip_read->stream.next_out;
 1503|      0|
 1504|      0|            /*
 1505|      0|            if ((pfile_in_zip_read_info->rest_read_uncompressed ==
 1506|      0|                     pfile_in_zip_read_info->stream.avail_out) &&
 1507|      0|                (pfile_in_zip_read_info->rest_read_compressed == 0))
 1508|      0|                flush = Z_FINISH;
 1509|      0|            */
 1510|      0|            err = inflate(&s->pfile_in_zip_read->stream,flush);
 1511|      0|
 1512|      0|            if ((err >= 0) && (s->pfile_in_zip_read->stream.msg != NULL))
 1513|      0|                err = Z_DATA_ERROR;
 1514|      0|
 1515|      0|            total_out_after = s->pfile_in_zip_read->stream.total_out;
 1516|      0|            out_bytes = total_out_after-total_out_before;
 1517|      0|
 1518|      0|            s->pfile_in_zip_read->total_out_64 += out_bytes;
 1519|      0|            s->pfile_in_zip_read->rest_read_uncompressed -= out_bytes;
 1520|      0|            s->pfile_in_zip_read->crc32 =
 1521|      0|                crc32(s->pfile_in_zip_read->crc32,buf_before, (uInt)(out_bytes));
 1522|      0|
 1523|      0|            read += (uInt)(total_out_after - total_out_before);
 1524|      0|
 1525|      0|            if (err == Z_STREAM_END)
 1526|      0|                return (read == 0) ? UNZ_EOF : read;
 1527|      0|            if (err != Z_OK)
 1528|      0|                break;
 1529|      0|        }
 1530|      0|    }
 1531|      0|
 1532|      0|    if (err == Z_OK)
 1533|      0|        return read;
 1534|      0|    return err;
 1535|      0|}
 1536|       |
 1537|       |extern ZPOS64_T ZEXPORT unzGetCurrentFileZStreamPos64(unzFile file)
 1538|      0|{
 1539|      0|    unz64_s* s;
 1540|      0|    s = (unz64_s*)file;
 1541|      0|    if (file == NULL)
 1542|      0|        return 0; /* UNZ_PARAMERROR */
 1543|      0|    if (s->pfile_in_zip_read == NULL)
 1544|      0|        return 0; /* UNZ_PARAMERROR */
 1545|      0|    return s->pfile_in_zip_read->pos_in_zipfile + s->pfile_in_zip_read->byte_before_the_zipfile;
 1546|      0|}
 1547|       |
 1548|       |extern int ZEXPORT unzGetLocalExtrafield(unzFile file, voidp buf, unsigned len)
 1549|      0|{
 1550|      0|    unz64_s* s;
 1551|      0|    uInt read_now;
 1552|      0|    ZPOS64_T size_to_read;
 1553|      0|
 1554|      0|    if (file == NULL)
 1555|      0|        return UNZ_PARAMERROR;
 1556|      0|    s = (unz64_s*)file;
 1557|      0|    if (s->pfile_in_zip_read == NULL)
 1558|      0|        return UNZ_PARAMERROR;
 1559|      0|
 1560|      0|    size_to_read = s->pfile_in_zip_read->size_local_extrafield - s->pfile_in_zip_read->pos_local_extrafield;
 1561|      0|
 1562|      0|    if (buf == NULL)
 1563|      0|        return (int)size_to_read;
 1564|      0|
 1565|      0|    if (len > size_to_read)
 1566|      0|        read_now = (uInt)size_to_read;
 1567|      0|    else
 1568|      0|        read_now = (uInt)len ;
 1569|      0|
 1570|      0|    if (read_now == 0)
 1571|      0|        return 0;
 1572|      0|
 1573|      0|    if (ZSEEK64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream,
 1574|      0|        s->pfile_in_zip_read->offset_local_extrafield + s->pfile_in_zip_read->pos_local_extrafield,
 1575|      0|        ZLIB_FILEFUNC_SEEK_SET) != 0)
 1576|      0|        return UNZ_ERRNO;
 1577|      0|
 1578|      0|    if (ZREAD64(s->pfile_in_zip_read->z_filefunc, s->pfile_in_zip_read->filestream, buf, read_now) != read_now)
 1579|      0|        return UNZ_ERRNO;
 1580|      0|
 1581|      0|    return (int)read_now;
 1582|      0|}
 1583|       |
 1584|       |extern int ZEXPORT unzCloseCurrentFile(unzFile file)
 1585|      0|{
 1586|      0|    int err = UNZ_OK;
 1587|      0|
 1588|      0|    unz64_s* s;
 1589|      0|    file_in_zip64_read_info_s* pfile_in_zip_read_info;
 1590|      0|    if (file == NULL)
 1591|      0|        return UNZ_PARAMERROR;
 1592|      0|    s = (unz64_s*)file;
 1593|      0|    pfile_in_zip_read_info=s->pfile_in_zip_read;
 1594|      0|
 1595|      0|    if (pfile_in_zip_read_info == NULL)
 1596|      0|        return UNZ_PARAMERROR;
 1597|      0|
 1598|      0|#ifdef HAVE_AES
 1599|       |    if (s->cur_file_info.compression_method == AES_METHOD)
 1600|       |    {
 1601|       |        unsigned char authcode[AES_AUTHCODESIZE];
 1602|       |        unsigned char rauthcode[AES_AUTHCODESIZE];
 1603|       |
 1604|       |        if (ZREAD64(s->z_filefunc, s->filestream, authcode, AES_AUTHCODESIZE) != AES_AUTHCODESIZE)
 1605|       |            return UNZ_ERRNO;
 1606|       |
 1607|       |        if (fcrypt_end(rauthcode, &s->pfile_in_zip_read->aes_ctx) != AES_AUTHCODESIZE)
 1608|       |            err = UNZ_CRCERROR;
 1609|       |        if (memcmp(authcode, rauthcode, AES_AUTHCODESIZE) != 0)
 1610|       |            err = UNZ_CRCERROR;
 1611|       |    }
 1612|       |    /* AES zip version AE-1 will expect a valid crc as well */
 1613|       |    if ((s->cur_file_info.compression_method != AES_METHOD) ||
 1614|       |        (s->cur_file_info_internal.aes_version == 0x0001))
 1615|       |#endif
 1616|      0|    {
 1617|      0|        if ((pfile_in_zip_read_info->rest_read_uncompressed == 0) &&
 1618|      0|            (!pfile_in_zip_read_info->raw))
 1619|      0|        {
 1620|      0|            if (pfile_in_zip_read_info->crc32 != pfile_in_zip_read_info->crc32_wait)
 1621|      0|                err = UNZ_CRCERROR;
 1622|      0|        }
 1623|      0|    }
 1624|      0|
 1625|      0|    TRYFREE(pfile_in_zip_read_info->read_buffer);
 1626|      0|    pfile_in_zip_read_info->read_buffer = NULL;
 1627|      0|    if (pfile_in_zip_read_info->stream_initialised == Z_DEFLATED)
 1628|      0|        inflateEnd(&pfile_in_zip_read_info->stream);
 1629|      0|#ifdef HAVE_BZIP2
 1630|       |    else if (pfile_in_zip_read_info->stream_initialised == Z_BZIP2ED)
 1631|       |        BZ2_bzDecompressEnd(&pfile_in_zip_read_info->bstream);
 1632|       |#endif
 1633|      0|
 1634|      0|    pfile_in_zip_read_info->stream_initialised = 0;
 1635|      0|    TRYFREE(pfile_in_zip_read_info);
 1636|      0|
 1637|      0|    s->pfile_in_zip_read = NULL;
 1638|      0|
 1639|      0|    return err;
 1640|      0|}
 1641|       |
 1642|       |extern int ZEXPORT unzGoToFirstFile2(unzFile file, unz_file_info64 *pfile_info, char *filename,
 1643|       |    uLong filename_size, void *extrafield, uLong extrafield_size, char *comment, uLong comment_size)
 1644|      0|{
 1645|      0|    int err = UNZ_OK;
 1646|      0|    unz64_s* s;
 1647|      0|    if (file == NULL)
 1648|      0|        return UNZ_PARAMERROR;
 1649|      0|    s = (unz64_s*)file;
 1650|      0|    s->pos_in_central_dir = s->offset_central_dir;
 1651|      0|    s->num_file = 0;
 1652|      0|    err = unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal,
 1653|      0|            filename,filename_size, extrafield,extrafield_size, comment,comment_size);
 1654|      0|    s->current_file_ok = (err == UNZ_OK);
 1655|      0|    if ((err == UNZ_OK) && (pfile_info != NULL))
 1656|      0|        memcpy(pfile_info, &s->cur_file_info, sizeof(unz_file_info64));
 1657|      0|    return err;
 1658|      0|}
 1659|       |
 1660|       |extern int ZEXPORT unzGoToFirstFile(unzFile file)
 1661|      0|{
 1662|      0|    return unzGoToFirstFile2(file, NULL, NULL, 0, NULL, 0, NULL, 0);
 1663|      0|}
 1664|       |
 1665|       |extern int ZEXPORT unzGoToNextFile2(unzFile file, unz_file_info64 *pfile_info, char *filename,
 1666|       |    uLong filename_size, void *extrafield, uLong extrafield_size, char *comment, uLong comment_size)
 1667|      0|{
 1668|      0|    unz64_s* s;
 1669|      0|    int err;
 1670|      0|
 1671|      0|    if (file == NULL)
 1672|      0|        return UNZ_PARAMERROR;
 1673|      0|    s = (unz64_s*)file;
 1674|      0|    if (!s->current_file_ok)
 1675|      0|        return UNZ_END_OF_LIST_OF_FILE;
 1676|      0|    if (s->gi.number_entry != 0xffff)    /* 2^16 files overflow hack */
 1677|      0|      if (s->num_file+1 == s->gi.number_entry)
 1678|      0|        return UNZ_END_OF_LIST_OF_FILE;
 1679|      0|    s->pos_in_central_dir += SIZECENTRALDIRITEM + s->cur_file_info.size_filename +
 1680|      0|            s->cur_file_info.size_file_extra + s->cur_file_info.size_file_comment;
 1681|      0|    s->num_file++;
 1682|      0|    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info, &s->cur_file_info_internal,
 1683|      0|            filename, filename_size, extrafield,extrafield_size, comment,comment_size);
 1684|      0|    s->current_file_ok = (err == UNZ_OK);
 1685|      0|    if ((err == UNZ_OK) && (pfile_info != NULL))
 1686|      0|        memcpy(pfile_info, &s->cur_file_info, sizeof(unz_file_info64));
 1687|      0|    return err;
 1688|      0|}
 1689|       |
 1690|       |extern int ZEXPORT unzGoToNextFile(unzFile file)
 1691|      0|{
 1692|      0|    return unzGoToNextFile2(file, NULL, NULL, 0, NULL, 0, NULL, 0);
 1693|      0|}
 1694|       |
 1695|       |extern int ZEXPORT unzLocateFile(unzFile file, const char *filename, unzFileNameComparer filename_compare_func)
 1696|      0|{
 1697|      0|    unz64_s* s;
 1698|      0|    int err;
 1699|      0|    unz_file_info64 cur_file_info_saved;
 1700|      0|    unz_file_info64_internal cur_file_info_internal_saved;
 1701|      0|    ZPOS64_T num_file_saved;
 1702|      0|    ZPOS64_T pos_in_central_dir_saved;
 1703|      0|    char current_filename[UNZ_MAXFILENAMEINZIP+1];
 1704|      0|
 1705|      0|    if (file == NULL)
 1706|      0|        return UNZ_PARAMERROR;
 1707|      0|    if (strlen(filename) >= UNZ_MAXFILENAMEINZIP)
 1708|      0|        return UNZ_PARAMERROR;
 1709|      0|    s = (unz64_s*)file;
 1710|      0|    if (!s->current_file_ok)
 1711|      0|        return UNZ_END_OF_LIST_OF_FILE;
 1712|      0|
 1713|      0|    /* Save the current state */
 1714|      0|    num_file_saved = s->num_file;
 1715|      0|    pos_in_central_dir_saved = s->pos_in_central_dir;
 1716|      0|    cur_file_info_saved = s->cur_file_info;
 1717|      0|    cur_file_info_internal_saved = s->cur_file_info_internal;
 1718|      0|
 1719|      0|    err = unzGoToFirstFile2(file, NULL, current_filename, sizeof(current_filename)-1, NULL, 0, NULL, 0);
 1720|      0|
 1721|      0|    while (err == UNZ_OK)
 1722|      0|    {
 1723|      0|        if (filename_compare_func != NULL)
 1724|      0|            err = filename_compare_func(file, current_filename, filename);
 1725|      0|        else
 1726|      0|            err = strcmp(current_filename, filename);
 1727|      0|        if (err == 0)
 1728|      0|            return UNZ_OK;
 1729|      0|        err = unzGoToNextFile2(file, NULL, current_filename, sizeof(current_filename)-1, NULL, 0, NULL, 0);
 1730|      0|    }
 1731|      0|
 1732|      0|    /* We failed, so restore the state of the 'current file' to where we were. */
 1733|      0|    s->num_file = num_file_saved;
 1734|      0|    s->pos_in_central_dir = pos_in_central_dir_saved;
 1735|      0|    s->cur_file_info = cur_file_info_saved;
 1736|      0|    s->cur_file_info_internal = cur_file_info_internal_saved;
 1737|      0|    return err;
 1738|      0|}
 1739|       |
 1740|       |extern int ZEXPORT unzGetFilePos(unzFile file, unz_file_pos* file_pos)
 1741|      0|{
 1742|      0|    unz64_file_pos file_pos64;
 1743|      0|    int err = unzGetFilePos64(file,&file_pos64);
 1744|      0|    if (err == UNZ_OK)
 1745|      0|    {
 1746|      0|        file_pos->pos_in_zip_directory = (uLong)file_pos64.pos_in_zip_directory;
 1747|      0|        file_pos->num_of_file = (uLong)file_pos64.num_of_file;
 1748|      0|    }
 1749|      0|    return err;
 1750|      0|}
 1751|       |
 1752|       |extern int ZEXPORT unzGoToFilePos(unzFile file, unz_file_pos* file_pos)
 1753|      0|{
 1754|      0|    unz64_file_pos file_pos64;
 1755|      0|
 1756|      0|    if (file_pos == NULL)
 1757|      0|        return UNZ_PARAMERROR;
 1758|      0|    file_pos64.pos_in_zip_directory = file_pos->pos_in_zip_directory;
 1759|      0|    file_pos64.num_of_file = file_pos->num_of_file;
 1760|      0|    return unzGoToFilePos64(file,&file_pos64);
 1761|      0|}
 1762|       |
 1763|       |extern int ZEXPORT unzGetFilePos64(unzFile file, unz64_file_pos*  file_pos)
 1764|      0|{
 1765|      0|    unz64_s* s;
 1766|      0|
 1767|      0|    if (file == NULL || file_pos == NULL)
 1768|      0|        return UNZ_PARAMERROR;
 1769|      0|    s = (unz64_s*)file;
 1770|      0|    if (!s->current_file_ok)
 1771|      0|        return UNZ_END_OF_LIST_OF_FILE;
 1772|      0|
 1773|      0|    file_pos->pos_in_zip_directory  = s->pos_in_central_dir;
 1774|      0|    file_pos->num_of_file = s->num_file;
 1775|      0|
 1776|      0|    return UNZ_OK;
 1777|      0|}
 1778|       |
 1779|       |extern int ZEXPORT unzGoToFilePos64(unzFile file, const unz64_file_pos* file_pos)
 1780|      0|{
 1781|      0|    unz64_s* s;
 1782|      0|    int err;
 1783|      0|
 1784|      0|    if (file == NULL || file_pos == NULL)
 1785|      0|        return UNZ_PARAMERROR;
 1786|      0|    s = (unz64_s*)file;
 1787|      0|
 1788|      0|    /* jump to the right spot */
 1789|      0|    s->pos_in_central_dir = file_pos->pos_in_zip_directory;
 1790|      0|    s->num_file = file_pos->num_of_file;
 1791|      0|
 1792|      0|    /* set the current file */
 1793|      0|    err = unz64local_GetCurrentFileInfoInternal(file,&s->cur_file_info, &s->cur_file_info_internal,NULL,0,NULL,0,NULL,0);
 1794|      0|    /* return results */
 1795|      0|    s->current_file_ok = (err == UNZ_OK);
 1796|      0|    return err;
 1797|      0|}
 1798|       |
 1799|       |extern uLong ZEXPORT unzGetOffset(unzFile file)
 1800|      0|{
 1801|      0|    ZPOS64_T offset64;
 1802|      0|
 1803|      0|    if (file == NULL)
 1804|      0|        return 0; /* UNZ_PARAMERROR; */
 1805|      0|    offset64 = unzGetOffset64(file);
 1806|      0|    return (uLong)offset64;
 1807|      0|}
 1808|       |
 1809|       |extern ZPOS64_T ZEXPORT unzGetOffset64(unzFile file)
 1810|      0|{
 1811|      0|    unz64_s* s;
 1812|      0|
 1813|      0|    if (file == NULL)
 1814|      0|        return 0; /* UNZ_PARAMERROR; */
 1815|      0|    s = (unz64_s*)file;
 1816|      0|    if (!s->current_file_ok)
 1817|      0|        return 0;
 1818|      0|    if (s->gi.number_entry != 0 && s->gi.number_entry != 0xffff)
 1819|      0|        if (s->num_file == s->gi.number_entry)
 1820|      0|            return 0;
 1821|      0|    return s->pos_in_central_dir;
 1822|      0|}
 1823|       |
 1824|       |extern int ZEXPORT unzSetOffset(unzFile file, uLong pos)
 1825|      0|{
 1826|      0|    return unzSetOffset64(file, pos);
 1827|      0|}
 1828|       |
 1829|       |extern int ZEXPORT unzSetOffset64(unzFile file, ZPOS64_T pos)
 1830|      0|{
 1831|      0|    unz64_s* s;
 1832|      0|    int err;
 1833|      0|
 1834|      0|    if (file == NULL)
 1835|      0|        return UNZ_PARAMERROR;
 1836|      0|    s = (unz64_s*)file;
 1837|      0|    s->pos_in_central_dir = pos;
 1838|      0|    s->num_file = s->gi.number_entry;      /* hack */
 1839|      0|
 1840|      0|    err = unz64local_GetCurrentFileInfoInternal(file, &s->cur_file_info, &s->cur_file_info_internal, NULL, 0, NULL, 0, NULL, 0);
 1841|      0|
 1842|      0|    s->current_file_ok = (err == UNZ_OK);
 1843|      0|    return err;
 1844|      0|}
 1845|       |
 1846|       |extern z_off_t ZEXPORT unztell(unzFile file)
 1847|      0|{
 1848|      0|    unz64_s* s;
 1849|      0|    if (file == NULL)
 1850|      0|        return UNZ_PARAMERROR;
 1851|      0|    s = (unz64_s*)file;
 1852|      0|    if (s->pfile_in_zip_read == NULL)
 1853|      0|        return UNZ_PARAMERROR;
 1854|      0|    return (z_off_t)s->pfile_in_zip_read->stream.total_out;
 1855|      0|}
 1856|       |
 1857|       |extern ZPOS64_T ZEXPORT unztell64(unzFile file)
 1858|      0|{
 1859|      0|    unz64_s* s;
 1860|      0|    if (file == NULL)
 1861|      0|        return (ZPOS64_T)-1;
 1862|      0|    s = (unz64_s*)file;
 1863|      0|    if (s->pfile_in_zip_read == NULL)
 1864|      0|        return (ZPOS64_T)-1;
 1865|      0|    return s->pfile_in_zip_read->total_out_64;
 1866|      0|}
 1867|       |
 1868|       |extern int ZEXPORT unzseek(unzFile file, z_off_t offset, int origin)
 1869|      0|{
 1870|      0|    return unzseek64(file, (ZPOS64_T)offset, origin);
 1871|      0|}
 1872|       |
 1873|       |extern int ZEXPORT unzseek64(unzFile file, ZPOS64_T offset, int origin)
 1874|      0|{
 1875|      0|    unz64_s* s;
 1876|      0|    ZPOS64_T stream_pos_begin;
 1877|      0|    ZPOS64_T stream_pos_end;
 1878|      0|    int isWithinBuffer;
 1879|      0|    ZPOS64_T position;
 1880|      0|
 1881|      0|    if (file == NULL)
 1882|      0|        return UNZ_PARAMERROR;
 1883|      0|
 1884|      0|    s = (unz64_s*)file;
 1885|      0|
 1886|      0|    if (s->pfile_in_zip_read == NULL)
 1887|      0|        return UNZ_ERRNO;
 1888|      0|    if (s->pfile_in_zip_read->compression_method != 0)
 1889|      0|        return UNZ_ERRNO;
 1890|      0|
 1891|      0|    if (origin == SEEK_SET)
 1892|      0|        position = offset;
 1893|      0|    else if (origin == SEEK_CUR)
 1894|      0|        position = s->pfile_in_zip_read->total_out_64 + offset;
 1895|      0|    else if (origin == SEEK_END)
 1896|      0|        position = s->cur_file_info.compressed_size + offset;
 1897|      0|    else
 1898|      0|        return UNZ_PARAMERROR;
 1899|      0|
 1900|      0|    if (position > s->cur_file_info.compressed_size)
 1901|      0|        return UNZ_PARAMERROR;
 1902|      0|
 1903|      0|    stream_pos_end = s->pfile_in_zip_read->pos_in_zipfile;
 1904|      0|    stream_pos_begin = stream_pos_end;
 1905|      0|
 1906|      0|    if (stream_pos_begin > UNZ_BUFSIZE)
 1907|      0|        stream_pos_begin -= UNZ_BUFSIZE;
 1908|      0|    else
 1909|      0|        stream_pos_begin = 0;
 1910|      0|
 1911|      0|    isWithinBuffer = s->pfile_in_zip_read->stream.avail_in != 0 &&
 1912|      0|        (s->pfile_in_zip_read->rest_read_compressed != 0 || s->cur_file_info.compressed_size < UNZ_BUFSIZE) &&
 1913|      0|        position >= stream_pos_begin && position < stream_pos_end;
 1914|      0|
 1915|      0|    if (isWithinBuffer)
 1916|      0|    {
 1917|      0|        s->pfile_in_zip_read->stream.next_in += position - s->pfile_in_zip_read->total_out_64;
 1918|      0|        s->pfile_in_zip_read->stream.avail_in = (uInt)(stream_pos_end - position);
 1919|      0|    }
 1920|      0|    else
 1921|      0|    {
 1922|      0|        s->pfile_in_zip_read->stream.avail_in = 0;
 1923|      0|        s->pfile_in_zip_read->stream.next_in = 0;
 1924|      0|
 1925|      0|        s->pfile_in_zip_read->pos_in_zipfile = s->pfile_in_zip_read->offset_local_extrafield + position;
 1926|      0|        s->pfile_in_zip_read->rest_read_compressed = s->cur_file_info.compressed_size - position;
 1927|      0|    }
 1928|      0|
 1929|      0|    s->pfile_in_zip_read->rest_read_uncompressed -= (position - s->pfile_in_zip_read->total_out_64);
 1930|      0|    s->pfile_in_zip_read->stream.total_out = (uLong)position;
 1931|      0|    s->pfile_in_zip_read->total_out_64 = position;
 1932|      0|
 1933|      0|    return UNZ_OK;
 1934|      0|}
 1935|       |
 1936|       |extern int ZEXPORT unzeof(unzFile file)
 1937|      0|{
 1938|      0|    unz64_s* s;
 1939|      0|    if (file == NULL)
 1940|      0|        return UNZ_PARAMERROR;
 1941|      0|    s = (unz64_s*)file;
 1942|      0|    if (s->pfile_in_zip_read == NULL)
 1943|      0|        return UNZ_PARAMERROR;
 1944|      0|    if (s->pfile_in_zip_read->rest_read_uncompressed == 0)
 1945|      0|        return 1;
 1946|      0|    return 0;
 1947|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/Zip/Zip/minizip/zip.c:
    1|       |/* zip.c -- IO on .zip files using zlib
    2|       |   Version 1.1, February 14h, 2010
    3|       |   part of the MiniZip project
    4|       |
    5|       |   Copyright (C) 1998-2010 Gilles Vollant
    6|       |     http://www.winimage.com/zLibDll/minizip.html
    7|       |   Modifications for Zip64 support
    8|       |     Copyright (C) 2009-2010 Mathias Svensson
    9|       |     http://result42.com
   10|       |   Modifications for AES, PKWARE disk spanning
   11|       |     Copyright (C) 2010-2014 Nathan Moinvaziri
   12|       |
   13|       |   This program is distributed under the terms of the same license as zlib.
   14|       |   See the accompanying LICENSE file for the full text of the license.
   15|       |*/
   16|       |
   17|       |#include <stdio.h>
   18|       |#include <stdlib.h>
   19|       |#include <string.h>
   20|       |#include <time.h>
   21|       |#include "zlib.h"
   22|       |#include "zip.h"
   23|       |
   24|       |#ifdef STDC
   25|       |#  include <stddef.h>
   26|       |#  include <string.h>
   27|       |#  include <stdlib.h>
   28|       |#endif
   29|       |#ifdef NO_ERRNO_H
   30|       |    extern int errno;
   31|       |#else
   32|       |#   include <errno.h>
   33|       |#endif
   34|       |
   35|       |#ifdef HAVE_AES
   36|       |#  define AES_METHOD          (99)
   37|       |#  define AES_PWVERIFYSIZE    (2)
   38|       |#  define AES_AUTHCODESIZE    (10)
   39|       |#  define AES_MAXSALTLENGTH   (16)
   40|       |#  define AES_VERSION         (0x0001)
   41|       |#  define AES_ENCRYPTIONMODE  (0x03)
   42|       |
   43|       |#  include "aes/aes.h"
   44|       |#  include "aes/fileenc.h"
   45|       |#  include "aes/prng.h"
   46|       |#  include "aes/entropy.h"
   47|       |#endif
   48|       |
   49|       |#ifndef NOCRYPT
   50|       |#  define INCLUDECRYPTINGCODE_IFCRYPTALLOWED
   51|       |#  include "crypt.h"
   52|       |#endif
   53|       |
   54|       |#ifndef local
   55|       |#  define local static
   56|       |#endif
   57|       |/* compile with -Dlocal if your debugger can't find static symbols */
   58|       |
   59|      0|#define SIZEDATA_INDATABLOCK        (4096-(4*4))
   60|       |
   61|      0|#define DISKHEADERMAGIC             (0x08074b50)
   62|      0|#define LOCALHEADERMAGIC            (0x04034b50)
   63|      0|#define CENTRALHEADERMAGIC          (0x02014b50)
   64|      0|#define ENDHEADERMAGIC              (0x06054b50)
   65|      0|#define ZIP64ENDHEADERMAGIC         (0x06064b50)
   66|      0|#define ZIP64ENDLOCHEADERMAGIC      (0x07064b50)
   67|       |
   68|       |#define FLAG_LOCALHEADER_OFFSET     (0x06)
   69|       |#define CRC_LOCALHEADER_OFFSET      (0x0e)
   70|       |
   71|      0|#define SIZECENTRALHEADER           (0x2e) /* 46 */
   72|       |#define SIZECENTRALHEADERLOCATOR    (0x14) /* 20 */
   73|       |#define SIZECENTRALDIRITEM          (0x2e)
   74|       |#define SIZEZIPLOCALHEADER          (0x1e)
   75|       |
   76|       |#ifndef BUFREADCOMMENT
   77|      0|#  define BUFREADCOMMENT            (0x400)
   78|       |#endif
   79|       |#ifndef VERSIONMADEBY
   80|      0|#  define VERSIONMADEBY             (0x0) /* platform dependent */
   81|       |#endif
   82|       |
   83|       |#ifndef Z_BUFSIZE
   84|      0|#  define Z_BUFSIZE (64*1024)
   85|       |#endif
   86|       |#ifndef Z_MAXFILENAMEINZIP
   87|       |#  define Z_MAXFILENAMEINZIP (256)
   88|       |#endif
   89|       |
   90|       |#ifndef ALLOC
   91|      0|#  define ALLOC(size) (malloc(size))
   92|       |#endif
   93|       |#ifndef TRYFREE
   94|      0|#  define TRYFREE(p) {if (p) free(p);}
   95|       |#endif
   96|       |
   97|       |/* NOT sure that this work on ALL platform */
   98|       |#define MAKEULONG64(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) << 32))
   99|       |
  100|       |#ifndef DEF_MEM_LEVEL
  101|       |#  if MAX_MEM_LEVEL >= 8
  102|       |#    define DEF_MEM_LEVEL 8
  103|       |#  else
  104|       |#    define DEF_MEM_LEVEL  MAX_MEM_LEVEL
  105|       |#  endif
  106|       |#endif
  107|       |
  108|       |const char zip_copyright[] = " zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll";
  109|       |
  110|       |typedef struct linkedlist_datablock_internal_s
  111|       |{
  112|       |    struct linkedlist_datablock_internal_s* next_datablock;
  113|       |    uLong  avail_in_this_block;
  114|       |    uLong  filled_in_this_block;
  115|       |    uLong  unused; /* for future use and alignment */
  116|       |    unsigned char data[SIZEDATA_INDATABLOCK];
  117|       |} linkedlist_datablock_internal;
  118|       |
  119|       |typedef struct linkedlist_data_s
  120|       |{
  121|       |    linkedlist_datablock_internal* first_block;
  122|       |    linkedlist_datablock_internal* last_block;
  123|       |} linkedlist_data;
  124|       |
  125|       |typedef struct
  126|       |{
  127|       |    z_stream stream;                /* zLib stream structure for inflate */
  128|       |#ifdef HAVE_BZIP2
  129|       |    bz_stream bstream;              /* bzLib stream structure for bziped */
  130|       |#endif
  131|       |#ifdef HAVE_AES
  132|       |    fcrypt_ctx aes_ctx;
  133|       |    prng_ctx aes_rng[1];
  134|       |#endif
  135|       |    int  stream_initialised;        /* 1 is stream is initialized */
  136|       |    uInt pos_in_buffered_data;      /* last written byte in buffered_data */
  137|       |
  138|       |    ZPOS64_T pos_local_header;      /* offset of the local header of the file currently writing */
  139|       |    char* central_header;           /* central header data for the current file */
  140|       |    uLong size_centralextra;
  141|       |    uLong size_centralheader;       /* size of the central header for cur file */
  142|       |    uLong size_centralextrafree;    /* Extra bytes allocated to the central header but that are not used */
  143|       |    uLong size_comment;
  144|       |    uLong flag;                     /* flag of the file currently writing */
  145|       |
  146|       |    int  method;                    /* compression method written to file.*/
  147|       |    int  compression_method;        /* compression method to use */
  148|       |    int  raw;                       /* 1 for directly writing raw data */
  149|       |    Byte buffered_data[Z_BUFSIZE];  /* buffer contain compressed data to be writ*/
  150|       |    uLong dosDate;
  151|       |    uLong crc32;
  152|       |    int  zip64;                     /* Add ZIP64 extended information in the extra field */
  153|       |    uLong number_disk;              /* number of current disk used for spanning ZIP */
  154|       |    ZPOS64_T pos_zip64extrainfo;
  155|       |    ZPOS64_T total_compressed;
  156|       |    ZPOS64_T total_uncompressed;
  157|       |#ifndef NOCRYPT
  158|       |    unsigned long keys[3];          /* keys defining the pseudo-random sequence */
  159|       |    const unsigned long* pcrc_32_tab;
  160|       |    int crypt_header_size;
  161|       |#endif
  162|       |} curfile64_info;
  163|       |
  164|       |typedef struct
  165|       |{
  166|       |    zlib_filefunc64_32_def z_filefunc;
  167|       |    voidpf filestream;              /* io structure of the zipfile */
  168|       |    voidpf filestream_with_CD;      /* io structure of the zipfile with the central dir */
  169|       |    linkedlist_data central_dir;    /* datablock with central dir in construction*/
  170|       |    int in_opened_file_inzip;       /* 1 if a file in the zip is currently writ.*/
  171|       |    int append;                     /* append mode */
  172|       |    curfile64_info ci;              /* info on the file currently writing */
  173|       |
  174|       |    ZPOS64_T begin_pos;             /* position of the beginning of the zipfile */
  175|       |    ZPOS64_T add_position_when_writting_offset;
  176|       |    ZPOS64_T number_entry;
  177|       |    ZPOS64_T disk_size;             /* size of each disk */
  178|       |    uLong number_disk;              /* number of the current disk, used for spanning ZIP */
  179|       |    uLong number_disk_with_CD;      /* number the the disk with central dir, used for spanning ZIP */
  180|       |#ifndef NO_ADDFILEINEXISTINGZIP
  181|       |    char *globalcomment;
  182|       |#endif
  183|       |} zip64_internal;
  184|       |
  185|       |/* Allocate a new data block */
  186|       |local linkedlist_datablock_internal* allocate_new_datablock OF(());
  187|       |local linkedlist_datablock_internal* allocate_new_datablock()
  188|      0|{
  189|      0|    linkedlist_datablock_internal* ldi;
  190|      0|
  191|      0|    ldi = (linkedlist_datablock_internal*)ALLOC(sizeof(linkedlist_datablock_internal));
  192|      0|
  193|      0|    if (ldi != NULL)
  194|      0|    {
  195|      0|        ldi->next_datablock = NULL;
  196|      0|        ldi->filled_in_this_block = 0;
  197|      0|        ldi->avail_in_this_block = SIZEDATA_INDATABLOCK;
  198|      0|    }
  199|      0|    return ldi;
  200|      0|}
  201|       |
  202|       |/* Free data block in linked list */
  203|       |local void free_datablock OF((linkedlist_datablock_internal* ldi));
  204|       |local void free_datablock(linkedlist_datablock_internal* ldi)
  205|      0|{
  206|      0|    while (ldi != NULL)
  207|      0|    {
  208|      0|        linkedlist_datablock_internal* ldinext = ldi->next_datablock;
  209|      0|        TRYFREE(ldi);
  210|      0|        ldi = ldinext;
  211|      0|    }
  212|      0|}
  213|       |
  214|       |/* Initialize linked list */
  215|       |local void init_linkedlist OF((linkedlist_data* ll));
  216|       |local void init_linkedlist(linkedlist_data* ll)
  217|      0|{
  218|      0|    ll->first_block = ll->last_block = NULL;
  219|      0|}
  220|       |
  221|       |/* Free entire linked list and all data blocks */
  222|       |local void free_linkedlist OF((linkedlist_data* ll));
  223|       |local void free_linkedlist(linkedlist_data* ll)
  224|      0|{
  225|      0|    free_datablock(ll->first_block);
  226|      0|    ll->first_block = ll->last_block = NULL;
  227|      0|}
  228|       |
  229|       |/* Add data to linked list data block */
  230|       |local int add_data_in_datablock OF((linkedlist_data* ll, const void* buf, uLong len));
  231|       |local int add_data_in_datablock(linkedlist_data* ll, const void* buf, uLong len)
  232|      0|{
  233|      0|    linkedlist_datablock_internal* ldi;
  234|      0|    const unsigned char* from_copy;
  235|      0|
  236|      0|    if (ll == NULL)
  237|      0|        return ZIP_INTERNALERROR;
  238|      0|
  239|      0|    if (ll->last_block == NULL)
  240|      0|    {
  241|      0|        ll->first_block = ll->last_block = allocate_new_datablock();
  242|      0|        if (ll->first_block == NULL)
  243|      0|            return ZIP_INTERNALERROR;
  244|      0|    }
  245|      0|
  246|      0|    ldi = ll->last_block;
  247|      0|    from_copy = (unsigned char*)buf;
  248|      0|
  249|      0|    while (len > 0)
  250|      0|    {
  251|      0|        uInt copy_this;
  252|      0|        uInt i;
  253|      0|        unsigned char* to_copy;
  254|      0|
  255|      0|        if (ldi->avail_in_this_block == 0)
  256|      0|        {
  257|      0|            ldi->next_datablock = allocate_new_datablock();
  258|      0|            if (ldi->next_datablock == NULL)
  259|      0|                return ZIP_INTERNALERROR;
  260|      0|            ldi = ldi->next_datablock ;
  261|      0|            ll->last_block = ldi;
  262|      0|        }
  263|      0|
  264|      0|        if (ldi->avail_in_this_block < len)
  265|      0|            copy_this = (uInt)ldi->avail_in_this_block;
  266|      0|        else
  267|      0|            copy_this = (uInt)len;
  268|      0|
  269|      0|        to_copy = &(ldi->data[ldi->filled_in_this_block]);
  270|      0|
  271|      0|        for (i = 0; i < copy_this; i++)
  272|      0|            *(to_copy+i) = *(from_copy+i);
  273|      0|
  274|      0|        ldi->filled_in_this_block += copy_this;
  275|      0|        ldi->avail_in_this_block -= copy_this;
  276|      0|        from_copy += copy_this;
  277|      0|        len -= copy_this;
  278|      0|    }
  279|      0|    return ZIP_OK;
  280|      0|}
  281|       |
  282|       |local uLong zip64local_TmzDateToDosDate OF((const tm_zip* ptm));
  283|       |local uLong zip64local_TmzDateToDosDate(const tm_zip* ptm)
  284|      0|{
  285|      0|    uLong year;
  286|      0|#define zip64local_in_range(min, max, value) ((min) <= (value) && (value) <= (max))
  287|      0|    /* Years supported:
  288|      0|       * [00, 79] (assumed to be between 2000 and 2079)
  289|      0|       * [80, 207] (assumed to be between 1980 and 2107, typical output of old
  290|      0|         software that does 'year-1900' to get a double digit year)
  291|      0|       * [1980, 2107]
  292|      0|       Due to the date format limitations, only years between 1980 and 2107 can be stored.
  293|      0|    */
  294|      0|    if (!(zip64local_in_range(1980, 2107, ptm->tm_year) || zip64local_in_range(0, 207, ptm->tm_year)) ||
  295|      0|        !zip64local_in_range(0, 11, ptm->tm_mon) ||
  296|      0|        !zip64local_in_range(1, 31, ptm->tm_mday) ||
  297|      0|        !zip64local_in_range(0, 23, ptm->tm_hour) ||
  298|      0|        !zip64local_in_range(0, 59, ptm->tm_min) ||
  299|      0|        !zip64local_in_range(0, 59, ptm->tm_sec))
  300|      0|      return 0;
  301|      0|#undef zip64local_in_range
  302|      0|
  303|      0|    year = (uLong)ptm->tm_year;
  304|      0|    if (year >= 1980) /* range [1980, 2107] */
  305|      0|        year -= 1980;
  306|      0|    else if (year >= 80) /* range [80, 99] */
  307|      0|        year -= 80;
  308|      0|    else /* range [00, 79] */
  309|      0|        year += 20;
  310|      0|
  311|      0|    return (uLong)(((ptm->tm_mday) + (32 * (ptm->tm_mon+1)) + (512 * year)) << 16) |
  312|      0|        ((ptm->tm_sec / 2) + (32 * ptm->tm_min) + (2048 * (uLong)ptm->tm_hour));
  313|      0|}
  314|       |
  315|       |/* Inputs a long in LSB order to the given file: nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T) */
  316|       |local int zip64local_putValue OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream,
  317|       |    ZPOS64_T x, int nbByte));
  318|       |local int zip64local_putValue (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream,
  319|       |    ZPOS64_T x, int nbByte)
  320|      0|{
  321|      0|    unsigned char buf[8];
  322|      0|    int n;
  323|      0|    for (n = 0; n < nbByte; n++)
  324|      0|    {
  325|      0|        buf[n] = (unsigned char)(x & 0xff);
  326|      0|        x >>= 8;
  327|      0|    }
  328|      0|    if (x != 0)
  329|      0|    {
  330|      0|        /* Data overflow - hack for ZIP64 (X Roche) */
  331|      0|        for (n = 0; n < nbByte; n++)
  332|      0|        {
  333|      0|            buf[n] = 0xff;
  334|      0|        }
  335|      0|    }
  336|      0|
  337|      0|    if (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
  338|      0|        return ZIP_ERRNO;
  339|      0|
  340|      0|    return ZIP_OK;
  341|      0|}
  342|       |
  343|       |local void zip64local_putValue_inmemory OF((void* dest, ZPOS64_T x, int nbByte));
  344|       |local void zip64local_putValue_inmemory (void* dest, ZPOS64_T x, int nbByte)
  345|      0|{
  346|      0|    unsigned char* buf =(unsigned char*)dest;
  347|      0|    int n;
  348|      0|    for (n = 0; n < nbByte; n++) {
  349|      0|        buf[n] = (unsigned char)(x & 0xff);
  350|      0|        x >>= 8;
  351|      0|    }
  352|      0|
  353|      0|    if (x != 0)
  354|      0|    {
  355|      0|       /* data overflow - hack for ZIP64 */
  356|      0|       for (n = 0; n < nbByte; n++)
  357|      0|       {
  358|      0|          buf[n] = 0xff;
  359|      0|       }
  360|      0|    }
  361|      0|}
  362|       |
  363|       |local int zip64local_getByte OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, int *pi));
  364|       |local int zip64local_getByte(const zlib_filefunc64_32_def* pzlib_filefunc_def,voidpf filestream,int* pi)
  365|      0|{
  366|      0|    unsigned char c;
  367|      0|    int err = (int)ZREAD64(*pzlib_filefunc_def, filestream, &c,1);
  368|      0|    if (err == 1)
  369|      0|    {
  370|      0|        *pi = (int)c;
  371|      0|        return ZIP_OK;
  372|      0|    }
  373|      0|    if (ZERROR64(*pzlib_filefunc_def, filestream))
  374|      0|        return ZIP_ERRNO;
  375|      0|    return ZIP_EOF;
  376|      0|}
  377|       |
  378|       |local int zip64local_getShort OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
  379|       |local int zip64local_getShort (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
  380|      0|{
  381|      0|    uLong x;
  382|      0|    int i = 0;
  383|      0|    int err;
  384|      0|
  385|      0|    err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  386|      0|    x = (uLong)i;
  387|      0|    if (err == ZIP_OK)
  388|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  389|      0|    x += ((uLong)i) << 8;
  390|      0|
  391|      0|    if (err == ZIP_OK)
  392|      0|        *pX = x;
  393|      0|    else
  394|      0|        *pX = 0;
  395|      0|    return err;
  396|      0|}
  397|       |
  398|       |local int zip64local_getLong OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));
  399|       |local int zip64local_getLong (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
  400|      0|{
  401|      0|    uLong x;
  402|      0|    int i = 0;
  403|      0|    int err;
  404|      0|
  405|      0|    err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  406|      0|    x = (uLong)i;
  407|      0|    if (err == ZIP_OK)
  408|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  409|      0|    x += ((uLong)i) << 8;
  410|      0|    if (err == ZIP_OK)
  411|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  412|      0|    x += ((uLong)i) << 16;
  413|      0|    if (err == ZIP_OK)
  414|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  415|      0|    x += ((uLong)i) << 24;
  416|      0|
  417|      0|    if (err == ZIP_OK)
  418|      0|        *pX = x;
  419|      0|    else
  420|      0|        *pX = 0;
  421|      0|    return err;
  422|      0|}
  423|       |
  424|       |local int zip64local_getLong64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX));
  425|       |local int zip64local_getLong64 (const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)
  426|      0|{
  427|      0|    ZPOS64_T x;
  428|      0|    int i = 0;
  429|      0|    int err;
  430|      0|
  431|      0|    err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  432|      0|    x = (ZPOS64_T)i;
  433|      0|    if (err == ZIP_OK)
  434|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  435|      0|    x += ((ZPOS64_T)i) << 8;
  436|      0|    if (err == ZIP_OK)
  437|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  438|      0|    x += ((ZPOS64_T)i) << 16;
  439|      0|    if (err == ZIP_OK)
  440|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  441|      0|    x += ((ZPOS64_T)i) << 24;
  442|      0|    if (err == ZIP_OK)
  443|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  444|      0|    x += ((ZPOS64_T)i) << 32;
  445|      0|    if (err == ZIP_OK)
  446|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  447|      0|    x += ((ZPOS64_T)i) << 40;
  448|      0|    if (err == ZIP_OK)
  449|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  450|      0|    x += ((ZPOS64_T)i) << 48;
  451|      0|    if (err == ZIP_OK)
  452|      0|        err = zip64local_getByte(pzlib_filefunc_def, filestream, &i);
  453|      0|    x += ((ZPOS64_T)i) << 56;
  454|      0|
  455|      0|    if (err == ZIP_OK)
  456|      0|        *pX = x;
  457|      0|    else
  458|      0|        *pX = 0;
  459|      0|
  460|      0|    return err;
  461|      0|}
  462|       |
  463|       |/* Gets the amount of bytes left to write to the current disk for spanning archives */
  464|       |local int zipGetDiskSizeAvailable OF((zipFile file, ZPOS64_T *size_available));
  465|       |local int zipGetDiskSizeAvailable(zipFile file, ZPOS64_T *size_available)
  466|      0|{
  467|      0|    zip64_internal* zi;
  468|      0|    ZPOS64_T current_disk_size;
  469|      0|
  470|      0|    zi = (zip64_internal*)file;
  471|      0|    ZSEEK64(zi->z_filefunc, zi->filestream, 0, ZLIB_FILEFUNC_SEEK_END);
  472|      0|    current_disk_size = ZTELL64(zi->z_filefunc, zi->filestream);
  473|      0|    *size_available = zi->disk_size - current_disk_size;
  474|      0|    return ZIP_OK;
  475|      0|}
  476|       |
  477|       |/* Goes to a specific disk number for spanning archives */
  478|       |local int zipGoToSpecificDisk OF((zipFile file, int number_disk, int open_existing));
  479|       |local int zipGoToSpecificDisk(zipFile file, int number_disk, int open_existing)
  480|      0|{
  481|      0|    zip64_internal* zi;
  482|      0|    int err = ZIP_OK;
  483|      0|
  484|      0|    zi = (zip64_internal*)file;
  485|      0|    if (zi->disk_size == 0)
  486|      0|        return err;
  487|      0|
  488|      0|    if ((zi->filestream != NULL) && (zi->filestream != zi->filestream_with_CD))
  489|      0|        ZCLOSE64(zi->z_filefunc, zi->filestream);
  490|      0|
  491|      0|    zi->filestream = ZOPENDISK64(zi->z_filefunc, zi->filestream_with_CD, number_disk, (open_existing == 1) ?
  492|      0|            (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING) :
  493|      0|            (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE));
  494|      0|
  495|      0|    if (zi->filestream == NULL)
  496|      0|        err = ZIP_ERRNO;
  497|      0|
  498|      0|    return err;
  499|      0|}
  500|       |
  501|       |/* Goes to the first disk in a spanned archive */
  502|       |local int zipGoToFirstDisk OF((zipFile file));
  503|       |local int zipGoToFirstDisk(zipFile file)
  504|      0|{
  505|      0|    zip64_internal* zi;
  506|      0|    int number_disk_next;
  507|      0|    int err = ZIP_OK;
  508|      0|
  509|      0|    zi = (zip64_internal*)file;
  510|      0|
  511|      0|    if (zi->disk_size == 0)
  512|      0|        return err;
  513|      0|    number_disk_next = 0;
  514|      0|    if (zi->number_disk_with_CD > 0)
  515|      0|        number_disk_next = (int)zi->number_disk_with_CD - 1;
  516|      0|    err = zipGoToSpecificDisk(file, number_disk_next, (zi->append == APPEND_STATUS_ADDINZIP));
  517|      0|    if ((err == ZIP_ERRNO) && (zi->append == APPEND_STATUS_ADDINZIP))
  518|      0|        err = zipGoToSpecificDisk(file, number_disk_next, 0);
  519|      0|    if (err == ZIP_OK)
  520|      0|        zi->number_disk = number_disk_next;
  521|      0|    ZSEEK64(zi->z_filefunc, zi->filestream, 0, ZLIB_FILEFUNC_SEEK_END);
  522|      0|    return err;
  523|      0|}
  524|       |
  525|       |/* Goes to the next disk in a spanned archive */
  526|       |local int zipGoToNextDisk OF((zipFile file));
  527|       |local int zipGoToNextDisk(zipFile file)
  528|      0|{
  529|      0|    zip64_internal* zi;
  530|      0|    ZPOS64_T size_available_in_disk;
  531|      0|    int err = ZIP_OK;
  532|      0|    int number_disk_next;
  533|      0|
  534|      0|    zi = (zip64_internal*)file;
  535|      0|
  536|      0|    if (zi->disk_size == 0)
  537|      0|        return err;
  538|      0|
  539|      0|    number_disk_next = (int)zi->number_disk + 1;
  540|      0|
  541|      0|    do
  542|      0|    {
  543|      0|        err = zipGoToSpecificDisk(file, number_disk_next, (zi->append == APPEND_STATUS_ADDINZIP));
  544|      0|        if ((err == ZIP_ERRNO) && (zi->append == APPEND_STATUS_ADDINZIP))
  545|      0|            err = zipGoToSpecificDisk(file, number_disk_next, 0);
  546|      0|        if (err != ZIP_OK)
  547|      0|            break;
  548|      0|        err = zipGetDiskSizeAvailable(file, &size_available_in_disk);
  549|      0|        if (err != ZIP_OK)
  550|      0|            break;
  551|      0|        zi->number_disk = number_disk_next;
  552|      0|        zi->number_disk_with_CD = zi->number_disk + 1;
  553|      0|
  554|      0|        number_disk_next += 1;
  555|      0|    }
  556|      0|    while (size_available_in_disk <= 0);
  557|      0|
  558|      0|    return err;
  559|      0|}
  560|       |
  561|       |/* Locate the Central directory of a zipfile (at the end, just before the global comment) */
  562|       |local ZPOS64_T zip64local_SearchCentralDir OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));
  563|       |local ZPOS64_T zip64local_SearchCentralDir(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
  564|      0|{
  565|      0|    unsigned char* buf;
  566|      0|    ZPOS64_T file_size;
  567|      0|    ZPOS64_T back_read = 4;
  568|      0|    ZPOS64_T max_back=0xffff; /* maximum size of global comment */
  569|      0|    ZPOS64_T pos_found=0;
  570|      0|    uLong read_size;
  571|      0|    ZPOS64_T read_pos;
  572|      0|    int i;
  573|      0|
  574|      0|    buf = (unsigned char*)ALLOC(BUFREADCOMMENT+4);
  575|      0|    if (buf == NULL)
  576|      0|        return 0;
  577|      0|
  578|      0|    if (ZSEEK64(*pzlib_filefunc_def, filestream, 0, ZLIB_FILEFUNC_SEEK_END) != 0)
  579|      0|    {
  580|      0|        TRYFREE(buf);
  581|      0|        return 0;
  582|      0|    }
  583|      0|
  584|      0|    file_size = ZTELL64(*pzlib_filefunc_def, filestream);
  585|      0|
  586|      0|    if (max_back > file_size)
  587|      0|        max_back = file_size;
  588|      0|
  589|      0|    while (back_read < max_back)
  590|      0|    {
  591|      0|        if (back_read + BUFREADCOMMENT > max_back)
  592|      0|            back_read = max_back;
  593|      0|        else
  594|      0|            back_read += BUFREADCOMMENT;
  595|      0|
  596|      0|        read_pos = file_size-back_read;
  597|      0|        read_size = ((BUFREADCOMMENT+4) < (file_size-read_pos)) ?
  598|      0|                     (BUFREADCOMMENT+4) : (uLong)(file_size-read_pos);
  599|      0|
  600|      0|        if (ZSEEK64(*pzlib_filefunc_def, filestream, read_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
  601|      0|            break;
  602|      0|        if (ZREAD64(*pzlib_filefunc_def, filestream, buf, read_size) != read_size)
  603|      0|            break;
  604|      0|
  605|      0|        for (i = (int)read_size-3; (i--) > 0;)
  606|      0|            if ((*(buf+i)) == (ENDHEADERMAGIC & 0xff) &&
  607|      0|                (*(buf+i+1)) == (ENDHEADERMAGIC >> 8 & 0xff) &&
  608|      0|                (*(buf+i+2)) == (ENDHEADERMAGIC >> 16 & 0xff) &&
  609|      0|                (*(buf+i+3)) == (ENDHEADERMAGIC >> 24 & 0xff))
  610|      0|            {
  611|      0|                pos_found = read_pos+i;
  612|      0|                break;
  613|      0|            }
  614|      0|
  615|      0|        if (pos_found != 0)
  616|      0|            break;
  617|      0|    }
  618|      0|    TRYFREE(buf);
  619|      0|    return pos_found;
  620|      0|}
  621|       |
  622|       |/* Locate the Central directory 64 of a zipfile (at the end, just before the global comment) */
  623|       |local ZPOS64_T zip64local_SearchCentralDir64 OF((const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream,
  624|       |    const ZPOS64_T endcentraloffset));
  625|       |local ZPOS64_T zip64local_SearchCentralDir64(const zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream,
  626|       |    const ZPOS64_T endcentraloffset)
  627|      0|{
  628|      0|    ZPOS64_T offset;
  629|      0|    uLong uL;
  630|      0|
  631|      0|    /* Zip64 end of central directory locator */
  632|      0|    if (ZSEEK64(*pzlib_filefunc_def, filestream, endcentraloffset - SIZECENTRALHEADERLOCATOR, ZLIB_FILEFUNC_SEEK_SET) != 0)
  633|      0|        return 0;
  634|      0|
  635|      0|    /* Read locator signature */
  636|      0|    if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
  637|      0|        return 0;
  638|      0|    if (uL != ZIP64ENDLOCHEADERMAGIC)
  639|      0|        return 0;
  640|      0|    /* Number of the disk with the start of the zip64 end of  central directory */
  641|      0|    if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
  642|      0|        return 0;
  643|      0|    /* Relative offset of the zip64 end of central directory record */
  644|      0|    if (zip64local_getLong64(pzlib_filefunc_def, filestream, &offset) != ZIP_OK)
  645|      0|        return 0;
  646|      0|    /* Total number of disks */
  647|      0|    if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
  648|      0|        return 0;
  649|      0|    /* Goto end of central directory record */
  650|      0|    if (ZSEEK64(*pzlib_filefunc_def,filestream, offset, ZLIB_FILEFUNC_SEEK_SET) != 0)
  651|      0|        return 0;
  652|      0|    /* The signature */
  653|      0|    if (zip64local_getLong(pzlib_filefunc_def, filestream, &uL) != ZIP_OK)
  654|      0|        return 0;
  655|      0|    if (uL != ZIP64ENDHEADERMAGIC)
  656|      0|        return 0;
  657|      0|
  658|      0|    return offset;
  659|      0|}
  660|       |
  661|       |extern zipFile ZEXPORT zipOpen4(const void *pathname, int append, ZPOS64_T disk_size, const char ** globalcomment,
  662|       |    zlib_filefunc64_32_def* pzlib_filefunc64_32_def)
  663|      0|{
  664|      0|    zip64_internal ziinit;
  665|      0|    zip64_internal* zi;
  666|      0|#ifndef NO_ADDFILEINEXISTINGZIP
  667|      0|    ZPOS64_T byte_before_the_zipfile;   /* byte before the zipfile, (>0 for sfx)*/
  668|      0|    ZPOS64_T size_central_dir = 0;          /* size of the central directory  */
  669|      0|    ZPOS64_T offset_central_dir = 0;        /* offset of start of central directory */
  670|      0|    ZPOS64_T number_entry_CD = 0;           /* total number of entries in the central dir */
  671|      0|    ZPOS64_T number_entry;
  672|      0|    ZPOS64_T central_pos;
  673|      0|    ZPOS64_T size_central_dir_to_read;
  674|      0|    uLong uL;
  675|      0|    uLong size_comment = 0;
  676|      0|    size_t buf_size = SIZEDATA_INDATABLOCK;
  677|      0|    void* buf_read;
  678|      0|#endif
  679|      0|    int err = ZIP_OK;
  680|      0|    int mode;
  681|      0|
  682|      0|    ziinit.z_filefunc.zseek32_file = NULL;
  683|      0|    ziinit.z_filefunc.ztell32_file = NULL;
  684|      0|    if (pzlib_filefunc64_32_def == NULL)
  685|      0|        fill_fopen64_filefunc(&ziinit.z_filefunc.zfile_func64);
  686|      0|    else
  687|      0|        ziinit.z_filefunc = *pzlib_filefunc64_32_def;
  688|      0|
  689|      0|    if (append == APPEND_STATUS_CREATE)
  690|      0|        mode = (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE);
  691|      0|    else
  692|      0|        mode = (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING);
  693|      0|
  694|      0|    ziinit.filestream = ZOPEN64(ziinit.z_filefunc, pathname, mode);
  695|      0|    if (ziinit.filestream == NULL)
  696|      0|        return NULL;
  697|      0|
  698|      0|    if (append == APPEND_STATUS_CREATEAFTER)
  699|      0|    {
  700|      0|        /* Don't support spanning ZIP with APPEND_STATUS_CREATEAFTER */
  701|      0|        if (disk_size > 0)
  702|      0|            return NULL;
  703|      0|
  704|      0|        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);
  705|      0|    }
  706|      0|
  707|      0|    ziinit.filestream_with_CD = ziinit.filestream;
  708|      0|    ziinit.append = append;
  709|      0|    ziinit.number_disk = 0;
  710|      0|    ziinit.number_disk_with_CD = 0;
  711|      0|    ziinit.disk_size = disk_size;
  712|      0|    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);
  713|      0|    ziinit.in_opened_file_inzip = 0;
  714|      0|    ziinit.ci.stream_initialised = 0;
  715|      0|    ziinit.number_entry = 0;
  716|      0|    ziinit.add_position_when_writting_offset = 0;
  717|      0|    init_linkedlist(&(ziinit.central_dir));
  718|      0|
  719|      0|    zi = (zip64_internal*)ALLOC(sizeof(zip64_internal));
  720|      0|    if (zi == NULL)
  721|      0|    {
  722|      0|        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);
  723|      0|        return NULL;
  724|      0|    }
  725|      0|
  726|      0|#ifndef NO_ADDFILEINEXISTINGZIP
  727|      0|    /* Add file in a zipfile */
  728|      0|    ziinit.globalcomment = NULL;
  729|      0|    if (append == APPEND_STATUS_ADDINZIP)
  730|      0|    {
  731|      0|        /* Read and Cache Central Directory Records */
  732|      0|        central_pos = zip64local_SearchCentralDir(&ziinit.z_filefunc,ziinit.filestream);
  733|      0|        /* Disable to allow appending to empty ZIP archive (must be standard zip, not zip64)
  734|      0|            if (central_pos == 0)
  735|      0|                err = ZIP_ERRNO;
  736|      0|        */
  737|      0|
  738|      0|        if (err == ZIP_OK)
  739|      0|        {
  740|      0|            /* Read end of central directory info */
  741|      0|            if (ZSEEK64(ziinit.z_filefunc, ziinit.filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET) != 0)
  742|      0|                err = ZIP_ERRNO;
  743|      0|
  744|      0|            /* The signature, already checked */
  745|      0|            if (zip64local_getLong(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  746|      0|                err = ZIP_ERRNO;
  747|      0|            /* Number of this disk */
  748|      0|            if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &ziinit.number_disk) != ZIP_OK)
  749|      0|                err = ZIP_ERRNO;
  750|      0|            /* Number of the disk with the start of the central directory */
  751|      0|            if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &ziinit.number_disk_with_CD) != ZIP_OK)
  752|      0|                err = ZIP_ERRNO;
  753|      0|            /* Total number of entries in the central dir on this disk */
  754|      0|            number_entry = 0;
  755|      0|            if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  756|      0|                err = ZIP_ERRNO;
  757|      0|            else
  758|      0|                number_entry = uL;
  759|      0|            /* Total number of entries in the central dir */
  760|      0|            number_entry_CD = 0;
  761|      0|            if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  762|      0|                err = ZIP_ERRNO;
  763|      0|            else
  764|      0|                number_entry_CD = uL;
  765|      0|            if (number_entry_CD!=number_entry)
  766|      0|                err = ZIP_BADZIPFILE;
  767|      0|            /* Size of the central directory */
  768|      0|            size_central_dir = 0;
  769|      0|            if (zip64local_getLong(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  770|      0|                err = ZIP_ERRNO;
  771|      0|            else
  772|      0|                size_central_dir = uL;
  773|      0|            /* Offset of start of central directory with respect to the starting disk number */
  774|      0|            offset_central_dir = 0;
  775|      0|            if (zip64local_getLong(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  776|      0|                err = ZIP_ERRNO;
  777|      0|            else
  778|      0|                offset_central_dir = uL;
  779|      0|            /* Zipfile global comment length */
  780|      0|            if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &size_comment) != ZIP_OK)
  781|      0|                err = ZIP_ERRNO;
  782|      0|
  783|      0|            if ((err == ZIP_OK) && ((number_entry_CD == 0xffff) || (offset_central_dir == 0xffffffff)))
  784|      0|            {
  785|      0|                /* Format should be Zip64, as the central directory or file size is too large */
  786|      0|                central_pos = zip64local_SearchCentralDir64(&ziinit.z_filefunc, ziinit.filestream, central_pos);
  787|      0|
  788|      0|                if (central_pos)
  789|      0|                {
  790|      0|                    ZPOS64_T sizeEndOfCentralDirectory;
  791|      0|
  792|      0|                    if (ZSEEK64(ziinit.z_filefunc, ziinit.filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
  793|      0|                        err = ZIP_ERRNO;
  794|      0|
  795|      0|                    /* The signature, already checked */
  796|      0|                    if (zip64local_getLong(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  797|      0|                        err = ZIP_ERRNO;
  798|      0|                    /* Size of zip64 end of central directory record */
  799|      0|                    if (zip64local_getLong64(&ziinit.z_filefunc, ziinit.filestream, &sizeEndOfCentralDirectory) != ZIP_OK)
  800|      0|                        err = ZIP_ERRNO;
  801|      0|                    /* Version made by */
  802|      0|                    if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  803|      0|                        err = ZIP_ERRNO;
  804|      0|                    /* Version needed to extract */
  805|      0|                    if (zip64local_getShort(&ziinit.z_filefunc, ziinit.filestream, &uL) != ZIP_OK)
  806|      0|                        err = ZIP_ERRNO;
  807|      0|                    /* Number of this disk */
  808|      0|                    if (zip64local_getLong(&ziinit.z_filefunc, ziinit.filestream, &ziinit.number_disk) != ZIP_OK)
  809|      0|                        err = ZIP_ERRNO;
  810|      0|                    /* Number of the disk with the start of the central directory */
  811|      0|                    if (zip64local_getLong(&ziinit.z_filefunc, ziinit.filestream, &ziinit.number_disk_with_CD) != ZIP_OK)
  812|      0|                        err = ZIP_ERRNO;
  813|      0|                    /* Total number of entries in the central directory on this disk */
  814|      0|                    if (zip64local_getLong64(&ziinit.z_filefunc, ziinit.filestream, &number_entry) != ZIP_OK)
  815|      0|                        err = ZIP_ERRNO;
  816|      0|                    /* Total number of entries in the central directory */
  817|      0|                    if (zip64local_getLong64(&ziinit.z_filefunc, ziinit.filestream, &number_entry_CD) != ZIP_OK)
  818|      0|                        err = ZIP_ERRNO;
  819|      0|                    if (number_entry_CD!=number_entry)
  820|      0|                        err = ZIP_BADZIPFILE;
  821|      0|                    /* Size of the central directory */
  822|      0|                    if (zip64local_getLong64(&ziinit.z_filefunc, ziinit.filestream, &size_central_dir) != ZIP_OK)
  823|      0|                        err = ZIP_ERRNO;
  824|      0|                    /* Offset of start of central directory with respect to the starting disk number */
  825|      0|                    if (zip64local_getLong64(&ziinit.z_filefunc, ziinit.filestream, &offset_central_dir) != ZIP_OK)
  826|      0|                        err = ZIP_ERRNO;
  827|      0|                }
  828|      0|                else
  829|      0|                    err = ZIP_BADZIPFILE;
  830|      0|             }
  831|      0|        }
  832|      0|
  833|      0|        if ((err == ZIP_OK) && (central_pos<offset_central_dir+size_central_dir))
  834|      0|            err = ZIP_BADZIPFILE;
  835|      0|
  836|      0|        if (err != ZIP_OK)
  837|      0|        {
  838|      0|            ZCLOSE64(ziinit.z_filefunc, ziinit.filestream);
  839|      0|            TRYFREE(zi);
  840|      0|            return NULL;
  841|      0|        }
  842|      0|
  843|      0|        if (size_comment > 0)
  844|      0|        {
  845|      0|            ziinit.globalcomment = (char*)ALLOC(size_comment+1);
  846|      0|            if (ziinit.globalcomment)
  847|      0|            {
  848|      0|                size_comment = ZREAD64(ziinit.z_filefunc, ziinit.filestream, ziinit.globalcomment, size_comment);
  849|      0|                ziinit.globalcomment[size_comment] = 0;
  850|      0|            }
  851|      0|        }
  852|      0|
  853|      0|        byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);
  854|      0|        ziinit.add_position_when_writting_offset = byte_before_the_zipfile;
  855|      0|
  856|      0|        /* Store central directory in memory */
  857|      0|        size_central_dir_to_read = size_central_dir;
  858|      0|        buf_size = SIZEDATA_INDATABLOCK;
  859|      0|        buf_read = (void*)ALLOC(buf_size);
  860|      0|
  861|      0|        if (ZSEEK64(ziinit.z_filefunc, ziinit.filestream,
  862|      0|                offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
  863|      0|            err = ZIP_ERRNO;
  864|      0|
  865|      0|        while ((size_central_dir_to_read > 0) && (err == ZIP_OK))
  866|      0|        {
  867|      0|            ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
  868|      0|            if (read_this > size_central_dir_to_read)
  869|      0|                read_this = size_central_dir_to_read;
  870|      0|
  871|      0|            if (ZREAD64(ziinit.z_filefunc, ziinit.filestream, buf_read, (uLong)read_this) != read_this)
  872|      0|                err = ZIP_ERRNO;
  873|      0|
  874|      0|            if (err == ZIP_OK)
  875|      0|                err = add_data_in_datablock(&ziinit.central_dir, buf_read, (uLong)read_this);
  876|      0|
  877|      0|            size_central_dir_to_read -= read_this;
  878|      0|        }
  879|      0|        TRYFREE(buf_read);
  880|      0|
  881|      0|        ziinit.begin_pos = byte_before_the_zipfile;
  882|      0|        ziinit.number_entry = number_entry_CD;
  883|      0|
  884|      0|        if (ZSEEK64(ziinit.z_filefunc, ziinit.filestream,
  885|      0|                offset_central_dir+byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
  886|      0|            err = ZIP_ERRNO;
  887|      0|    }
  888|      0|
  889|      0|    if (globalcomment)
  890|      0|        *globalcomment = ziinit.globalcomment;
  891|      0|#endif
  892|      0|
  893|      0|    if (err != ZIP_OK)
  894|      0|    {
  895|      0|#ifndef NO_ADDFILEINEXISTINGZIP
  896|      0|        TRYFREE(ziinit.globalcomment);
  897|      0|#endif
  898|      0|        TRYFREE(zi);
  899|      0|        return NULL;
  900|      0|    }
  901|      0|
  902|      0|    *zi = ziinit;
  903|      0|    zipGoToFirstDisk((zipFile)zi);
  904|      0|    return(zipFile)zi;
  905|      0|}
  906|       |
  907|       |extern zipFile ZEXPORT zipOpen2(const char *pathname, int append, const char ** globalcomment,
  908|       |    zlib_filefunc_def* pzlib_filefunc32_def)
  909|      0|{
  910|      0|    if (pzlib_filefunc32_def != NULL)
  911|      0|    {
  912|      0|        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
  913|      0|        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
  914|      0|        return zipOpen4(pathname, append, 0, globalcomment, &zlib_filefunc64_32_def_fill);
  915|      0|    }
  916|      0|    return zipOpen4(pathname, append, 0, globalcomment, NULL);
  917|      0|}
  918|       |
  919|       |extern zipFile ZEXPORT zipOpen2_64(const void *pathname, int append, const char ** globalcomment,
  920|       |    zlib_filefunc64_def* pzlib_filefunc_def)
  921|      0|{
  922|      0|    if (pzlib_filefunc_def != NULL)
  923|      0|    {
  924|      0|        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
  925|      0|        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
  926|      0|        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
  927|      0|        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
  928|      0|        return zipOpen4(pathname, append, 0, globalcomment, &zlib_filefunc64_32_def_fill);
  929|      0|    }
  930|      0|    return zipOpen4(pathname, append, 0, globalcomment, NULL);
  931|      0|}
  932|       |
  933|       |extern zipFile ZEXPORT zipOpen3(const char *pathname, int append, ZPOS64_T disk_size, const char ** globalcomment,
  934|       |    zlib_filefunc_def* pzlib_filefunc32_def)
  935|      0|{
  936|      0|    if (pzlib_filefunc32_def != NULL)
  937|      0|    {
  938|      0|        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
  939|      0|        fill_zlib_filefunc64_32_def_from_filefunc32(&zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
  940|      0|        return zipOpen4(pathname, append, disk_size, globalcomment, &zlib_filefunc64_32_def_fill);
  941|      0|    }
  942|      0|    return zipOpen4(pathname, append, disk_size, globalcomment, NULL);
  943|      0|}
  944|       |
  945|       |extern zipFile ZEXPORT zipOpen3_64(const void *pathname, int append, ZPOS64_T disk_size, const char ** globalcomment,
  946|       |    zlib_filefunc64_def* pzlib_filefunc_def)
  947|      0|{
  948|      0|    if (pzlib_filefunc_def != NULL)
  949|      0|    {
  950|      0|        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
  951|      0|        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
  952|      0|        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
  953|      0|        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
  954|      0|        return zipOpen4(pathname, append, disk_size, globalcomment, &zlib_filefunc64_32_def_fill);
  955|      0|    }
  956|      0|    return zipOpen4(pathname, append, disk_size, globalcomment, NULL);
  957|      0|}
  958|       |
  959|       |extern zipFile ZEXPORT zipOpen(const char* pathname, int append)
  960|      0|{
  961|      0|    return zipOpen3((const void*)pathname,append,0,NULL,NULL);
  962|      0|}
  963|       |
  964|       |extern zipFile ZEXPORT zipOpen64(const void* pathname, int append)
  965|      0|{
  966|      0|    return zipOpen3(pathname,append,0,NULL,NULL);
  967|      0|}
  968|       |
  969|       |extern int ZEXPORT zipOpenNewFileInZip4_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
  970|       |    const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global,
  971|       |    uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits, int memLevel,
  972|       |    int strategy, const char* password, uLong crcForCrypting, uLong versionMadeBy, uLong flagBase, int zip64)
  973|      0|{
  974|      0|    zip64_internal* zi;
  975|      0|    uInt size_filename;
  976|      0|    uInt size_comment = 0;
  977|      0|    uInt i;
  978|      0|    int err = ZIP_OK;
  979|      0|    ZPOS64_T size_available;
  980|      0|    ZPOS64_T size_needed;
  981|      0|
  982|      0|#ifdef NOCRYPT
  983|       |    (crcForCrypting);
  984|       |    if (password != NULL)
  985|       |        return ZIP_PARAMERROR;
  986|       |#endif
  987|      0|
  988|      0|    if (file == NULL)
  989|      0|        return ZIP_PARAMERROR;
  990|      0|
  991|      0|    if ((method != 0) &&
  992|      0|#ifdef HAVE_BZIP2
  993|       |        (method != Z_BZIP2ED) &&
  994|       |#endif
  995|      0|        (method != Z_DEFLATED))
  996|      0|        return ZIP_PARAMERROR;
  997|      0|
  998|      0|    zi = (zip64_internal*)file;
  999|      0|
 1000|      0|    if (zi->in_opened_file_inzip == 1)
 1001|      0|    {
 1002|      0|        err = zipCloseFileInZip (file);
 1003|      0|        if (err != ZIP_OK)
 1004|      0|            return err;
 1005|      0|    }
 1006|      0|
 1007|      0|    if (filename == NULL)
 1008|      0|        filename = "-";
 1009|      0|    if (comment != NULL)
 1010|      0|        size_comment = (uInt)strlen(comment);
 1011|      0|
 1012|      0|    size_filename = (uInt)strlen(filename);
 1013|      0|
 1014|      0|    if (zipfi == NULL)
 1015|      0|        zi->ci.dosDate = 0;
 1016|      0|    else
 1017|      0|    {
 1018|      0|        if (zipfi->dosDate != 0)
 1019|      0|            zi->ci.dosDate = zipfi->dosDate;
 1020|      0|        else
 1021|      0|            zi->ci.dosDate = zip64local_TmzDateToDosDate(&zipfi->tmz_date);
 1022|      0|    }
 1023|      0|
 1024|      0|    zi->ci.method = method;
 1025|      0|    zi->ci.compression_method = method;
 1026|      0|    zi->ci.crc32 = 0;
 1027|      0|    zi->ci.stream_initialised = 0;
 1028|      0|    zi->ci.pos_in_buffered_data = 0;
 1029|      0|    zi->ci.raw = raw;
 1030|      0|    zi->ci.flag = flagBase;
 1031|      0|    if ((level == 8) || (level == 9))
 1032|      0|        zi->ci.flag |= 2;
 1033|      0|    if (level == 2)
 1034|      0|        zi->ci.flag |= 4;
 1035|      0|    if (level == 1)
 1036|      0|        zi->ci.flag |= 6;
 1037|      0|    if (password != NULL)
 1038|      0|    {
 1039|      0|        zi->ci.flag |= 1;
 1040|      0|#ifdef HAVE_AES
 1041|       |        zi->ci.method = AES_METHOD;
 1042|       |#endif
 1043|      0|    }
 1044|      0|
 1045|      0|    if (zi->disk_size > 0)
 1046|      0|    {
 1047|      0|        if ((zi->number_disk == 0) && (zi->number_entry == 0))
 1048|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)DISKHEADERMAGIC, 4);
 1049|      0|
 1050|      0|        /* Make sure enough space available on current disk for local header */
 1051|      0|        zipGetDiskSizeAvailable((zipFile)zi, &size_available);
 1052|      0|        size_needed = 30 + size_filename + size_extrafield_local;
 1053|      0|        if (zi->ci.zip64)
 1054|      0|            size_needed += 20;
 1055|      0|#ifdef HAVE_AES
 1056|       |        if (zi->ci.method == AES_METHOD)
 1057|       |            size_needed += 11;
 1058|       |#endif
 1059|      0|        if (size_available < size_needed)
 1060|      0|            zipGoToNextDisk((zipFile)zi);
 1061|      0|    }
 1062|      0|
 1063|      0|    zi->ci.pos_local_header = ZTELL64(zi->z_filefunc, zi->filestream);
 1064|      0|    zi->ci.size_comment = size_comment;
 1065|      0|    zi->ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global;
 1066|      0|    zi->ci.size_centralextra = size_extrafield_global;
 1067|      0|    zi->ci.size_centralextrafree = 32; /* Extra space reserved for ZIP64 extra info */
 1068|      0|#ifdef HAVE_AES
 1069|       |    if (zi->ci.method == AES_METHOD)
 1070|       |        zi->ci.size_centralextrafree += 11; /* Extra space reserved for AES extra info */
 1071|       |#endif
 1072|      0|    zi->ci.central_header = (char*)ALLOC((uInt)zi->ci.size_centralheader + zi->ci.size_centralextrafree + size_comment);
 1073|      0|    zi->ci.number_disk = zi->number_disk;
 1074|      0|
 1075|      0|    /* Write central directory header */
 1076|      0|    zip64local_putValue_inmemory(zi->ci.central_header, (uLong)CENTRALHEADERMAGIC, 4);
 1077|      0|    zip64local_putValue_inmemory(zi->ci.central_header+4, (uLong)versionMadeBy, 2);
 1078|      0|    zip64local_putValue_inmemory(zi->ci.central_header+6, (uLong)20, 2);
 1079|      0|    zip64local_putValue_inmemory(zi->ci.central_header+8, (uLong)zi->ci.flag, 2);
 1080|      0|    zip64local_putValue_inmemory(zi->ci.central_header+10, (uLong)zi->ci.method, 2);
 1081|      0|    zip64local_putValue_inmemory(zi->ci.central_header+12, (uLong)zi->ci.dosDate, 4);
 1082|      0|    zip64local_putValue_inmemory(zi->ci.central_header+16, (uLong)0, 4); /*crc*/
 1083|      0|    zip64local_putValue_inmemory(zi->ci.central_header+20, (uLong)0, 4); /*compr size*/
 1084|      0|    zip64local_putValue_inmemory(zi->ci.central_header+24, (uLong)0, 4); /*uncompr size*/
 1085|      0|    zip64local_putValue_inmemory(zi->ci.central_header+28, (uLong)size_filename, 2);
 1086|      0|    zip64local_putValue_inmemory(zi->ci.central_header+30, (uLong)size_extrafield_global, 2);
 1087|      0|    zip64local_putValue_inmemory(zi->ci.central_header+32, (uLong)size_comment, 2);
 1088|      0|    zip64local_putValue_inmemory(zi->ci.central_header+34, (uLong)zi->ci.number_disk, 2); /*disk nm start*/
 1089|      0|
 1090|      0|    if (zipfi == NULL)
 1091|      0|        zip64local_putValue_inmemory(zi->ci.central_header+36, (uLong)0, 2);
 1092|      0|    else
 1093|      0|        zip64local_putValue_inmemory(zi->ci.central_header+36, (uLong)zipfi->internal_fa, 2);
 1094|      0|    if (zipfi == NULL)
 1095|      0|        zip64local_putValue_inmemory(zi->ci.central_header+38, (uLong)0, 4);
 1096|      0|    else
 1097|      0|        zip64local_putValue_inmemory(zi->ci.central_header+38, (uLong)zipfi->external_fa, 4);
 1098|      0|    if (zi->ci.pos_local_header >= 0xffffffff)
 1099|      0|        zip64local_putValue_inmemory(zi->ci.central_header+42, (uLong)0xffffffff, 4);
 1100|      0|    else
 1101|      0|        zip64local_putValue_inmemory(zi->ci.central_header+42,
 1102|      0|            (uLong)zi->ci.pos_local_header - zi->add_position_when_writting_offset, 4);
 1103|      0|
 1104|      0|    for (i = 0; i < size_filename; i++)
 1105|      0|        zi->ci.central_header[SIZECENTRALHEADER+i] = filename[i];
 1106|      0|    for (i = 0; i < size_extrafield_global; i++)
 1107|      0|        zi->ci.central_header[SIZECENTRALHEADER+size_filename+i] =
 1108|      0|            ((const char*)extrafield_global)[i];
 1109|      0|    /* Store comment at the end for later repositioning */
 1110|      0|    for (i = 0; i < size_comment; i++)
 1111|      0|        zi->ci.central_header[zi->ci.size_centralheader+
 1112|      0|            zi->ci.size_centralextrafree+i] = comment[i];
 1113|      0|
 1114|      0|    if (zi->ci.central_header == NULL)
 1115|      0|        return ZIP_INTERNALERROR;
 1116|      0|
 1117|      0|    zi->ci.zip64 = zip64;
 1118|      0|    zi->ci.total_compressed = 0;
 1119|      0|    zi->ci.total_uncompressed = 0;
 1120|      0|    zi->ci.pos_zip64extrainfo = 0;
 1121|      0|
 1122|      0|    /* Write the local header */
 1123|      0|    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)LOCALHEADERMAGIC, 4);
 1124|      0|
 1125|      0|    if (err == ZIP_OK)
 1126|      0|    {
 1127|      0|        if (zi->ci.zip64)
 1128|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)45, 2); /* version needed to extract */
 1129|      0|        else
 1130|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)20, 2); /* version needed to extract */
 1131|      0|    }
 1132|      0|    if (err == ZIP_OK)
 1133|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->ci.flag, 2);
 1134|      0|    if (err == ZIP_OK)
 1135|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->ci.method, 2);
 1136|      0|    if (err == ZIP_OK)
 1137|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->ci.dosDate, 4);
 1138|      0|
 1139|      0|    /* CRC & compressed size & uncompressed size will be filled in later and rewritten later */
 1140|      0|
 1141|      0|    if (err == ZIP_OK)
 1142|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4); /* crc 32, unknown */
 1143|      0|    if (err == ZIP_OK)
 1144|      0|    {
 1145|      0|        if (zi->ci.zip64)
 1146|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xFFFFFFFF, 4); /* compressed size, unknown */
 1147|      0|        else
 1148|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4); /* compressed size, unknown */
 1149|      0|    }
 1150|      0|    if (err == ZIP_OK)
 1151|      0|    {
 1152|      0|        if (zi->ci.zip64) /* uncompressed size, unknown */
 1153|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xFFFFFFFF, 4);
 1154|      0|        else /* uncompressed size, unknown */
 1155|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0, 4);
 1156|      0|    }
 1157|      0|    if (err == ZIP_OK)
 1158|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_filename, 2);
 1159|      0|    if (err == ZIP_OK)
 1160|      0|    {
 1161|      0|        ZPOS64_T size_extrafield = size_extrafield_local;
 1162|      0|        if (zi->ci.zip64)
 1163|      0|            size_extrafield += 20;
 1164|      0|#ifdef HAVE_AES
 1165|       |        if (zi->ci.method == AES_METHOD)
 1166|       |            size_extrafield += 11;
 1167|       |#endif
 1168|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_extrafield,2);
 1169|      0|    }
 1170|      0|    if ((err == ZIP_OK) && (size_filename > 0))
 1171|      0|    {
 1172|      0|        if (ZWRITE64(zi->z_filefunc, zi->filestream, filename, size_filename) != size_filename)
 1173|      0|            err = ZIP_ERRNO;
 1174|      0|    }
 1175|      0|    if ((err == ZIP_OK) && (size_extrafield_local > 0))
 1176|      0|    {
 1177|      0|        if (ZWRITE64(zi->z_filefunc, zi->filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)
 1178|      0|            err = ZIP_ERRNO;
 1179|      0|    }
 1180|      0|
 1181|      0|    /* Write the Zip64 extended info */
 1182|      0|    if ((err == ZIP_OK) && (zi->ci.zip64))
 1183|      0|    {
 1184|      0|        short headerid = 1;
 1185|      0|        short datasize = 16;
 1186|      0|        ZPOS64_T compressed_size = 0;
 1187|      0|        ZPOS64_T uncompressed_size = 0;
 1188|      0|
 1189|      0|        /* Remember position of Zip64 extended info for the local file header.
 1190|      0|           (needed when we update size after done with file) */
 1191|      0|        zi->ci.pos_zip64extrainfo = ZTELL64(zi->z_filefunc, zi->filestream);
 1192|      0|
 1193|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)headerid, 2);
 1194|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (short)datasize, 2);
 1195|      0|
 1196|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)uncompressed_size, 8);
 1197|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)compressed_size, 8);
 1198|      0|    }
 1199|      0|#ifdef HAVE_AES
 1200|       |    /* Write the AES extended info */
 1201|       |    if ((err == ZIP_OK) && (zi->ci.method == AES_METHOD))
 1202|       |    {
 1203|       |        int headerid = 0x9901;
 1204|       |        short datasize = 7;
 1205|       |
 1206|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, headerid, 2);
 1207|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, datasize, 2);
 1208|       |
 1209|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, AES_VERSION, 2);
 1210|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, 'A', 1);
 1211|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, 'E', 1);
 1212|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, AES_ENCRYPTIONMODE, 1);
 1213|       |        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->ci.compression_method, 2);
 1214|       |    }
 1215|       |#endif
 1216|      0|
 1217|      0|#ifdef HAVE_BZIP2
 1218|       |    zi->ci.bstream.avail_in = (uInt)0;
 1219|       |    zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
 1220|       |    zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
 1221|       |    zi->ci.bstream.total_in_hi32 = 0;
 1222|       |    zi->ci.bstream.total_in_lo32 = 0;
 1223|       |    zi->ci.bstream.total_out_hi32 = 0;
 1224|       |    zi->ci.bstream.total_out_lo32 = 0;
 1225|       |#endif
 1226|      0|
 1227|      0|    zi->ci.stream.avail_in = (uInt)0;
 1228|      0|    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
 1229|      0|    zi->ci.stream.next_out = zi->ci.buffered_data;
 1230|      0|    zi->ci.stream.total_in = 0;
 1231|      0|    zi->ci.stream.total_out = 0;
 1232|      0|    zi->ci.stream.data_type = Z_BINARY;
 1233|      0|
 1234|      0|    if ((err == ZIP_OK) && (!zi->ci.raw))
 1235|      0|    {
 1236|      0|        if (method == Z_DEFLATED)
 1237|      0|        {
 1238|      0|            zi->ci.stream.zalloc = (alloc_func)0;
 1239|      0|            zi->ci.stream.zfree = (free_func)0;
 1240|      0|            zi->ci.stream.opaque = (voidpf)zi;
 1241|      0|
 1242|      0|            if (windowBits > 0)
 1243|      0|                windowBits = -windowBits;
 1244|      0|
 1245|      0|            err = deflateInit2(&zi->ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);
 1246|      0|
 1247|      0|            if (err == Z_OK)
 1248|      0|                zi->ci.stream_initialised = Z_DEFLATED;
 1249|      0|        }
 1250|      0|        else if (method == Z_BZIP2ED)
 1251|      0|        {
 1252|      0|#ifdef HAVE_BZIP2
 1253|       |            zi->ci.bstream.bzalloc = 0;
 1254|       |            zi->ci.bstream.bzfree = 0;
 1255|       |            zi->ci.bstream.opaque = (voidpf)0;
 1256|       |
 1257|       |            err = BZ2_bzCompressInit(&zi->ci.bstream, level, 0, 35);
 1258|       |            if (err == BZ_OK)
 1259|       |                zi->ci.stream_initialised = Z_BZIP2ED;
 1260|       |#endif
 1261|      0|        }
 1262|      0|    }
 1263|      0|
 1264|      0|#ifndef NOCRYPT
 1265|      0|    zi->ci.crypt_header_size = 0;
 1266|      0|    if ((err == Z_OK) && ((zi->ci.flag & 1) != 0))
 1267|      0|    {
 1268|      0|#ifdef HAVE_AES
 1269|       |        if (zi->ci.method == AES_METHOD)
 1270|       |        {
 1271|       |            unsigned char passverify[AES_PWVERIFYSIZE];
 1272|       |            unsigned char saltvalue[AES_MAXSALTLENGTH];
 1273|       |            uInt saltlength;
 1274|       |
 1275|       |            if ((AES_ENCRYPTIONMODE < 1) || (AES_ENCRYPTIONMODE > 3))
 1276|       |                return Z_ERRNO;
 1277|       |
 1278|       |            saltlength = SALT_LENGTH(AES_ENCRYPTIONMODE);
 1279|       |
 1280|       |            prng_init(entropy_fun, zi->ci.aes_rng);
 1281|       |            prng_rand(saltvalue, saltlength, zi->ci.aes_rng);
 1282|       |            prng_end(zi->ci.aes_rng);
 1283|       |
 1284|       |            fcrypt_init(AES_ENCRYPTIONMODE, password, strlen(password), saltvalue, passverify, &zi->ci.aes_ctx);
 1285|       |
 1286|       |            if (ZWRITE64(zi->z_filefunc, zi->filestream, saltvalue, saltlength) != saltlength)
 1287|       |                err = ZIP_ERRNO;
 1288|       |            if (ZWRITE64(zi->z_filefunc, zi->filestream, passverify, AES_PWVERIFYSIZE) != AES_PWVERIFYSIZE)
 1289|       |                err = ZIP_ERRNO;
 1290|       |
 1291|       |            zi->ci.crypt_header_size = saltlength + AES_PWVERIFYSIZE + AES_AUTHCODESIZE;
 1292|       |        }
 1293|       |        else
 1294|       |#endif
 1295|      0|        {
 1296|      0|            unsigned char bufHead[RAND_HEAD_LEN];
 1297|      0|            unsigned int sizeHead;
 1298|      0|
 1299|      0|            zi->ci.pcrc_32_tab = (const unsigned long *)get_crc_table();
 1300|      0|            /*init_keys(password, zi->ci.keys, zi->ci.pcrc_32_tab);*/
 1301|      0|
 1302|      0|            sizeHead = crypthead(password, bufHead, RAND_HEAD_LEN, zi->ci.keys, zi->ci.pcrc_32_tab, crcForCrypting);
 1303|      0|            zi->ci.crypt_header_size = sizeHead;
 1304|      0|
 1305|      0|            if (ZWRITE64(zi->z_filefunc, zi->filestream, bufHead, sizeHead) != sizeHead)
 1306|      0|                err = ZIP_ERRNO;
 1307|      0|        }
 1308|      0|    }
 1309|      0|#endif
 1310|      0|
 1311|      0|    if (err == Z_OK)
 1312|      0|        zi->in_opened_file_inzip = 1;
 1313|      0|    return err;
 1314|      0|}
 1315|       |
 1316|       |extern int ZEXPORT zipOpenNewFileInZip4(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1317|       |    const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global,
 1318|       |    uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits,
 1319|       |    int memLevel, int strategy, const char* password, uLong crcForCrypting, uLong versionMadeBy, uLong flagBase)
 1320|      0|{
 1321|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1322|      0|        extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel,
 1323|      0|        strategy, password, crcForCrypting, versionMadeBy, flagBase, 0);
 1324|      0|}
 1325|       |
 1326|       |extern int ZEXPORT zipOpenNewFileInZip3(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1327|       |    const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global,
 1328|       |    uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits,
 1329|       |    int memLevel, int strategy, const char* password, uLong crcForCrypting)
 1330|      0|{
 1331|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1332|      0|        extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel,
 1333|      0|        strategy, password, crcForCrypting, VERSIONMADEBY, 0, 0);
 1334|      0|}
 1335|       |
 1336|       |extern int ZEXPORT zipOpenNewFileInZip3_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1337|       |    const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global,
 1338|       |    uInt size_extrafield_global, const char* comment, int method, int level, int raw, int windowBits,
 1339|       |    int memLevel, int strategy, const char* password, uLong crcForCrypting, int zip64)
 1340|      0|{
 1341|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1342|      0|        extrafield_global, size_extrafield_global, comment, method, level, raw, windowBits, memLevel, strategy,
 1343|      0|        password, crcForCrypting, VERSIONMADEBY, 0, zip64);
 1344|      0|}
 1345|       |
 1346|       |extern int ZEXPORT zipOpenNewFileInZip2(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1347|       |    const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global,
 1348|       |    uInt size_extrafield_global, const char* comment, int method, int level, int raw)
 1349|      0|{
 1350|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1351|      0|        extrafield_global, size_extrafield_global, comment, method, level, raw, -MAX_WBITS, DEF_MEM_LEVEL,
 1352|      0|        Z_DEFAULT_STRATEGY, NULL, 0, VERSIONMADEBY, 0, 0);
 1353|      0|}
 1354|       |
 1355|       |extern int ZEXPORT zipOpenNewFileInZip2_64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1356|       |    const void* extrafield_local, uInt size_extrafield_local, const void* extrafield_global,
 1357|       |    uInt size_extrafield_global, const char* comment, int method, int level, int raw, int zip64)
 1358|      0|{
 1359|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1360|      0|        extrafield_global, size_extrafield_global, comment, method, level, raw, -MAX_WBITS, DEF_MEM_LEVEL,
 1361|      0|        Z_DEFAULT_STRATEGY, NULL, 0, VERSIONMADEBY, 0, zip64);
 1362|      0|}
 1363|       |
 1364|       |extern int ZEXPORT zipOpenNewFileInZip64(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1365|       |    const void* extrafield_local, uInt size_extrafield_local, const void*extrafield_global,
 1366|       |    uInt size_extrafield_global, const char* comment, int method, int level, int zip64)
 1367|      0|{
 1368|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1369|      0|        extrafield_global, size_extrafield_global, comment, method, level, 0, -MAX_WBITS, DEF_MEM_LEVEL,
 1370|      0|        Z_DEFAULT_STRATEGY, NULL, 0, VERSIONMADEBY, 0, zip64);
 1371|      0|}
 1372|       |
 1373|       |extern int ZEXPORT zipOpenNewFileInZip(zipFile file, const char* filename, const zip_fileinfo* zipfi,
 1374|       |    const void* extrafield_local, uInt size_extrafield_local, const void*extrafield_global,
 1375|       |    uInt size_extrafield_global, const char* comment, int method, int level)
 1376|      0|{
 1377|      0|    return zipOpenNewFileInZip4_64(file, filename, zipfi, extrafield_local, size_extrafield_local,
 1378|      0|        extrafield_global, size_extrafield_global, comment, method, level, 0, -MAX_WBITS, DEF_MEM_LEVEL,
 1379|      0|        Z_DEFAULT_STRATEGY, NULL, 0, VERSIONMADEBY, 0, 0);
 1380|      0|}
 1381|       |
 1382|       |/* Flushes the write buffer to disk */
 1383|       |local int zip64FlushWriteBuffer OF((zip64_internal* zi));
 1384|       |local int zip64FlushWriteBuffer(zip64_internal* zi)
 1385|      0|{
 1386|      0|    int err = ZIP_OK;
 1387|      0|    uInt written = 0;
 1388|      0|    uInt total_written = 0;
 1389|      0|    uInt write = 0;
 1390|      0|    uInt max_write = 0;
 1391|      0|    ZPOS64_T size_available = 0;
 1392|      0|
 1393|      0|    if ((zi->ci.flag & 1) != 0)
 1394|      0|    {
 1395|      0|#ifndef NOCRYPT
 1396|      0|#ifdef HAVE_AES
 1397|       |        if (zi->ci.method == AES_METHOD)
 1398|       |        {
 1399|       |            fcrypt_encrypt(zi->ci.buffered_data, zi->ci.pos_in_buffered_data, &zi->ci.aes_ctx);
 1400|       |        }
 1401|       |        else
 1402|       |#endif
 1403|      0|        {
 1404|      0|            uInt i;
 1405|      0|            int t;
 1406|      0|            for (i = 0;i < zi->ci.pos_in_buffered_data; i++)
 1407|      0|                zi->ci.buffered_data[i] = zencode(zi->ci.keys, zi->ci.pcrc_32_tab, zi->ci.buffered_data[i],t);
 1408|      0|        }
 1409|      0|#endif
 1410|      0|    }
 1411|      0|
 1412|      0|    write = zi->ci.pos_in_buffered_data;
 1413|      0|
 1414|      0|    do
 1415|      0|    {
 1416|      0|        max_write = write;
 1417|      0|
 1418|      0|        if (zi->disk_size > 0)
 1419|      0|        {
 1420|      0|            err = zipGetDiskSizeAvailable((zipFile)zi, &size_available);
 1421|      0|            if (err != ZIP_OK)
 1422|      0|                return err;
 1423|      0|
 1424|      0|            if (size_available == 0)
 1425|      0|            {
 1426|      0|                err = zipGoToNextDisk((zipFile)zi);
 1427|      0|                if (err != ZIP_OK)
 1428|      0|                    return err;
 1429|      0|            }
 1430|      0|
 1431|      0|            if (size_available < (ZPOS64_T)max_write)
 1432|      0|                max_write = (uInt)size_available;
 1433|      0|        }
 1434|      0|
 1435|      0|        written = (unsigned int)ZWRITE64(zi->z_filefunc, zi->filestream, zi->ci.buffered_data + total_written, max_write);
 1436|      0|
 1437|      0|        if (ZERROR64(zi->z_filefunc, zi->filestream))
 1438|      0|        {
 1439|      0|            err = ZIP_ERRNO;
 1440|      0|            break;
 1441|      0|        }
 1442|      0|
 1443|      0|        total_written += written;
 1444|      0|        write -= written;
 1445|      0|    }
 1446|      0|    while (write > 0);
 1447|      0|
 1448|      0|    zi->ci.total_compressed += zi->ci.pos_in_buffered_data;
 1449|      0|
 1450|      0|#ifdef HAVE_BZIP2
 1451|       |    if (zi->ci.compression_method == Z_BZIP2ED)
 1452|       |    {
 1453|       |        zi->ci.total_uncompressed += zi->ci.bstream.total_in_lo32;
 1454|       |        zi->ci.bstream.total_in_lo32 = 0;
 1455|       |        zi->ci.bstream.total_in_hi32 = 0;
 1456|       |    }
 1457|       |    else
 1458|       |#endif
 1459|      0|    {
 1460|      0|        zi->ci.total_uncompressed += zi->ci.stream.total_in;
 1461|      0|        zi->ci.stream.total_in = 0;
 1462|      0|    }
 1463|      0|
 1464|      0|    zi->ci.pos_in_buffered_data = 0;
 1465|      0|
 1466|      0|    return err;
 1467|      0|}
 1468|       |
 1469|       |extern int ZEXPORT zipWriteInFileInZip(zipFile file,const void* buf,unsigned int len)
 1470|      0|{
 1471|      0|    zip64_internal* zi;
 1472|      0|    int err = ZIP_OK;
 1473|      0|
 1474|      0|    if (file == NULL)
 1475|      0|        return ZIP_PARAMERROR;
 1476|      0|    zi = (zip64_internal*)file;
 1477|      0|
 1478|      0|    if (zi->in_opened_file_inzip == 0)
 1479|      0|        return ZIP_PARAMERROR;
 1480|      0|
 1481|      0|    zi->ci.crc32 = crc32(zi->ci.crc32, buf, (uInt)len);
 1482|      0|
 1483|      0|#ifdef HAVE_BZIP2
 1484|       |    if ((zi->ci.compression_method == Z_BZIP2ED) && (!zi->ci.raw))
 1485|       |    {
 1486|       |        zi->ci.bstream.next_in = (void*)buf;
 1487|       |        zi->ci.bstream.avail_in = len;
 1488|       |        err = BZ_RUN_OK;
 1489|       |
 1490|       |        while ((err == BZ_RUN_OK) && (zi->ci.bstream.avail_in > 0))
 1491|       |        {
 1492|       |            if (zi->ci.bstream.avail_out == 0)
 1493|       |            {
 1494|       |                if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
 1495|       |                    err = ZIP_ERRNO;
 1496|       |                zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
 1497|       |                zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
 1498|       |            }
 1499|       |            else
 1500|       |            {
 1501|       |                uLong uTotalOutBefore_lo = zi->ci.bstream.total_out_lo32;
 1502|       |                uLong uTotalOutBefore_hi = zi->ci.bstream.total_out_hi32;
 1503|       |
 1504|       |                err = BZ2_bzCompress(&zi->ci.bstream, BZ_RUN);
 1505|       |
 1506|       |                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - uTotalOutBefore_lo);
 1507|       |            }
 1508|       |        }
 1509|       |
 1510|       |        if (err == BZ_RUN_OK)
 1511|       |            err = ZIP_OK;
 1512|       |    }
 1513|       |    else
 1514|       |#endif
 1515|      0|    {
 1516|      0|        zi->ci.stream.next_in = (Bytef*)buf;
 1517|      0|        zi->ci.stream.avail_in = len;
 1518|      0|
 1519|      0|        while ((err == ZIP_OK) && (zi->ci.stream.avail_in > 0))
 1520|      0|        {
 1521|      0|            if (zi->ci.stream.avail_out == 0)
 1522|      0|            {
 1523|      0|                if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
 1524|      0|                    err = ZIP_ERRNO;
 1525|      0|                zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
 1526|      0|                zi->ci.stream.next_out = zi->ci.buffered_data;
 1527|      0|            }
 1528|      0|
 1529|      0|            if (err != ZIP_OK)
 1530|      0|                break;
 1531|      0|
 1532|      0|            if ((zi->ci.compression_method == Z_DEFLATED) && (!zi->ci.raw))
 1533|      0|            {
 1534|      0|                uLong total_out_before = zi->ci.stream.total_out;
 1535|      0|                err = deflate(&zi->ci.stream, Z_NO_FLUSH);
 1536|      0|                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - total_out_before);
 1537|      0|            }
 1538|      0|            else
 1539|      0|            {
 1540|      0|                uInt copy_this,i;
 1541|      0|                if (zi->ci.stream.avail_in < zi->ci.stream.avail_out)
 1542|      0|                    copy_this = zi->ci.stream.avail_in;
 1543|      0|                else
 1544|      0|                    copy_this = zi->ci.stream.avail_out;
 1545|      0|
 1546|      0|                for (i = 0; i < copy_this; i++)
 1547|      0|                    *(((char*)zi->ci.stream.next_out)+i) =
 1548|      0|                        *(((const char*)zi->ci.stream.next_in)+i);
 1549|      0|
 1550|      0|                zi->ci.stream.avail_in  -= copy_this;
 1551|      0|                zi->ci.stream.avail_out -= copy_this;
 1552|      0|                zi->ci.stream.next_in += copy_this;
 1553|      0|                zi->ci.stream.next_out += copy_this;
 1554|      0|                zi->ci.stream.total_in += copy_this;
 1555|      0|                zi->ci.stream.total_out += copy_this;
 1556|      0|                zi->ci.pos_in_buffered_data += copy_this;
 1557|      0|            }
 1558|      0|        }
 1559|      0|    }
 1560|      0|
 1561|      0|    return err;
 1562|      0|}
 1563|       |
 1564|       |extern int ZEXPORT zipCloseFileInZipRaw(zipFile file, uLong uncompressed_size, uLong crc32)
 1565|      0|{
 1566|      0|    return zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);
 1567|      0|}
 1568|       |
 1569|       |extern int ZEXPORT zipCloseFileInZipRaw64(zipFile file, ZPOS64_T uncompressed_size, uLong crc32)
 1570|      0|{
 1571|      0|    zip64_internal* zi;
 1572|      0|    ZPOS64_T compressed_size;
 1573|      0|    uLong invalidValue = 0xffffffff;
 1574|      0|    uLong i = 0;
 1575|      0|    short datasize = 0;
 1576|      0|    int err = ZIP_OK;
 1577|      0|
 1578|      0|    if (file == NULL)
 1579|      0|        return ZIP_PARAMERROR;
 1580|      0|    zi = (zip64_internal*)file;
 1581|      0|
 1582|      0|    if (zi->in_opened_file_inzip == 0)
 1583|      0|        return ZIP_PARAMERROR;
 1584|      0|    zi->ci.stream.avail_in = 0;
 1585|      0|
 1586|      0|    if (!zi->ci.raw)
 1587|      0|    {
 1588|      0|        if (zi->ci.compression_method == Z_DEFLATED)
 1589|      0|        {
 1590|      0|            while (err == ZIP_OK)
 1591|      0|            {
 1592|      0|                uLong total_out_before;
 1593|      0|                if (zi->ci.stream.avail_out == 0)
 1594|      0|                {
 1595|      0|                    if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
 1596|      0|                        err = ZIP_ERRNO;
 1597|      0|                    zi->ci.stream.avail_out = (uInt)Z_BUFSIZE;
 1598|      0|                    zi->ci.stream.next_out = zi->ci.buffered_data;
 1599|      0|                }
 1600|      0|                total_out_before = zi->ci.stream.total_out;
 1601|      0|                err = deflate(&zi->ci.stream, Z_FINISH);
 1602|      0|                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.stream.total_out - total_out_before);
 1603|      0|            }
 1604|      0|        }
 1605|      0|        else if (zi->ci.compression_method == Z_BZIP2ED)
 1606|      0|        {
 1607|      0|#ifdef HAVE_BZIP2
 1608|       |            err = BZ_FINISH_OK;
 1609|       |            while (err == BZ_FINISH_OK)
 1610|       |            {
 1611|       |                uLong total_out_before;
 1612|       |                if (zi->ci.bstream.avail_out == 0)
 1613|       |                {
 1614|       |                    if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
 1615|       |                        err = ZIP_ERRNO;
 1616|       |                    zi->ci.bstream.avail_out = (uInt)Z_BUFSIZE;
 1617|       |                    zi->ci.bstream.next_out = (char*)zi->ci.buffered_data;
 1618|       |                }
 1619|       |                total_out_before = zi->ci.bstream.total_out_lo32;
 1620|       |                err = BZ2_bzCompress(&zi->ci.bstream, BZ_FINISH);
 1621|       |                if (err == BZ_STREAM_END)
 1622|       |                    err = Z_STREAM_END;
 1623|       |                zi->ci.pos_in_buffered_data += (uInt)(zi->ci.bstream.total_out_lo32 - total_out_before);
 1624|       |            }
 1625|       |
 1626|       |            if (err == BZ_FINISH_OK)
 1627|       |                err = ZIP_OK;
 1628|       |#endif
 1629|      0|        }
 1630|      0|    }
 1631|      0|
 1632|      0|    if (err == Z_STREAM_END)
 1633|      0|        err = ZIP_OK; /* this is normal */
 1634|      0|
 1635|      0|    if ((zi->ci.pos_in_buffered_data > 0) && (err == ZIP_OK))
 1636|      0|    {
 1637|      0|        if (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
 1638|      0|            err = ZIP_ERRNO;
 1639|      0|    }
 1640|      0|
 1641|      0|#ifdef HAVE_AES
 1642|       |    if (zi->ci.method == AES_METHOD)
 1643|       |    {
 1644|       |        unsigned char authcode[AES_AUTHCODESIZE];
 1645|       |
 1646|       |        fcrypt_end(authcode, &zi->ci.aes_ctx);
 1647|       |
 1648|       |        if (ZWRITE64(zi->z_filefunc, zi->filestream, authcode, AES_AUTHCODESIZE) != AES_AUTHCODESIZE)
 1649|       |            err = ZIP_ERRNO;
 1650|       |    }
 1651|       |#endif
 1652|      0|
 1653|      0|    if (!zi->ci.raw)
 1654|      0|    {
 1655|      0|        if (zi->ci.compression_method == Z_DEFLATED)
 1656|      0|        {
 1657|      0|            int tmp_err = deflateEnd(&zi->ci.stream);
 1658|      0|            if (err == ZIP_OK)
 1659|      0|                err = tmp_err;
 1660|      0|            zi->ci.stream_initialised = 0;
 1661|      0|        }
 1662|      0|#ifdef HAVE_BZIP2
 1663|       |        else if (zi->ci.compression_method == Z_BZIP2ED)
 1664|       |        {
 1665|       |            int tmperr = BZ2_bzCompressEnd(&zi->ci.bstream);
 1666|       |            if (err == ZIP_OK)
 1667|       |                err = tmperr;
 1668|       |            zi->ci.stream_initialised = 0;
 1669|       |        }
 1670|       |#endif
 1671|      0|
 1672|      0|        crc32 = (uLong)zi->ci.crc32;
 1673|      0|        uncompressed_size = zi->ci.total_uncompressed;
 1674|      0|    }
 1675|      0|
 1676|      0|    compressed_size = zi->ci.total_compressed;
 1677|      0|#ifndef NOCRYPT
 1678|      0|    compressed_size += zi->ci.crypt_header_size;
 1679|      0|#endif
 1680|      0|
 1681|      0|    /* Update current item crc and sizes */
 1682|      0|    if (compressed_size >= 0xffffffff || uncompressed_size >= 0xffffffff || zi->ci.pos_local_header >= 0xffffffff)
 1683|      0|    {
 1684|      0|        zip64local_putValue_inmemory(zi->ci.central_header+4, (uLong)45, 2); /* version made by */
 1685|      0|        zip64local_putValue_inmemory(zi->ci.central_header+6, (uLong)45, 2); /* version needed */
 1686|      0|    }
 1687|      0|    zip64local_putValue_inmemory(zi->ci.central_header+16, crc32, 4); /* crc */
 1688|      0|    if (compressed_size >= 0xffffffff)
 1689|      0|        zip64local_putValue_inmemory(zi->ci.central_header+20, invalidValue, 4); /* compr size */
 1690|      0|    else
 1691|      0|        zip64local_putValue_inmemory(zi->ci.central_header+20, compressed_size, 4); /* compr size */
 1692|      0|    if (zi->ci.stream.data_type == Z_ASCII)
 1693|      0|        zip64local_putValue_inmemory(zi->ci.central_header+36, (uLong)Z_ASCII, 2); /* internal file attrib */
 1694|      0|    if (uncompressed_size >= 0xffffffff)
 1695|      0|        zip64local_putValue_inmemory(zi->ci.central_header+24, invalidValue, 4); /* uncompr size */
 1696|      0|    else
 1697|      0|        zip64local_putValue_inmemory(zi->ci.central_header+24, uncompressed_size, 4); /* uncompr size */
 1698|      0|
 1699|      0|    /* Add ZIP64 extra info field for uncompressed size */
 1700|      0|    if (uncompressed_size >= 0xffffffff)
 1701|      0|        datasize += 8;
 1702|      0|    /* Add ZIP64 extra info field for compressed size */
 1703|      0|    if (compressed_size >= 0xffffffff)
 1704|      0|        datasize += 8;
 1705|      0|    /* Add ZIP64 extra info field for relative offset to local file header of current file */
 1706|      0|    if (zi->ci.pos_local_header >= 0xffffffff)
 1707|      0|        datasize += 8;
 1708|      0|
 1709|      0|    /* Add Extra Information Header for 'ZIP64 information' */
 1710|      0|    if (datasize > 0)
 1711|      0|    {
 1712|      0|        char* p = zi->ci.central_header + zi->ci.size_centralheader;
 1713|      0|
 1714|      0|        if ((uLong)(datasize + 4) > zi->ci.size_centralextrafree)
 1715|      0|            return ZIP_BADZIPFILE;
 1716|      0|
 1717|      0|        zip64local_putValue_inmemory(p, 0x0001, 2);
 1718|      0|        p += 2;
 1719|      0|        zip64local_putValue_inmemory(p, datasize, 2);
 1720|      0|        p += 2;
 1721|      0|
 1722|      0|        if (uncompressed_size >= 0xffffffff)
 1723|      0|        {
 1724|      0|            zip64local_putValue_inmemory(p, uncompressed_size, 8);
 1725|      0|            p += 8;
 1726|      0|        }
 1727|      0|        if (compressed_size >= 0xffffffff)
 1728|      0|        {
 1729|      0|            zip64local_putValue_inmemory(p, compressed_size, 8);
 1730|      0|            p += 8;
 1731|      0|        }
 1732|      0|        if (zi->ci.pos_local_header >= 0xffffffff)
 1733|      0|        {
 1734|      0|            zip64local_putValue_inmemory(p, zi->ci.pos_local_header, 8);
 1735|      0|            p += 8;
 1736|      0|        }
 1737|      0|
 1738|      0|        zi->ci.size_centralextrafree -= datasize + 4;
 1739|      0|        zi->ci.size_centralheader += datasize + 4;
 1740|      0|        zi->ci.size_centralextra += datasize + 4;
 1741|      0|
 1742|      0|        zip64local_putValue_inmemory(zi->ci.central_header+30, (uLong)zi->ci.size_centralextra, 2);
 1743|      0|    }
 1744|      0|
 1745|      0|#ifdef HAVE_AES
 1746|       |    /* Write the AES extended info */
 1747|       |    if (zi->ci.method == AES_METHOD)
 1748|       |    {
 1749|       |        char* p = zi->ci.central_header + zi->ci.size_centralheader;
 1750|       |
 1751|       |        datasize = 7;
 1752|       |
 1753|       |        if ((uLong)(datasize + 4) > zi->ci.size_centralextrafree)
 1754|       |            return ZIP_BADZIPFILE;
 1755|       |
 1756|       |        zip64local_putValue_inmemory(p, 0x9901, 2);
 1757|       |        p += 2;
 1758|       |        zip64local_putValue_inmemory(p, datasize, 2);
 1759|       |        p += 2;
 1760|       |        zip64local_putValue_inmemory(p, AES_VERSION, 2);
 1761|       |        p += 2;
 1762|       |        zip64local_putValue_inmemory(p, 'A', 1);
 1763|       |        p += 1;
 1764|       |        zip64local_putValue_inmemory(p, 'E', 1);
 1765|       |        p += 1;
 1766|       |        zip64local_putValue_inmemory(p, AES_ENCRYPTIONMODE, 1);
 1767|       |        p += 1;
 1768|       |        zip64local_putValue_inmemory(p, zi->ci.compression_method, 2);
 1769|       |        p += 2;
 1770|       |
 1771|       |        zi->ci.size_centralextrafree -= datasize + 4;
 1772|       |        zi->ci.size_centralheader += datasize + 4;
 1773|       |        zi->ci.size_centralextra += datasize + 4;
 1774|       |
 1775|       |        zip64local_putValue_inmemory(zi->ci.central_header+30, (uLong)zi->ci.size_centralextra, 2);
 1776|       |    }
 1777|       |#endif
 1778|      0|    /* Restore comment to correct position */
 1779|      0|    for (i = 0; i < zi->ci.size_comment; i++)
 1780|      0|        zi->ci.central_header[zi->ci.size_centralheader+i] =
 1781|      0|            zi->ci.central_header[zi->ci.size_centralheader+zi->ci.size_centralextrafree+i];
 1782|      0|    zi->ci.size_centralheader += zi->ci.size_comment;
 1783|      0|
 1784|      0|    if (err == ZIP_OK)
 1785|      0|        err = add_data_in_datablock(&zi->central_dir, zi->ci.central_header, (uLong)zi->ci.size_centralheader);
 1786|      0|
 1787|      0|    free(zi->ci.central_header);
 1788|      0|
 1789|      0|    if (err == ZIP_OK)
 1790|      0|    {
 1791|      0|        /* Update the LocalFileHeader with the new values. */
 1792|      0|        ZPOS64_T cur_pos_inzip = ZTELL64(zi->z_filefunc, zi->filestream);
 1793|      0|        uLong cur_number_disk = zi->number_disk;
 1794|      0|
 1795|      0|        /* Local file header is stored on previous disk, switch to make edits */
 1796|      0|        if (zi->ci.number_disk != cur_number_disk)
 1797|      0|            err = zipGoToSpecificDisk(file, (int)zi->ci.number_disk, 1);
 1798|      0|
 1799|      0|        if (ZSEEK64(zi->z_filefunc, zi->filestream, zi->ci.pos_local_header + 14, ZLIB_FILEFUNC_SEEK_SET) != 0)
 1800|      0|            err = ZIP_ERRNO;
 1801|      0|        if (err == ZIP_OK)
 1802|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream,crc32,4); /* crc 32, unknown */
 1803|      0|
 1804|      0|        if (uncompressed_size >= 0xffffffff || compressed_size >= 0xffffffff)
 1805|      0|        {
 1806|      0|            if (zi->ci.pos_zip64extrainfo > 0)
 1807|      0|            {
 1808|      0|                /* Update the size in the ZIP64 extended field. */
 1809|      0|                if (ZSEEK64(zi->z_filefunc, zi->filestream, zi->ci.pos_zip64extrainfo + 4, ZLIB_FILEFUNC_SEEK_SET) != 0)
 1810|      0|                    err = ZIP_ERRNO;
 1811|      0|
 1812|      0|                if (err == ZIP_OK) /* compressed size, unknown */
 1813|      0|                    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, uncompressed_size, 8);
 1814|      0|                if (err == ZIP_OK) /* uncompressed size, unknown */
 1815|      0|                    err = zip64local_putValue(&zi->z_filefunc, zi->filestream, compressed_size, 8);
 1816|      0|            }
 1817|      0|            else
 1818|      0|                err = ZIP_BADZIPFILE; /* Caller passed zip64 = 0, so no room for zip64 info -> fatal */
 1819|      0|        }
 1820|      0|        else
 1821|      0|        {
 1822|      0|          if (err == ZIP_OK) /* compressed size, unknown */
 1823|      0|              err = zip64local_putValue(&zi->z_filefunc, zi->filestream,compressed_size, 4);
 1824|      0|          if (err == ZIP_OK) /* uncompressed size, unknown */
 1825|      0|              err = zip64local_putValue(&zi->z_filefunc, zi->filestream,uncompressed_size, 4);
 1826|      0|        }
 1827|      0|
 1828|      0|        /* Now switch back again to the disk we were on before */
 1829|      0|        if (zi->ci.number_disk != cur_number_disk)
 1830|      0|            err = zipGoToSpecificDisk(file, (int)cur_number_disk, 1);
 1831|      0|
 1832|      0|        if (ZSEEK64(zi->z_filefunc, zi->filestream, cur_pos_inzip, ZLIB_FILEFUNC_SEEK_SET) != 0)
 1833|      0|            err = ZIP_ERRNO;
 1834|      0|    }
 1835|      0|
 1836|      0|    zi->number_entry++;
 1837|      0|    zi->in_opened_file_inzip = 0;
 1838|      0|
 1839|      0|    return err;
 1840|      0|}
 1841|       |
 1842|       |extern int ZEXPORT zipCloseFileInZip(zipFile file)
 1843|      0|{
 1844|      0|    return zipCloseFileInZipRaw(file, 0, 0);
 1845|      0|}
 1846|       |
 1847|       |extern int ZEXPORT zipClose(zipFile file, const char* global_comment)
 1848|      0|{
 1849|      0|    zip64_internal* zi;
 1850|      0|    int err = 0;
 1851|      0|    uLong size_centraldir = 0;
 1852|      0|    uInt size_global_comment = 0;
 1853|      0|    ZPOS64_T centraldir_pos_inzip;
 1854|      0|    ZPOS64_T pos = 0;
 1855|      0|    uLong write = 0;
 1856|      0|
 1857|      0|    if (file == NULL)
 1858|      0|        return ZIP_PARAMERROR;
 1859|      0|
 1860|      0|    zi = (zip64_internal*)file;
 1861|      0|
 1862|      0|    if (zi->in_opened_file_inzip == 1)
 1863|      0|        err = zipCloseFileInZip(file);
 1864|      0|
 1865|      0|#ifndef NO_ADDFILEINEXISTINGZIP
 1866|      0|    if (global_comment == NULL)
 1867|      0|        global_comment = zi->globalcomment;
 1868|      0|#endif
 1869|      0|
 1870|      0|    if (zi->filestream != zi->filestream_with_CD)
 1871|      0|    {
 1872|      0|        if (ZCLOSE64(zi->z_filefunc, zi->filestream) != 0)
 1873|      0|            if (err == ZIP_OK)
 1874|      0|                err = ZIP_ERRNO;
 1875|      0|        if (zi->disk_size > 0)
 1876|      0|            zi->number_disk_with_CD = zi->number_disk + 1;
 1877|      0|        zi->filestream = zi->filestream_with_CD;
 1878|      0|    }
 1879|      0|
 1880|      0|    centraldir_pos_inzip = ZTELL64(zi->z_filefunc, zi->filestream);
 1881|      0|
 1882|      0|    if (err == ZIP_OK)
 1883|      0|    {
 1884|      0|        linkedlist_datablock_internal* ldi = zi->central_dir.first_block;
 1885|      0|        while (ldi!= NULL)
 1886|      0|        {
 1887|      0|            if ((err == ZIP_OK) && (ldi->filled_in_this_block > 0))
 1888|      0|            {
 1889|      0|                write = ZWRITE64(zi->z_filefunc, zi->filestream, ldi->data, ldi->filled_in_this_block);
 1890|      0|                if (write != ldi->filled_in_this_block)
 1891|      0|                    err = ZIP_ERRNO;
 1892|      0|            }
 1893|      0|
 1894|      0|            size_centraldir += ldi->filled_in_this_block;
 1895|      0|            ldi = ldi->next_datablock;
 1896|      0|        }
 1897|      0|    }
 1898|      0|
 1899|      0|    free_linkedlist(&(zi->central_dir));
 1900|      0|
 1901|      0|    pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
 1902|      0|
 1903|      0|    /* Write the ZIP64 central directory header */
 1904|      0|    if (pos >= 0xffffffff || zi->number_entry > 0xffff)
 1905|      0|    {
 1906|      0|        ZPOS64_T zip64eocd_pos_inzip = ZTELL64(zi->z_filefunc, zi->filestream);
 1907|      0|        uLong zip64datasize = 44;
 1908|      0|
 1909|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)ZIP64ENDHEADERMAGIC, 4);
 1910|      0|
 1911|      0|        /* Size of this 'zip64 end of central directory' */
 1912|      0|        if (err == ZIP_OK)
 1913|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)zip64datasize, 8);
 1914|      0|        /* Version made by */
 1915|      0|        if (err == ZIP_OK)
 1916|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)45, 2);
 1917|      0|        /* Version needed */
 1918|      0|        if (err == ZIP_OK)
 1919|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)45, 2);
 1920|      0|        /* Number of this disk */
 1921|      0|        if (err == ZIP_OK)
 1922|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_disk_with_CD, 4);
 1923|      0|        /* Number of the disk with the start of the central directory */
 1924|      0|        if (err == ZIP_OK)
 1925|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_disk_with_CD, 4);
 1926|      0|        /* Total number of entries in the central dir on this disk */
 1927|      0|        if (err == ZIP_OK)
 1928|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
 1929|      0|        /* Total number of entries in the central dir */
 1930|      0|        if (err == ZIP_OK)
 1931|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, zi->number_entry, 8);
 1932|      0|        /* Size of the central directory */
 1933|      0|        if (err == ZIP_OK)
 1934|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)size_centraldir, 8);
 1935|      0|
 1936|      0|        if (err == ZIP_OK)
 1937|      0|        {
 1938|      0|            /* Offset of start of central directory with respect to the starting disk number */
 1939|      0|            ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
 1940|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (ZPOS64_T)pos, 8);
 1941|      0|        }
 1942|      0|        if (err == ZIP_OK)
 1943|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)ZIP64ENDLOCHEADERMAGIC, 4);
 1944|      0|
 1945|      0|        /* Number of the disk with the start of the central directory */
 1946|      0|        if (err == ZIP_OK)
 1947|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_disk_with_CD, 4);
 1948|      0|        /* Relative offset to the Zip64EndOfCentralDirectory */
 1949|      0|        if (err == ZIP_OK)
 1950|      0|        {
 1951|      0|            ZPOS64_T pos = zip64eocd_pos_inzip - zi->add_position_when_writting_offset;
 1952|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, pos, 8);
 1953|      0|        }
 1954|      0|        /* Number of the disk with the start of the central directory */
 1955|      0|        if (err == ZIP_OK)
 1956|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_disk_with_CD+1, 4);
 1957|      0|    }
 1958|      0|
 1959|      0|    /* Write the central directory header */
 1960|      0|
 1961|      0|    /* Signature */
 1962|      0|    if (err == ZIP_OK)
 1963|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)ENDHEADERMAGIC, 4);
 1964|      0|    /* Number of this disk */
 1965|      0|    if (err == ZIP_OK)
 1966|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_disk_with_CD, 2);
 1967|      0|    /* Number of the disk with the start of the central directory */
 1968|      0|    if (err == ZIP_OK)
 1969|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_disk_with_CD, 2);
 1970|      0|    /* Total number of entries in the central dir on this disk */
 1971|      0|    if (err == ZIP_OK)
 1972|      0|    {
 1973|      0|        if (zi->number_entry >= 0xffff)
 1974|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xffff, 2); /* use value in ZIP64 record */
 1975|      0|        else
 1976|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_entry, 2);
 1977|      0|    }
 1978|      0|    /* Total number of entries in the central dir */
 1979|      0|    if (err == ZIP_OK)
 1980|      0|    {
 1981|      0|        if (zi->number_entry >= 0xffff)
 1982|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xffff, 2); /* use value in ZIP64 record */
 1983|      0|        else
 1984|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)zi->number_entry, 2);
 1985|      0|    }
 1986|      0|    /* Size of the central directory */
 1987|      0|    if (err == ZIP_OK)
 1988|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_centraldir,4);
 1989|      0|    /* Offset of start of central directory with respect to the starting disk number */
 1990|      0|    if (err == ZIP_OK)
 1991|      0|    {
 1992|      0|        ZPOS64_T pos = centraldir_pos_inzip - zi->add_position_when_writting_offset;
 1993|      0|        if (pos >= 0xffffffff)
 1994|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)0xffffffff, 4);
 1995|      0|        else
 1996|      0|            err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)pos, 4);
 1997|      0|    }
 1998|      0|
 1999|      0|    /* Write global comment */
 2000|      0|
 2001|      0|    if (global_comment != NULL)
 2002|      0|        size_global_comment = (uInt)strlen(global_comment);
 2003|      0|    if (err == ZIP_OK)
 2004|      0|        err = zip64local_putValue(&zi->z_filefunc, zi->filestream, (uLong)size_global_comment, 2);
 2005|      0|    if (err == ZIP_OK && size_global_comment > 0)
 2006|      0|    {
 2007|      0|        if (ZWRITE64(zi->z_filefunc, zi->filestream, global_comment, size_global_comment) != size_global_comment)
 2008|      0|            err = ZIP_ERRNO;
 2009|      0|    }
 2010|      0|
 2011|      0|    if ((ZCLOSE64(zi->z_filefunc, zi->filestream) != 0) && (err == ZIP_OK))
 2012|      0|        err = ZIP_ERRNO;
 2013|      0|
 2014|      0|#ifndef NO_ADDFILEINEXISTINGZIP
 2015|      0|    TRYFREE(zi->globalcomment);
 2016|      0|#endif
 2017|      0|    TRYFREE(zi);
 2018|      0|
 2019|      0|    return err;
 2020|      0|}

