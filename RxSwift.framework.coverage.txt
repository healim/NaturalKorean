/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/Platform/DataStructures/Bag.swift:
    1|       |//
    2|       |//  Bag.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Swift
   10|       |
   11|       |let arrayDictionaryMaxSize = 30
   12|       |
   13|       |struct BagKey {
   14|       |    /**
   15|       |    Unique identifier for object added to `Bag`.
   16|       |     
   17|       |    It's underlying type is UInt64. If we assume there in an idealized CPU that works at 4GHz,
   18|       |     it would take ~150 years of continuous running time for it to overflow.
   19|       |    */
   20|       |    fileprivate let rawValue: UInt64
   21|       |}
   22|       |
   23|       |/**
   24|       |Data structure that represents a bag of elements typed `T`.
   25|       |
   26|       |Single element can be stored multiple times.
   27|       |
   28|       |Time and space complexity of insertion an deletion is O(n). 
   29|       |
   30|       |It is suitable for storing small number of elements.
   31|       |*/
   32|       |struct Bag<T> : CustomDebugStringConvertible {
   33|       |    /// Type of identifier for inserted elements.
   34|       |    typealias KeyType = BagKey
   35|       |    
   36|       |    typealias Entry = (key: BagKey, value: T)
   37|       | 
   38|       |    fileprivate var _nextKey: BagKey = BagKey(rawValue: 0)
   39|       |
   40|       |    // data
   41|       |
   42|       |    // first fill inline variables
   43|       |    var _key0: BagKey? = nil
   44|       |    var _value0: T? = nil
   45|       |
   46|       |    // then fill "array dictionary"
   47|       |    var _pairs = ContiguousArray<Entry>()
   48|       |
   49|       |    // last is sparse dictionary
   50|       |    var _dictionary: [BagKey : T]? = nil
   51|       |
   52|       |    var _onlyFastPath = true
   53|       |
   54|       |    /// Creates new empty `Bag`.
   55|    992|    init() {
   56|    992|    }
   57|       |    
   58|       |    /**
   59|       |    Inserts `value` into bag.
   60|       |    
   61|       |    - parameter element: Element to insert.
   62|       |    - returns: Key that can be used to remove element from bag.
   63|       |    */
   64|  1.15k|    mutating func insert(_ element: T) -> BagKey {
   65|  1.15k|        let key = _nextKey
   66|  1.15k|
   67|  1.15k|        _nextKey = BagKey(rawValue: _nextKey.rawValue &+ 1)
   68|  1.15k|
   69|    800|        if _key0 == nil {
   70|    800|            _key0 = key
   71|    800|            _value0 = element
   72|    800|            return key
   73|    359|        }
   74|    359|
   75|    359|        _onlyFastPath = false
   76|    359|
   77|      0|        if _dictionary != nil {
   78|      0|            _dictionary![key] = element
   79|      0|            return key
   80|    359|        }
   81|    359|
   82|    359|        if _pairs.count < arrayDictionaryMaxSize {
   83|    359|            _pairs.append(key: key, value: element)
   84|    359|            return key
   85|      0|        }
   86|      0|
   87|      0|        if _dictionary == nil {
   88|      0|            _dictionary = [:]
   89|      0|        }
   90|      0|
   91|      0|        _dictionary![key] = element
   92|      0|        
   93|      0|        return key
   94|      0|    }
   95|       |    
   96|       |    /// - returns: Number of elements in bag.
   97|    381|    var count: Int {
   98|    381|        let dictionaryCount: Int = _dictionary?.count ?? 0
   99|    271|        return (_value0 != nil ? 1 : 0) + _pairs.count + dictionaryCount
  100|    381|    }
  101|       |    
  102|       |    /// Removes all elements from bag and clears capacity.
  103|      0|    mutating func removeAll() {
  104|      0|        _key0 = nil
  105|      0|        _value0 = nil
  106|      0|
  107|      0|        _pairs.removeAll(keepingCapacity: false)
  108|      0|        _dictionary?.removeAll(keepingCapacity: false)
  109|      0|    }
  110|       |    
  111|       |    /**
  112|       |    Removes element with a specific `key` from bag.
  113|       |    
  114|       |    - parameter key: Key that identifies element to remove from bag.
  115|       |    - returns: Element that bag contained, or nil in case element was already removed.
  116|       |    */
  117|      7|    mutating func removeKey(_ key: BagKey) -> T? {
  118|      1|        if _key0 == key {
  119|      1|            _key0 = nil
  120|      1|            let value = _value0!
  121|      1|            _value0 = nil
  122|      1|            return value
  123|      6|        }
  124|      6|
  125|      0|        if let existingObject = _dictionary?.removeValue(forKey: key) {
  126|      0|            return existingObject
  127|      6|        }
  128|      6|
  129|      6|        for i in 0 ..< _pairs.count {
  130|      6|            if _pairs[i].key == key {
  131|      6|                let value = _pairs[i].value
  132|      6|                _pairs.remove(at: i)
  133|      6|                return value
  134|      0|            }
  135|      0|        }
  136|      0|
  137|      0|        return nil
  138|      6|    }
  139|       |}
  140|       |
  141|       |extension Bag {
  142|       |    /// A textual representation of `self`, suitable for debugging.
  143|      0|    var debugDescription : String {
  144|      0|        return "\(self.count) elements in Bag"
  145|      0|    }
  146|       |}
  147|       |
  148|       |extension Bag {
  149|       |    /// Enumerates elements inside the bag.
  150|       |    ///
  151|       |    /// - parameter action: Enumeration closure.
  152|      0|    func forEach(_ action: (T) -> Void) {
  153|      0|        if _onlyFastPath {
  154|      0|            if let value0 = _value0 {
  155|      0|                action(value0)
  156|      0|            }
  157|      0|            return
  158|      0|        }
  159|      0|
  160|      0|        let value0 = _value0
  161|      0|        let dictionary = _dictionary
  162|      0|
  163|      0|        if let value0 = value0 {
  164|      0|            action(value0)
  165|      0|        }
  166|      0|
  167|      0|        for i in 0 ..< _pairs.count {
  168|      0|            action(_pairs[i].value)
  169|      0|        }
  170|      0|
  171|      0|        if dictionary?.count ?? 0 > 0 {
  172|      0|            for element in dictionary!.values {
  173|      0|                action(element)
  174|      0|            }
  175|      0|        }
  176|      0|    }
  177|       |}
  178|       |
  179|       |extension BagKey: Hashable {
  180|      0|    var hashValue: Int {
  181|      0|        return rawValue.hashValue
  182|      0|    }
  183|       |}
  184|       |
  185|     13|func ==(lhs: BagKey, rhs: BagKey) -> Bool {
  186|     13|    return lhs.rawValue == rhs.rawValue
  187|     13|}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/Platform/DataStructures/InfiniteSequence.swift:
    1|       |//
    2|       |//  InfiniteSequence.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Sequence that repeats `repeatedValue` infinite number of times.
   10|       |struct InfiniteSequence<E> : Sequence {
   11|       |    typealias Element = E
   12|       |    typealias Iterator = AnyIterator<E>
   13|       |    
   14|       |    private let _repeatedValue: E
   15|       |    
   16|      0|    init(repeatedValue: E) {
   17|      0|        _repeatedValue = repeatedValue
   18|      0|    }
   19|       |    
   20|      0|    func makeIterator() -> Iterator {
   21|      0|        let repeatedValue = _repeatedValue
   22|      0|        return AnyIterator {
   23|      0|            return repeatedValue
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/Platform/DataStructures/PriorityQueue.swift:
    1|       |//
    2|       |//  PriorityQueue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct PriorityQueue<Element> {
   10|       |    private let _hasHigherPriority: (Element, Element) -> Bool
   11|       |    private let _isEqual: (Element, Element) -> Bool
   12|       |
   13|       |    fileprivate var _elements = [Element]()
   14|       |
   15|      7|    init(hasHigherPriority: @escaping (Element, Element) -> Bool, isEqual: @escaping (Element, Element) -> Bool) {
   16|      7|        _hasHigherPriority = hasHigherPriority
   17|      7|        _isEqual = isEqual
   18|      7|    }
   19|       |
   20|      1|    mutating func enqueue(_ element: Element) {
   21|      1|        _elements.append(element)
   22|      1|        bubbleToHigherPriority(_elements.count - 1)
   23|      1|    }
   24|       |
   25|      2|    func peek() -> Element? {
   26|      2|        return _elements.first
   27|      2|    }
   28|       |
   29|      0|    var isEmpty: Bool {
   30|      0|        return _elements.count == 0
   31|      0|    }
   32|       |
   33|      0|    mutating func dequeue() -> Element? {
   34|      0|        guard let front = peek() else {
   35|      0|            return nil
   36|      0|        }
   37|      0|
   38|      0|        removeAt(0)
   39|      0|
   40|      0|        return front
   41|      0|    }
   42|       |
   43|      1|    mutating func remove(_ element: Element) {
   44|      1|        for i in 0 ..< _elements.count {
   45|      1|            if _isEqual(_elements[i], element) {
   46|      1|                removeAt(i)
   47|      1|                return
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |
   52|      1|    private mutating func removeAt(_ index: Int) {
   53|      1|        let removingLast = index == _elements.count - 1
   54|      0|        if !removingLast {
   55|      0|            swap(&_elements[index], &_elements[_elements.count - 1])
   56|      1|        }
   57|      1|
   58|      1|        _ = _elements.popLast()
   59|      1|
   60|      0|        if !removingLast {
   61|      0|            bubbleToHigherPriority(index)
   62|      0|            bubbleToLowerPriority(index)
   63|      1|        }
   64|      1|    }
   65|       |
   66|      1|    private mutating func bubbleToHigherPriority(_ initialUnbalancedIndex: Int) {
   67|      1|        precondition(initialUnbalancedIndex >= 0)
   68|      1|        precondition(initialUnbalancedIndex < _elements.count)
   69|      1|
   70|      1|        var unbalancedIndex = initialUnbalancedIndex
   71|      1|
   72|      1|        while unbalancedIndex > 0 {
   73|      0|            let parentIndex = (unbalancedIndex - 1) / 2
   74|      0|            guard _hasHigherPriority(_elements[unbalancedIndex], _elements[parentIndex]) else { break }
   75|      0|            
   76|      0|            swap(&_elements[unbalancedIndex], &_elements[parentIndex])
   77|      0|            unbalancedIndex = parentIndex
   78|      1|        }
   79|      1|    }
   80|       |
   81|      0|    private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {
   82|      0|        precondition(initialUnbalancedIndex >= 0)
   83|      0|        precondition(initialUnbalancedIndex < _elements.count)
   84|      0|
   85|      0|        var unbalancedIndex = initialUnbalancedIndex
   86|      0|        while true {
   87|      0|            let leftChildIndex = unbalancedIndex * 2 + 1
   88|      0|            let rightChildIndex = unbalancedIndex * 2 + 2
   89|      0|
   90|      0|            var highestPriorityIndex = unbalancedIndex
   91|      0|
   92|      0|            if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {
   93|      0|                highestPriorityIndex = leftChildIndex
   94|      0|            }
   95|      0|
   96|      0|            if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {
   97|      0|                highestPriorityIndex = rightChildIndex
   98|      0|            }
   99|      0|
  100|      0|            guard highestPriorityIndex != unbalancedIndex else { break }
  101|      0|
  102|      0|            swap(&_elements[highestPriorityIndex], &_elements[unbalancedIndex])
  103|      0|            unbalancedIndex = highestPriorityIndex
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |extension PriorityQueue : CustomDebugStringConvertible {
  109|      0|    var debugDescription: String {
  110|      0|        return _elements.debugDescription
  111|      0|    }
  112|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/Platform/DataStructures/Queue.swift:
    1|       |//
    2|       |//  Queue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Data structure that represents queue.
   11|       |
   12|       |Complexity of `enqueue`, `dequeue` is O(1) when number of operations is
   13|       |averaged over N operations.
   14|       |
   15|       |Complexity of `peek` is O(1).
   16|       |*/
   17|       |struct Queue<T>: Sequence {
   18|       |    /// Type of generator.
   19|       |    typealias Generator = AnyIterator<T>
   20|       |
   21|       |    private let _resizeFactor = 2
   22|       |    
   23|       |    private var _storage: ContiguousArray<T?>
   24|       |    private var _count = 0
   25|       |    private var _pushNextIndex = 0
   26|       |    private let _initialCapacity: Int
   27|       |
   28|       |    /**
   29|       |    Creates new queue.
   30|       |    
   31|       |    - parameter capacity: Capacity of newly created queue.
   32|       |    */
   33|      4|    init(capacity: Int) {
   34|      4|        _initialCapacity = capacity
   35|      4|
   36|      4|        _storage = ContiguousArray<T?>(repeating: nil, count: capacity)
   37|      4|    }
   38|       |    
   39|      0|    private var dequeueIndex: Int {
   40|      0|        let index = _pushNextIndex - count
   41|      0|        return index < 0 ? index + _storage.count : index
   42|      0|    }
   43|       |    
   44|       |    /// - returns: Is queue empty.
   45|      0|    var isEmpty: Bool {
   46|      0|        return count == 0
   47|      0|    }
   48|       |    
   49|       |    /// - returns: Number of elements inside queue.
   50|      4|    var count: Int {
   51|      4|        return _count
   52|      4|    }
   53|       |    
   54|       |    /// - returns: Element in front of a list of elements to `dequeue`.
   55|      0|    func peek() -> T {
   56|      0|        precondition(count > 0)
   57|      0|        
   58|      0|        return _storage[dequeueIndex]!
   59|      0|    }
   60|       |    
   61|      0|    mutating private func resizeTo(_ size: Int) {
   62|      0|        var newStorage = ContiguousArray<T?>(repeating: nil, count: size)
   63|      0|        
   64|      0|        let count = _count
   65|      0|        
   66|      0|        let dequeueIndex = self.dequeueIndex
   67|      0|        let spaceToEndOfQueue = _storage.count - dequeueIndex
   68|      0|        
   69|      0|        // first batch is from dequeue index to end of array
   70|      0|        let countElementsInFirstBatch = Swift.min(count, spaceToEndOfQueue)
   71|      0|        // second batch is wrapped from start of array to end of queue
   72|      0|        let numberOfElementsInSecondBatch = count - countElementsInFirstBatch
   73|      0|        
   74|      0|        newStorage[0 ..< countElementsInFirstBatch] = _storage[dequeueIndex ..< (dequeueIndex + countElementsInFirstBatch)]
   75|      0|        newStorage[countElementsInFirstBatch ..< (countElementsInFirstBatch + numberOfElementsInSecondBatch)] = _storage[0 ..< numberOfElementsInSecondBatch]
   76|      0|        
   77|      0|        _count = count
   78|      0|        _pushNextIndex = count
   79|      0|        _storage = newStorage
   80|      0|    }
   81|       |    
   82|       |    /// Enqueues `element`.
   83|       |    ///
   84|       |    /// - parameter element: Element to enqueue.
   85|      0|    mutating func enqueue(_ element: T) {
   86|      0|        if count == _storage.count {
   87|      0|            resizeTo(Swift.max(_storage.count, 1) * _resizeFactor)
   88|      0|        }
   89|      0|        
   90|      0|        _storage[_pushNextIndex] = element
   91|      0|        _pushNextIndex += 1
   92|      0|        _count += 1
   93|      0|        
   94|      0|        if _pushNextIndex >= _storage.count {
   95|      0|            _pushNextIndex -= _storage.count
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    private mutating func dequeueElementOnly() -> T {
  100|      0|        precondition(count > 0)
  101|      0|        
  102|      0|        let index = dequeueIndex
  103|      0|
  104|      0|        defer {
  105|      0|            _storage[index] = nil
  106|      0|            _count -= 1
  107|      0|        }
  108|      0|
  109|      0|        return _storage[index]!
  110|      0|    }
  111|       |
  112|       |    /// Dequeues element or throws an exception in case queue is empty.
  113|       |    ///
  114|       |    /// - returns: Dequeued element.
  115|      0|    mutating func dequeue() -> T? {
  116|      0|        if self.count == 0 {
  117|      0|            return nil
  118|      0|        }
  119|      0|
  120|      0|        defer {
  121|      0|            let downsizeLimit = _storage.count / (_resizeFactor * _resizeFactor)
  122|      0|            if _count < downsizeLimit && downsizeLimit >= _initialCapacity {
  123|      0|                resizeTo(_storage.count / _resizeFactor)
  124|      0|            }
  125|      0|        }
  126|      0|
  127|      0|        return dequeueElementOnly()
  128|      0|    }
  129|       |    
  130|       |    /// - returns: Generator of contained elements.
  131|      0|    func makeIterator() -> AnyIterator<T> {
  132|      0|        var i = dequeueIndex
  133|      0|        var count = _count
  134|      0|
  135|      0|        return AnyIterator {
  136|      0|            if count == 0 {
  137|      0|                return nil
  138|      0|            }
  139|      0|
  140|      0|            defer {
  141|      0|                count -= 1
  142|      0|                i += 1
  143|      0|            }
  144|      0|
  145|      0|            if i >= self._storage.count {
  146|      0|                i -= self._storage.count
  147|      0|            }
  148|      0|
  149|      0|            return self._storage[i]
  150|      0|        }
  151|      0|    }
  152|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/Platform/DispatchQueue+Extensions.swift:
    1|       |//
    2|       |//  DispatchQueue+Extensions.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/22/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |extension DispatchQueue {
   12|       |    private static var token: DispatchSpecificKey<()> = {
   13|       |        let key = DispatchSpecificKey<()>()
   14|       |        DispatchQueue.main.setSpecific(key: key, value: ())
   15|       |        return key
   16|       |    }()
   17|       |
   18|  1.87k|    static var isMain: Bool {
   19|  1.87k|        return DispatchQueue.getSpecific(key: token) != nil
   20|  1.87k|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/Platform/Platform.Darwin.swift:
    1|       |//
    2|       |//  Platform.Darwin.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
   10|       |
   11|       |    import Darwin
   12|       |    import class Foundation.Thread
   13|       |    import func Foundation.OSAtomicCompareAndSwap32Barrier
   14|       |    import func Foundation.OSAtomicIncrement32Barrier
   15|       |    import func Foundation.OSAtomicDecrement32Barrier
   16|       |    import protocol Foundation.NSCopying
   17|       |
   18|       |    typealias AtomicInt = Int32
   19|       |
   20|  4.44k|    fileprivate func castToUInt32Pointer(_ pointer: UnsafeMutablePointer<Int32>) -> UnsafeMutablePointer<UInt32> {
   21|  4.44k|        let raw = UnsafeMutableRawPointer(pointer)
   22|  4.44k|        return raw.assumingMemoryBound(to: UInt32.self)
   23|  4.44k|    }
   24|       |
   25|       |    let AtomicCompareAndSwap = OSAtomicCompareAndSwap32Barrier
   26|       |    let AtomicIncrement = OSAtomicIncrement32Barrier
   27|       |    let AtomicDecrement = OSAtomicDecrement32Barrier
   28|  4.43k|    func AtomicOr(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Int32 {
   29|  4.43k|        return OSAtomicOr32OrigBarrier(mask, castToUInt32Pointer(theValue))
   30|  4.43k|    }
   31|     13|    func AtomicFlagSet(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Bool {
   32|     13|        // just used to create a barrier
   33|     13|        OSAtomicXor32OrigBarrier(0, castToUInt32Pointer(theValue))
   34|     13|        return (theValue.pointee & Int32(mask)) != 0
   35|     13|    }
   36|       |
   37|       |    extension Thread {
   38|       |
   39|       |        static func setThreadLocalStorageValue<T: AnyObject>(_ value: T?, forKey key: NSCopying
   40|    352|            ) {
   41|    352|            let currentThread = Thread.current
   42|    352|            let threadDictionary = currentThread.threadDictionary
   43|    352|
   44|      0|            if let newValue = value {
   45|      0|                threadDictionary[key] = newValue
   46|    352|            }
   47|    352|            else {
   48|    352|                threadDictionary[key] = nil
   49|    352|            }
   50|    352|
   51|    352|        }
   52|    352|        static func getThreadLocalStorageValueForKey<T>(_ key: NSCopying) -> T? {
   53|    352|            let currentThread = Thread.current
   54|    352|            let threadDictionary = currentThread.threadDictionary
   55|    352|            
   56|    352|            return threadDictionary[key] as? T
   57|    352|        }
   58|       |    }
   59|       |
   60|       |    extension AtomicInt {
   61|      0|        func valueSnapshot() -> Int32 {
   62|      0|            return self
   63|      0|        }
   64|       |    }
   65|       |    
   66|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/AnyObserver.swift:
    1|       |//
    2|       |//  AnyObserver.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A type-erased `ObserverType`.
   10|       |///
   11|       |/// Forwards operations to an arbitrary underlying observer with the same `Element` type, hiding the specifics of the underlying observer type.
   12|       |public struct AnyObserver<Element> : ObserverType {
   13|       |    /// The type of elements in sequence that observer can observe.
   14|       |    public typealias E = Element
   15|       |    
   16|       |    /// Anonymous event handler type.
   17|       |    public typealias EventHandler = (Event<Element>) -> Void
   18|       |
   19|       |    private let observer: EventHandler
   20|       |
   21|       |    /// Construct an instance whose `on(event)` calls `eventHandler(event)`
   22|       |    ///
   23|       |    /// - parameter eventHandler: Event handler that observes sequences events.
   24|    352|    public init(eventHandler: @escaping EventHandler) {
   25|    352|        self.observer = eventHandler
   26|    352|    }
   27|       |    
   28|       |    /// Construct an instance whose `on(event)` calls `observer.on(event)`
   29|       |    ///
   30|       |    /// - parameter observer: Observer that receives sequence events.
   31|  1.05k|    public init<O : ObserverType>(_ observer: O) where O.E == Element {
   32|  1.05k|        self.observer = observer.on
   33|  1.05k|    }
   34|       |    
   35|       |    /// Send `event` to this observer.
   36|       |    ///
   37|       |    /// - parameter event: Event instance.
   38|    385|    public func on(_ event: Event<Element>) {
   39|    385|        return self.observer(event)
   40|    385|    }
   41|       |
   42|       |    /// Erases type of observer and returns canonical observer.
   43|       |    ///
   44|       |    /// - returns: type erased observer.
   45|      0|    public func asObserver() -> AnyObserver<E> {
   46|      0|        return self
   47|      0|    }
   48|       |}
   49|       |
   50|       |extension AnyObserver {
   51|       |    /// Collection of `AnyObserver`s
   52|       |    typealias s = Bag<(Event<Element>) -> ()>
   53|       |}
   54|       |
   55|       |extension ObserverType {
   56|       |    /// Erases type of observer and returns canonical observer.
   57|       |    ///
   58|       |    /// - returns: type erased observer.
   59|    670|    public func asObserver() -> AnyObserver<E> {
   60|    670|        return AnyObserver(self)
   61|    670|    }
   62|       |
   63|       |    /// Transforms observer of type R to type E using custom transform method.
   64|       |    /// Each event sent to result observer is transformed and sent to `self`.
   65|       |    ///
   66|       |    /// - returns: observer that transforms events.
   67|    148|    public func mapObserver<R>(_ transform: @escaping (R) throws -> E) -> AnyObserver<R> {
   68|      0|        return AnyObserver { e in
   69|      0|            self.on(e.map(transform))
   70|      0|        }
   71|    148|    }
   72|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Concurrency/AsyncLock.swift:
    1|       |//
    2|       |//  AsyncLock.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |In case nobody holds this lock, the work will be queued and executed immediately
   11|       |on thread that is requesting lock.
   12|       |
   13|       |In case there is somebody currently holding that lock, action will be enqueued.
   14|       |When owned of the lock finishes with it's processing, it will also execute
   15|       |and pending work.
   16|       |
   17|       |That means that enqueued work could possibly be executed later on a different thread.
   18|       |*/
   19|       |final class AsyncLock<I: InvocableType>
   20|       |    : Disposable
   21|       |    , Lock
   22|       |    , SynchronizedDisposeType {
   23|       |    typealias Action = () -> Void
   24|       |    
   25|       |    var _lock = SpinLock()
   26|       |    
   27|       |    private var _queue: Queue<I> = Queue(capacity: 0)
   28|       |
   29|       |    private var _isExecuting: Bool = false
   30|       |    private var _hasFaulted: Bool = false
   31|       |
   32|       |    // lock {
   33|      0|    func lock() {
   34|      0|        _lock.lock()
   35|      0|    }
   36|       |
   37|      0|    func unlock() {
   38|      0|        _lock.unlock()
   39|      0|    }
   40|       |    // }
   41|       |
   42|      4|    private func enqueue(_ action: I) -> I? {
   43|      4|        _lock.lock(); defer { _lock.unlock() } // {
   44|      0|            if _hasFaulted {
   45|      0|                return nil
   46|      4|            }
   47|      4|
   48|      0|            if _isExecuting {
   49|      0|                _queue.enqueue(action)
   50|      0|                return nil
   51|      4|            }
   52|      4|
   53|      4|            _isExecuting = true
   54|      4|
   55|      4|            return action
   56|      4|        // }
   57|      4|    }
   58|       |
   59|      4|    private func dequeue() -> I? {
   60|      4|        _lock.lock(); defer { _lock.unlock() } // {
   61|      0|            if _queue.count > 0 {
   62|      0|                return _queue.dequeue()
   63|      4|            }
   64|      4|            else {
   65|      4|                _isExecuting = false
   66|      4|                return nil
   67|      0|            }
   68|      0|        // }
   69|      0|    }
   70|       |
   71|      4|    func invoke(_ action: I) {
   72|      4|        let firstEnqueuedAction = enqueue(action)
   73|      4|        
   74|      4|        if let firstEnqueuedAction = firstEnqueuedAction {
   75|      4|            firstEnqueuedAction.invoke()
   76|      4|        }
   77|      0|        else {
   78|      0|            // action is enqueued, it's somebody else's concern now
   79|      0|            return
   80|      4|        }
   81|      4|        
   82|      4|        while true {
   83|      4|            let nextAction = dequeue()
   84|      4|
   85|      0|            if let nextAction = nextAction {
   86|      0|                nextAction.invoke()
   87|      4|            }
   88|      4|            else {
   89|      4|                return
   90|      0|            }
   91|      0|        }
   92|      0|    }
   93|       |    
   94|      0|    func dispose() {
   95|      0|        synchronizedDispose()
   96|      0|    }
   97|       |
   98|      0|    func _synchronized_dispose() {
   99|      0|        _queue = Queue(capacity: 0)
  100|      0|        _hasFaulted = true
  101|      0|    }
  102|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Concurrency/Lock.swift:
    1|       |//
    2|       |//  Lock.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol Lock {
   10|       |    func lock()
   11|       |    func unlock()
   12|       |}
   13|       |
   14|       |// https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20151214/000321.html
   15|       |typealias SpinLock = RecursiveLock
   16|       |
   17|       |extension RecursiveLock : Lock {
   18|       |    @inline(__always)
   19|     14|    final func performLocked(_ action: () -> Void) {
   20|     14|        lock(); defer { unlock() }
   21|     14|        action()
   22|     14|    }
   23|       |
   24|       |    @inline(__always)
   25|  1.30k|    final func calculateLocked<T>(_ action: () -> T) -> T {
   26|  1.30k|        lock(); defer { unlock() }
   27|  1.30k|        return action()
   28|  1.30k|    }
   29|       |
   30|       |    @inline(__always)
   31|      0|    final func calculateLockedOrFail<T>(_ action: () throws -> T) throws -> T {
   32|      0|        lock(); defer { unlock() }
   33|      0|        let result = try action()
   34|      0|        return result
   35|      0|    }
   36|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Concurrency/LockOwnerType.swift:
    1|       |//
    2|       |//  LockOwnerType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol LockOwnerType : class, Lock {
   10|       |    var _lock: RecursiveLock { get }
   11|       |}
   12|       |
   13|       |extension LockOwnerType {
   14|    334|    func lock() {
   15|    334|        _lock.lock()
   16|    334|    }
   17|       |
   18|    334|    func unlock() {
   19|    334|        _lock.unlock()
   20|    334|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Concurrency/SynchronizedDisposeType.swift:
    1|       |//
    2|       |//  SynchronizedDisposeType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol SynchronizedDisposeType : class, Disposable, Lock {
   10|       |    func _synchronized_dispose()
   11|       |}
   12|       |
   13|       |extension SynchronizedDisposeType {
   14|      0|    func synchronizedDispose() {
   15|      0|        lock(); defer { unlock() }
   16|      0|        _synchronized_dispose()
   17|      0|    }
   18|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Concurrency/SynchronizedOnType.swift:
    1|       |//
    2|       |//  SynchronizedOnType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol SynchronizedOnType : class, ObserverType, Lock {
   10|       |    func _synchronized_on(_ event: Event<E>)
   11|       |}
   12|       |
   13|       |extension SynchronizedOnType {
   14|    334|    func synchronizedOn(_ event: Event<E>) {
   15|    334|        lock(); defer { unlock() }
   16|    334|        _synchronized_on(event)
   17|    334|    }
   18|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Concurrency/SynchronizedSubscribeType.swift:
    1|       |//
    2|       |//  SynchronizedSubscribeType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol SynchronizedSubscribeType : class, ObservableType, Lock {
   10|       |    func _synchronized_subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E
   11|       |}
   12|       |
   13|       |extension SynchronizedSubscribeType {
   14|      0|    func synchronizedSubscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   15|      0|        lock(); defer { unlock() }
   16|      0|        return _synchronized_subscribe(observer)
   17|      0|    }
   18|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Deprecated.swift:
    1|       |//
    2|       |//  Deprecated.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/5/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension Observable {
   10|       |    /**
   11|       |     Converts a optional to an observable sequence.
   12|       |     
   13|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   14|       |     
   15|       |     - parameter optional: Optional element in the resulting observable sequence.
   16|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
   17|       |     */
   18|       |    @available(*, deprecated, message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.", renamed: "from(optional:)")
   19|      0|    public static func from(_ optional: E?) -> Observable<E> {
   20|      0|        return ObservableOptional(optional: optional)
   21|      0|    }
   22|       |
   23|       |    /**
   24|       |     Converts a optional to an observable sequence.
   25|       |
   26|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   27|       |
   28|       |     - parameter optional: Optional element in the resulting observable sequence.
   29|       |     - parameter: Scheduler to send the optional element on.
   30|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
   31|       |     */
   32|       |    @available(*, deprecated, message: "Implicit conversions from any type to optional type are allowed and that is causing issues with `from` operator overloading.", renamed: "from(optional:scheduler:)")
   33|      0|    public static func from(_ optional: E?, scheduler: ImmediateSchedulerType) -> Observable<E> {
   34|      0|        return ObservableOptionalScheduled(optional: optional, scheduler: scheduler)
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension Disposable {
   39|       |    /// Deprecated in favor of `disposed(by:)`
   40|       |    ///
   41|       |    /// **@available(\*, deprecated, message="use disposed(by:) instead")**
   42|       |    ///
   43|       |    /// Adds `self` to `bag`.
   44|       |    ///
   45|       |    /// - parameter bag: `DisposeBag` to add `self` to.
   46|      0|    public func addDisposableTo(_ bag: DisposeBag) {
   47|      0|        disposed(by: bag)
   48|      0|    }
   49|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/AnonymousDisposable.swift:
    1|       |//
    2|       |//  AnonymousDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an Action-based disposable.
   10|       |///
   11|       |/// When dispose method is called, disposal action will be dereferenced.
   12|       |fileprivate final class AnonymousDisposable : DisposeBase, Cancelable {
   13|       |    public typealias DisposeAction = () -> Void
   14|       |
   15|       |    private var _isDisposed: AtomicInt = 0
   16|       |    private var _disposeAction: DisposeAction?
   17|       |
   18|       |    /// - returns: Was resource disposed.
   19|      0|    public var isDisposed: Bool {
   20|      0|        return _isDisposed == 1
   21|      0|    }
   22|       |
   23|       |    /// Constructs a new disposable with the given action used for disposal.
   24|       |    ///
   25|       |    /// - parameter disposeAction: Disposal action which will be run upon calling `dispose`.
   26|      0|    fileprivate init(_ disposeAction: @escaping DisposeAction) {
   27|      0|        _disposeAction = disposeAction
   28|      0|        super.init()
   29|      0|    }
   30|       |    
   31|       |    // Non-deprecated version of the constructor, used by `Disposables.create(with:)`
   32|    492|    fileprivate init(disposeAction: @escaping DisposeAction) {
   33|    492|        _disposeAction = disposeAction
   34|    492|        super.init()
   35|    492|    }
   36|       |    
   37|       |    /// Calls the disposal action if and only if the current instance hasn't been disposed yet.
   38|       |    ///
   39|       |    /// After invoking disposal action, disposal action will be dereferenced.
   40|     29|    fileprivate func dispose() {
   41|     29|        if AtomicCompareAndSwap(0, 1, &_isDisposed) {
   42|     29|            assert(_isDisposed == 1)
   43|     29|
   44|     29|            if let action = _disposeAction {
   45|     29|                _disposeAction = nil
   46|     29|                action()
   47|     29|            }
   48|     29|        }
   49|     29|    }
   50|       |}
   51|       |
   52|       |extension Disposables {
   53|       |    
   54|       |    /// Constructs a new disposable with the given action used for disposal.
   55|       |    ///
   56|       |    /// - parameter dispose: Disposal action which will be run upon calling `dispose`.
   57|    492|    public static func create(with dispose: @escaping () -> ()) -> Cancelable {
   58|    492|        return AnonymousDisposable(disposeAction: dispose)
   59|    492|    }
   60|       |    
   61|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/BinaryDisposable.swift:
    1|       |//
    2|       |//  BinaryDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents two disposable resources that are disposed together.
   10|       |private final class BinaryDisposable : DisposeBase, Cancelable {
   11|       |
   12|       |    private var _isDisposed: AtomicInt = 0
   13|       |
   14|       |    // state
   15|       |    private var _disposable1: Disposable?
   16|       |    private var _disposable2: Disposable?
   17|       |
   18|       |    /// - returns: Was resource disposed.
   19|      0|    var isDisposed: Bool {
   20|      0|        return _isDisposed > 0
   21|      0|    }
   22|       |
   23|       |    /// Constructs new binary disposable from two disposables.
   24|       |    ///
   25|       |    /// - parameter disposable1: First disposable
   26|       |    /// - parameter disposable2: Second disposable
   27|    812|    init(_ disposable1: Disposable, _ disposable2: Disposable) {
   28|    812|        _disposable1 = disposable1
   29|    812|        _disposable2 = disposable2
   30|    812|        super.init()
   31|    812|    }
   32|       |
   33|       |    /// Calls the disposal action if and only if the current instance hasn't been disposed yet.
   34|       |    ///
   35|       |    /// After invoking disposal action, disposal action will be dereferenced.
   36|     11|    func dispose() {
   37|     11|        if AtomicCompareAndSwap(0, 1, &_isDisposed) {
   38|     11|            _disposable1?.dispose()
   39|     11|            _disposable2?.dispose()
   40|     11|            _disposable1 = nil
   41|     11|            _disposable2 = nil
   42|     11|        }
   43|     11|    }
   44|       |}
   45|       |
   46|       |extension Disposables {
   47|       |    
   48|       |    /// Creates a disposable with the given disposables.
   49|    812|    public static func create(_ disposable1: Disposable, _ disposable2: Disposable) -> Cancelable {
   50|    812|        return BinaryDisposable(disposable1, disposable2)
   51|    812|    }
   52|       |    
   53|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/BooleanDisposable.swift:
    1|       |//
    2|       |//  BooleanDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 10/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable resource that can be checked for disposal status.
   10|       |public final class BooleanDisposable : Disposable, Cancelable {
   11|       |
   12|       |    internal static let BooleanDisposableTrue = BooleanDisposable(isDisposed: true)
   13|       |    private var _isDisposed = false
   14|       |    
   15|       |    /// Initializes a new instance of the `BooleanDisposable` class
   16|      0|    public init() {
   17|      0|    }
   18|       |    
   19|       |    /// Initializes a new instance of the `BooleanDisposable` class with given value
   20|      0|    public init(isDisposed: Bool) {
   21|      0|        self._isDisposed = isDisposed
   22|      0|    }
   23|       |    
   24|       |    /// - returns: Was resource disposed.
   25|      0|    public var isDisposed: Bool {
   26|      0|        return _isDisposed
   27|      0|    }
   28|       |    
   29|       |    /// Sets the status to disposed, which can be observer through the `isDisposed` property.
   30|      0|    public func dispose() {
   31|      0|        _isDisposed = true
   32|      0|    }
   33|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/CompositeDisposable.swift:
    1|       |//
    2|       |//  CompositeDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/20/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a group of disposable resources that are disposed together.
   10|       |public final class CompositeDisposable : DisposeBase, Disposable, Cancelable {
   11|       |    /// Key used to remove disposable from composite disposable
   12|       |    public struct DisposeKey {
   13|       |        fileprivate let key: BagKey
   14|     35|        fileprivate init(key: BagKey) {
   15|     35|            self.key = key
   16|     35|        }
   17|       |    }
   18|       |
   19|       |    private var _lock = SpinLock()
   20|       |    
   21|       |    // state
   22|       |    private var _disposables: Bag<Disposable>? = Bag()
   23|       |
   24|      0|    public var isDisposed: Bool {
   25|      0|        _lock.lock(); defer { _lock.unlock() }
   26|      0|        return _disposables == nil
   27|      0|    }
   28|       |    
   29|     29|    public override init() {
   30|     29|    }
   31|       |    
   32|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   33|      0|    public init(_ disposable1: Disposable, _ disposable2: Disposable) {
   34|      0|        // This overload is here to make sure we are using optimized version up to 4 arguments.
   35|      0|        let _ = _disposables!.insert(disposable1)
   36|      0|        let _ = _disposables!.insert(disposable2)
   37|      0|    }
   38|       |    
   39|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   40|      0|    public init(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable) {
   41|      0|        // This overload is here to make sure we are using optimized version up to 4 arguments.
   42|      0|        let _ = _disposables!.insert(disposable1)
   43|      0|        let _ = _disposables!.insert(disposable2)
   44|      0|        let _ = _disposables!.insert(disposable3)
   45|      0|    }
   46|       |    
   47|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   48|      0|    public init(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable, _ disposable4: Disposable, _ disposables: Disposable...) {
   49|      0|        // This overload is here to make sure we are using optimized version up to 4 arguments.
   50|      0|        let _ = _disposables!.insert(disposable1)
   51|      0|        let _ = _disposables!.insert(disposable2)
   52|      0|        let _ = _disposables!.insert(disposable3)
   53|      0|        let _ = _disposables!.insert(disposable4)
   54|      0|        
   55|      0|        for disposable in disposables {
   56|      0|            let _ = _disposables!.insert(disposable)
   57|      0|        }
   58|      0|    }
   59|       |    
   60|       |    /// Initializes a new instance of composite disposable with the specified number of disposables.
   61|     34|    public init(disposables: [Disposable]) {
   62|    204|        for disposable in disposables {
   63|    204|            let _ = _disposables!.insert(disposable)
   64|     34|        }
   65|     34|    }
   66|       |
   67|       |    /**
   68|       |     Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
   69|       |     
   70|       |     - parameter disposable: Disposable to add.
   71|       |     - returns: Key that can be used to remove disposable from composite disposable. In case dispose bag was already
   72|       |     disposed `nil` will be returned.
   73|       |     */
   74|     35|    public func insert(_ disposable: Disposable) -> DisposeKey? {
   75|     35|        let key = _insert(disposable)
   76|     35|        
   77|      0|        if key == nil {
   78|      0|            disposable.dispose()
   79|     35|        }
   80|     35|        
   81|     35|        return key
   82|     35|    }
   83|       |    
   84|     35|    private func _insert(_ disposable: Disposable) -> DisposeKey? {
   85|     35|        _lock.lock(); defer { _lock.unlock() }
   86|     35|
   87|     35|        let bagKey = _disposables?.insert(disposable)
   88|     35|        return bagKey.map(DisposeKey.init)
   89|     35|    }
   90|       |    
   91|       |    /// - returns: Gets the number of disposables contained in the `CompositeDisposable`.
   92|      0|    public var count: Int {
   93|      0|        _lock.lock(); defer { _lock.unlock() }
   94|      0|        return _disposables?.count ?? 0
   95|      0|    }
   96|       |    
   97|       |    /// Removes and disposes the disposable identified by `disposeKey` from the CompositeDisposable.
   98|       |    ///
   99|       |    /// - parameter disposeKey: Key used to identify disposable to be removed.
  100|      6|    public func remove(for disposeKey: DisposeKey) {
  101|      6|        _remove(for: disposeKey)?.dispose()
  102|      6|    }
  103|       |    
  104|      6|    private func _remove(for disposeKey: DisposeKey) -> Disposable? {
  105|      6|        _lock.lock(); defer { _lock.unlock() }
  106|      6|        return _disposables?.removeKey(disposeKey.key)
  107|      6|    }
  108|       |    
  109|       |    /// Disposes all disposables in the group and removes them from the group.
  110|     16|    public func dispose() {
  111|     16|        if let disposables = _dispose() {
  112|     16|            disposeAll(in: disposables)
  113|     16|        }
  114|     16|    }
  115|       |
  116|     16|    private func _dispose() -> Bag<Disposable>? {
  117|     16|        _lock.lock(); defer { _lock.unlock() }
  118|     16|
  119|     16|        let disposeBag = _disposables
  120|     16|        _disposables = nil
  121|     16|
  122|     16|        return disposeBag
  123|     16|    }
  124|       |}
  125|       |
  126|       |extension Disposables {
  127|       |
  128|       |    /// Creates a disposable with the given disposables.
  129|      0|    public static func create(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable) -> Cancelable {
  130|      0|        return CompositeDisposable(disposable1, disposable2, disposable3)
  131|      0|    }
  132|       |    
  133|       |    /// Creates a disposable with the given disposables.
  134|      0|    public static func create(_ disposable1: Disposable, _ disposable2: Disposable, _ disposable3: Disposable, _ disposables: Disposable ...) -> Cancelable {
  135|      0|        var disposables = disposables
  136|      0|        disposables.append(disposable1)
  137|      0|        disposables.append(disposable2)
  138|      0|        disposables.append(disposable3)
  139|      0|        return CompositeDisposable(disposables: disposables)
  140|      0|    }
  141|       |    
  142|       |    /// Creates a disposable with the given disposables.
  143|     40|    public static func create(_ disposables: [Disposable]) -> Cancelable {
  144|     40|        switch disposables.count {
  145|      6|        case 2:
  146|      6|            return Disposables.create(disposables[0], disposables[1])
  147|     34|        default:
  148|     34|            return CompositeDisposable(disposables: disposables)
  149|     40|        }
  150|     40|    }
  151|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/Disposables.swift:
    1|       |//
    2|       |//  Disposables.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Mohsen Ramezanpoor on 01/08/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A collection of utility methods for common disposable operations.
   10|       |public struct Disposables {
   11|      0|    private init() {}
   12|       |}
   13|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/DisposeBag.swift:
    1|       |//
    2|       |//  DisposeBag.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension Disposable {
   10|       |    /// Adds `self` to `bag`
   11|       |    ///
   12|       |    /// - parameter bag: `DisposeBag` to add `self` to.
   13|    445|    public func disposed(by bag: DisposeBag) {
   14|    445|        bag.insert(self)
   15|    445|    }
   16|       |}
   17|       |
   18|       |/**
   19|       |Thread safe bag that disposes added disposables on `deinit`.
   20|       |
   21|       |This returns ARC (RAII) like resource management to `RxSwift`.
   22|       |
   23|       |In case contained disposables need to be disposed, just put a different dispose bag
   24|       |or create a new one in its place.
   25|       |
   26|       |    self.existingDisposeBag = DisposeBag()
   27|       |
   28|       |In case explicit disposal is necessary, there is also `CompositeDisposable`.
   29|       |*/
   30|       |public final class DisposeBag: DisposeBase {
   31|       |    
   32|       |    private var _lock = SpinLock()
   33|       |    
   34|       |    // state
   35|       |    private var _disposables = [Disposable]()
   36|       |    private var _isDisposed = false
   37|       |    
   38|       |    /// Constructs new empty dispose bag.
   39|    164|    public override init() {
   40|    164|        super.init()
   41|    164|    }
   42|       |    
   43|       |    /// Adds `disposable` to be disposed when dispose bag is being deinited.
   44|       |    ///
   45|       |    /// - parameter disposable: Disposable to add.
   46|    445|    public func insert(_ disposable: Disposable) {
   47|    445|        _insert(disposable)?.dispose()
   48|    445|    }
   49|       |    
   50|    445|    private func _insert(_ disposable: Disposable) -> Disposable? {
   51|    445|        _lock.lock(); defer { _lock.unlock() }
   52|      0|        if _isDisposed {
   53|      0|            return disposable
   54|    445|        }
   55|    445|
   56|    445|        _disposables.append(disposable)
   57|    445|
   58|    445|        return nil
   59|    445|    }
   60|       |
   61|       |    /// This is internal on purpose, take a look at `CompositeDisposable` instead.
   62|     17|    private func dispose() {
   63|     17|        let oldDisposables = _dispose()
   64|     17|
   65|      2|        for disposable in oldDisposables {
   66|      2|            disposable.dispose()
   67|     17|        }
   68|     17|    }
   69|       |
   70|     17|    private func _dispose() -> [Disposable] {
   71|     17|        _lock.lock(); defer { _lock.unlock() }
   72|     17|
   73|     17|        let disposables = _disposables
   74|     17|        
   75|     17|        _disposables.removeAll(keepingCapacity: false)
   76|     17|        _isDisposed = true
   77|     17|        
   78|     17|        return disposables
   79|     17|    }
   80|       |    
   81|     17|    deinit {
   82|     17|        dispose()
   83|     17|    }
   84|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/DisposeBase.swift:
    1|       |//
    2|       |//  DisposeBase.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Base class for all disposables.
   10|       |public class DisposeBase {
   11|  3.85k|    init() {
   12|  3.85k|#if TRACE_RESOURCES
   13|  3.85k|    let _ = Resources.incrementTotal()
   14|  3.85k|#endif
   15|  3.85k|    }
   16|       |    
   17|    697|    deinit {
   18|    697|#if TRACE_RESOURCES
   19|    697|    let _ = Resources.decrementTotal()
   20|    697|#endif
   21|    697|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/NopDisposable.swift:
    1|       |//
    2|       |//  NopDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable that does nothing on disposal.
   10|       |///
   11|       |/// Nop = No Operation
   12|       |fileprivate struct NopDisposable : Disposable {
   13|       | 
   14|       |    fileprivate static let noOp: Disposable = NopDisposable()
   15|       |    
   16|      1|    fileprivate init() {
   17|      1|        
   18|      1|    }
   19|       |    
   20|       |    /// Does nothing.
   21|    651|    public func dispose() {
   22|    651|    }
   23|       |}
   24|       |
   25|       |extension Disposables {
   26|       |    /**
   27|       |     Creates a disposable that does nothing on disposal.
   28|       |     */
   29|  1.08k|    static public func create() -> Disposable {
   30|  1.08k|        return NopDisposable.noOp
   31|  1.08k|    }
   32|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/RefCountDisposable.swift:
    1|       |//
    2|       |//  RefCountDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 10/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable resource that only disposes its underlying disposable resource when all dependent disposable objects have been disposed.
   10|       |public final class RefCountDisposable : DisposeBase, Cancelable {
   11|       |    private var _lock = SpinLock()
   12|       |    private var _disposable = nil as Disposable?
   13|       |    private var _primaryDisposed = false
   14|       |    private var _count = 0
   15|       |
   16|       |    /// - returns: Was resource disposed.
   17|      0|    public var isDisposed: Bool {
   18|      0|        _lock.lock(); defer { _lock.unlock() }
   19|      0|        return _disposable == nil
   20|      0|    }
   21|       |
   22|       |    /// Initializes a new instance of the `RefCountDisposable`.
   23|      0|    public init(disposable: Disposable) {
   24|      0|        _disposable = disposable
   25|      0|        super.init()
   26|      0|    }
   27|       |
   28|       |    /**
   29|       |     Holds a dependent disposable that when disposed decreases the refcount on the underlying disposable.
   30|       |
   31|       |     When getter is called, a dependent disposable contributing to the reference count that manages the underlying disposable's lifetime is returned.
   32|       |     */
   33|      0|    public func retain() -> Disposable {
   34|      0|        return _lock.calculateLocked {
   35|      0|            if let _ = _disposable {
   36|      0|
   37|      0|                do {
   38|      0|                    let _ = try incrementChecked(&_count)
   39|      0|                } catch (_) {
   40|      0|                    rxFatalError("RefCountDisposable increment failed")
   41|      0|                }
   42|      0|
   43|      0|                return RefCountInnerDisposable(self)
   44|      0|            } else {
   45|      0|                return Disposables.create()
   46|      0|            }
   47|      0|        }
   48|      0|    }
   49|       |
   50|       |    /// Disposes the underlying disposable only when all dependent disposables have been disposed.
   51|      0|    public func dispose() {
   52|      0|        let oldDisposable: Disposable? = _lock.calculateLocked {
   53|      0|            if let oldDisposable = _disposable, !_primaryDisposed
   54|      0|            {
   55|      0|                _primaryDisposed = true
   56|      0|
   57|      0|                if (_count == 0)
   58|      0|                {
   59|      0|                    _disposable = nil
   60|      0|                    return oldDisposable
   61|      0|                }
   62|      0|            }
   63|      0|
   64|      0|            return nil
   65|      0|        }
   66|      0|
   67|      0|        if let disposable = oldDisposable {
   68|      0|            disposable.dispose()
   69|      0|        }
   70|      0|    }
   71|       |
   72|      0|    fileprivate func release() {
   73|      0|        let oldDisposable: Disposable? = _lock.calculateLocked {
   74|      0|            if let oldDisposable = _disposable {
   75|      0|                do {
   76|      0|                    let _ = try decrementChecked(&_count)
   77|      0|                } catch (_) {
   78|      0|                    rxFatalError("RefCountDisposable decrement on release failed")
   79|      0|                }
   80|      0|
   81|      0|                guard _count >= 0 else {
   82|      0|                    rxFatalError("RefCountDisposable counter is lower than 0")
   83|      0|                }
   84|      0|
   85|      0|                if _primaryDisposed && _count == 0 {
   86|      0|                    _disposable = nil
   87|      0|                    return oldDisposable
   88|      0|                }
   89|      0|            }
   90|      0|
   91|      0|            return nil
   92|      0|        }
   93|      0|
   94|      0|        if let disposable = oldDisposable {
   95|      0|            disposable.dispose()
   96|      0|        }
   97|      0|    }
   98|       |}
   99|       |
  100|       |internal final class RefCountInnerDisposable: DisposeBase, Disposable
  101|       |{
  102|       |    private let _parent: RefCountDisposable
  103|       |    private var _isDisposed: AtomicInt = 0
  104|       |
  105|       |    init(_ parent: RefCountDisposable)
  106|      0|    {
  107|      0|        _parent = parent
  108|      0|        super.init()
  109|      0|    }
  110|       |
  111|       |    internal func dispose()
  112|      0|    {
  113|      0|        if AtomicCompareAndSwap(0, 1, &_isDisposed) {
  114|      0|            _parent.release()
  115|      0|        }
  116|      0|    }
  117|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/ScheduledDisposable.swift:
    1|       |//
    2|       |//  ScheduledDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |private let disposeScheduledDisposable: (ScheduledDisposable) -> Disposable = { sd in
   10|       |    sd.disposeInner()
   11|       |    return Disposables.create()
   12|       |}
   13|       |
   14|       |/// Represents a disposable resource whose disposal invocation will be scheduled on the specified scheduler.
   15|       |public final class ScheduledDisposable : Cancelable {
   16|       |    public let scheduler: ImmediateSchedulerType
   17|       |
   18|       |    private var _isDisposed: AtomicInt = 0
   19|       |
   20|       |    // state
   21|       |    private var _disposable: Disposable?
   22|       |
   23|       |    /// - returns: Was resource disposed.
   24|      0|    public var isDisposed: Bool {
   25|      0|        return _isDisposed == 1
   26|      0|    }
   27|       |
   28|       |    /**
   29|       |    Initializes a new instance of the `ScheduledDisposable` that uses a `scheduler` on which to dispose the `disposable`.
   30|       |
   31|       |    - parameter scheduler: Scheduler where the disposable resource will be disposed on.
   32|       |    - parameter disposable: Disposable resource to dispose on the given scheduler.
   33|       |    */
   34|    594|    public init(scheduler: ImmediateSchedulerType, disposable: Disposable) {
   35|    594|        self.scheduler = scheduler
   36|    594|        _disposable = disposable
   37|    594|    }
   38|       |
   39|       |    /// Disposes the wrapped disposable on the provided scheduler.
   40|      1|    public func dispose() {
   41|      1|        let _ = scheduler.schedule(self, action: disposeScheduledDisposable)
   42|      1|    }
   43|       |
   44|      1|    func disposeInner() {
   45|      1|        if AtomicCompareAndSwap(0, 1, &_isDisposed) {
   46|      1|            _disposable!.dispose()
   47|      1|            _disposable = nil
   48|      1|        }
   49|      1|    }
   50|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/SerialDisposable.swift:
    1|       |//
    2|       |//  SerialDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a disposable resource whose underlying disposable resource can be replaced by another disposable resource, causing automatic disposal of the previous underlying disposable resource.
   10|       |public final class SerialDisposable : DisposeBase, Cancelable {
   11|       |    private var _lock = SpinLock()
   12|       |    
   13|       |    // state
   14|       |    private var _current = nil as Disposable?
   15|       |    private var _isDisposed = false
   16|       |    
   17|       |    /// - returns: Was resource disposed.
   18|     14|    public var isDisposed: Bool {
   19|     14|        return _isDisposed
   20|     14|    }
   21|       |    
   22|       |    /// Initializes a new instance of the `SerialDisposable`.
   23|    659|    override public init() {
   24|    659|        super.init()
   25|    659|    }
   26|       |    
   27|       |    /**
   28|       |    Gets or sets the underlying disposable.
   29|       |    
   30|       |    Assigning this property disposes the previous disposable object.
   31|       |    
   32|       |    If the `SerialDisposable` has already been disposed, assignment to this property causes immediate disposal of the given disposable object.
   33|       |    */
   34|       |    public var disposable: Disposable {
   35|      0|        get {
   36|      0|            return _lock.calculateLocked {
   37|      0|                return self.disposable
   38|      0|            }
   39|      0|        }
   40|  1.26k|        set (newDisposable) {
   41|  1.26k|            let disposable: Disposable? = _lock.calculateLocked {
   42|      0|                if _isDisposed {
   43|      0|                    return newDisposable
   44|  1.26k|                }
   45|  1.26k|                else {
   46|  1.26k|                    let toDispose = _current
   47|  1.26k|                    _current = newDisposable
   48|  1.26k|                    return toDispose
   49|      0|                }
   50|      0|            }
   51|  1.26k|            
   52|    602|            if let disposable = disposable {
   53|    602|                disposable.dispose()
   54|  1.26k|            }
   55|  1.26k|        }
   56|       |    }
   57|       |    
   58|       |    /// Disposes the underlying disposable as well as all future replacements.
   59|     17|    public func dispose() {
   60|     17|        _dispose()?.dispose()
   61|     17|    }
   62|       |
   63|     17|    private func _dispose() -> Disposable? {
   64|     17|        _lock.lock(); defer { _lock.unlock() }
   65|      0|        if _isDisposed {
   66|      0|            return nil
   67|     17|        }
   68|     17|        else {
   69|     17|            _isDisposed = true
   70|     17|            let current = _current
   71|     17|            _current = nil
   72|     17|            return current
   73|      0|        }
   74|      0|    }
   75|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/SingleAssignmentDisposable.swift:
    1|       |//
    2|       |//  SingleAssignmentDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Represents a disposable resource which only allows a single assignment of its underlying disposable resource.
   11|       |
   12|       |If an underlying disposable resource has already been set, future attempts to set the underlying disposable resource will throw an exception.
   13|       |*/
   14|       |public final class SingleAssignmentDisposable : DisposeBase, Disposable, Cancelable {
   15|       |
   16|       |    fileprivate enum DisposeState: UInt32 {
   17|       |        case disposed = 1
   18|       |        case disposableSet = 2
   19|       |    }
   20|       |
   21|       |    // Jeej, swift API consistency rules
   22|       |    fileprivate enum DisposeStateInt32: Int32 {
   23|       |        case disposed = 1
   24|       |        case disposableSet = 2
   25|       |    }
   26|       |
   27|       |    // state
   28|       |    private var _state: AtomicInt = 0
   29|       |    private var _disposable = nil as Disposable?
   30|       |
   31|       |    /// - returns: A value that indicates whether the object is disposed.
   32|     13|    public var isDisposed: Bool {
   33|     13|        return AtomicFlagSet(DisposeState.disposed.rawValue, &_state)
   34|     13|    }
   35|       |
   36|       |    /// Initializes a new instance of the `SingleAssignmentDisposable`.
   37|  1.66k|    public override init() {
   38|  1.66k|        super.init()
   39|  1.66k|    }
   40|       |
   41|       |    /// Gets or sets the underlying disposable. After disposal, the result of getting this property is undefined.
   42|       |    ///
   43|       |    /// **Throws exception if the `SingleAssignmentDisposable` has already been assigned to.**
   44|  1.63k|    public func setDisposable(_ disposable: Disposable) {
   45|  1.63k|        _disposable = disposable
   46|  1.63k|
   47|  1.63k|        let previousState = AtomicOr(DisposeState.disposableSet.rawValue, &_state)
   48|  1.63k|        
   49|      0|        if (previousState & DisposeStateInt32.disposableSet.rawValue) != 0 {
   50|      0|            rxFatalError("oldState.disposable != nil")
   51|  1.63k|        }
   52|  1.63k|
   53|    643|        if (previousState & DisposeStateInt32.disposed.rawValue) != 0 {
   54|    643|            disposable.dispose()
   55|    643|            _disposable = nil
   56|  1.63k|        }
   57|  1.63k|    }
   58|       |
   59|       |    /// Disposes the underlying disposable.
   60|    676|    public func dispose() {
   61|    676|        let previousState = AtomicOr(DisposeState.disposed.rawValue, &_state)
   62|    676|
   63|      7|        if (previousState & DisposeStateInt32.disposed.rawValue) != 0 {
   64|      7|            return
   65|    669|        }
   66|    669|
   67|     26|        if (previousState & DisposeStateInt32.disposableSet.rawValue) != 0 {
   68|      0|            guard let disposable = _disposable else {
   69|      0|                rxFatalError("Disposable not set")
   70|     26|            }
   71|     26|            disposable.dispose()
   72|     26|            _disposable = nil
   73|    669|        }
   74|    669|    }
   75|       |
   76|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Disposables/SubscriptionDisposable.swift:
    1|       |//
    2|       |//  SubscriptionDisposable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct SubscriptionDisposable<T: SynchronizedUnsubscribeType> : Disposable {
   10|       |    private let _key: T.DisposeKey
   11|       |    private weak var _owner: T?
   12|       |
   13|    920|    init(owner: T, key: T.DisposeKey) {
   14|    920|        _owner = owner
   15|    920|        _key = key
   16|    920|    }
   17|       |
   18|      1|    func dispose() {
   19|      1|        _owner?.synchronizedUnsubscribe(_key)
   20|      1|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Errors.swift:
    1|       |//
    2|       |//  Errors.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |let RxErrorDomain       = "RxErrorDomain"
   10|       |let RxCompositeFailures = "RxCompositeFailures"
   11|       |
   12|       |/// Generic Rx error codes.
   13|       |public enum RxError
   14|       |    : Swift.Error
   15|       |    , CustomDebugStringConvertible {
   16|       |    /// Unknown error occured.
   17|       |    case unknown
   18|       |    /// Performing an action on disposed object.
   19|       |    case disposed(object: AnyObject)
   20|       |    /// Aritmetic overflow error.
   21|       |    case overflow
   22|       |    /// Argument out of range error.
   23|       |    case argumentOutOfRange
   24|       |    /// Sequence doesn't contain any elements.
   25|       |    case noElements
   26|       |    /// Sequence contains more than one element.
   27|       |    case moreThanOneElement
   28|       |    /// Timeout error.
   29|       |    case timeout
   30|       |}
   31|       |
   32|       |extension RxError {
   33|       |    /// A textual representation of `self`, suitable for debugging.
   34|      0|    public var debugDescription: String {
   35|      0|        switch self {
   36|      0|        case .unknown:
   37|      0|            return "Unknown error occured."
   38|      0|        case .disposed(let object):
   39|      0|            return "Object `\(object)` was already disposed."
   40|      0|        case .overflow:
   41|      0|            return "Arithmetic overflow occured."
   42|      0|        case .argumentOutOfRange:
   43|      0|            return "Argument out of range."
   44|      0|        case .noElements:
   45|      0|            return "Sequence doesn't contain any elements."
   46|      0|        case .moreThanOneElement:
   47|      0|            return "Sequence contains more than one element."
   48|      0|        case .timeout:
   49|      0|            return "Sequence timeout."
   50|      0|        }
   51|      0|    }
   52|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Event.swift:
    1|       |//
    2|       |//  Event.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a sequence event.
   10|       |///
   11|       |/// Sequence grammar: 
   12|       |/// **next\* (error | completed)**
   13|       |public enum Event<Element> {
   14|       |    /// Next element is produced.
   15|       |    case next(Element)
   16|       |
   17|       |    /// Sequence terminated with an error.
   18|       |    case error(Swift.Error)
   19|       |
   20|       |    /// Sequence completed successfully.
   21|       |    case completed
   22|       |}
   23|       |
   24|       |extension Event : CustomDebugStringConvertible {
   25|       |    /// - returns: Description of event.
   26|      0|    public var debugDescription: String {
   27|      0|        switch self {
   28|      0|        case .next(let value):
   29|      0|            return "next(\(value))"
   30|      0|        case .error(let error):
   31|      0|            return "error(\(error))"
   32|      0|        case .completed:
   33|      0|            return "completed"
   34|      0|        }
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension Event {
   39|       |    /// Is `completed` or `error` event.
   40|    363|    public var isStopEvent: Bool {
   41|    363|        switch self {
   42|    356|        case .next: return false
   43|      7|        case .error, .completed: return true
   44|    363|        }
   45|    363|    }
   46|       |
   47|       |    /// If `next` event, returns element value.
   48|      6|    public var element: Element? {
   49|      6|        if case .next(let value) = self {
   50|      6|            return value
   51|      0|        }
   52|      0|        return nil
   53|      6|    }
   54|       |
   55|       |    /// If `error` event, returns error.
   56|      0|    public var error: Swift.Error? {
   57|      0|        if case .error(let error) = self {
   58|      0|            return error
   59|      0|        }
   60|      0|        return nil
   61|      0|    }
   62|       |
   63|       |    /// If `completed` event, returns true.
   64|      0|    public var isCompleted: Bool {
   65|      0|        if case .completed = self {
   66|      0|            return true
   67|      0|        }
   68|      0|        return false
   69|      0|    }
   70|       |}
   71|       |
   72|       |extension Event {
   73|       |    /// Maps sequence elements using transform. If error happens during the transform .error
   74|       |    /// will be returned as value
   75|      0|    public func map<Result>(_ transform: (Element) throws -> Result) -> Event<Result> {
   76|      0|        do {
   77|      0|            switch self {
   78|      0|            case let .next(element):
   79|      0|                return .next(try transform(element))
   80|      0|            case let .error(error):
   81|      0|                return .error(error)
   82|      0|            case .completed:
   83|      0|                return .completed
   84|      0|            }
   85|      0|        }
   86|      0|        catch let e {
   87|      0|            return .error(e)
   88|      0|        }
   89|      0|    }
   90|       |}
   91|       |
   92|       |/// A type that can be converted to `Event<Element>`.
   93|       |public protocol EventConvertible {
   94|       |    /// Type of element in event
   95|       |    associatedtype ElementType
   96|       |
   97|       |    /// Event representation of this instance
   98|       |    var event: Event<ElementType> { get }
   99|       |}
  100|       |
  101|       |extension Event : EventConvertible {
  102|       |    /// Event representation of this instance
  103|      0|    public var event: Event<Element> {
  104|      0|        return self
  105|      0|    }
  106|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Extensions/Bag+Rx.swift:
    1|       |//
    2|       |//  Bag+Rx.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/19/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |// MARK: forEach
   11|       |
   12|       |@inline(__always)
   13|    403|func dispatch<E>(_ bag: Bag<(Event<E>) -> ()>, _ event: Event<E>) {
   14|    394|    if bag._onlyFastPath {
   15|    394|        bag._value0?(event)
   16|    394|        return
   17|      9|    }
   18|      9|
   19|      9|    let value0 = bag._value0
   20|      9|    let dictionary = bag._dictionary
   21|      9|
   22|      9|    if let value0 = value0 {
   23|      9|        value0(event)
   24|      9|    }
   25|      9|
   26|      9|    let pairs = bag._pairs
   27|     33|    for i in 0 ..< pairs.count {
   28|     33|        pairs[i].value(event)
   29|      9|    }
   30|      9|
   31|      0|    if let dictionary = dictionary {
   32|      0|        for element in dictionary.values {
   33|      0|            element(event)
   34|      0|        }
   35|      9|    }
   36|      9|}
   37|       |
   38|       |/// Dispatches `dispose` to all disposables contained inside bag.
   39|     16|func disposeAll(in bag: Bag<Disposable>) {
   40|     14|    if bag._onlyFastPath {
   41|     14|        bag._value0?.dispose()
   42|     14|        return
   43|      2|    }
   44|      2|
   45|      2|    let value0 = bag._value0
   46|      2|    let dictionary = bag._dictionary
   47|      2|
   48|      2|    if let value0 = value0 {
   49|      2|        value0.dispose()
   50|      2|    }
   51|      2|
   52|      2|    let pairs = bag._pairs
   53|      0|    for i in 0 ..< pairs.count {
   54|      0|        pairs[i].value.dispose()
   55|      2|    }
   56|      2|
   57|      0|    if let dictionary = dictionary {
   58|      0|        for element in dictionary.values {
   59|      0|            element.dispose()
   60|      0|        }
   61|      2|    }
   62|      2|}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Extensions/String+Rx.swift:
    1|       |//
    2|       |//  String+Rx.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension String {
   10|       |    /// This is needed because on Linux Swift doesn't have `rangeOfString(..., options: .BackwardsSearch)`
   11|      5|    func lastIndexOf(_ character: Character) -> Index? {
   12|      5|        var index = endIndex
   13|    120|        while index > startIndex {
   14|    120|            index = self.index(before: index)
   15|      5|            if self[index] == character {
   16|      5|                return index
   17|    115|            }
   18|      0|        }
   19|      0|
   20|      0|        return nil
   21|      5|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/GroupedObservable.swift:
    1|       |//
    2|       |//  GroupedObservable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 01/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an observable sequence of elements that have a common key.
   10|       |public struct GroupedObservable<Key, Element> : ObservableType {
   11|       |    public typealias E = Element
   12|       |
   13|       |    /// Gets the common key.
   14|       |    public let key: Key
   15|       |
   16|       |    private let source: Observable<Element>
   17|       |
   18|       |    /// Initializes grouped observable sequence with key and source observable sequence.
   19|       |    ///
   20|       |    /// - parameter key: Grouped observable sequence key
   21|       |    /// - parameter source: Observable sequence that represents sequence of elements for the key
   22|       |    /// - returns: Grouped observable sequence of elements for the specific key
   23|      0|    public init(key: Key, source: Observable<Element>) {
   24|      0|        self.key = key
   25|      0|        self.source = source
   26|      0|    }
   27|       |
   28|       |    /// Subscribes `observer` to receive events for this sequence.
   29|      0|    public func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   30|      0|        return self.source.subscribe(observer)
   31|      0|    }
   32|       |
   33|       |    /// Converts `self` to `Observable` sequence. 
   34|      0|    public func asObservable() -> Observable<Element> {
   35|      0|        return source
   36|      0|    }
   37|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/ImmediateSchedulerType.swift:
    1|       |//
    2|       |//  ImmediateSchedulerType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that immediately schedules units of work.
   10|       |public protocol ImmediateSchedulerType {
   11|       |    /**
   12|       |    Schedules an action to be executed immediatelly.
   13|       |    
   14|       |    - parameter state: State passed to the action to be executed.
   15|       |    - parameter action: Action to be executed.
   16|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   17|       |    */
   18|       |    func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable
   19|       |}
   20|       |
   21|       |extension ImmediateSchedulerType {
   22|       |    /**
   23|       |    Schedules an action to be executed recursively.
   24|       |    
   25|       |    - parameter state: State passed to the action to be executed.
   26|       |    - parameter action: Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
   27|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   28|       |    */
   29|      0|    public func scheduleRecursive<State>(_ state: State, action: @escaping (_ state: State, _ recurse: (State) -> ()) -> ()) -> Disposable {
   30|      0|        let recursiveScheduler = RecursiveImmediateScheduler(action: action, scheduler: self)
   31|      0|        
   32|      0|        recursiveScheduler.schedule(state)
   33|      0|        
   34|      0|        return Disposables.create(with: recursiveScheduler.dispose)
   35|      0|    }
   36|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observable.swift:
    1|       |//
    2|       |//  Observable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A type-erased `ObservableType`. 
   10|       |///
   11|       |/// It represents a push style sequence.
   12|       |public class Observable<Element> : ObservableType {
   13|       |    /// Type of elements in sequence.
   14|       |    public typealias E = Element
   15|       |    
   16|  3.08k|    init() {
   17|  3.08k|#if TRACE_RESOURCES
   18|  3.08k|        let _ = Resources.incrementTotal()
   19|  3.08k|#endif
   20|  3.08k|    }
   21|       |    
   22|      0|    public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   23|      0|        rxAbstractMethod()
   24|      0|    }
   25|       |    
   26|  2.03k|    public func asObservable() -> Observable<E> {
   27|  2.03k|        return self
   28|  2.03k|    }
   29|       |    
   30|    210|    deinit {
   31|    210|#if TRACE_RESOURCES
   32|    210|        let _ = Resources.decrementTotal()
   33|    210|#endif
   34|    210|    }
   35|       |
   36|       |    // this is kind of ugly I know :(
   37|       |    // Swift compiler reports "Not supported yet" when trying to override protocol extensions, so ¯\_(ツ)_/¯
   38|       |
   39|       |    /// Optimizations for map operator
   40|    396|    internal func composeMap<R>(_ selector: @escaping (Element) throws -> R) -> Observable<R> {
   41|    396|        return Map(source: self, transform: selector)
   42|    396|    }
   43|       |}
   44|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/ObservableType+Extensions.swift:
    1|       |//
    2|       |//  ObservableType+Extensions.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension ObservableType {
   10|       |    /**
   11|       |    Subscribes an event handler to an observable sequence.
   12|       |
   13|       |    - parameter on: Action to invoke for each event in the observable sequence.
   14|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
   15|       |    */
   16|       |    public func subscribe(_ on: @escaping (Event<E>) -> Void)
   17|     17|        -> Disposable {
   18|     49|        let observer = AnonymousObserver { e in
   19|     49|            on(e)
   20|     49|        }
   21|     17|        return self.subscribeSafe(observer)
   22|     17|    }
   23|       |
   24|       |    #if DEBUG
   25|       |    /**
   26|       |    Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.
   27|       |
   28|       |    - parameter onNext: Action to invoke for each element in the observable sequence.
   29|       |    - parameter onError: Action to invoke upon errored termination of the observable sequence.
   30|       |    - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   31|       |    - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has
   32|       |        gracefully completed, errored, or if the generation is cancelled by disposing subscription).
   33|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
   34|       |    */
   35|       |    public func subscribe(file: String = #file, line: UInt = #line, function: String = #function, onNext: ((E) -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onDisposed: (() -> Void)? = nil)
   36|    382|        -> Disposable {
   37|    382|
   38|    382|        let disposable: Disposable
   39|    382|
   40|      0|        if let disposed = onDisposed {
   41|      0|            disposable = Disposables.create(with: disposed)
   42|    382|        }
   43|    382|        else {
   44|    382|            disposable = Disposables.create()
   45|    382|        }
   46|    382|
   47|    153|        let observer = AnonymousObserver<E> { e in
   48|    153|            switch e {
   49|    146|            case .next(let value):
   50|    146|                onNext?(value)
   51|      0|            case .error(let e):
   52|      0|                if let onError = onError {
   53|      0|                    onError(e)
   54|      0|                }
   55|      0|                else {
   56|      0|                    print("Received unhandled error: \(file):\(line):\(function) -> \(e)")
   57|      0|                }
   58|      0|                disposable.dispose()
   59|      7|            case .completed:
   60|      7|                onCompleted?()
   61|      7|                disposable.dispose()
   62|    153|            }
   63|    153|        }
   64|    382|        return Disposables.create(
   65|    382|            self.subscribeSafe(observer),
   66|    382|            disposable
   67|    382|        )
   68|    382|    }
   69|       |    #else
   70|       |    /**
   71|       |    Subscribes an element handler, an error handler, a completion handler and disposed handler to an observable sequence.
   72|       |
   73|       |    - parameter onNext: Action to invoke for each element in the observable sequence.
   74|       |    - parameter onError: Action to invoke upon errored termination of the observable sequence.
   75|       |    - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   76|       |    - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has
   77|       |        gracefully completed, errored, or if the generation is cancelled by disposing subscription).
   78|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
   79|       |    */
   80|       |    public func subscribe(onNext: ((E) -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onDisposed: (() -> Void)? = nil)
   81|       |        -> Disposable {
   82|       |
   83|       |        let disposable: Disposable
   84|       |
   85|       |        if let disposed = onDisposed {
   86|       |            disposable = Disposables.create(with: disposed)
   87|       |        }
   88|       |        else {
   89|       |            disposable = Disposables.create()
   90|       |        }
   91|       |
   92|       |        let observer = AnonymousObserver<E> { e in
   93|       |            switch e {
   94|       |            case .next(let value):
   95|       |                onNext?(value)
   96|       |            case .error(let e):
   97|       |                onError?(e)
   98|       |                disposable.dispose()
   99|       |            case .completed:
  100|       |                onCompleted?()
  101|       |                disposable.dispose()
  102|       |            }
  103|       |        }
  104|       |        return Disposables.create(
  105|       |            self.subscribeSafe(observer),
  106|       |            disposable
  107|       |        )
  108|       |    }
  109|       |    #endif
  110|       |}
  111|       |
  112|       |extension ObservableType {
  113|       |    /// All internal subscribe calls go through this method.
  114|    399|    fileprivate func subscribeSafe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
  115|    399|        return self.asObservable().subscribe(observer)
  116|    399|    }
  117|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/ObservableType.swift:
    1|       |//
    2|       |//  ObservableType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a push style sequence.
   10|       |public protocol ObservableType : ObservableConvertibleType {
   11|       |    /// Type of elements in sequence.
   12|       |    associatedtype E
   13|       |    
   14|       |    /**
   15|       |    Subscribes `observer` to receive events for this sequence.
   16|       |    
   17|       |    ### Grammar
   18|       |    
   19|       |    **Next\* (Error | Completed)?**
   20|       |    
   21|       |    * sequences can produce zero or more elements so zero or more `Next` events can be sent to `observer`
   22|       |    * once an `Error` or `Completed` event is sent, the sequence terminates and can't produce any other elements
   23|       |    
   24|       |    It is possible that events are sent from different threads, but no two events can be sent concurrently to
   25|       |    `observer`.
   26|       |    
   27|       |    ### Resource Management
   28|       |    
   29|       |    When sequence sends `Complete` or `Error` event all internal resources that compute sequence elements
   30|       |    will be freed.
   31|       |    
   32|       |    To cancel production of sequence elements and free resources immediatelly, call `dispose` on returned
   33|       |    subscription.
   34|       |    
   35|       |    - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
   36|       |    */
   37|       |    func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E
   38|       |}
   39|       |
   40|       |extension ObservableType {
   41|       |    
   42|       |    /// Default implementation of converting `ObservableType` to `Observable`.
   43|      0|    public func asObservable() -> Observable<E> {
   44|      0|        // temporary workaround
   45|      0|        //return Observable.create(subscribe: self.subscribe)
   46|      0|        return Observable.create { o in
   47|      0|            return self.subscribe(o)
   48|      0|        }
   49|      0|    }
   50|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/AddRef.swift:
    1|       |//
    2|       |//  AddRef.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 30/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class AddRefSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias Element = O.E
   11|       |    
   12|      0|    override init(observer: O, cancel: Cancelable) {
   13|      0|        super.init(observer: observer, cancel: cancel)
   14|      0|    }
   15|       |    
   16|      0|    func on(_ event: Event<Element>) {
   17|      0|        switch event {
   18|      0|        case .next(_):
   19|      0|            forwardOn(event)
   20|      0|        case .completed, .error(_):
   21|      0|            forwardOn(event)
   22|      0|            dispose()
   23|      0|        }
   24|      0|    }
   25|       |}
   26|       |
   27|       |final class AddRef<Element> : Producer<Element> {
   28|       |    typealias EventHandler = (Event<Element>) throws -> Void
   29|       |    
   30|       |    private let _source: Observable<Element>
   31|       |    private let _refCount: RefCountDisposable
   32|       |    
   33|      0|    init(source: Observable<Element>, refCount: RefCountDisposable) {
   34|      0|        _source = source
   35|      0|        _refCount = refCount
   36|      0|    }
   37|       |    
   38|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   39|      0|        let releaseDisposable = _refCount.retain()
   40|      0|        let sink = AddRefSink(observer: observer, cancel: cancel)
   41|      0|        let subscription = Disposables.create(releaseDisposable, _source.subscribe(sink))
   42|      0|
   43|      0|        return (sink: sink, subscription: subscription)
   44|      0|    }
   45|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Amb.swift:
    1|       |//
    2|       |//  Amb.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |enum AmbState {
   10|       |    case neither
   11|       |    case left
   12|       |    case right
   13|       |}
   14|       |
   15|       |final class AmbObserver<O: ObserverType> : ObserverType {
   16|       |    typealias Element = O.E
   17|       |    typealias Parent = AmbSink<O>
   18|       |    typealias This = AmbObserver<O>
   19|       |    typealias Sink = (This, Event<Element>) -> Void
   20|       |    
   21|       |    fileprivate let _parent: Parent
   22|       |    fileprivate var _sink: Sink
   23|       |    fileprivate var _cancel: Disposable
   24|       |    
   25|      0|    init(parent: Parent, cancel: Disposable, sink: @escaping Sink) {
   26|      0|#if TRACE_RESOURCES
   27|      0|        let _ = Resources.incrementTotal()
   28|      0|#endif
   29|      0|        
   30|      0|        _parent = parent
   31|      0|        _sink = sink
   32|      0|        _cancel = cancel
   33|      0|    }
   34|       |    
   35|      0|    func on(_ event: Event<Element>) {
   36|      0|        _sink(self, event)
   37|      0|        if event.isStopEvent {
   38|      0|            _cancel.dispose()
   39|      0|        }
   40|      0|    }
   41|       |    
   42|      0|    deinit {
   43|      0|#if TRACE_RESOURCES
   44|      0|        let _ = Resources.decrementTotal()
   45|      0|#endif
   46|      0|    }
   47|       |}
   48|       |
   49|       |final class AmbSink<O: ObserverType> : Sink<O> {
   50|       |    typealias ElementType = O.E
   51|       |    typealias Parent = Amb<ElementType>
   52|       |    typealias AmbObserverType = AmbObserver<O>
   53|       |
   54|       |    private let _parent: Parent
   55|       |    
   56|       |    private let _lock = RecursiveLock()
   57|       |    // state
   58|       |    private var _choice = AmbState.neither
   59|       |    
   60|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   61|      0|        _parent = parent
   62|      0|        super.init(observer: observer, cancel: cancel)
   63|      0|    }
   64|       |    
   65|      0|    func run() -> Disposable {
   66|      0|        let subscription1 = SingleAssignmentDisposable()
   67|      0|        let subscription2 = SingleAssignmentDisposable()
   68|      0|        let disposeAll = Disposables.create(subscription1, subscription2)
   69|      0|        
   70|      0|        let forwardEvent = { (o: AmbObserverType, event: Event<ElementType>) -> Void in
   71|      0|            self.forwardOn(event)
   72|      0|            if event.isStopEvent {
   73|      0|                self.dispose()
   74|      0|            }
   75|      0|        }
   76|      0|
   77|      0|        let decide = { (o: AmbObserverType, event: Event<ElementType>, me: AmbState, otherSubscription: Disposable) in
   78|      0|            self._lock.performLocked {
   79|      0|                if self._choice == .neither {
   80|      0|                    self._choice = me
   81|      0|                    o._sink = forwardEvent
   82|      0|                    o._cancel = disposeAll
   83|      0|                    otherSubscription.dispose()
   84|      0|                }
   85|      0|                
   86|      0|                if self._choice == me {
   87|      0|                    self.forwardOn(event)
   88|      0|                    if event.isStopEvent {
   89|      0|                        self.dispose()
   90|      0|                    }
   91|      0|                }
   92|      0|            }
   93|      0|        }
   94|      0|        
   95|      0|        let sink1 = AmbObserver(parent: self, cancel: subscription1) { o, e in
   96|      0|            decide(o, e, .left, subscription2)
   97|      0|        }
   98|      0|        
   99|      0|        let sink2 = AmbObserver(parent: self, cancel: subscription1) { o, e in
  100|      0|            decide(o, e, .right, subscription1)
  101|      0|        }
  102|      0|        
  103|      0|        subscription1.setDisposable(_parent._left.subscribe(sink1))
  104|      0|        subscription2.setDisposable(_parent._right.subscribe(sink2))
  105|      0|        
  106|      0|        return disposeAll
  107|      0|    }
  108|       |}
  109|       |
  110|       |final class Amb<Element>: Producer<Element> {
  111|       |    fileprivate let _left: Observable<Element>
  112|       |    fileprivate let _right: Observable<Element>
  113|       |    
  114|      0|    init(left: Observable<Element>, right: Observable<Element>) {
  115|      0|        _left = left
  116|      0|        _right = right
  117|      0|    }
  118|       |    
  119|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  120|      0|        let sink = AmbSink(parent: self, observer: observer, cancel: cancel)
  121|      0|        let subscription = sink.run()
  122|      0|        return (sink: sink, subscription: subscription)
  123|      0|    }
  124|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/AnonymousObservable.swift:
    1|       |//
    2|       |//  AnonymousObservable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class AnonymousObservableSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias E = O.E
   11|       |    typealias Parent = AnonymousObservable<E>
   12|       |
   13|       |    // state
   14|       |    private var _isStopped: AtomicInt = 0
   15|       |
   16|       |    #if DEBUG
   17|       |        fileprivate var _numberOfConcurrentCalls: AtomicInt = 0
   18|       |    #endif
   19|       |
   20|    383|    override init(observer: O, cancel: Cancelable) {
   21|    383|        super.init(observer: observer, cancel: cancel)
   22|    383|    }
   23|       |
   24|    180|    func on(_ event: Event<E>) {
   25|    180|        #if DEBUG
   26|      0|            if AtomicIncrement(&_numberOfConcurrentCalls) > 1 {
   27|      0|                rxFatalError("Warning: Recursive call or synchronization error!")
   28|    180|            }
   29|    180|
   30|    180|            defer {
   31|    180|                _ = AtomicDecrement(&_numberOfConcurrentCalls)
   32|    180|        }
   33|    180|        #endif
   34|    180|        switch event {
   35|    167|        case .next:
   36|      0|            if _isStopped == 1 {
   37|      0|                return
   38|    167|            }
   39|    167|            forwardOn(event)
   40|     13|        case .error, .completed:
   41|     13|            if AtomicCompareAndSwap(0, 1, &_isStopped) {
   42|     13|                forwardOn(event)
   43|     13|                dispose()
   44|     13|            }
   45|    180|        }
   46|    180|    }
   47|       |
   48|    383|    func run(_ parent: Parent) -> Disposable {
   49|    383|        return parent._subscribeHandler(AnyObserver(self))
   50|    383|    }
   51|       |}
   52|       |
   53|       |final class AnonymousObservable<Element> : Producer<Element> {
   54|       |    typealias SubscribeHandler = (AnyObserver<Element>) -> Disposable
   55|       |
   56|       |    let _subscribeHandler: SubscribeHandler
   57|       |
   58|    387|    init(_ subscribeHandler: @escaping SubscribeHandler) {
   59|    387|        _subscribeHandler = subscribeHandler
   60|    387|    }
   61|       |
   62|    383|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   63|    383|        let sink = AnonymousObservableSink(observer: observer, cancel: cancel)
   64|    383|        let subscription = sink.run(self)
   65|    383|        return (sink: sink, subscription: subscription)
   66|    383|    }
   67|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/AsMaybe.swift:
    1|       |//
    2|       |//  AsMaybe.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class AsMaybeSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias ElementType = O.E
   11|       |    typealias E = ElementType
   12|       |
   13|       |    private var _element: Event<E>? = nil
   14|       |
   15|      0|    func on(_ event: Event<E>) {
   16|      0|        switch event {
   17|      0|        case .next:
   18|      0|            if _element != nil {
   19|      0|                forwardOn(.error(RxError.moreThanOneElement))
   20|      0|                dispose()
   21|      0|            }
   22|      0|
   23|      0|            _element = event
   24|      0|        case .error:
   25|      0|            forwardOn(event)
   26|      0|            dispose()
   27|      0|        case .completed:
   28|      0|            if let element = _element {
   29|      0|                forwardOn(element)
   30|      0|            }
   31|      0|            forwardOn(.completed)
   32|      0|            dispose()
   33|      0|        }
   34|      0|    }
   35|       |}
   36|       |
   37|       |final class AsMaybe<Element>: Producer<Element> {
   38|       |    fileprivate let _source: Observable<Element>
   39|       |
   40|      0|    init(source: Observable<Element>) {
   41|      0|        _source = source
   42|      0|    }
   43|       |
   44|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   45|      0|        let sink = AsMaybeSink(observer: observer, cancel: cancel)
   46|      0|        let subscription = _source.subscribe(sink)
   47|      0|        return (sink: sink, subscription: subscription)
   48|      0|    }
   49|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/AsSingle.swift:
    1|       |//
    2|       |//  AsSingle.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class AsSingleSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias ElementType = O.E
   11|       |    typealias E = ElementType
   12|       |
   13|       |    private var _element: Event<E>? = nil
   14|       |
   15|      0|    func on(_ event: Event<E>) {
   16|      0|        switch event {
   17|      0|        case .next:
   18|      0|            if _element != nil {
   19|      0|                forwardOn(.error(RxError.moreThanOneElement))
   20|      0|                dispose()
   21|      0|            }
   22|      0|
   23|      0|            _element = event
   24|      0|        case .error:
   25|      0|            forwardOn(event)
   26|      0|            dispose()
   27|      0|        case .completed:
   28|      0|            if let element = _element {
   29|      0|                forwardOn(element)
   30|      0|                forwardOn(.completed)
   31|      0|            }
   32|      0|            else {
   33|      0|                forwardOn(.error(RxError.noElements))
   34|      0|            }
   35|      0|            dispose()
   36|      0|        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |final class AsSingle<Element>: Producer<Element> {
   41|       |    fileprivate let _source: Observable<Element>
   42|       |
   43|      0|    init(source: Observable<Element>) {
   44|      0|        _source = source
   45|      0|    }
   46|       |
   47|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   48|      0|        let sink = AsSingleSink(observer: observer, cancel: cancel)
   49|      0|        let subscription = _source.subscribe(sink)
   50|      0|        return (sink: sink, subscription: subscription)
   51|      0|    }
   52|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Buffer.swift:
    1|       |//
    2|       |//  Buffer.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class BufferTimeCount<Element> : Producer<[Element]> {
   10|       |    
   11|       |    fileprivate let _timeSpan: RxTimeInterval
   12|       |    fileprivate let _count: Int
   13|       |    fileprivate let _scheduler: SchedulerType
   14|       |    fileprivate let _source: Observable<Element>
   15|       |    
   16|      0|    init(source: Observable<Element>, timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType) {
   17|      0|        _source = source
   18|      0|        _timeSpan = timeSpan
   19|      0|        _count = count
   20|      0|        _scheduler = scheduler
   21|      0|    }
   22|       |    
   23|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == [Element] {
   24|      0|        let sink = BufferTimeCountSink(parent: self, observer: observer, cancel: cancel)
   25|      0|        let subscription = sink.run()
   26|      0|        return (sink: sink, subscription: subscription)
   27|      0|    }
   28|       |}
   29|       |
   30|       |final class BufferTimeCountSink<Element, O: ObserverType>
   31|       |    : Sink<O>
   32|       |    , LockOwnerType
   33|       |    , ObserverType
   34|       |    , SynchronizedOnType where O.E == [Element] {
   35|       |    typealias Parent = BufferTimeCount<Element>
   36|       |    typealias E = Element
   37|       |    
   38|       |    private let _parent: Parent
   39|       |    
   40|       |    let _lock = RecursiveLock()
   41|       |    
   42|       |    // state
   43|       |    private let _timerD = SerialDisposable()
   44|       |    private var _buffer = [Element]()
   45|       |    private var _windowID = 0
   46|       |    
   47|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   48|      0|        _parent = parent
   49|      0|        super.init(observer: observer, cancel: cancel)
   50|      0|    }
   51|       | 
   52|      0|    func run() -> Disposable {
   53|      0|        createTimer(_windowID)
   54|      0|        return Disposables.create(_timerD, _parent._source.subscribe(self))
   55|      0|    }
   56|       |    
   57|      0|    func startNewWindowAndSendCurrentOne() {
   58|      0|        _windowID = _windowID &+ 1
   59|      0|        let windowID = _windowID
   60|      0|        
   61|      0|        let buffer = _buffer
   62|      0|        _buffer = []
   63|      0|        forwardOn(.next(buffer))
   64|      0|        
   65|      0|        createTimer(windowID)
   66|      0|    }
   67|       |    
   68|      0|    func on(_ event: Event<E>) {
   69|      0|        synchronizedOn(event)
   70|      0|    }
   71|       |
   72|      0|    func _synchronized_on(_ event: Event<E>) {
   73|      0|        switch event {
   74|      0|        case .next(let element):
   75|      0|            _buffer.append(element)
   76|      0|            
   77|      0|            if _buffer.count == _parent._count {
   78|      0|                startNewWindowAndSendCurrentOne()
   79|      0|            }
   80|      0|            
   81|      0|        case .error(let error):
   82|      0|            _buffer = []
   83|      0|            forwardOn(.error(error))
   84|      0|            dispose()
   85|      0|        case .completed:
   86|      0|            forwardOn(.next(_buffer))
   87|      0|            forwardOn(.completed)
   88|      0|            dispose()
   89|      0|        }
   90|      0|    }
   91|       |    
   92|      0|    func createTimer(_ windowID: Int) {
   93|      0|        if _timerD.isDisposed {
   94|      0|            return
   95|      0|        }
   96|      0|        
   97|      0|        if _windowID != windowID {
   98|      0|            return
   99|      0|        }
  100|      0|
  101|      0|        let nextTimer = SingleAssignmentDisposable()
  102|      0|        
  103|      0|        _timerD.disposable = nextTimer
  104|      0|
  105|      0|        let disposable = _parent._scheduler.scheduleRelative(windowID, dueTime: _parent._timeSpan) { previousWindowID in
  106|      0|            self._lock.performLocked {
  107|      0|                if previousWindowID != self._windowID {
  108|      0|                    return
  109|      0|                }
  110|      0|             
  111|      0|                self.startNewWindowAndSendCurrentOne()
  112|      0|            }
  113|      0|            
  114|      0|            return Disposables.create()
  115|      0|        }
  116|      0|
  117|      0|        nextTimer.setDisposable(disposable)
  118|      0|    }
  119|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Catch.swift:
    1|       |//
    2|       |//  Catch.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// catch with callback
   10|       |
   11|       |final class CatchSinkProxy<O: ObserverType> : ObserverType {
   12|       |    typealias E = O.E
   13|       |    typealias Parent = CatchSink<O>
   14|       |    
   15|       |    private let _parent: Parent
   16|       |    
   17|      0|    init(parent: Parent) {
   18|      0|        _parent = parent
   19|      0|    }
   20|       |    
   21|      0|    func on(_ event: Event<E>) {
   22|      0|        _parent.forwardOn(event)
   23|      0|        
   24|      0|        switch event {
   25|      0|        case .next:
   26|      0|            break
   27|      0|        case .error, .completed:
   28|      0|            _parent.dispose()
   29|      0|        }
   30|      0|    }
   31|       |}
   32|       |
   33|       |final class CatchSink<O: ObserverType> : Sink<O>, ObserverType {
   34|       |    typealias E = O.E
   35|       |    typealias Parent = Catch<E>
   36|       |    
   37|       |    private let _parent: Parent
   38|       |    private let _subscription = SerialDisposable()
   39|       |    
   40|      4|    init(parent: Parent, observer: O, cancel: Cancelable) {
   41|      4|        _parent = parent
   42|      4|        super.init(observer: observer, cancel: cancel)
   43|      4|    }
   44|       |    
   45|      4|    func run() -> Disposable {
   46|      4|        let d1 = SingleAssignmentDisposable()
   47|      4|        _subscription.disposable = d1
   48|      4|        d1.setDisposable(_parent._source.subscribe(self))
   49|      4|
   50|      4|        return _subscription
   51|      4|    }
   52|       |    
   53|     37|    func on(_ event: Event<E>) {
   54|     37|        switch event {
   55|     37|        case .next:
   56|     37|            forwardOn(event)
   57|      0|        case .completed:
   58|      0|            forwardOn(event)
   59|      0|            dispose()
   60|      0|        case .error(let error):
   61|      0|            do {
   62|      0|                let catchSequence = try _parent._handler(error)
   63|      0|
   64|      0|                let observer = CatchSinkProxy(parent: self)
   65|      0|                
   66|      0|                _subscription.disposable = catchSequence.subscribe(observer)
   67|      0|            }
   68|      0|            catch let e {
   69|      0|                forwardOn(.error(e))
   70|      0|                dispose()
   71|      0|            }
   72|     37|        }
   73|     37|    }
   74|       |}
   75|       |
   76|       |final class Catch<Element> : Producer<Element> {
   77|       |    typealias Handler = (Swift.Error) throws -> Observable<Element>
   78|       |    
   79|       |    fileprivate let _source: Observable<Element>
   80|       |    fileprivate let _handler: Handler
   81|       |    
   82|      9|    init(source: Observable<Element>, handler: @escaping Handler) {
   83|      9|        _source = source
   84|      9|        _handler = handler
   85|      9|    }
   86|       |    
   87|      4|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   88|      4|        let sink = CatchSink(parent: self, observer: observer, cancel: cancel)
   89|      4|        let subscription = sink.run()
   90|      4|        return (sink: sink, subscription: subscription)
   91|      4|    }
   92|       |}
   93|       |
   94|       |// catch enumerable
   95|       |
   96|       |final class CatchSequenceSink<S: Sequence, O: ObserverType>
   97|       |    : TailRecursiveSink<S, O>
   98|       |    , ObserverType where S.Iterator.Element : ObservableConvertibleType, S.Iterator.Element.E == O.E {
   99|       |    typealias Element = O.E
  100|       |    typealias Parent = CatchSequence<S>
  101|       |    
  102|       |    private var _lastError: Swift.Error?
  103|       |    
  104|      0|    override init(observer: O, cancel: Cancelable) {
  105|      0|        super.init(observer: observer, cancel: cancel)
  106|      0|    }
  107|       |    
  108|      0|    func on(_ event: Event<Element>) {
  109|      0|        switch event {
  110|      0|        case .next:
  111|      0|            forwardOn(event)
  112|      0|        case .error(let error):
  113|      0|            _lastError = error
  114|      0|            schedule(.moveNext)
  115|      0|        case .completed:
  116|      0|            forwardOn(event)
  117|      0|            dispose()
  118|      0|        }
  119|      0|    }
  120|       |
  121|      0|    override func subscribeToNext(_ source: Observable<E>) -> Disposable {
  122|      0|        return source.subscribe(self)
  123|      0|    }
  124|       |    
  125|      0|    override func done() {
  126|      0|        if let lastError = _lastError {
  127|      0|            forwardOn(.error(lastError))
  128|      0|        }
  129|      0|        else {
  130|      0|            forwardOn(.completed)
  131|      0|        }
  132|      0|        
  133|      0|        self.dispose()
  134|      0|    }
  135|       |    
  136|      0|    override func extract(_ observable: Observable<Element>) -> SequenceGenerator? {
  137|      0|        if let onError = observable as? CatchSequence<S> {
  138|      0|            return (onError.sources.makeIterator(), nil)
  139|      0|        }
  140|      0|        else {
  141|      0|            return nil
  142|      0|        }
  143|      0|    }
  144|       |}
  145|       |
  146|       |final class CatchSequence<S: Sequence> : Producer<S.Iterator.Element.E> where S.Iterator.Element : ObservableConvertibleType {
  147|       |    typealias Element = S.Iterator.Element.E
  148|       |    
  149|       |    let sources: S
  150|       |    
  151|      0|    init(sources: S) {
  152|      0|        self.sources = sources
  153|      0|    }
  154|       |    
  155|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  156|      0|        let sink = CatchSequenceSink<S, O>(observer: observer, cancel: cancel)
  157|      0|        let subscription = sink.run((self.sources.makeIterator(), nil))
  158|      0|        return (sink: sink, subscription: subscription)
  159|      0|    }
  160|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/CombineLatest+Collection.swift:
    1|       |//
    2|       |//  CombineLatest+Collection.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class CombineLatestCollectionTypeSink<C: Collection, O: ObserverType>
   10|       |    : Sink<O> where C.Iterator.Element : ObservableConvertibleType {
   11|       |    typealias R = O.E
   12|       |    typealias Parent = CombineLatestCollectionType<C, R>
   13|       |    typealias SourceElement = C.Iterator.Element.E
   14|       |    
   15|       |    let _parent: Parent
   16|       |    
   17|       |    let _lock = RecursiveLock()
   18|       |
   19|       |    // state
   20|       |    var _numberOfValues = 0
   21|       |    var _values: [SourceElement?]
   22|       |    var _isDone: [Bool]
   23|       |    var _numberOfDone = 0
   24|       |    var _subscriptions: [SingleAssignmentDisposable]
   25|       |    
   26|     34|    init(parent: Parent, observer: O, cancel: Cancelable) {
   27|     34|        _parent = parent
   28|     34|        _values = [SourceElement?](repeating: nil, count: parent._count)
   29|     34|        _isDone = [Bool](repeating: false, count: parent._count)
   30|     34|        _subscriptions = Array<SingleAssignmentDisposable>()
   31|     34|        _subscriptions.reserveCapacity(parent._count)
   32|     34|        
   33|    204|        for _ in 0 ..< parent._count {
   34|    204|            _subscriptions.append(SingleAssignmentDisposable())
   35|     34|        }
   36|     34|        
   37|     34|        super.init(observer: observer, cancel: cancel)
   38|     34|    }
   39|       |    
   40|    205|    func on(_ event: Event<SourceElement>, atIndex: Int) {
   41|    205|        _lock.lock(); defer { _lock.unlock() } // {
   42|    205|            switch event {
   43|    205|            case .next(let element):
   44|    204|                if _values[atIndex] == nil {
   45|    204|                   _numberOfValues += 1
   46|    205|                }
   47|    205|                
   48|    205|                _values[atIndex] = element
   49|    205|                
   50|    170|                if _numberOfValues < _parent._count {
   51|    170|                    let numberOfOthersThatAreDone = self._numberOfDone - (_isDone[atIndex] ? 1 : 0)
   52|      0|                    if numberOfOthersThatAreDone == self._parent._count - 1 {
   53|      0|                        forwardOn(.completed)
   54|      0|                        dispose()
   55|    170|                    }
   56|    170|                    return
   57|     35|                }
   58|     35|                
   59|     35|                do {
   60|    210|                    let result = try _parent._resultSelector(_values.map { $0! })
   61|     35|                    forwardOn(.next(result))
   62|     35|                }
   63|      0|                catch let error {
   64|      0|                    forwardOn(.error(error))
   65|      0|                    dispose()
   66|      0|                }
   67|    205|                
   68|      0|            case .error(let error):
   69|      0|                forwardOn(.error(error))
   70|      0|                dispose()
   71|      0|            case .completed:
   72|      0|                if _isDone[atIndex] {
   73|      0|                    return
   74|      0|                }
   75|      0|                
   76|      0|                _isDone[atIndex] = true
   77|      0|                _numberOfDone += 1
   78|      0|                
   79|      0|                if _numberOfDone == self._parent._count {
   80|      0|                    forwardOn(.completed)
   81|      0|                    dispose()
   82|      0|                }
   83|      0|                else {
   84|      0|                    _subscriptions[atIndex].dispose()
   85|      0|                }
   86|    205|            }
   87|    205|        // }
   88|    205|    }
   89|       |    
   90|     34|    func run() -> Disposable {
   91|     34|        var j = 0
   92|    204|        for i in _parent._sources {
   93|    204|            let index = j
   94|    204|            let source = i.asObservable()
   95|    205|            let disposable = source.subscribe(AnyObserver { event in
   96|    205|                self.on(event, atIndex: index)
   97|    205|            })
   98|    204|
   99|    204|            _subscriptions[j].setDisposable(disposable)
  100|    204|            
  101|    204|            j += 1
  102|     34|        }
  103|     34|        
  104|     34|        return Disposables.create(_subscriptions)
  105|     34|    }
  106|       |}
  107|       |
  108|       |final class CombineLatestCollectionType<C: Collection, R> : Producer<R> where C.Iterator.Element : ObservableConvertibleType {
  109|       |    typealias ResultSelector = ([C.Iterator.Element.E]) throws -> R
  110|       |    
  111|       |    let _sources: C
  112|       |    let _resultSelector: ResultSelector
  113|       |    let _count: Int
  114|       |
  115|     34|    init(sources: C, resultSelector: @escaping ResultSelector) {
  116|     34|        _sources = sources
  117|     34|        _resultSelector = resultSelector
  118|     34|        _count = Int(self._sources.count.toIntMax())
  119|     34|    }
  120|       |    
  121|     34|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  122|     34|        let sink = CombineLatestCollectionTypeSink(parent: self, observer: observer, cancel: cancel)
  123|     34|        let subscription = sink.run()
  124|     34|        return (sink: sink, subscription: subscription)
  125|     34|    }
  126|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/CombineLatest+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  CombineLatest+arity.swift
    4|       |//  RxSwift
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 4/22/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |
   11|       |
   12|       |// 2
   13|       |
   14|       |extension Observable {
   15|       |    /**
   16|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   17|       |
   18|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   19|       |
   20|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType>
   24|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   25|      6|            -> Observable<E> {
   26|      6|        return CombineLatest2(
   27|      6|            source1: source1.asObservable(), source2: source2.asObservable(),
   28|      6|            resultSelector: resultSelector
   29|      6|        )
   30|      6|    }
   31|       |}
   32|       |
   33|       |extension ObservableType where E == Any {
   34|       |    /**
   35|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
   36|       |
   37|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   38|       |
   39|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   40|       |    */
   41|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType>
   42|       |        (_ source1: O1, _ source2: O2)
   43|      0|            -> Observable<(O1.E, O2.E)> {
   44|      0|        return CombineLatest2(
   45|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   46|      0|            resultSelector: { ($0, $1) }
   47|      0|        )
   48|      0|    }
   49|       |}
   50|       |
   51|       |final class CombineLatestSink2_<E1, E2, O: ObserverType> : CombineLatestSink<O> {
   52|       |    typealias R = O.E
   53|       |    typealias Parent = CombineLatest2<E1, E2, R>
   54|       |
   55|       |    let _parent: Parent
   56|       |
   57|       |    var _latestElement1: E1! = nil
   58|       |    var _latestElement2: E2! = nil
   59|       |
   60|      6|    init(parent: Parent, observer: O, cancel: Cancelable) {
   61|      6|        _parent = parent
   62|      6|        super.init(arity: 2, observer: observer, cancel: cancel)
   63|      6|    }
   64|       |
   65|      6|    func run() -> Disposable {
   66|      6|        let subscription1 = SingleAssignmentDisposable()
   67|      6|        let subscription2 = SingleAssignmentDisposable()
   68|      6|
   69|      6|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
   70|      6|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
   71|      6|
   72|      6|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
   73|      6|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
   74|      6|
   75|      6|        return Disposables.create([
   76|      6|                subscription1,
   77|      6|                subscription2
   78|      6|        ])
   79|      6|    }
   80|       |
   81|      6|    override func getResult() throws -> R {
   82|      6|        return try _parent._resultSelector(_latestElement1, _latestElement2)
   83|      6|    }
   84|       |}
   85|       |
   86|       |final class CombineLatest2<E1, E2, R> : Producer<R> {
   87|       |    typealias ResultSelector = (E1, E2) throws -> R
   88|       |
   89|       |    let _source1: Observable<E1>
   90|       |    let _source2: Observable<E2>
   91|       |
   92|       |    let _resultSelector: ResultSelector
   93|       |
   94|      6|    init(source1: Observable<E1>, source2: Observable<E2>, resultSelector: @escaping ResultSelector) {
   95|      6|        _source1 = source1
   96|      6|        _source2 = source2
   97|      6|
   98|      6|        _resultSelector = resultSelector
   99|      6|    }
  100|       |
  101|      6|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  102|      6|        let sink = CombineLatestSink2_(parent: self, observer: observer, cancel: cancel)
  103|      6|        let subscription = sink.run()
  104|      6|        return (sink: sink, subscription: subscription)
  105|      6|    }
  106|       |}
  107|       |
  108|       |
  109|       |
  110|       |// 3
  111|       |
  112|       |extension Observable {
  113|       |    /**
  114|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  115|       |
  116|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  117|       |
  118|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  119|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  120|       |    */
  121|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  122|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
  123|      0|            -> Observable<E> {
  124|      0|        return CombineLatest3(
  125|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  126|      0|            resultSelector: resultSelector
  127|      0|        )
  128|      0|    }
  129|       |}
  130|       |
  131|       |extension ObservableType where E == Any {
  132|       |    /**
  133|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  134|       |
  135|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  136|       |
  137|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  138|       |    */
  139|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  140|       |        (_ source1: O1, _ source2: O2, _ source3: O3)
  141|      0|            -> Observable<(O1.E, O2.E, O3.E)> {
  142|      0|        return CombineLatest3(
  143|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  144|      0|            resultSelector: { ($0, $1, $2) }
  145|      0|        )
  146|      0|    }
  147|       |}
  148|       |
  149|       |final class CombineLatestSink3_<E1, E2, E3, O: ObserverType> : CombineLatestSink<O> {
  150|       |    typealias R = O.E
  151|       |    typealias Parent = CombineLatest3<E1, E2, E3, R>
  152|       |
  153|       |    let _parent: Parent
  154|       |
  155|       |    var _latestElement1: E1! = nil
  156|       |    var _latestElement2: E2! = nil
  157|       |    var _latestElement3: E3! = nil
  158|       |
  159|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  160|      0|        _parent = parent
  161|      0|        super.init(arity: 3, observer: observer, cancel: cancel)
  162|      0|    }
  163|       |
  164|      0|    func run() -> Disposable {
  165|      0|        let subscription1 = SingleAssignmentDisposable()
  166|      0|        let subscription2 = SingleAssignmentDisposable()
  167|      0|        let subscription3 = SingleAssignmentDisposable()
  168|      0|
  169|      0|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  170|      0|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  171|      0|        let observer3 = CombineLatestObserver(lock: _lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  172|      0|
  173|      0|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
  174|      0|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
  175|      0|         subscription3.setDisposable(_parent._source3.subscribe(observer3))
  176|      0|
  177|      0|        return Disposables.create([
  178|      0|                subscription1,
  179|      0|                subscription2,
  180|      0|                subscription3
  181|      0|        ])
  182|      0|    }
  183|       |
  184|      0|    override func getResult() throws -> R {
  185|      0|        return try _parent._resultSelector(_latestElement1, _latestElement2, _latestElement3)
  186|      0|    }
  187|       |}
  188|       |
  189|       |final class CombineLatest3<E1, E2, E3, R> : Producer<R> {
  190|       |    typealias ResultSelector = (E1, E2, E3) throws -> R
  191|       |
  192|       |    let _source1: Observable<E1>
  193|       |    let _source2: Observable<E2>
  194|       |    let _source3: Observable<E3>
  195|       |
  196|       |    let _resultSelector: ResultSelector
  197|       |
  198|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, resultSelector: @escaping ResultSelector) {
  199|      0|        _source1 = source1
  200|      0|        _source2 = source2
  201|      0|        _source3 = source3
  202|      0|
  203|      0|        _resultSelector = resultSelector
  204|      0|    }
  205|       |
  206|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  207|      0|        let sink = CombineLatestSink3_(parent: self, observer: observer, cancel: cancel)
  208|      0|        let subscription = sink.run()
  209|      0|        return (sink: sink, subscription: subscription)
  210|      0|    }
  211|       |}
  212|       |
  213|       |
  214|       |
  215|       |// 4
  216|       |
  217|       |extension Observable {
  218|       |    /**
  219|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  220|       |
  221|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  222|       |
  223|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  224|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  225|       |    */
  226|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  227|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  228|      0|            -> Observable<E> {
  229|      0|        return CombineLatest4(
  230|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  231|      0|            resultSelector: resultSelector
  232|      0|        )
  233|      0|    }
  234|       |}
  235|       |
  236|       |extension ObservableType where E == Any {
  237|       |    /**
  238|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  239|       |
  240|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  241|       |
  242|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  243|       |    */
  244|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  245|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
  246|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E)> {
  247|      0|        return CombineLatest4(
  248|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  249|      0|            resultSelector: { ($0, $1, $2, $3) }
  250|      0|        )
  251|      0|    }
  252|       |}
  253|       |
  254|       |final class CombineLatestSink4_<E1, E2, E3, E4, O: ObserverType> : CombineLatestSink<O> {
  255|       |    typealias R = O.E
  256|       |    typealias Parent = CombineLatest4<E1, E2, E3, E4, R>
  257|       |
  258|       |    let _parent: Parent
  259|       |
  260|       |    var _latestElement1: E1! = nil
  261|       |    var _latestElement2: E2! = nil
  262|       |    var _latestElement3: E3! = nil
  263|       |    var _latestElement4: E4! = nil
  264|       |
  265|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  266|      0|        _parent = parent
  267|      0|        super.init(arity: 4, observer: observer, cancel: cancel)
  268|      0|    }
  269|       |
  270|      0|    func run() -> Disposable {
  271|      0|        let subscription1 = SingleAssignmentDisposable()
  272|      0|        let subscription2 = SingleAssignmentDisposable()
  273|      0|        let subscription3 = SingleAssignmentDisposable()
  274|      0|        let subscription4 = SingleAssignmentDisposable()
  275|      0|
  276|      0|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  277|      0|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  278|      0|        let observer3 = CombineLatestObserver(lock: _lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  279|      0|        let observer4 = CombineLatestObserver(lock: _lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  280|      0|
  281|      0|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
  282|      0|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
  283|      0|         subscription3.setDisposable(_parent._source3.subscribe(observer3))
  284|      0|         subscription4.setDisposable(_parent._source4.subscribe(observer4))
  285|      0|
  286|      0|        return Disposables.create([
  287|      0|                subscription1,
  288|      0|                subscription2,
  289|      0|                subscription3,
  290|      0|                subscription4
  291|      0|        ])
  292|      0|    }
  293|       |
  294|      0|    override func getResult() throws -> R {
  295|      0|        return try _parent._resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4)
  296|      0|    }
  297|       |}
  298|       |
  299|       |final class CombineLatest4<E1, E2, E3, E4, R> : Producer<R> {
  300|       |    typealias ResultSelector = (E1, E2, E3, E4) throws -> R
  301|       |
  302|       |    let _source1: Observable<E1>
  303|       |    let _source2: Observable<E2>
  304|       |    let _source3: Observable<E3>
  305|       |    let _source4: Observable<E4>
  306|       |
  307|       |    let _resultSelector: ResultSelector
  308|       |
  309|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, resultSelector: @escaping ResultSelector) {
  310|      0|        _source1 = source1
  311|      0|        _source2 = source2
  312|      0|        _source3 = source3
  313|      0|        _source4 = source4
  314|      0|
  315|      0|        _resultSelector = resultSelector
  316|      0|    }
  317|       |
  318|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  319|      0|        let sink = CombineLatestSink4_(parent: self, observer: observer, cancel: cancel)
  320|      0|        let subscription = sink.run()
  321|      0|        return (sink: sink, subscription: subscription)
  322|      0|    }
  323|       |}
  324|       |
  325|       |
  326|       |
  327|       |// 5
  328|       |
  329|       |extension Observable {
  330|       |    /**
  331|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  332|       |
  333|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  334|       |
  335|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  336|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  337|       |    */
  338|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  339|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  340|      0|            -> Observable<E> {
  341|      0|        return CombineLatest5(
  342|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  343|      0|            resultSelector: resultSelector
  344|      0|        )
  345|      0|    }
  346|       |}
  347|       |
  348|       |extension ObservableType where E == Any {
  349|       |    /**
  350|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  351|       |
  352|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  353|       |
  354|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  355|       |    */
  356|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  357|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
  358|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E)> {
  359|      0|        return CombineLatest5(
  360|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  361|      0|            resultSelector: { ($0, $1, $2, $3, $4) }
  362|      0|        )
  363|      0|    }
  364|       |}
  365|       |
  366|       |final class CombineLatestSink5_<E1, E2, E3, E4, E5, O: ObserverType> : CombineLatestSink<O> {
  367|       |    typealias R = O.E
  368|       |    typealias Parent = CombineLatest5<E1, E2, E3, E4, E5, R>
  369|       |
  370|       |    let _parent: Parent
  371|       |
  372|       |    var _latestElement1: E1! = nil
  373|       |    var _latestElement2: E2! = nil
  374|       |    var _latestElement3: E3! = nil
  375|       |    var _latestElement4: E4! = nil
  376|       |    var _latestElement5: E5! = nil
  377|       |
  378|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  379|      0|        _parent = parent
  380|      0|        super.init(arity: 5, observer: observer, cancel: cancel)
  381|      0|    }
  382|       |
  383|      0|    func run() -> Disposable {
  384|      0|        let subscription1 = SingleAssignmentDisposable()
  385|      0|        let subscription2 = SingleAssignmentDisposable()
  386|      0|        let subscription3 = SingleAssignmentDisposable()
  387|      0|        let subscription4 = SingleAssignmentDisposable()
  388|      0|        let subscription5 = SingleAssignmentDisposable()
  389|      0|
  390|      0|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  391|      0|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  392|      0|        let observer3 = CombineLatestObserver(lock: _lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  393|      0|        let observer4 = CombineLatestObserver(lock: _lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  394|      0|        let observer5 = CombineLatestObserver(lock: _lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  395|      0|
  396|      0|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
  397|      0|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
  398|      0|         subscription3.setDisposable(_parent._source3.subscribe(observer3))
  399|      0|         subscription4.setDisposable(_parent._source4.subscribe(observer4))
  400|      0|         subscription5.setDisposable(_parent._source5.subscribe(observer5))
  401|      0|
  402|      0|        return Disposables.create([
  403|      0|                subscription1,
  404|      0|                subscription2,
  405|      0|                subscription3,
  406|      0|                subscription4,
  407|      0|                subscription5
  408|      0|        ])
  409|      0|    }
  410|       |
  411|      0|    override func getResult() throws -> R {
  412|      0|        return try _parent._resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5)
  413|      0|    }
  414|       |}
  415|       |
  416|       |final class CombineLatest5<E1, E2, E3, E4, E5, R> : Producer<R> {
  417|       |    typealias ResultSelector = (E1, E2, E3, E4, E5) throws -> R
  418|       |
  419|       |    let _source1: Observable<E1>
  420|       |    let _source2: Observable<E2>
  421|       |    let _source3: Observable<E3>
  422|       |    let _source4: Observable<E4>
  423|       |    let _source5: Observable<E5>
  424|       |
  425|       |    let _resultSelector: ResultSelector
  426|       |
  427|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, resultSelector: @escaping ResultSelector) {
  428|      0|        _source1 = source1
  429|      0|        _source2 = source2
  430|      0|        _source3 = source3
  431|      0|        _source4 = source4
  432|      0|        _source5 = source5
  433|      0|
  434|      0|        _resultSelector = resultSelector
  435|      0|    }
  436|       |
  437|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  438|      0|        let sink = CombineLatestSink5_(parent: self, observer: observer, cancel: cancel)
  439|      0|        let subscription = sink.run()
  440|      0|        return (sink: sink, subscription: subscription)
  441|      0|    }
  442|       |}
  443|       |
  444|       |
  445|       |
  446|       |// 6
  447|       |
  448|       |extension Observable {
  449|       |    /**
  450|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  451|       |
  452|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  453|       |
  454|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  455|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  456|       |    */
  457|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  458|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  459|      0|            -> Observable<E> {
  460|      0|        return CombineLatest6(
  461|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  462|      0|            resultSelector: resultSelector
  463|      0|        )
  464|      0|    }
  465|       |}
  466|       |
  467|       |extension ObservableType where E == Any {
  468|       |    /**
  469|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  470|       |
  471|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  472|       |
  473|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  474|       |    */
  475|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  476|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
  477|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> {
  478|      0|        return CombineLatest6(
  479|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  480|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5) }
  481|      0|        )
  482|      0|    }
  483|       |}
  484|       |
  485|       |final class CombineLatestSink6_<E1, E2, E3, E4, E5, E6, O: ObserverType> : CombineLatestSink<O> {
  486|       |    typealias R = O.E
  487|       |    typealias Parent = CombineLatest6<E1, E2, E3, E4, E5, E6, R>
  488|       |
  489|       |    let _parent: Parent
  490|       |
  491|       |    var _latestElement1: E1! = nil
  492|       |    var _latestElement2: E2! = nil
  493|       |    var _latestElement3: E3! = nil
  494|       |    var _latestElement4: E4! = nil
  495|       |    var _latestElement5: E5! = nil
  496|       |    var _latestElement6: E6! = nil
  497|       |
  498|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  499|      0|        _parent = parent
  500|      0|        super.init(arity: 6, observer: observer, cancel: cancel)
  501|      0|    }
  502|       |
  503|      0|    func run() -> Disposable {
  504|      0|        let subscription1 = SingleAssignmentDisposable()
  505|      0|        let subscription2 = SingleAssignmentDisposable()
  506|      0|        let subscription3 = SingleAssignmentDisposable()
  507|      0|        let subscription4 = SingleAssignmentDisposable()
  508|      0|        let subscription5 = SingleAssignmentDisposable()
  509|      0|        let subscription6 = SingleAssignmentDisposable()
  510|      0|
  511|      0|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  512|      0|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  513|      0|        let observer3 = CombineLatestObserver(lock: _lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  514|      0|        let observer4 = CombineLatestObserver(lock: _lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  515|      0|        let observer5 = CombineLatestObserver(lock: _lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  516|      0|        let observer6 = CombineLatestObserver(lock: _lock, parent: self, index: 5, setLatestValue: { (e: E6) -> Void in self._latestElement6 = e }, this: subscription6)
  517|      0|
  518|      0|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
  519|      0|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
  520|      0|         subscription3.setDisposable(_parent._source3.subscribe(observer3))
  521|      0|         subscription4.setDisposable(_parent._source4.subscribe(observer4))
  522|      0|         subscription5.setDisposable(_parent._source5.subscribe(observer5))
  523|      0|         subscription6.setDisposable(_parent._source6.subscribe(observer6))
  524|      0|
  525|      0|        return Disposables.create([
  526|      0|                subscription1,
  527|      0|                subscription2,
  528|      0|                subscription3,
  529|      0|                subscription4,
  530|      0|                subscription5,
  531|      0|                subscription6
  532|      0|        ])
  533|      0|    }
  534|       |
  535|      0|    override func getResult() throws -> R {
  536|      0|        return try _parent._resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5, _latestElement6)
  537|      0|    }
  538|       |}
  539|       |
  540|       |final class CombineLatest6<E1, E2, E3, E4, E5, E6, R> : Producer<R> {
  541|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6) throws -> R
  542|       |
  543|       |    let _source1: Observable<E1>
  544|       |    let _source2: Observable<E2>
  545|       |    let _source3: Observable<E3>
  546|       |    let _source4: Observable<E4>
  547|       |    let _source5: Observable<E5>
  548|       |    let _source6: Observable<E6>
  549|       |
  550|       |    let _resultSelector: ResultSelector
  551|       |
  552|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, resultSelector: @escaping ResultSelector) {
  553|      0|        _source1 = source1
  554|      0|        _source2 = source2
  555|      0|        _source3 = source3
  556|      0|        _source4 = source4
  557|      0|        _source5 = source5
  558|      0|        _source6 = source6
  559|      0|
  560|      0|        _resultSelector = resultSelector
  561|      0|    }
  562|       |
  563|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  564|      0|        let sink = CombineLatestSink6_(parent: self, observer: observer, cancel: cancel)
  565|      0|        let subscription = sink.run()
  566|      0|        return (sink: sink, subscription: subscription)
  567|      0|    }
  568|       |}
  569|       |
  570|       |
  571|       |
  572|       |// 7
  573|       |
  574|       |extension Observable {
  575|       |    /**
  576|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  577|       |
  578|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  579|       |
  580|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  581|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  582|       |    */
  583|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  584|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  585|      0|            -> Observable<E> {
  586|      0|        return CombineLatest7(
  587|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  588|      0|            resultSelector: resultSelector
  589|      0|        )
  590|      0|    }
  591|       |}
  592|       |
  593|       |extension ObservableType where E == Any {
  594|       |    /**
  595|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  596|       |
  597|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  598|       |
  599|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  600|       |    */
  601|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  602|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
  603|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> {
  604|      0|        return CombineLatest7(
  605|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  606|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
  607|      0|        )
  608|      0|    }
  609|       |}
  610|       |
  611|       |final class CombineLatestSink7_<E1, E2, E3, E4, E5, E6, E7, O: ObserverType> : CombineLatestSink<O> {
  612|       |    typealias R = O.E
  613|       |    typealias Parent = CombineLatest7<E1, E2, E3, E4, E5, E6, E7, R>
  614|       |
  615|       |    let _parent: Parent
  616|       |
  617|       |    var _latestElement1: E1! = nil
  618|       |    var _latestElement2: E2! = nil
  619|       |    var _latestElement3: E3! = nil
  620|       |    var _latestElement4: E4! = nil
  621|       |    var _latestElement5: E5! = nil
  622|       |    var _latestElement6: E6! = nil
  623|       |    var _latestElement7: E7! = nil
  624|       |
  625|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  626|      0|        _parent = parent
  627|      0|        super.init(arity: 7, observer: observer, cancel: cancel)
  628|      0|    }
  629|       |
  630|      0|    func run() -> Disposable {
  631|      0|        let subscription1 = SingleAssignmentDisposable()
  632|      0|        let subscription2 = SingleAssignmentDisposable()
  633|      0|        let subscription3 = SingleAssignmentDisposable()
  634|      0|        let subscription4 = SingleAssignmentDisposable()
  635|      0|        let subscription5 = SingleAssignmentDisposable()
  636|      0|        let subscription6 = SingleAssignmentDisposable()
  637|      0|        let subscription7 = SingleAssignmentDisposable()
  638|      0|
  639|      0|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  640|      0|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  641|      0|        let observer3 = CombineLatestObserver(lock: _lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  642|      0|        let observer4 = CombineLatestObserver(lock: _lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  643|      0|        let observer5 = CombineLatestObserver(lock: _lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  644|      0|        let observer6 = CombineLatestObserver(lock: _lock, parent: self, index: 5, setLatestValue: { (e: E6) -> Void in self._latestElement6 = e }, this: subscription6)
  645|      0|        let observer7 = CombineLatestObserver(lock: _lock, parent: self, index: 6, setLatestValue: { (e: E7) -> Void in self._latestElement7 = e }, this: subscription7)
  646|      0|
  647|      0|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
  648|      0|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
  649|      0|         subscription3.setDisposable(_parent._source3.subscribe(observer3))
  650|      0|         subscription4.setDisposable(_parent._source4.subscribe(observer4))
  651|      0|         subscription5.setDisposable(_parent._source5.subscribe(observer5))
  652|      0|         subscription6.setDisposable(_parent._source6.subscribe(observer6))
  653|      0|         subscription7.setDisposable(_parent._source7.subscribe(observer7))
  654|      0|
  655|      0|        return Disposables.create([
  656|      0|                subscription1,
  657|      0|                subscription2,
  658|      0|                subscription3,
  659|      0|                subscription4,
  660|      0|                subscription5,
  661|      0|                subscription6,
  662|      0|                subscription7
  663|      0|        ])
  664|      0|    }
  665|       |
  666|      0|    override func getResult() throws -> R {
  667|      0|        return try _parent._resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5, _latestElement6, _latestElement7)
  668|      0|    }
  669|       |}
  670|       |
  671|       |final class CombineLatest7<E1, E2, E3, E4, E5, E6, E7, R> : Producer<R> {
  672|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7) throws -> R
  673|       |
  674|       |    let _source1: Observable<E1>
  675|       |    let _source2: Observable<E2>
  676|       |    let _source3: Observable<E3>
  677|       |    let _source4: Observable<E4>
  678|       |    let _source5: Observable<E5>
  679|       |    let _source6: Observable<E6>
  680|       |    let _source7: Observable<E7>
  681|       |
  682|       |    let _resultSelector: ResultSelector
  683|       |
  684|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, resultSelector: @escaping ResultSelector) {
  685|      0|        _source1 = source1
  686|      0|        _source2 = source2
  687|      0|        _source3 = source3
  688|      0|        _source4 = source4
  689|      0|        _source5 = source5
  690|      0|        _source6 = source6
  691|      0|        _source7 = source7
  692|      0|
  693|      0|        _resultSelector = resultSelector
  694|      0|    }
  695|       |
  696|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  697|      0|        let sink = CombineLatestSink7_(parent: self, observer: observer, cancel: cancel)
  698|      0|        let subscription = sink.run()
  699|      0|        return (sink: sink, subscription: subscription)
  700|      0|    }
  701|       |}
  702|       |
  703|       |
  704|       |
  705|       |// 8
  706|       |
  707|       |extension Observable {
  708|       |    /**
  709|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  710|       |
  711|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  712|       |
  713|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  714|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  715|       |    */
  716|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  717|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  718|      0|            -> Observable<E> {
  719|      0|        return CombineLatest8(
  720|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  721|      0|            resultSelector: resultSelector
  722|      0|        )
  723|      0|    }
  724|       |}
  725|       |
  726|       |extension ObservableType where E == Any {
  727|       |    /**
  728|       |    Merges the specified observable sequences into one observable sequence of tuples whenever any of the observable sequences produces an element.
  729|       |
  730|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  731|       |
  732|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  733|       |    */
  734|       |    public static func combineLatest<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  735|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
  736|      0|            -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> {
  737|      0|        return CombineLatest8(
  738|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  739|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
  740|      0|        )
  741|      0|    }
  742|       |}
  743|       |
  744|       |final class CombineLatestSink8_<E1, E2, E3, E4, E5, E6, E7, E8, O: ObserverType> : CombineLatestSink<O> {
  745|       |    typealias R = O.E
  746|       |    typealias Parent = CombineLatest8<E1, E2, E3, E4, E5, E6, E7, E8, R>
  747|       |
  748|       |    let _parent: Parent
  749|       |
  750|       |    var _latestElement1: E1! = nil
  751|       |    var _latestElement2: E2! = nil
  752|       |    var _latestElement3: E3! = nil
  753|       |    var _latestElement4: E4! = nil
  754|       |    var _latestElement5: E5! = nil
  755|       |    var _latestElement6: E6! = nil
  756|       |    var _latestElement7: E7! = nil
  757|       |    var _latestElement8: E8! = nil
  758|       |
  759|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  760|      0|        _parent = parent
  761|      0|        super.init(arity: 8, observer: observer, cancel: cancel)
  762|      0|    }
  763|       |
  764|      0|    func run() -> Disposable {
  765|      0|        let subscription1 = SingleAssignmentDisposable()
  766|      0|        let subscription2 = SingleAssignmentDisposable()
  767|      0|        let subscription3 = SingleAssignmentDisposable()
  768|      0|        let subscription4 = SingleAssignmentDisposable()
  769|      0|        let subscription5 = SingleAssignmentDisposable()
  770|      0|        let subscription6 = SingleAssignmentDisposable()
  771|      0|        let subscription7 = SingleAssignmentDisposable()
  772|      0|        let subscription8 = SingleAssignmentDisposable()
  773|      0|
  774|      0|        let observer1 = CombineLatestObserver(lock: _lock, parent: self, index: 0, setLatestValue: { (e: E1) -> Void in self._latestElement1 = e }, this: subscription1)
  775|      0|        let observer2 = CombineLatestObserver(lock: _lock, parent: self, index: 1, setLatestValue: { (e: E2) -> Void in self._latestElement2 = e }, this: subscription2)
  776|      0|        let observer3 = CombineLatestObserver(lock: _lock, parent: self, index: 2, setLatestValue: { (e: E3) -> Void in self._latestElement3 = e }, this: subscription3)
  777|      0|        let observer4 = CombineLatestObserver(lock: _lock, parent: self, index: 3, setLatestValue: { (e: E4) -> Void in self._latestElement4 = e }, this: subscription4)
  778|      0|        let observer5 = CombineLatestObserver(lock: _lock, parent: self, index: 4, setLatestValue: { (e: E5) -> Void in self._latestElement5 = e }, this: subscription5)
  779|      0|        let observer6 = CombineLatestObserver(lock: _lock, parent: self, index: 5, setLatestValue: { (e: E6) -> Void in self._latestElement6 = e }, this: subscription6)
  780|      0|        let observer7 = CombineLatestObserver(lock: _lock, parent: self, index: 6, setLatestValue: { (e: E7) -> Void in self._latestElement7 = e }, this: subscription7)
  781|      0|        let observer8 = CombineLatestObserver(lock: _lock, parent: self, index: 7, setLatestValue: { (e: E8) -> Void in self._latestElement8 = e }, this: subscription8)
  782|      0|
  783|      0|         subscription1.setDisposable(_parent._source1.subscribe(observer1))
  784|      0|         subscription2.setDisposable(_parent._source2.subscribe(observer2))
  785|      0|         subscription3.setDisposable(_parent._source3.subscribe(observer3))
  786|      0|         subscription4.setDisposable(_parent._source4.subscribe(observer4))
  787|      0|         subscription5.setDisposable(_parent._source5.subscribe(observer5))
  788|      0|         subscription6.setDisposable(_parent._source6.subscribe(observer6))
  789|      0|         subscription7.setDisposable(_parent._source7.subscribe(observer7))
  790|      0|         subscription8.setDisposable(_parent._source8.subscribe(observer8))
  791|      0|
  792|      0|        return Disposables.create([
  793|      0|                subscription1,
  794|      0|                subscription2,
  795|      0|                subscription3,
  796|      0|                subscription4,
  797|      0|                subscription5,
  798|      0|                subscription6,
  799|      0|                subscription7,
  800|      0|                subscription8
  801|      0|        ])
  802|      0|    }
  803|       |
  804|      0|    override func getResult() throws -> R {
  805|      0|        return try _parent._resultSelector(_latestElement1, _latestElement2, _latestElement3, _latestElement4, _latestElement5, _latestElement6, _latestElement7, _latestElement8)
  806|      0|    }
  807|       |}
  808|       |
  809|       |final class CombineLatest8<E1, E2, E3, E4, E5, E6, E7, E8, R> : Producer<R> {
  810|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7, E8) throws -> R
  811|       |
  812|       |    let _source1: Observable<E1>
  813|       |    let _source2: Observable<E2>
  814|       |    let _source3: Observable<E3>
  815|       |    let _source4: Observable<E4>
  816|       |    let _source5: Observable<E5>
  817|       |    let _source6: Observable<E6>
  818|       |    let _source7: Observable<E7>
  819|       |    let _source8: Observable<E8>
  820|       |
  821|       |    let _resultSelector: ResultSelector
  822|       |
  823|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, source8: Observable<E8>, resultSelector: @escaping ResultSelector) {
  824|      0|        _source1 = source1
  825|      0|        _source2 = source2
  826|      0|        _source3 = source3
  827|      0|        _source4 = source4
  828|      0|        _source5 = source5
  829|      0|        _source6 = source6
  830|      0|        _source7 = source7
  831|      0|        _source8 = source8
  832|      0|
  833|      0|        _resultSelector = resultSelector
  834|      0|    }
  835|       |
  836|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  837|      0|        let sink = CombineLatestSink8_(parent: self, observer: observer, cancel: cancel)
  838|      0|        let subscription = sink.run()
  839|      0|        return (sink: sink, subscription: subscription)
  840|      0|    }
  841|       |}
  842|       |
  843|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/CombineLatest.swift:
    1|       |//
    2|       |//  CombineLatest.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol CombineLatestProtocol : class {
   10|       |    func next(_ index: Int)
   11|       |    func fail(_ error: Swift.Error)
   12|       |    func done(_ index: Int)
   13|       |}
   14|       |
   15|       |class CombineLatestSink<O: ObserverType>
   16|       |    : Sink<O>
   17|       |    , CombineLatestProtocol {
   18|       |    typealias Element = O.E
   19|       |   
   20|       |    let _lock = RecursiveLock()
   21|       |
   22|       |    private let _arity: Int
   23|       |    private var _numberOfValues = 0
   24|       |    private var _numberOfDone = 0
   25|       |    private var _hasValue: [Bool]
   26|       |    private var _isDone: [Bool]
   27|       |   
   28|      6|    init(arity: Int, observer: O, cancel: Cancelable) {
   29|      6|        _arity = arity
   30|      6|        _hasValue = [Bool](repeating: false, count: arity)
   31|      6|        _isDone = [Bool](repeating: false, count: arity)
   32|      6|        
   33|      6|        super.init(observer: observer, cancel: cancel)
   34|      6|    }
   35|       |    
   36|      0|    func getResult() throws -> Element {
   37|      0|        rxAbstractMethod()
   38|      0|    }
   39|       |    
   40|     12|    func next(_ index: Int) {
   41|     12|        if !_hasValue[index] {
   42|     12|            _hasValue[index] = true
   43|     12|            _numberOfValues += 1
   44|     12|        }
   45|     12|
   46|      6|        if _numberOfValues == _arity {
   47|      6|            do {
   48|      6|                let result = try getResult()
   49|      6|                forwardOn(.next(result))
   50|      6|            }
   51|      0|            catch let e {
   52|      0|                forwardOn(.error(e))
   53|      0|                dispose()
   54|      6|            }
   55|     12|        }
   56|      6|        else {
   57|      6|            var allOthersDone = true
   58|      6|
   59|     12|            for i in 0 ..< _arity {
   60|      6|                if i != index && !_isDone[i] {
   61|      6|                    allOthersDone = false
   62|      6|                    break
   63|      6|                }
   64|      6|            }
   65|      6|            
   66|      0|            if allOthersDone {
   67|      0|                forwardOn(.completed)
   68|      0|                dispose()
   69|      6|            }
   70|     12|        }
   71|     12|    }
   72|       |    
   73|      0|    func fail(_ error: Swift.Error) {
   74|      0|        forwardOn(.error(error))
   75|      0|        dispose()
   76|      0|    }
   77|       |    
   78|      0|    func done(_ index: Int) {
   79|      0|        if _isDone[index] {
   80|      0|            return
   81|      0|        }
   82|      0|
   83|      0|        _isDone[index] = true
   84|      0|        _numberOfDone += 1
   85|      0|
   86|      0|        if _numberOfDone == _arity {
   87|      0|            forwardOn(.completed)
   88|      0|            dispose()
   89|      0|        }
   90|      0|    }
   91|       |}
   92|       |
   93|       |final class CombineLatestObserver<ElementType>
   94|       |    : ObserverType
   95|       |    , LockOwnerType
   96|       |    , SynchronizedOnType {
   97|       |    typealias Element = ElementType
   98|       |    typealias ValueSetter = (Element) -> Void
   99|       |    
  100|       |    private let _parent: CombineLatestProtocol
  101|       |    
  102|       |    let _lock: RecursiveLock
  103|       |    private let _index: Int
  104|       |    private let _this: Disposable
  105|       |    private let _setLatestValue: ValueSetter
  106|       |    
  107|     12|    init(lock: RecursiveLock, parent: CombineLatestProtocol, index: Int, setLatestValue: @escaping ValueSetter, this: Disposable) {
  108|     12|        _lock = lock
  109|     12|        _parent = parent
  110|     12|        _index = index
  111|     12|        _this = this
  112|     12|        _setLatestValue = setLatestValue
  113|     12|    }
  114|       |    
  115|     12|    func on(_ event: Event<Element>) {
  116|     12|        synchronizedOn(event)
  117|     12|    }
  118|       |
  119|     12|    func _synchronized_on(_ event: Event<Element>) {
  120|     12|        switch event {
  121|     12|        case .next(let value):
  122|     12|            _setLatestValue(value)
  123|     12|            _parent.next(_index)
  124|      0|        case .error(let error):
  125|      0|            _this.dispose()
  126|      0|            _parent.fail(error)
  127|      0|        case .completed:
  128|      0|            _this.dispose()
  129|      0|            _parent.done(_index)
  130|     12|        }
  131|     12|    }
  132|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Concat.swift:
    1|       |//
    2|       |//  Concat.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |final class ConcatSink<S: Sequence, O: ObserverType>
   11|       |    : TailRecursiveSink<S, O>
   12|       |    , ObserverType where S.Iterator.Element : ObservableConvertibleType, S.Iterator.Element.E == O.E {
   13|       |    typealias Element = O.E
   14|       |    
   15|      4|    override init(observer: O, cancel: Cancelable) {
   16|      4|        super.init(observer: observer, cancel: cancel)
   17|      4|    }
   18|       |    
   19|     37|    func on(_ event: Event<Element>){
   20|     37|        switch event {
   21|     37|        case .next:
   22|     37|            forwardOn(event)
   23|      0|        case .error:
   24|      0|            forwardOn(event)
   25|      0|            dispose()
   26|      0|        case .completed:
   27|      0|            schedule(.moveNext)
   28|     37|        }
   29|     37|    }
   30|       |
   31|      4|    override func subscribeToNext(_ source: Observable<E>) -> Disposable {
   32|      4|        return source.subscribe(self)
   33|      4|    }
   34|       |    
   35|      4|    override func extract(_ observable: Observable<E>) -> SequenceGenerator? {
   36|      0|        if let source = observable as? Concat<S> {
   37|      0|            return (source._sources.makeIterator(), source._count)
   38|      4|        }
   39|      4|        else {
   40|      4|            return nil
   41|      0|        }
   42|      0|    }
   43|       |}
   44|       |
   45|       |final class Concat<S: Sequence> : Producer<S.Iterator.Element.E> where S.Iterator.Element : ObservableConvertibleType {
   46|       |    typealias Element = S.Iterator.Element.E
   47|       |    
   48|       |    fileprivate let _sources: S
   49|       |    fileprivate let _count: IntMax?
   50|       |
   51|      4|    init(sources: S, count: IntMax?) {
   52|      4|        _sources = sources
   53|      4|        _count = count
   54|      4|    }
   55|       |    
   56|      4|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   57|      4|        let sink = ConcatSink<S, O>(observer: observer, cancel: cancel)
   58|      4|        let subscription = sink.run((_sources.makeIterator(), _count))
   59|      4|        return (sink: sink, subscription: subscription)
   60|      4|    }
   61|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ConnectableObservable.swift:
    1|       |//
    2|       |//  ConnectableObservable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       | Represents an observable wrapper that can be connected and disconnected from its underlying observable sequence.
   11|       |*/
   12|       |public class ConnectableObservable<Element>
   13|       |    : Observable<Element>
   14|       |    , ConnectableObservableType {
   15|       |
   16|       |    /**
   17|       |     Connects the observable wrapper to its source. All subscribed observers will receive values from the underlying observable sequence as long as the connection is established.
   18|       |     
   19|       |     - returns: Disposable used to disconnect the observable wrapper from its source, causing subscribed observer to stop receiving values from the underlying observable sequence.
   20|       |    */
   21|      0|    public func connect() -> Disposable {
   22|      0|        rxAbstractMethod()
   23|      0|    }
   24|       |}
   25|       |
   26|       |final class Connection<S: SubjectType> : ObserverType, Disposable {
   27|       |    typealias E = S.SubjectObserverType.E
   28|       |
   29|       |    private var _lock: RecursiveLock
   30|       |    // state
   31|       |    private var _parent: ConnectableObservableAdapter<S>?
   32|       |    private var _subscription : Disposable?
   33|       |    private var _subjectObserver: S.SubjectObserverType
   34|       |
   35|       |    private var _disposed: Bool = false
   36|       |
   37|     42|    init(parent: ConnectableObservableAdapter<S>, subjectObserver: S.SubjectObserverType, lock: RecursiveLock, subscription: Disposable) {
   38|     42|        _parent = parent
   39|     42|        _subscription = subscription
   40|     42|        _lock = lock
   41|     42|        _subjectObserver = subjectObserver
   42|     42|    }
   43|       |
   44|      0|    func on(_ event: Event<S.SubjectObserverType.E>) {
   45|      0|        if _disposed {
   46|      0|            return
   47|      0|        }
   48|      0|        _subjectObserver.on(event)
   49|      0|        if event.isStopEvent {
   50|      0|            self.dispose()
   51|      0|        }
   52|      0|    }
   53|       |    
   54|      0|    func dispose() {
   55|      0|        _lock.lock(); defer { _lock.unlock() } // {
   56|      0|            _disposed = true
   57|      0|            guard let parent = _parent else {
   58|      0|                return
   59|      0|            }
   60|      0|        
   61|      0|            if parent._connection === self {
   62|      0|                parent._connection = nil
   63|      0|            }
   64|      0|            _parent = nil
   65|      0|
   66|      0|            _subscription?.dispose()
   67|      0|            _subscription = nil
   68|      0|        // }
   69|      0|    }
   70|       |}
   71|       |
   72|       |final class ConnectableObservableAdapter<S: SubjectType>
   73|       |    : ConnectableObservable<S.E> {
   74|       |    typealias ConnectionType = Connection<S>
   75|       |    
   76|       |    fileprivate let _subject: S
   77|       |    fileprivate let _source: Observable<S.SubjectObserverType.E>
   78|       |    
   79|       |    fileprivate let _lock = RecursiveLock()
   80|       |    
   81|       |    // state
   82|       |    fileprivate var _connection: ConnectionType?
   83|       |    
   84|     42|    init(source: Observable<S.SubjectObserverType.E>, subject: S) {
   85|     42|        _source = source
   86|     42|        _subject = subject
   87|     42|        _connection = nil
   88|     42|    }
   89|       |    
   90|     42|    override func connect() -> Disposable {
   91|     42|        return _lock.calculateLocked {
   92|      0|            if let connection = _connection {
   93|      0|                return connection
   94|     42|            }
   95|     42|
   96|     42|            let singleAssignmentDisposable = SingleAssignmentDisposable()
   97|     42|            let connection = Connection(parent: self, subjectObserver: _subject.asObserver(), lock: _lock, subscription: singleAssignmentDisposable)
   98|     42|            _connection = connection
   99|     42|            let subscription = _source.subscribe(connection)
  100|     42|            singleAssignmentDisposable.setDisposable(subscription)
  101|     42|            return connection
  102|     42|        }
  103|     42|    }
  104|       |    
  105|     42|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == S.E {
  106|     42|        return _subject.subscribe(observer)
  107|     42|    }
  108|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Debounce.swift:
    1|       |//
    2|       |//  Debounce.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/11/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class DebounceSink<O: ObserverType>
   10|       |    : Sink<O>
   11|       |    , ObserverType
   12|       |    , LockOwnerType
   13|       |    , SynchronizedOnType {
   14|       |    typealias Element = O.E
   15|       |    typealias ParentType = Debounce<Element>
   16|       |
   17|       |    private let _parent: ParentType
   18|       |
   19|       |    let _lock = RecursiveLock()
   20|       |
   21|       |    // state
   22|       |    private var _id = 0 as UInt64
   23|       |    private var _value: Element? = nil
   24|       |
   25|       |    let cancellable = SerialDisposable()
   26|       |
   27|      0|    init(parent: ParentType, observer: O, cancel: Cancelable) {
   28|      0|        _parent = parent
   29|      0|
   30|      0|        super.init(observer: observer, cancel: cancel)
   31|      0|    }
   32|       |
   33|      0|    func run() -> Disposable {
   34|      0|        let subscription = _parent._source.subscribe(self)
   35|      0|
   36|      0|        return Disposables.create(subscription, cancellable)
   37|      0|    }
   38|       |
   39|      0|    func on(_ event: Event<Element>) {
   40|      0|        synchronizedOn(event)
   41|      0|    }
   42|       |
   43|      0|    func _synchronized_on(_ event: Event<Element>) {
   44|      0|        switch event {
   45|      0|        case .next(let element):
   46|      0|            _id = _id &+ 1
   47|      0|            let currentId = _id
   48|      0|            _value = element
   49|      0|
   50|      0|
   51|      0|            let scheduler = _parent._scheduler
   52|      0|            let dueTime = _parent._dueTime
   53|      0|
   54|      0|            let d = SingleAssignmentDisposable()
   55|      0|            self.cancellable.disposable = d
   56|      0|            d.setDisposable(scheduler.scheduleRelative(currentId, dueTime: dueTime, action: self.propagate))
   57|      0|        case .error:
   58|      0|            _value = nil
   59|      0|            forwardOn(event)
   60|      0|            dispose()
   61|      0|        case .completed:
   62|      0|            if let value = _value {
   63|      0|                _value = nil
   64|      0|                forwardOn(.next(value))
   65|      0|            }
   66|      0|            forwardOn(.completed)
   67|      0|            dispose()
   68|      0|        }
   69|      0|    }
   70|       |
   71|      0|    func propagate(_ currentId: UInt64) -> Disposable {
   72|      0|        _lock.lock(); defer { _lock.unlock() } // {
   73|      0|        let originalValue = _value
   74|      0|
   75|      0|        if let value = originalValue, _id == currentId {
   76|      0|            _value = nil
   77|      0|            forwardOn(.next(value))
   78|      0|        }
   79|      0|        // }
   80|      0|        return Disposables.create()
   81|      0|    }
   82|       |}
   83|       |
   84|       |final class Debounce<Element> : Producer<Element> {
   85|       |
   86|       |    fileprivate let _source: Observable<Element>
   87|       |    fileprivate let _dueTime: RxTimeInterval
   88|       |    fileprivate let _scheduler: SchedulerType
   89|       |
   90|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, scheduler: SchedulerType) {
   91|      0|        _source = source
   92|      0|        _dueTime = dueTime
   93|      0|        _scheduler = scheduler
   94|      0|    }
   95|       |
   96|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   97|      0|        let sink = DebounceSink(parent: self, observer: observer, cancel: cancel)
   98|      0|        let subscription = sink.run()
   99|      0|        return (sink: sink, subscription: subscription)
  100|      0|    }
  101|       |    
  102|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Debug.swift:
    1|       |//
    2|       |//  Debug.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import class Foundation.DateFormatter
   11|       |
   12|       |let dateFormat = "yyyy-MM-dd HH:mm:ss.SSS"
   13|       |
   14|      0|func logEvent(_ identifier: String, dateFormat: DateFormatter, content: String) {
   15|      0|    print("\(dateFormat.string(from: Date())): \(identifier) -> \(content)")
   16|      0|}
   17|       |
   18|       |final class DebugSink<Source: ObservableType, O: ObserverType> : Sink<O>, ObserverType where O.E == Source.E {
   19|       |    typealias Element = O.E
   20|       |    typealias Parent = Debug<Source>
   21|       |    
   22|       |    private let _parent: Parent
   23|       |    private let _timestampFormatter = DateFormatter()
   24|       |    
   25|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   26|      0|        _parent = parent
   27|      0|        _timestampFormatter.dateFormat = dateFormat
   28|      0|
   29|      0|        logEvent(_parent._identifier, dateFormat: _timestampFormatter, content: "subscribed")
   30|      0|
   31|      0|        super.init(observer: observer, cancel: cancel)
   32|      0|    }
   33|       |    
   34|      0|    func on(_ event: Event<Element>) {
   35|      0|        let maxEventTextLength = 40
   36|      0|        let eventText = "\(event)"
   37|      0|
   38|      0|        let eventNormalized = (eventText.characters.count > maxEventTextLength) && _parent._trimOutput
   39|      0|            ? String(eventText.characters.prefix(maxEventTextLength / 2)) + "..." + String(eventText.characters.suffix(maxEventTextLength / 2))
   40|      0|            : eventText
   41|      0|
   42|      0|        logEvent(_parent._identifier, dateFormat: _timestampFormatter, content: "Event \(eventNormalized)")
   43|      0|
   44|      0|        forwardOn(event)
   45|      0|        if event.isStopEvent {
   46|      0|            dispose()
   47|      0|        }
   48|      0|    }
   49|       |    
   50|      0|    override func dispose() {
   51|      0|        if !self.disposed {
   52|      0|            logEvent(_parent._identifier, dateFormat: _timestampFormatter, content: "isDisposed")
   53|      0|        }
   54|      0|        super.dispose()
   55|      0|    }
   56|       |}
   57|       |
   58|       |final class Debug<Source: ObservableType> : Producer<Source.E> {
   59|       |    fileprivate let _identifier: String
   60|       |    fileprivate let _trimOutput: Bool
   61|       |    fileprivate let _source: Source
   62|       |
   63|      5|    init(source: Source, identifier: String?, trimOutput: Bool, file: String, line: UInt, function: String) {
   64|      5|        _trimOutput = trimOutput
   65|      0|        if let identifier = identifier {
   66|      0|            _identifier = identifier
   67|      5|        }
   68|      5|        else {
   69|      5|            let trimmedFile: String
   70|      5|            if let lastIndex = file.lastIndexOf("/") {
   71|      5|                trimmedFile = file[file.index(after: lastIndex) ..< file.endIndex]
   72|      5|            }
   73|      0|            else {
   74|      0|                trimmedFile = file
   75|      5|            }
   76|      5|            _identifier = "\(trimmedFile):\(line) (\(function))"
   77|      5|        }
   78|      5|        _source = source
   79|      5|    }
   80|       |    
   81|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Source.E {
   82|      0|        let sink = DebugSink(parent: self, observer: observer, cancel: cancel)
   83|      0|        let subscription = _source.subscribe(sink)
   84|      0|        return (sink: sink, subscription: subscription)
   85|      0|    }
   86|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/DefaultIfEmpty.swift:
    1|       |//
    2|       |//  DefaultIfEmpty.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 23/12/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class DefaultIfEmptySink<O: ObserverType>: Sink<O>, ObserverType {
   10|       |    typealias E = O.E
   11|       |    private let _default: E
   12|       |    private var _isEmpty = true
   13|       |    
   14|      0|    init(default: E, observer: O, cancel: Cancelable) {
   15|      0|        _default = `default`
   16|      0|        super.init(observer: observer, cancel: cancel)
   17|      0|    }
   18|       |    
   19|      0|    func on(_ event: Event<E>) {
   20|      0|        switch event {
   21|      0|        case .next(_):
   22|      0|            _isEmpty = false
   23|      0|            forwardOn(event)
   24|      0|        case .error(_):
   25|      0|            forwardOn(event)
   26|      0|            dispose()
   27|      0|        case .completed:
   28|      0|            if _isEmpty {
   29|      0|                forwardOn(.next(_default))
   30|      0|            }
   31|      0|            forwardOn(.completed)
   32|      0|            dispose()
   33|      0|        }
   34|      0|    }
   35|       |}
   36|       |
   37|       |final class DefaultIfEmpty<SourceType>: Producer<SourceType> {
   38|       |    private let _source: Observable<SourceType>
   39|       |    private let _default: SourceType
   40|       |    
   41|      0|    init(source: Observable<SourceType>, `default`: SourceType) {
   42|      0|        _source = source
   43|      0|        _default = `default`
   44|      0|    }
   45|       |    
   46|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceType {
   47|      0|        let sink = DefaultIfEmptySink(default: _default, observer: observer, cancel: cancel)
   48|      0|        let subscription = _source.subscribe(sink)
   49|      0|        return (sink: sink, subscription: subscription)
   50|      0|    }
   51|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Deferred.swift:
    1|       |//
    2|       |//  Deferred.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class DeferredSink<S: ObservableType, O: ObserverType> : Sink<O>, ObserverType where S.E == O.E {
   10|       |    typealias E = O.E
   11|       |
   12|       |    private let _observableFactory: () throws -> S
   13|       |
   14|      0|    init(observableFactory: @escaping () throws -> S, observer: O, cancel: Cancelable) {
   15|      0|        _observableFactory = observableFactory
   16|      0|        super.init(observer: observer, cancel: cancel)
   17|      0|    }
   18|       |    
   19|      0|    func run() -> Disposable {
   20|      0|        do {
   21|      0|            let result = try _observableFactory()
   22|      0|            return result.subscribe(self)
   23|      0|        }
   24|      0|        catch let e {
   25|      0|            forwardOn(.error(e))
   26|      0|            dispose()
   27|      0|            return Disposables.create()
   28|      0|        }
   29|      0|    }
   30|       |    
   31|      0|    func on(_ event: Event<E>) {
   32|      0|        forwardOn(event)
   33|      0|        
   34|      0|        switch event {
   35|      0|        case .next:
   36|      0|            break
   37|      0|        case .error:
   38|      0|            dispose()
   39|      0|        case .completed:
   40|      0|            dispose()
   41|      0|        }
   42|      0|    }
   43|       |}
   44|       |
   45|       |final class Deferred<S: ObservableType> : Producer<S.E> {
   46|       |    typealias Factory = () throws -> S
   47|       |    
   48|       |    private let _observableFactory : Factory
   49|       |    
   50|      0|    init(observableFactory: @escaping Factory) {
   51|      0|        _observableFactory = observableFactory
   52|      0|    }
   53|       |    
   54|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
   55|      0|        let sink = DeferredSink(observableFactory: _observableFactory, observer: observer, cancel: cancel)
   56|      0|        let subscription = sink.run()
   57|      0|        return (sink: sink, subscription: subscription)
   58|      0|    }
   59|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Delay.swift:
    1|       |//
    2|       |//  Delay.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by tarunon on 2016/02/09.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |final class DelaySink<O: ObserverType>
   12|       |    : Sink<O>
   13|       |    , ObserverType {
   14|       |    typealias E = O.E
   15|       |    typealias Source = Observable<E>
   16|       |    typealias DisposeKey = Bag<Disposable>.KeyType
   17|       |    
   18|       |    private let _lock = RecursiveLock()
   19|       |
   20|       |    private let _dueTime: RxTimeInterval
   21|       |    private let _scheduler: SchedulerType
   22|       |    
   23|       |    private let _sourceSubscription = SingleAssignmentDisposable()
   24|       |    private let _cancelable = SerialDisposable()
   25|       |
   26|       |    // is scheduled some action
   27|       |    private var _active = false
   28|       |    // is "run loop" on different scheduler running
   29|       |    private var _running = false
   30|       |    private var _errorEvent: Event<E>? = nil
   31|       |
   32|       |    // state
   33|       |    private var _queue = Queue<(eventTime: RxTime, event: Event<E>)>(capacity: 0)
   34|       |    private var _disposed = false
   35|       |    
   36|      0|    init(observer: O, dueTime: RxTimeInterval, scheduler: SchedulerType, cancel: Cancelable) {
   37|      0|        _dueTime = dueTime
   38|      0|        _scheduler = scheduler
   39|      0|        super.init(observer: observer, cancel: cancel)
   40|      0|    }
   41|       |
   42|       |    // All of these complications in this method are caused by the fact that 
   43|       |    // error should be propagated immediatelly. Error can bepotentially received on different
   44|       |    // scheduler so this process needs to be synchronized somehow.
   45|       |    //
   46|       |    // Another complication is that scheduler is potentially concurrent so internal queue is used.
   47|      0|    func drainQueue(state: (), scheduler: AnyRecursiveScheduler<()>) {
   48|      0|
   49|      0|        _lock.lock()    // {
   50|      0|            let hasFailed = _errorEvent != nil
   51|      0|            if !hasFailed {
   52|      0|                _running = true
   53|      0|            }
   54|      0|        _lock.unlock()  // }
   55|      0|
   56|      0|        if hasFailed {
   57|      0|            return
   58|      0|        }
   59|      0|
   60|      0|        var ranAtLeastOnce = false
   61|      0|
   62|      0|        while true {
   63|      0|            _lock.lock() // {
   64|      0|                let errorEvent = _errorEvent
   65|      0|
   66|      0|                let eventToForwardImmediatelly = ranAtLeastOnce ? nil : _queue.dequeue()?.event
   67|      0|                let nextEventToScheduleOriginalTime: Date? = ranAtLeastOnce && !_queue.isEmpty ? _queue.peek().eventTime : nil
   68|      0|
   69|      0|                if let _ = errorEvent {
   70|      0|                }
   71|      0|                else  {
   72|      0|                    if let _ = eventToForwardImmediatelly {
   73|      0|                    }
   74|      0|                    else if let _ = nextEventToScheduleOriginalTime {
   75|      0|                        _running = false
   76|      0|                    }
   77|      0|                    else {
   78|      0|                        _running = false
   79|      0|                        _active = false
   80|      0|                    }
   81|      0|                }
   82|      0|            _lock.unlock() // {
   83|      0|
   84|      0|            if let errorEvent = errorEvent {
   85|      0|                self.forwardOn(errorEvent)
   86|      0|                self.dispose()
   87|      0|                return
   88|      0|            }
   89|      0|            else {
   90|      0|                if let eventToForwardImmediatelly = eventToForwardImmediatelly {
   91|      0|                    ranAtLeastOnce = true
   92|      0|                    self.forwardOn(eventToForwardImmediatelly)
   93|      0|                    if case .completed = eventToForwardImmediatelly {
   94|      0|                        self.dispose()
   95|      0|                        return
   96|      0|                    }
   97|      0|                }
   98|      0|                else if let nextEventToScheduleOriginalTime = nextEventToScheduleOriginalTime {
   99|      0|                    let elapsedTime = _scheduler.now.timeIntervalSince(nextEventToScheduleOriginalTime)
  100|      0|                    let interval = _dueTime - elapsedTime
  101|      0|                    let normalizedInterval = interval < 0.0 ? 0.0 : interval
  102|      0|                    scheduler.schedule((), dueTime: normalizedInterval)
  103|      0|                    return
  104|      0|                }
  105|      0|                else {
  106|      0|                    return
  107|      0|                }
  108|      0|            }
  109|      0|        }
  110|      0|    }
  111|       |    
  112|      0|    func on(_ event: Event<E>) {
  113|      0|        if event.isStopEvent {
  114|      0|            _sourceSubscription.dispose()
  115|      0|        }
  116|      0|
  117|      0|        switch event {
  118|      0|        case .error(_):
  119|      0|            _lock.lock()    // {
  120|      0|                let shouldSendImmediatelly = !_running
  121|      0|                _queue = Queue(capacity: 0)
  122|      0|                _errorEvent = event
  123|      0|            _lock.unlock()  // }
  124|      0|
  125|      0|            if shouldSendImmediatelly {
  126|      0|                forwardOn(event)
  127|      0|                dispose()
  128|      0|            }
  129|      0|        default:
  130|      0|            _lock.lock()    // {
  131|      0|                let shouldSchedule = !_active
  132|      0|                _active = true
  133|      0|                _queue.enqueue((_scheduler.now, event))
  134|      0|            _lock.unlock()  // }
  135|      0|
  136|      0|            if shouldSchedule {
  137|      0|                _cancelable.disposable = _scheduler.scheduleRecursive((), dueTime: _dueTime, action: self.drainQueue)
  138|      0|            }
  139|      0|        }
  140|      0|    }
  141|       |    
  142|      0|    func run(source: Observable<E>) -> Disposable {
  143|      0|        _sourceSubscription.setDisposable(source.subscribe(self))
  144|      0|        return Disposables.create(_sourceSubscription, _cancelable)
  145|      0|    }
  146|       |}
  147|       |
  148|       |final class Delay<Element>: Producer<Element> {
  149|       |    private let _source: Observable<Element>
  150|       |    private let _dueTime: RxTimeInterval
  151|       |    private let _scheduler: SchedulerType
  152|       |    
  153|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, scheduler: SchedulerType) {
  154|      0|        _source = source
  155|      0|        _dueTime = dueTime
  156|      0|        _scheduler = scheduler
  157|      0|    }
  158|       |
  159|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  160|      0|        let sink = DelaySink(observer: observer, dueTime: _dueTime, scheduler: _scheduler, cancel: cancel)
  161|      0|        let subscription = sink.run(source: _source)
  162|      0|        return (sink: sink, subscription: subscription)
  163|      0|    }
  164|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/DelaySubscription.swift:
    1|       |//
    2|       |//  DelaySubscription.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class DelaySubscriptionSink<O: ObserverType>
   10|       |    : Sink<O>, ObserverType {
   11|       |    typealias E = O.E
   12|       |    typealias Parent = DelaySubscription<E>
   13|       |    
   14|       |    private let _parent: Parent
   15|       |    
   16|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   17|      0|        _parent = parent
   18|      0|        super.init(observer: observer, cancel: cancel)
   19|      0|    }
   20|       |    
   21|      0|    func on(_ event: Event<E>) {
   22|      0|        forwardOn(event)
   23|      0|        if event.isStopEvent {
   24|      0|            dispose()
   25|      0|        }
   26|      0|    }
   27|       |    
   28|       |}
   29|       |
   30|       |final class DelaySubscription<Element>: Producer<Element> {
   31|       |    private let _source: Observable<Element>
   32|       |    private let _dueTime: RxTimeInterval
   33|       |    private let _scheduler: SchedulerType
   34|       |    
   35|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, scheduler: SchedulerType) {
   36|      0|        _source = source
   37|      0|        _dueTime = dueTime
   38|      0|        _scheduler = scheduler
   39|      0|    }
   40|       |    
   41|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   42|      0|        let sink = DelaySubscriptionSink(parent: self, observer: observer, cancel: cancel)
   43|      0|        let subscription = _scheduler.scheduleRelative((), dueTime: _dueTime) { _ in
   44|      0|            return self._source.subscribe(sink)
   45|      0|        }
   46|      0|
   47|      0|        return (sink: sink, subscription: subscription)
   48|      0|    }
   49|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Dematerialize.swift:
    1|       |//
    2|       |//  Dematerialize.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Jamie Pinkham on 3/13/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class DematerializeSink<Element: EventConvertible, O: ObserverType>: Sink<O>, ObserverType where O.E == Element.ElementType {
   10|      0|    fileprivate func on(_ event: Event<Element>) {
   11|      0|        switch event {
   12|      0|        case .next(let element):
   13|      0|            forwardOn(element.event)
   14|      0|            if element.event.isStopEvent {
   15|      0|                dispose()
   16|      0|            }
   17|      0|        case .completed:
   18|      0|            forwardOn(.completed)
   19|      0|            dispose()
   20|      0|        case .error(let error):
   21|      0|            forwardOn(.error(error))
   22|      0|            dispose()
   23|      0|        }
   24|      0|    }
   25|       |}
   26|       |
   27|       |final class Dematerialize<Element: EventConvertible>: Producer<Element.ElementType>  {
   28|       |    private let _source: Observable<Element>
   29|       |    
   30|      0|    init(source: Observable<Element>) {
   31|      0|        _source = source
   32|      0|    }
   33|       |    
   34|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element.ElementType {
   35|      0|        let sink = DematerializeSink<Element, O>(observer: observer, cancel: cancel)
   36|      0|        let subscription = _source.subscribe(sink)
   37|      0|        return (sink: sink, subscription: subscription)
   38|      0|    }
   39|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/DistinctUntilChanged.swift:
    1|       |//
    2|       |//  DistinctUntilChanged.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class DistinctUntilChangedSink<O: ObserverType, Key>: Sink<O>, ObserverType {
   10|       |    typealias E = O.E
   11|       |    
   12|       |    private let _parent: DistinctUntilChanged<E, Key>
   13|       |    private var _currentKey: Key? = nil
   14|       |    
   15|      7|    init(parent: DistinctUntilChanged<E, Key>, observer: O, cancel: Cancelable) {
   16|      7|        _parent = parent
   17|      7|        super.init(observer: observer, cancel: cancel)
   18|      7|    }
   19|       |    
   20|      8|    func on(_ event: Event<E>) {
   21|      8|        switch event {
   22|      8|        case .next(let value):
   23|      8|            do {
   24|      8|                let key = try _parent._selector(value)
   25|      8|                var areEqual = false
   26|      1|                if let currentKey = _currentKey {
   27|      1|                    areEqual = try _parent._comparer(currentKey, key)
   28|      8|                }
   29|      8|                
   30|      0|                if areEqual {
   31|      0|                    return
   32|      8|                }
   33|      8|                
   34|      8|                _currentKey = key
   35|      8|                
   36|      8|                forwardOn(event)
   37|      8|            }
   38|      0|            catch let error {
   39|      0|                forwardOn(.error(error))
   40|      0|                dispose()
   41|      0|            }
   42|      0|        case .error, .completed:
   43|      0|            forwardOn(event)
   44|      0|            dispose()
   45|      8|        }
   46|      8|    }
   47|       |}
   48|       |
   49|       |final class DistinctUntilChanged<Element, Key>: Producer<Element> {
   50|       |    typealias KeySelector = (Element) throws -> Key
   51|       |    typealias EqualityComparer = (Key, Key) throws -> Bool
   52|       |    
   53|       |    fileprivate let _source: Observable<Element>
   54|       |    fileprivate let _selector: KeySelector
   55|       |    fileprivate let _comparer: EqualityComparer
   56|       |    
   57|      7|    init(source: Observable<Element>, selector: @escaping KeySelector, comparer: @escaping EqualityComparer) {
   58|      7|        _source = source
   59|      7|        _selector = selector
   60|      7|        _comparer = comparer
   61|      7|    }
   62|       |    
   63|      7|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   64|      7|        let sink = DistinctUntilChangedSink(parent: self, observer: observer, cancel: cancel)
   65|      7|        let subscription = _source.subscribe(sink)
   66|      7|        return (sink: sink, subscription: subscription)
   67|      7|    }
   68|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Do.swift:
    1|       |//
    2|       |//  Do.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class DoSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias Element = O.E
   11|       |    typealias Parent = Do<Element>
   12|       |    
   13|       |    private let _parent: Parent
   14|       |    
   15|     45|    init(parent: Parent, observer: O, cancel: Cancelable) {
   16|     45|        _parent = parent
   17|     45|        super.init(observer: observer, cancel: cancel)
   18|     45|    }
   19|       |    
   20|      2|    func on(_ event: Event<Element>) {
   21|      2|        do {
   22|      2|            try _parent._eventHandler(event)
   23|      2|            forwardOn(event)
   24|      1|            if event.isStopEvent {
   25|      1|                dispose()
   26|      2|            }
   27|      2|        }
   28|      0|        catch let error {
   29|      0|            forwardOn(.error(error))
   30|      0|            dispose()
   31|      2|        }
   32|      2|    }
   33|       |}
   34|       |
   35|       |final class Do<Element> : Producer<Element> {
   36|       |    typealias EventHandler = (Event<Element>) throws -> Void
   37|       |    
   38|       |    fileprivate let _source: Observable<Element>
   39|       |    fileprivate let _eventHandler: EventHandler
   40|       |    fileprivate let _onSubscribe: (() -> ())?
   41|       |    fileprivate let _onSubscribed: (() -> ())?
   42|       |    fileprivate let _onDispose: (() -> ())?
   43|       |    
   44|     45|    init(source: Observable<Element>, eventHandler: @escaping EventHandler, onSubscribe: (() -> ())?, onSubscribed: (() -> ())?, onDispose: (() -> ())?) {
   45|     45|        _source = source
   46|     45|        _eventHandler = eventHandler
   47|     45|        _onSubscribe = onSubscribe
   48|     45|        _onSubscribed = onSubscribed
   49|     45|        _onDispose = onDispose
   50|     45|    }
   51|       |    
   52|     45|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   53|     45|        _onSubscribe?()
   54|     45|        let sink = DoSink(parent: self, observer: observer, cancel: cancel)
   55|     45|        let subscription = _source.subscribe(sink)
   56|     45|        _onSubscribed?()
   57|     45|        let onDispose = _onDispose
   58|      1|        let allSubscriptions = Disposables.create {
   59|      1|            subscription.dispose()
   60|      1|            onDispose?()
   61|      1|        }
   62|     45|        return (sink: sink, subscription: allSubscriptions)
   63|     45|    }
   64|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ElementAt.swift:
    1|       |//
    2|       |//  ElementAt.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 21/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |
   10|       |final class ElementAtSink<O: ObserverType> : Sink<O>, ObserverType {
   11|       |    typealias SourceType = O.E
   12|       |    typealias Parent = ElementAt<SourceType>
   13|       |    
   14|       |    let _parent: Parent
   15|       |    var _i: Int
   16|       |    
   17|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   18|      0|        _parent = parent
   19|      0|        _i = parent._index
   20|      0|        
   21|      0|        super.init(observer: observer, cancel: cancel)
   22|      0|    }
   23|       |    
   24|      0|    func on(_ event: Event<SourceType>) {
   25|      0|        switch event {
   26|      0|        case .next(_):
   27|      0|
   28|      0|            if (_i == 0) {
   29|      0|                forwardOn(event)
   30|      0|                forwardOn(.completed)
   31|      0|                self.dispose()
   32|      0|            }
   33|      0|            
   34|      0|            do {
   35|      0|                let _ = try decrementChecked(&_i)
   36|      0|            } catch(let e) {
   37|      0|                forwardOn(.error(e))
   38|      0|                dispose()
   39|      0|                return
   40|      0|            }
   41|      0|            
   42|      0|        case .error(let e):
   43|      0|            forwardOn(.error(e))
   44|      0|            self.dispose()
   45|      0|        case .completed:
   46|      0|            if (_parent._throwOnEmpty) {
   47|      0|                forwardOn(.error(RxError.argumentOutOfRange))
   48|      0|            } else {
   49|      0|                forwardOn(.completed)
   50|      0|            }
   51|      0|            
   52|      0|            self.dispose()
   53|      0|        }
   54|      0|    }
   55|       |}
   56|       |
   57|       |final class ElementAt<SourceType> : Producer<SourceType> {
   58|       |    
   59|       |    let _source: Observable<SourceType>
   60|       |    let _throwOnEmpty: Bool
   61|       |    let _index: Int
   62|       |    
   63|      0|    init(source: Observable<SourceType>, index: Int, throwOnEmpty: Bool) {
   64|      0|        if index < 0 {
   65|      0|            rxFatalError("index can't be negative")
   66|      0|        }
   67|      0|
   68|      0|        self._source = source
   69|      0|        self._index = index
   70|      0|        self._throwOnEmpty = throwOnEmpty
   71|      0|    }
   72|       |    
   73|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == SourceType {
   74|      0|        let sink = ElementAtSink(parent: self, observer: observer, cancel: cancel)
   75|      0|        let subscription = _source.subscribe(sink)
   76|      0|        return (sink: sink, subscription: subscription)
   77|      0|    }
   78|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Empty.swift:
    1|       |//
    2|       |//  Empty.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class EmptyProducer<Element> : Producer<Element> {
   10|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   11|      0|        observer.on(.completed)
   12|      0|        return Disposables.create()
   13|      0|    }
   14|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Error.swift:
    1|       |//
    2|       |//  Error.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ErrorProducer<Element> : Producer<Element> {
   10|       |    private let _error: Swift.Error
   11|       |    
   12|      7|    init(error: Swift.Error) {
   13|      7|        _error = error
   14|      7|    }
   15|       |    
   16|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   17|      0|        observer.on(.error(_error))
   18|      0|        return Disposables.create()
   19|      0|    }
   20|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Filter.swift:
    1|       |//
    2|       |//  Filter.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/17/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class FilterSink<O : ObserverType>: Sink<O>, ObserverType {
   10|       |    typealias Predicate = (Element) throws -> Bool
   11|       |    typealias Element = O.E
   12|       |    
   13|       |    private let _predicate: Predicate
   14|       |    
   15|      0|    init(predicate: @escaping Predicate, observer: O, cancel: Cancelable) {
   16|      0|        _predicate = predicate
   17|      0|        super.init(observer: observer, cancel: cancel)
   18|      0|    }
   19|       |    
   20|      0|    func on(_ event: Event<Element>) {
   21|      0|        switch event {
   22|      0|            case .next(let value):
   23|      0|                do {
   24|      0|                    let satisfies = try _predicate(value)
   25|      0|                    if satisfies {
   26|      0|                        forwardOn(.next(value))
   27|      0|                    }
   28|      0|                }
   29|      0|                catch let e {
   30|      0|                    forwardOn(.error(e))
   31|      0|                    dispose()
   32|      0|                }
   33|      0|            case .completed, .error:
   34|      0|                forwardOn(event)
   35|      0|                dispose()
   36|      0|        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |final class Filter<Element> : Producer<Element> {
   41|       |    typealias Predicate = (Element) throws -> Bool
   42|       |    
   43|       |    private let _source: Observable<Element>
   44|       |    private let _predicate: Predicate
   45|       |    
   46|      0|    init(source: Observable<Element>, predicate: @escaping Predicate) {
   47|      0|        _source = source
   48|      0|        _predicate = predicate
   49|      0|    }
   50|       |    
   51|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   52|      0|        let sink = FilterSink(predicate: _predicate, observer: observer, cancel: cancel)
   53|      0|        let subscription = _source.subscribe(sink)
   54|      0|        return (sink: sink, subscription: subscription)
   55|      0|    }
   56|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Generate.swift:
    1|       |//
    2|       |//  Generate.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class GenerateSink<S, O: ObserverType> : Sink<O> {
   10|       |    typealias Parent = Generate<S, O.E>
   11|       |    
   12|       |    private let _parent: Parent
   13|       |    
   14|       |    private var _state: S
   15|       |    
   16|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   17|      0|        _parent = parent
   18|      0|        _state = parent._initialState
   19|      0|        super.init(observer: observer, cancel: cancel)
   20|      0|    }
   21|       |    
   22|      0|    func run() -> Disposable {
   23|      0|        return _parent._scheduler.scheduleRecursive(true) { (isFirst, recurse) -> Void in
   24|      0|            do {
   25|      0|                if !isFirst {
   26|      0|                    self._state = try self._parent._iterate(self._state)
   27|      0|                }
   28|      0|                
   29|      0|                if try self._parent._condition(self._state) {
   30|      0|                    let result = try self._parent._resultSelector(self._state)
   31|      0|                    self.forwardOn(.next(result))
   32|      0|                    
   33|      0|                    recurse(false)
   34|      0|                }
   35|      0|                else {
   36|      0|                    self.forwardOn(.completed)
   37|      0|                    self.dispose()
   38|      0|                }
   39|      0|            }
   40|      0|            catch let error {
   41|      0|                self.forwardOn(.error(error))
   42|      0|                self.dispose()
   43|      0|            }
   44|      0|        }
   45|      0|    }
   46|       |}
   47|       |
   48|       |final class Generate<S, E> : Producer<E> {
   49|       |    fileprivate let _initialState: S
   50|       |    fileprivate let _condition: (S) throws -> Bool
   51|       |    fileprivate let _iterate: (S) throws -> S
   52|       |    fileprivate let _resultSelector: (S) throws -> E
   53|       |    fileprivate let _scheduler: ImmediateSchedulerType
   54|       |    
   55|      0|    init(initialState: S, condition: @escaping (S) throws -> Bool, iterate: @escaping (S) throws -> S, resultSelector: @escaping (S) throws -> E, scheduler: ImmediateSchedulerType) {
   56|      0|        _initialState = initialState
   57|      0|        _condition = condition
   58|      0|        _iterate = iterate
   59|      0|        _resultSelector = resultSelector
   60|      0|        _scheduler = scheduler
   61|      0|        super.init()
   62|      0|    }
   63|       |    
   64|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   65|      0|        let sink = GenerateSink(parent: self, observer: observer, cancel: cancel)
   66|      0|        let subscription = sink.run()
   67|      0|        return (sink: sink, subscription: subscription)
   68|      0|    }
   69|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/GroupBy.swift:
    1|       |//
    2|       |//  GroupBy.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 01/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class GroupedObservableImpl<Key, Element> : Observable<Element> {
   10|       |    private var _subject: PublishSubject<Element>
   11|       |    private var _refCount: RefCountDisposable
   12|       |    
   13|      0|    init(key: Key, subject: PublishSubject<Element>, refCount: RefCountDisposable) {
   14|      0|        _subject = subject
   15|      0|        _refCount = refCount
   16|      0|    }
   17|       |
   18|      0|    override public func subscribe<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   19|      0|        let release = _refCount.retain()
   20|      0|        let subscription = _subject.subscribe(observer)
   21|      0|        return Disposables.create(release, subscription)
   22|      0|    }
   23|       |}
   24|       |
   25|       |
   26|       |final class GroupBySink<Key: Hashable, Element, O: ObserverType>
   27|       |    : Sink<O>
   28|       |    , ObserverType where O.E == GroupedObservable<Key, Element> {
   29|       |    typealias E = Element
   30|       |    typealias ResultType = O.E
   31|       |    typealias Parent = GroupBy<Key, Element>
   32|       |
   33|       |    private let _parent: Parent
   34|       |    private let _subscription = SingleAssignmentDisposable()
   35|       |    private var _refCountDisposable: RefCountDisposable!
   36|       |    private var _groupedSubjectTable: [Key: PublishSubject<Element>]
   37|       |    
   38|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   39|      0|        _parent = parent
   40|      0|        _groupedSubjectTable = [Key: PublishSubject<Element>]()
   41|      0|        super.init(observer: observer, cancel: cancel)
   42|      0|    }
   43|       |    
   44|      0|    func run() -> Disposable {
   45|      0|        _refCountDisposable = RefCountDisposable(disposable: _subscription)
   46|      0|        
   47|      0|        _subscription.setDisposable(_parent._source.subscribe(self))
   48|      0|        
   49|      0|        return _refCountDisposable
   50|      0|    }
   51|       |    
   52|      0|    private func onGroupEvent(key: Key, value: Element) {
   53|      0|        if let writer = _groupedSubjectTable[key] {
   54|      0|            writer.on(.next(value))
   55|      0|        } else {
   56|      0|            let writer = PublishSubject<Element>()
   57|      0|            _groupedSubjectTable[key] = writer
   58|      0|            
   59|      0|            let group = GroupedObservable(
   60|      0|                key: key,
   61|      0|                source: GroupedObservableImpl(key: key, subject: writer, refCount: _refCountDisposable)
   62|      0|            )
   63|      0|            
   64|      0|            forwardOn(.next(group))
   65|      0|            writer.on(.next(value))
   66|      0|        }
   67|      0|    }
   68|       |
   69|      0|    final func on(_ event: Event<Element>) {
   70|      0|        switch event {
   71|      0|        case let .next(value):
   72|      0|            do {
   73|      0|                let groupKey = try _parent._selector(value)
   74|      0|                onGroupEvent(key: groupKey, value: value)
   75|      0|            }
   76|      0|            catch let e {
   77|      0|                error(e)
   78|      0|                return
   79|      0|            }
   80|      0|        case let .error(e):
   81|      0|            error(e)
   82|      0|        case .completed:
   83|      0|            forwardOnGroups(event: .completed)
   84|      0|            forwardOn(.completed)
   85|      0|            _subscription.dispose()
   86|      0|            dispose()
   87|      0|        }
   88|      0|    }
   89|       |
   90|      0|    final func error(_ error: Swift.Error) {
   91|      0|        forwardOnGroups(event: .error(error))
   92|      0|        forwardOn(.error(error))
   93|      0|        _subscription.dispose()
   94|      0|        dispose()
   95|      0|    }
   96|       |    
   97|      0|    final func forwardOnGroups(event: Event<Element>) {
   98|      0|        for writer in _groupedSubjectTable.values {
   99|      0|            writer.on(event)
  100|      0|        }
  101|      0|    }
  102|       |}
  103|       |
  104|       |final class GroupBy<Key: Hashable, Element>: Producer<GroupedObservable<Key,Element>> {
  105|       |    typealias KeySelector = (Element) throws -> Key
  106|       |
  107|       |    fileprivate let _source: Observable<Element>
  108|       |    fileprivate let _selector: KeySelector
  109|       |    
  110|      0|    init(source: Observable<Element>, selector: @escaping KeySelector) {
  111|      0|        _source = source
  112|      0|        _selector = selector
  113|      0|    }
  114|       |
  115|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == GroupedObservable<Key,Element> {
  116|      0|        let sink = GroupBySink(parent: self, observer: observer, cancel: cancel)
  117|      0|        return (sink: sink, subscription: sink.run())
  118|      0|    }
  119|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Just.swift:
    1|       |//
    2|       |//  Just.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class JustScheduledSink<O: ObserverType> : Sink<O> {
   10|       |    typealias Parent = JustScheduled<O.E>
   11|       |
   12|       |    private let _parent: Parent
   13|       |
   14|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   15|      0|        _parent = parent
   16|      0|        super.init(observer: observer, cancel: cancel)
   17|      0|    }
   18|       |
   19|      0|    func run() -> Disposable {
   20|      0|        let scheduler = _parent._scheduler
   21|      0|        return scheduler.schedule(_parent._element) { element in
   22|      0|            self.forwardOn(.next(element))
   23|      0|            return scheduler.schedule(()) { _ in
   24|      0|                self.forwardOn(.completed)
   25|      0|                self.dispose()
   26|      0|                return Disposables.create()
   27|      0|            }
   28|      0|        }
   29|      0|    }
   30|       |}
   31|       |
   32|       |final class JustScheduled<Element> : Producer<Element> {
   33|       |    fileprivate let _scheduler: ImmediateSchedulerType
   34|       |    fileprivate let _element: Element
   35|       |
   36|      0|    init(element: Element, scheduler: ImmediateSchedulerType) {
   37|      0|        _scheduler = scheduler
   38|      0|        _element = element
   39|      0|    }
   40|       |
   41|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   42|      0|        let sink = JustScheduledSink(parent: self, observer: observer, cancel: cancel)
   43|      0|        let subscription = sink.run()
   44|      0|        return (sink: sink, subscription: subscription)
   45|      0|    }
   46|       |}
   47|       |
   48|       |final class Just<Element> : Producer<Element> {
   49|       |    private let _element: Element
   50|       |    
   51|     51|    init(element: Element) {
   52|     51|        _element = element
   53|     51|    }
   54|       |    
   55|     50|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   56|     50|        observer.on(.next(_element))
   57|     50|        observer.on(.completed)
   58|     50|        return Disposables.create()
   59|     50|    }
   60|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Map.swift:
    1|       |//
    2|       |//  Map.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class MapSink<SourceType, O : ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias Transform = (SourceType) throws -> ResultType
   11|       |
   12|       |    typealias ResultType = O.E
   13|       |    typealias Element = SourceType
   14|       |
   15|       |    private let _transform: Transform
   16|       |    
   17|    392|    init(transform: @escaping Transform, observer: O, cancel: Cancelable) {
   18|    392|        _transform = transform
   19|    392|        super.init(observer: observer, cancel: cancel)
   20|    392|    }
   21|       |
   22|    364|    func on(_ event: Event<SourceType>) {
   23|    364|        switch event {
   24|    351|        case .next(let element):
   25|    351|            do {
   26|    351|                let mappedElement = try _transform(element)
   27|    351|                forwardOn(.next(mappedElement))
   28|    351|            }
   29|      0|            catch let e {
   30|      0|                forwardOn(.error(e))
   31|      0|                dispose()
   32|      0|            }
   33|      0|        case .error(let error):
   34|      0|            forwardOn(.error(error))
   35|      0|            dispose()
   36|     13|        case .completed:
   37|     13|            forwardOn(.completed)
   38|     13|            dispose()
   39|    364|        }
   40|    364|    }
   41|       |}
   42|       |
   43|       |final class MapWithIndexSink<SourceType, O : ObserverType> : Sink<O>, ObserverType {
   44|       |    typealias Selector = (SourceType, Int) throws -> ResultType
   45|       |
   46|       |    typealias ResultType = O.E
   47|       |    typealias Element = SourceType
   48|       |    typealias Parent = MapWithIndex<SourceType, ResultType>
   49|       |    
   50|       |    private let _selector: Selector
   51|       |
   52|       |    private var _index = 0
   53|       |
   54|      0|    init(selector: @escaping Selector, observer: O, cancel: Cancelable) {
   55|      0|        _selector = selector
   56|      0|        super.init(observer: observer, cancel: cancel)
   57|      0|    }
   58|       |
   59|      0|    func on(_ event: Event<SourceType>) {
   60|      0|        switch event {
   61|      0|        case .next(let element):
   62|      0|            do {
   63|      0|                let mappedElement = try _selector(element, try incrementChecked(&_index))
   64|      0|                forwardOn(.next(mappedElement))
   65|      0|            }
   66|      0|            catch let e {
   67|      0|                forwardOn(.error(e))
   68|      0|                dispose()
   69|      0|            }
   70|      0|        case .error(let error):
   71|      0|            forwardOn(.error(error))
   72|      0|            dispose()
   73|      0|        case .completed:
   74|      0|            forwardOn(.completed)
   75|      0|            dispose()
   76|      0|        }
   77|      0|    }
   78|       |}
   79|       |
   80|       |final class MapWithIndex<SourceType, ResultType> : Producer<ResultType> {
   81|       |    typealias Selector = (SourceType, Int) throws -> ResultType
   82|       |
   83|       |    private let _source: Observable<SourceType>
   84|       |
   85|       |    private let _selector: Selector
   86|       |
   87|      0|    init(source: Observable<SourceType>, selector: @escaping Selector) {
   88|      0|        _source = source
   89|      0|        _selector = selector
   90|      0|    }
   91|       |
   92|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
   93|      0|        let sink = MapWithIndexSink(selector: _selector, observer: observer, cancel: cancel)
   94|      0|        let subscription = _source.subscribe(sink)
   95|      0|        return (sink: sink, subscription: subscription)
   96|      0|    }
   97|       |}
   98|       |
   99|       |#if TRACE_RESOURCES
  100|       |    var _numberOfMapOperators: AtomicInt = 0
  101|       |    extension Resources {
  102|       |        public static var numberOfMapOperators: Int32 {
  103|       |            return _numberOfMapOperators.valueSnapshot()
  104|       |        }
  105|       |    }
  106|       |#endif
  107|       |
  108|       |final class Map<SourceType, ResultType>: Producer<ResultType> {
  109|       |    typealias Transform = (SourceType) throws -> ResultType
  110|       |
  111|       |    private let _source: Observable<SourceType>
  112|       |
  113|       |    private let _transform: Transform
  114|       |
  115|    417|    init(source: Observable<SourceType>, transform: @escaping Transform) {
  116|    417|        _source = source
  117|    417|        _transform = transform
  118|    417|
  119|    417|#if TRACE_RESOURCES
  120|    417|        let _ = AtomicIncrement(&_numberOfMapOperators)
  121|    417|#endif
  122|    417|    }
  123|       |
  124|     21|    override func composeMap<R>(_ selector: @escaping (ResultType) throws -> R) -> Observable<R> {
  125|     21|        let originalSelector = _transform
  126|     13|        return Map<SourceType, R>(source: _source, transform: { (s: SourceType) throws -> R in
  127|     13|            let r: ResultType = try originalSelector(s)
  128|     13|            return try selector(r)
  129|     13|        })
  130|     21|    }
  131|       |    
  132|    392|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
  133|    392|        let sink = MapSink(transform: _transform, observer: observer, cancel: cancel)
  134|    392|        let subscription = _source.subscribe(sink)
  135|    392|        return (sink: sink, subscription: subscription)
  136|    392|    }
  137|       |
  138|       |    #if TRACE_RESOURCES
  139|       |    deinit {
  140|       |        let _ = AtomicDecrement(&_numberOfMapOperators)
  141|       |    }
  142|       |    #endif
  143|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Materialize.swift:
    1|       |//
    2|       |//  Materialize.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 08/03/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class MaterializeSink<Element, O: ObserverType>: Sink<O>, ObserverType where O.E == Event<Element> {
   10|       |    
   11|      0|    func on(_ event: Event<Element>) {
   12|      0|        forwardOn(.next(event))
   13|      0|        if event.isStopEvent {
   14|      0|            forwardOn(.completed)
   15|      0|            dispose()
   16|      0|        }
   17|      0|    }
   18|       |}
   19|       |
   20|       |final class Materialize<Element>: Producer<Event<Element>> {
   21|       |    private let _source: Observable<Element>
   22|       |    
   23|      0|    init(source: Observable<Element>) {
   24|      0|        _source = source
   25|      0|    }
   26|       |
   27|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   28|      0|        let sink = MaterializeSink(observer: observer, cancel: cancel)
   29|      0|        let subscription = _source.subscribe(sink)
   30|      0|
   31|      0|        return (sink: sink, subscription: subscription)
   32|      0|    }
   33|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Merge.swift:
    1|       |//
    2|       |//  Merge.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: Limited concurrency version
   10|       |
   11|       |fileprivate final class MergeLimitedSinkIter<S: ObservableConvertibleType, O: ObserverType>
   12|       |    : ObserverType
   13|       |    , LockOwnerType
   14|       |    , SynchronizedOnType where S.E == O.E {
   15|       |    typealias E = O.E
   16|       |    typealias DisposeKey = CompositeDisposable.DisposeKey
   17|       |    typealias Parent = MergeLimitedSink<S, O>
   18|       |    
   19|       |    private let _parent: Parent
   20|       |    private let _disposeKey: DisposeKey
   21|       |
   22|      0|    var _lock: RecursiveLock {
   23|      0|        return _parent._lock
   24|      0|    }
   25|       |    
   26|      0|    init(parent: Parent, disposeKey: DisposeKey) {
   27|      0|        _parent = parent
   28|      0|        _disposeKey = disposeKey
   29|      0|    }
   30|       |    
   31|      0|    func on(_ event: Event<E>) {
   32|      0|        synchronizedOn(event)
   33|      0|    }
   34|       |
   35|      0|    func _synchronized_on(_ event: Event<E>) {
   36|      0|        switch event {
   37|      0|        case .next:
   38|      0|            _parent.forwardOn(event)
   39|      0|        case .error:
   40|      0|            _parent.forwardOn(event)
   41|      0|            _parent.dispose()
   42|      0|        case .completed:
   43|      0|            _parent._group.remove(for: _disposeKey)
   44|      0|            if let next = _parent._queue.dequeue() {
   45|      0|                _parent.subscribe(next, group: _parent._group)
   46|      0|            }
   47|      0|            else {
   48|      0|                _parent._activeCount = _parent._activeCount - 1
   49|      0|                
   50|      0|                if _parent._stopped && _parent._activeCount == 0 {
   51|      0|                    _parent.forwardOn(.completed)
   52|      0|                    _parent.dispose()
   53|      0|                }
   54|      0|            }
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |
   59|       |fileprivate final class MergeLimitedSink<S: ObservableConvertibleType, O: ObserverType>
   60|       |    : Sink<O>
   61|       |    , ObserverType
   62|       |    , LockOwnerType
   63|       |    , SynchronizedOnType where S.E == O.E {
   64|       |    typealias E = S
   65|       |    typealias QueueType = Queue<S>
   66|       |
   67|       |    let _maxConcurrent: Int
   68|       |
   69|       |    let _lock = RecursiveLock()
   70|       |
   71|       |    // state
   72|       |    var _stopped = false
   73|       |    var _activeCount = 0
   74|       |    var _queue = QueueType(capacity: 2)
   75|       |    
   76|       |    let _sourceSubscription = SingleAssignmentDisposable()
   77|       |    let _group = CompositeDisposable()
   78|       |    
   79|      0|    init(maxConcurrent: Int, observer: O, cancel: Cancelable) {
   80|      0|        _maxConcurrent = maxConcurrent
   81|      0|        
   82|      0|        let _ = _group.insert(_sourceSubscription)
   83|      0|        super.init(observer: observer, cancel: cancel)
   84|      0|    }
   85|       |    
   86|      0|    func run(_ source: Observable<S>) -> Disposable {
   87|      0|        let _ = _group.insert(_sourceSubscription)
   88|      0|        
   89|      0|        let disposable = source.subscribe(self)
   90|      0|        _sourceSubscription.setDisposable(disposable)
   91|      0|        return _group
   92|      0|    }
   93|       |    
   94|      0|    func subscribe(_ innerSource: E, group: CompositeDisposable) {
   95|      0|        let subscription = SingleAssignmentDisposable()
   96|      0|        
   97|      0|        let key = group.insert(subscription)
   98|      0|        
   99|      0|        if let key = key {
  100|      0|            let observer = MergeLimitedSinkIter(parent: self, disposeKey: key)
  101|      0|            
  102|      0|            let disposable = innerSource.asObservable().subscribe(observer)
  103|      0|            subscription.setDisposable(disposable)
  104|      0|        }
  105|      0|    }
  106|       |    
  107|      0|    func on(_ event: Event<E>) {
  108|      0|        synchronizedOn(event)
  109|      0|    }
  110|       |
  111|      0|    func _synchronized_on(_ event: Event<E>) {
  112|      0|        switch event {
  113|      0|        case .next(let value):
  114|      0|            let subscribe: Bool
  115|      0|            if _activeCount < _maxConcurrent {
  116|      0|                _activeCount += 1
  117|      0|                subscribe = true
  118|      0|            }
  119|      0|            else {
  120|      0|                _queue.enqueue(value)
  121|      0|                subscribe = false
  122|      0|            }
  123|      0|
  124|      0|            if subscribe {
  125|      0|                self.subscribe(value, group: _group)
  126|      0|            }
  127|      0|        case .error(let error):
  128|      0|            forwardOn(.error(error))
  129|      0|            dispose()
  130|      0|        case .completed:
  131|      0|            if _activeCount == 0 {
  132|      0|                forwardOn(.completed)
  133|      0|                dispose()
  134|      0|            }
  135|      0|            else {
  136|      0|                _sourceSubscription.dispose()
  137|      0|            }
  138|      0|
  139|      0|            _stopped = true
  140|      0|        }
  141|      0|    }
  142|       |}
  143|       |
  144|       |final class MergeLimited<S: ObservableConvertibleType> : Producer<S.E> {
  145|       |    private let _source: Observable<S>
  146|       |    private let _maxConcurrent: Int
  147|       |    
  148|      0|    init(source: Observable<S>, maxConcurrent: Int) {
  149|      0|        _source = source
  150|      0|        _maxConcurrent = maxConcurrent
  151|      0|    }
  152|       |    
  153|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  154|      0|        let sink = MergeLimitedSink<S, O>(maxConcurrent: _maxConcurrent, observer: observer, cancel: cancel)
  155|      0|        let subscription = sink.run(_source)
  156|      0|        return (sink: sink, subscription: subscription)
  157|      0|    }
  158|       |}
  159|       |
  160|       |// MARK: Merge
  161|       |
  162|       |fileprivate final class MergeBasicSink<S: ObservableConvertibleType, O: ObserverType> : MergeSink<S, S, O> where O.E == S.E {
  163|      0|    override init(observer: O, cancel: Cancelable) {
  164|      0|        super.init(observer: observer, cancel: cancel)
  165|      0|    }
  166|       |
  167|      0|    override func performMap(_ element: S) throws -> S {
  168|      0|        return element
  169|      0|    }
  170|       |}
  171|       |
  172|       |// MARK: flatMap
  173|       |
  174|       |fileprivate final class FlatMapSink<SourceType, S: ObservableConvertibleType, O: ObserverType> : MergeSink<SourceType, S, O> where O.E == S.E {
  175|       |    typealias Selector = (SourceType) throws -> S
  176|       |
  177|       |    private let _selector: Selector
  178|       |
  179|     14|    init(selector: @escaping Selector, observer: O, cancel: Cancelable) {
  180|     14|        _selector = selector
  181|     14|        super.init(observer: observer, cancel: cancel)
  182|     14|    }
  183|       |
  184|      6|    override func performMap(_ element: SourceType) throws -> S {
  185|      6|        return try _selector(element)
  186|      6|    }
  187|       |}
  188|       |
  189|       |fileprivate final class FlatMapWithIndexSink<SourceType, S: ObservableConvertibleType, O: ObserverType> : MergeSink<SourceType, S, O> where O.E == S.E {
  190|       |    typealias Selector = (SourceType, Int) throws -> S
  191|       |
  192|       |    private var _index = 0
  193|       |    private let _selector: Selector
  194|       |
  195|      0|    init(selector: @escaping Selector, observer: O, cancel: Cancelable) {
  196|      0|        _selector = selector
  197|      0|        super.init(observer: observer, cancel: cancel)
  198|      0|    }
  199|       |
  200|      0|    override func performMap(_ element: SourceType) throws -> S {
  201|      0|        return try _selector(element, try incrementChecked(&_index))
  202|      0|    }
  203|       |}
  204|       |
  205|       |// MARK: FlatMapFirst
  206|       |
  207|       |fileprivate final class FlatMapFirstSink<SourceType, S: ObservableConvertibleType, O: ObserverType> : MergeSink<SourceType, S, O> where O.E == S.E {
  208|       |    typealias Selector = (SourceType) throws -> S
  209|       |
  210|       |    private let _selector: Selector
  211|       |
  212|      0|    override var subscribeNext: Bool {
  213|      0|        return _activeCount == 0
  214|      0|    }
  215|       |
  216|      0|    init(selector: @escaping Selector, observer: O, cancel: Cancelable) {
  217|      0|        _selector = selector
  218|      0|        super.init(observer: observer, cancel: cancel)
  219|      0|    }
  220|       |
  221|      0|    override func performMap(_ element: SourceType) throws -> S {
  222|      0|        return try _selector(element)
  223|      0|    }
  224|       |}
  225|       |
  226|       |fileprivate final class MergeSinkIter<SourceType, S: ObservableConvertibleType, O: ObserverType> : ObserverType where O.E == S.E {
  227|       |    typealias Parent = MergeSink<SourceType, S, O>
  228|       |    typealias DisposeKey = CompositeDisposable.DisposeKey
  229|       |    typealias E = O.E
  230|       |    
  231|       |    private let _parent: Parent
  232|       |    private let _disposeKey: DisposeKey
  233|       |
  234|      6|    init(parent: Parent, disposeKey: DisposeKey) {
  235|      6|        _parent = parent
  236|      6|        _disposeKey = disposeKey
  237|      6|    }
  238|       |    
  239|     12|    func on(_ event: Event<E>) {
  240|     12|        _parent._lock.lock(); defer { _parent._lock.unlock() } // lock {
  241|     12|            switch event {
  242|      6|            case .next(let value):
  243|      6|                _parent.forwardOn(.next(value))
  244|      0|            case .error(let error):
  245|      0|                _parent.forwardOn(.error(error))
  246|      0|                _parent.dispose()
  247|      6|            case .completed:
  248|      6|                _parent._group.remove(for: _disposeKey)
  249|      6|                _parent._activeCount -= 1
  250|      6|                _parent.checkCompleted()
  251|     12|            }
  252|     12|        // }
  253|     12|    }
  254|       |}
  255|       |
  256|       |
  257|       |fileprivate class MergeSink<SourceType, S: ObservableConvertibleType, O: ObserverType>
  258|       |    : Sink<O>
  259|       |    , ObserverType where O.E == S.E {
  260|       |    typealias ResultType = O.E
  261|       |    typealias Element = SourceType
  262|       |
  263|       |    let _lock = RecursiveLock()
  264|       |
  265|      6|    var subscribeNext: Bool {
  266|      6|        return true
  267|      6|    }
  268|       |
  269|       |    // state
  270|       |    let _group = CompositeDisposable()
  271|       |    let _sourceSubscription = SingleAssignmentDisposable()
  272|       |
  273|       |    var _activeCount = 0
  274|       |    var _stopped = false
  275|       |
  276|     14|    override init(observer: O, cancel: Cancelable) {
  277|     14|        super.init(observer: observer, cancel: cancel)
  278|     14|    }
  279|       |
  280|      0|    func performMap(_ element: SourceType) throws -> S {
  281|      0|        rxAbstractMethod()
  282|      0|    }
  283|       |    
  284|      8|    func on(_ event: Event<SourceType>) {
  285|      8|        _lock.lock(); defer { _lock.unlock() } // lock {
  286|      8|            switch event {
  287|      6|            case .next(let element):
  288|      0|                if !subscribeNext {
  289|      0|                    return
  290|      6|                }
  291|      6|                do {
  292|      6|                    let value = try performMap(element)
  293|      6|                    subscribeInner(value.asObservable())
  294|      6|                }
  295|      0|                catch let e {
  296|      0|                    forwardOn(.error(e))
  297|      0|                    dispose()
  298|      0|                }
  299|      0|            case .error(let error):
  300|      0|                forwardOn(.error(error))
  301|      0|                dispose()
  302|      2|            case .completed:
  303|      2|                _stopped = true
  304|      2|                _sourceSubscription.dispose()
  305|      2|                checkCompleted()
  306|      8|            }
  307|      8|        //}
  308|      8|    }
  309|       |
  310|      6|    func subscribeInner(_ source: Observable<O.E>) {
  311|      6|        let iterDisposable = SingleAssignmentDisposable()
  312|      6|        if let disposeKey = _group.insert(iterDisposable) {
  313|      6|            _activeCount += 1
  314|      6|            let iter = MergeSinkIter(parent: self, disposeKey: disposeKey)
  315|      6|            let subscription = source.subscribe(iter)
  316|      6|            iterDisposable.setDisposable(subscription)
  317|      6|        }
  318|      6|    }
  319|       |
  320|      0|    func run(_ sources: [SourceType]) -> Disposable {
  321|      0|        let _ = _group.insert(_sourceSubscription)
  322|      0|        _stopped = true
  323|      0|
  324|      0|        for source in sources {
  325|      0|            self.on(.next(source))
  326|      0|        }
  327|      0|
  328|      0|        checkCompleted()
  329|      0|
  330|      0|        return _group
  331|      0|    }
  332|       |
  333|       |    @inline(__always)
  334|      8|    func checkCompleted() {
  335|      2|        if _stopped && _activeCount == 0 {
  336|      2|            self.forwardOn(.completed)
  337|      2|            self.dispose()
  338|      8|        }
  339|      8|    }
  340|       |    
  341|     14|    func run(_ source: Observable<SourceType>) -> Disposable {
  342|     14|        let _ = _group.insert(_sourceSubscription)
  343|     14|
  344|     14|        let subscription = source.subscribe(self)
  345|     14|        _sourceSubscription.setDisposable(subscription)
  346|     14|        
  347|     14|        return _group
  348|     14|    }
  349|       |}
  350|       |
  351|       |// MARK: Producers
  352|       |
  353|       |final class FlatMap<SourceType, S: ObservableConvertibleType>: Producer<S.E> {
  354|       |    typealias Selector = (SourceType) throws -> S
  355|       |
  356|       |    private let _source: Observable<SourceType>
  357|       |    
  358|       |    private let _selector: Selector
  359|       |
  360|     14|    init(source: Observable<SourceType>, selector: @escaping Selector) {
  361|     14|        _source = source
  362|     14|        _selector = selector
  363|     14|    }
  364|       |    
  365|     14|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  366|     14|        let sink = FlatMapSink(selector: _selector, observer: observer, cancel: cancel)
  367|     14|        let subscription = sink.run(_source)
  368|     14|        return (sink: sink, subscription: subscription)
  369|     14|    }
  370|       |}
  371|       |
  372|       |final class FlatMapWithIndex<SourceType, S: ObservableConvertibleType>: Producer<S.E> {
  373|       |    typealias Selector = (SourceType, Int) throws -> S
  374|       |
  375|       |    private let _source: Observable<SourceType>
  376|       |    
  377|       |    private let _selector: Selector
  378|       |
  379|      0|    init(source: Observable<SourceType>, selector: @escaping Selector) {
  380|      0|        _source = source
  381|      0|        _selector = selector
  382|      0|    }
  383|       |    
  384|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  385|      0|        let sink = FlatMapWithIndexSink<SourceType, S, O>(selector: _selector, observer: observer, cancel: cancel)
  386|      0|        let subscription = sink.run(_source)
  387|      0|        return (sink: sink, subscription: subscription)
  388|      0|    }
  389|       |
  390|       |}
  391|       |
  392|       |final class FlatMapFirst<SourceType, S: ObservableConvertibleType>: Producer<S.E> {
  393|       |    typealias Selector = (SourceType) throws -> S
  394|       |
  395|       |    private let _source: Observable<SourceType>
  396|       |
  397|       |    private let _selector: Selector
  398|       |
  399|      0|    init(source: Observable<SourceType>, selector: @escaping Selector) {
  400|      0|        _source = source
  401|      0|        _selector = selector
  402|      0|    }
  403|       |
  404|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  405|      0|        let sink = FlatMapFirstSink<SourceType, S, O>(selector: _selector, observer: observer, cancel: cancel)
  406|      0|        let subscription = sink.run(_source)
  407|      0|        return (sink: sink, subscription: subscription)
  408|      0|    }
  409|       |}
  410|       |
  411|       |final class Merge<S: ObservableConvertibleType> : Producer<S.E> {
  412|       |    private let _source: Observable<S>
  413|       |
  414|      0|    init(source: Observable<S>) {
  415|      0|        _source = source
  416|      0|    }
  417|       |    
  418|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  419|      0|        let sink = MergeBasicSink<S, O>(observer: observer, cancel: cancel)
  420|      0|        let subscription = sink.run(_source)
  421|      0|        return (sink: sink, subscription: subscription)
  422|      0|    }
  423|       |}
  424|       |
  425|       |final class MergeArray<E> : Producer<E> {
  426|       |    private let _sources: [Observable<E>]
  427|       |
  428|      0|    init(sources: [Observable<E>]) {
  429|      0|        _sources = sources
  430|      0|    }
  431|       |
  432|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
  433|      0|        let sink = MergeBasicSink<Observable<E>, O>(observer: observer, cancel: cancel)
  434|      0|        let subscription = sink.run(_sources)
  435|      0|        return (sink: sink, subscription: subscription)
  436|      0|    }
  437|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Multicast.swift:
    1|       |//
    2|       |//  Multicast.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class MulticastSink<S: SubjectType, O: ObserverType>: Sink<O>, ObserverType {
   10|       |    typealias Element = O.E
   11|       |    typealias ResultType = Element
   12|       |    typealias MutlicastType = Multicast<S, O.E>
   13|       |    
   14|       |    private let _parent: MutlicastType
   15|       |    
   16|      0|    init(parent: MutlicastType, observer: O, cancel: Cancelable) {
   17|      0|        _parent = parent
   18|      0|        super.init(observer: observer, cancel: cancel)
   19|      0|    }
   20|       |    
   21|      0|    func run() -> Disposable {
   22|      0|        do {
   23|      0|            let subject = try _parent._subjectSelector()
   24|      0|            let connectable = ConnectableObservableAdapter(source: _parent._source, subject: subject)
   25|      0|            
   26|      0|            let observable = try _parent._selector(connectable)
   27|      0|            
   28|      0|            let subscription = observable.subscribe(self)
   29|      0|            let connection = connectable.connect()
   30|      0|                
   31|      0|            return Disposables.create(subscription, connection)
   32|      0|        }
   33|      0|        catch let e {
   34|      0|            forwardOn(.error(e))
   35|      0|            dispose()
   36|      0|            return Disposables.create()
   37|      0|        }
   38|      0|    }
   39|       |    
   40|      0|    func on(_ event: Event<ResultType>) {
   41|      0|        forwardOn(event)
   42|      0|        switch event {
   43|      0|            case .next: break
   44|      0|            case .error, .completed:
   45|      0|                dispose()
   46|      0|        }
   47|      0|    }
   48|       |}
   49|       |
   50|       |final class Multicast<S: SubjectType, R>: Producer<R> {
   51|       |    typealias SubjectSelectorType = () throws -> S
   52|       |    typealias SelectorType = (Observable<S.E>) throws -> Observable<R>
   53|       |    
   54|       |    fileprivate let _source: Observable<S.SubjectObserverType.E>
   55|       |    fileprivate let _subjectSelector: SubjectSelectorType
   56|       |    fileprivate let _selector: SelectorType
   57|       |    
   58|      0|    init(source: Observable<S.SubjectObserverType.E>, subjectSelector: @escaping SubjectSelectorType, selector: @escaping SelectorType) {
   59|      0|        _source = source
   60|      0|        _subjectSelector = subjectSelector
   61|      0|        _selector = selector
   62|      0|    }
   63|       |    
   64|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
   65|      0|        let sink = MulticastSink(parent: self, observer: observer, cancel: cancel)
   66|      0|        let subscription = sink.run()
   67|      0|        return (sink: sink, subscription: subscription)
   68|      0|    }
   69|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Never.swift:
    1|       |//
    2|       |//  Never.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class NeverProducer<Element> : Producer<Element> {
   10|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   11|      0|        return Disposables.create()
   12|      0|    }
   13|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ObserveOn.swift:
    1|       |//
    2|       |//  ObserveOn.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ObserveOn<E> : Producer<E> {
   10|       |    let scheduler: ImmediateSchedulerType
   11|       |    let source: Observable<E>
   12|       |    
   13|      0|    init(source: Observable<E>, scheduler: ImmediateSchedulerType) {
   14|      0|        self.scheduler = scheduler
   15|      0|        self.source = source
   16|      0|        
   17|      0|#if TRACE_RESOURCES
   18|      0|        let _ = Resources.incrementTotal()
   19|      0|#endif
   20|      0|    }
   21|       |    
   22|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   23|      0|        let sink = ObserveOnSink(scheduler: scheduler, observer: observer, cancel: cancel)
   24|      0|        let subscription = source.subscribe(sink)
   25|      0|        return (sink: sink, subscription: subscription)
   26|      0|    }
   27|       |    
   28|       |#if TRACE_RESOURCES
   29|       |    deinit {
   30|       |        let _ = Resources.decrementTotal()
   31|       |    }
   32|       |#endif
   33|       |}
   34|       |
   35|       |enum ObserveOnState : Int32 {
   36|       |    // pump is not running
   37|       |    case stopped = 0
   38|       |    // pump is running
   39|       |    case running = 1
   40|       |}
   41|       |
   42|       |final class ObserveOnSink<O: ObserverType> : ObserverBase<O.E> {
   43|       |    typealias E = O.E
   44|       |    
   45|       |    let _scheduler: ImmediateSchedulerType
   46|       |
   47|       |    var _lock = SpinLock()
   48|       |    let _observer: O
   49|       |
   50|       |    // state
   51|       |    var _state = ObserveOnState.stopped
   52|       |    var _queue = Queue<Event<E>>(capacity: 10)
   53|       |
   54|       |    let _scheduleDisposable = SerialDisposable()
   55|       |    let _cancel: Cancelable
   56|       |
   57|      0|    init(scheduler: ImmediateSchedulerType, observer: O, cancel: Cancelable) {
   58|      0|        _scheduler = scheduler
   59|      0|        _observer = observer
   60|      0|        _cancel = cancel
   61|      0|    }
   62|       |
   63|      0|    override func onCore(_ event: Event<E>) {
   64|      0|        let shouldStart = _lock.calculateLocked { () -> Bool in
   65|      0|            self._queue.enqueue(event)
   66|      0|            
   67|      0|            switch self._state {
   68|      0|            case .stopped:
   69|      0|                self._state = .running
   70|      0|                return true
   71|      0|            case .running:
   72|      0|                return false
   73|      0|            }
   74|      0|        }
   75|      0|        
   76|      0|        if shouldStart {
   77|      0|            _scheduleDisposable.disposable = self._scheduler.scheduleRecursive((), action: self.run)
   78|      0|        }
   79|      0|    }
   80|       |    
   81|      0|    func run(_ state: Void, recurse: (Void) -> Void) {
   82|      0|        let (nextEvent, observer) = self._lock.calculateLocked { () -> (Event<E>?, O) in
   83|      0|            if self._queue.count > 0 {
   84|      0|                return (self._queue.dequeue(), self._observer)
   85|      0|            }
   86|      0|            else {
   87|      0|                self._state = .stopped
   88|      0|                return (nil, self._observer)
   89|      0|            }
   90|      0|        }
   91|      0|        
   92|      0|        if let nextEvent = nextEvent, !_cancel.isDisposed {
   93|      0|            observer.on(nextEvent)
   94|      0|            if nextEvent.isStopEvent {
   95|      0|                dispose()
   96|      0|            }
   97|      0|        }
   98|      0|        else {
   99|      0|            return
  100|      0|        }
  101|      0|        
  102|      0|        let shouldContinue = _shouldContinue_synchronized()
  103|      0|        
  104|      0|        if shouldContinue {
  105|      0|            recurse()
  106|      0|        }
  107|      0|    }
  108|       |
  109|      0|    func _shouldContinue_synchronized() -> Bool {
  110|      0|        _lock.lock(); defer { _lock.unlock() } // {
  111|      0|            if self._queue.count > 0 {
  112|      0|                return true
  113|      0|            }
  114|      0|            else {
  115|      0|                self._state = .stopped
  116|      0|                return false
  117|      0|            }
  118|      0|        // }
  119|      0|    }
  120|       |    
  121|      0|    override func dispose() {
  122|      0|        super.dispose()
  123|      0|
  124|      0|        _cancel.dispose()
  125|      0|        _scheduleDisposable.dispose()
  126|      0|    }
  127|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ObserveOnSerialDispatchQueue.swift:
    1|       |//
    2|       |//  ObserveOnSerialDispatchQueue.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if TRACE_RESOURCES
   10|       |    fileprivate var _numberOfSerialDispatchQueueObservables: AtomicInt = 0
   11|       |    extension Resources {
   12|       |        /**
   13|       |        Counts number of `SerialDispatchQueueObservables`.
   14|       |
   15|       |        Purposed for unit tests.
   16|       |        */
   17|       |        public static var numberOfSerialDispatchQueueObservables: Int32 {
   18|       |            return _numberOfSerialDispatchQueueObservables.valueSnapshot()
   19|       |        }
   20|       |    }
   21|       |#endif
   22|       |
   23|       |final class ObserveOnSerialDispatchQueueSink<O: ObserverType> : ObserverBase<O.E> {
   24|       |    let scheduler: SerialDispatchQueueScheduler
   25|       |    let observer: O
   26|       |    
   27|       |    let cancel: Cancelable
   28|       |
   29|       |    var cachedScheduleLambda: ((ObserveOnSerialDispatchQueueSink<O>, Event<E>) -> Disposable)!
   30|       |
   31|     37|    init(scheduler: SerialDispatchQueueScheduler, observer: O, cancel: Cancelable) {
   32|     37|        self.scheduler = scheduler
   33|     37|        self.observer = observer
   34|     37|        self.cancel = cancel
   35|     37|        super.init()
   36|     37|
   37|     59|        cachedScheduleLambda = { sink, event in
   38|     59|            sink.observer.on(event)
   39|     59|
   40|      6|            if event.isStopEvent {
   41|      6|                sink.dispose()
   42|     59|            }
   43|     59|
   44|     59|            return Disposables.create()
   45|     59|        }
   46|     37|    }
   47|       |
   48|     82|    override func onCore(_ event: Event<E>) {
   49|     82|        let _ = self.scheduler.schedule((self, event), action: cachedScheduleLambda)
   50|     82|    }
   51|       |   
   52|     12|    override func dispose() {
   53|     12|        super.dispose()
   54|     12|
   55|     12|        cancel.dispose()
   56|     12|    }
   57|       |}
   58|       |    
   59|       |final class ObserveOnSerialDispatchQueue<E> : Producer<E> {
   60|       |    let scheduler: SerialDispatchQueueScheduler
   61|       |    let source: Observable<E>
   62|       |    
   63|     42|    init(source: Observable<E>, scheduler: SerialDispatchQueueScheduler) {
   64|     42|        self.scheduler = scheduler
   65|     42|        self.source = source
   66|     42|        
   67|     42|#if TRACE_RESOURCES
   68|     42|        let _ = Resources.incrementTotal()
   69|     42|        let _ = AtomicIncrement(&_numberOfSerialDispatchQueueObservables)
   70|     42|#endif
   71|     42|    }
   72|       |    
   73|     37|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   74|     37|        let sink = ObserveOnSerialDispatchQueueSink(scheduler: scheduler, observer: observer, cancel: cancel)
   75|     37|        let subscription = source.subscribe(sink)
   76|     37|        return (sink: sink, subscription: subscription)
   77|     37|    }
   78|       |    
   79|       |#if TRACE_RESOURCES
   80|       |    deinit {
   81|       |        let _ = Resources.decrementTotal()
   82|       |        let _ = AtomicDecrement(&_numberOfSerialDispatchQueueObservables)
   83|       |    }
   84|       |#endif
   85|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Optional.swift:
    1|       |//
    2|       |//  Optional.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by tarunon on 2016/12/13.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ObservableOptionalScheduledSink<O: ObserverType> : Sink<O> {
   10|       |    typealias E = O.E
   11|       |    typealias Parent = ObservableOptionalScheduled<E>
   12|       |
   13|       |    private let _parent: Parent
   14|       |
   15|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   16|      0|        _parent = parent
   17|      0|        super.init(observer: observer, cancel: cancel)
   18|      0|    }
   19|       |
   20|      0|    func run() -> Disposable {
   21|      0|        return _parent._scheduler.schedule(_parent._optional) { (optional: E?) -> Disposable in
   22|      0|            if let next = optional {
   23|      0|                self.forwardOn(.next(next))
   24|      0|                return self._parent._scheduler.schedule(()) { _ in
   25|      0|                    self.forwardOn(.completed)
   26|      0|                    self.dispose()
   27|      0|                    return Disposables.create()
   28|      0|                }
   29|      0|            } else {
   30|      0|                self.forwardOn(.completed)
   31|      0|                self.dispose()
   32|      0|                return Disposables.create()
   33|      0|            }
   34|      0|        }
   35|      0|    }
   36|       |}
   37|       |
   38|       |final class ObservableOptionalScheduled<E> : Producer<E> {
   39|       |    fileprivate let _optional: E?
   40|       |    fileprivate let _scheduler: ImmediateSchedulerType
   41|       |
   42|      0|    init(optional: E?, scheduler: ImmediateSchedulerType) {
   43|      0|        _optional = optional
   44|      0|        _scheduler = scheduler
   45|      0|    }
   46|       |
   47|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   48|      0|        let sink = ObservableOptionalScheduledSink(parent: self, observer: observer, cancel: cancel)
   49|      0|        let subscription = sink.run()
   50|      0|        return (sink: sink, subscription: subscription)
   51|      0|    }
   52|       |}
   53|       |
   54|       |final class ObservableOptional<E>: Producer<E> {
   55|       |    private let _optional: E?
   56|       |    
   57|      0|    init(optional: E?) {
   58|      0|        _optional = optional
   59|      0|    }
   60|       |    
   61|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   62|      0|        if let element = _optional {
   63|      0|            observer.on(.next(element))
   64|      0|        }
   65|      0|        observer.on(.completed)
   66|      0|        return Disposables.create()
   67|      0|    }
   68|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Producer.swift:
    1|       |//
    2|       |//  Producer.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/20/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class Producer<Element> : Observable<Element> {
   10|  2.10k|    override init() {
   11|  2.10k|        super.init()
   12|  2.10k|    }
   13|       |    
   14|  2.00k|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   15|  1.64k|        if !CurrentThreadScheduler.isScheduleRequired {
   16|  1.64k|            // The returned disposable needs to release all references once it was disposed.
   17|  1.64k|            let disposer = SinkDisposer()
   18|  1.64k|            let sinkAndSubscription = run(observer, cancel: disposer)
   19|  1.64k|            disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)
   20|  1.64k|
   21|  1.64k|            return disposer
   22|    352|        }
   23|    352|        else {
   24|    352|            return CurrentThreadScheduler.instance.schedule(()) { _ in
   25|    352|                let disposer = SinkDisposer()
   26|    352|                let sinkAndSubscription = self.run(observer, cancel: disposer)
   27|    352|                disposer.setSinkAndSubscription(sink: sinkAndSubscription.sink, subscription: sinkAndSubscription.subscription)
   28|    352|
   29|    352|                return disposer
   30|    352|            }
   31|      0|        }
   32|      0|    }
   33|       |    
   34|      0|    func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   35|      0|        rxAbstractMethod()
   36|      0|    }
   37|       |}
   38|       |
   39|       |fileprivate final class SinkDisposer: Cancelable {
   40|       |    fileprivate enum DisposeState: UInt32 {
   41|       |        case disposed = 1
   42|       |        case sinkAndSubscriptionSet = 2
   43|       |    }
   44|       |
   45|       |    // Jeej, swift API consistency rules
   46|       |    fileprivate enum DisposeStateInt32: Int32 {
   47|       |        case disposed = 1
   48|       |        case sinkAndSubscriptionSet = 2
   49|       |    }
   50|       |    
   51|       |    private var _state: AtomicInt = 0
   52|       |    private var _sink: Disposable? = nil
   53|       |    private var _subscription: Disposable? = nil
   54|       |
   55|      0|    var isDisposed: Bool {
   56|      0|        return AtomicFlagSet(DisposeState.disposed.rawValue, &_state)
   57|      0|    }
   58|       |
   59|  2.00k|    func setSinkAndSubscription(sink: Disposable, subscription: Disposable) {
   60|  2.00k|        _sink = sink
   61|  2.00k|        _subscription = subscription
   62|  2.00k|
   63|  2.00k|        let previousState = AtomicOr(DisposeState.sinkAndSubscriptionSet.rawValue, &_state)
   64|      0|        if (previousState & DisposeStateInt32.sinkAndSubscriptionSet.rawValue) != 0 {
   65|      0|            rxFatalError("Sink and subscription were already set")
   66|  2.00k|        }
   67|  2.00k|
   68|      0|        if (previousState & DisposeStateInt32.disposed.rawValue) != 0 {
   69|      0|            sink.dispose()
   70|      0|            subscription.dispose()
   71|      0|            _sink = nil
   72|      0|            _subscription = nil
   73|  2.00k|        }
   74|  2.00k|    }
   75|       |    
   76|    126|    func dispose() {
   77|    126|        let previousState = AtomicOr(DisposeState.disposed.rawValue, &_state)
   78|    126|
   79|     79|        if (previousState & DisposeStateInt32.disposed.rawValue) != 0 {
   80|     79|            return
   81|     47|        }
   82|     47|
   83|     47|        if (previousState & DisposeStateInt32.sinkAndSubscriptionSet.rawValue) != 0 {
   84|      0|            guard let sink = _sink else {
   85|      0|                rxFatalError("Sink not set")
   86|     47|            }
   87|      0|            guard let subscription = _subscription else {
   88|      0|                rxFatalError("Subscription not set")
   89|     47|            }
   90|     47|
   91|     47|            sink.dispose()
   92|     47|            subscription.dispose()
   93|     47|
   94|     47|            _sink = nil
   95|     47|            _subscription = nil
   96|     47|        }
   97|     47|    }
   98|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Range.swift:
    1|       |//
    2|       |//  Range.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class RangeProducer<E: SignedInteger> : Producer<E> {
   10|       |    fileprivate let _start: E
   11|       |    fileprivate let _count: E
   12|       |    fileprivate let _scheduler: ImmediateSchedulerType
   13|       |
   14|      0|    init(start: E, count: E, scheduler: ImmediateSchedulerType) {
   15|      0|        if count < 0 {
   16|      0|            rxFatalError("count can't be negative")
   17|      0|        }
   18|      0|
   19|      0|        if start &+ (count - 1) < start {
   20|      0|            rxFatalError("overflow of count")
   21|      0|        }
   22|      0|
   23|      0|        _start = start
   24|      0|        _count = count
   25|      0|        _scheduler = scheduler
   26|      0|    }
   27|       |    
   28|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   29|      0|        let sink = RangeSink(parent: self, observer: observer, cancel: cancel)
   30|      0|        let subscription = sink.run()
   31|      0|        return (sink: sink, subscription: subscription)
   32|      0|    }
   33|       |}
   34|       |
   35|       |final class RangeSink<O: ObserverType> : Sink<O> where O.E: SignedInteger {
   36|       |    typealias Parent = RangeProducer<O.E>
   37|       |    
   38|       |    private let _parent: Parent
   39|       |    
   40|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   41|      0|        _parent = parent
   42|      0|        super.init(observer: observer, cancel: cancel)
   43|      0|    }
   44|       |    
   45|      0|    func run() -> Disposable {
   46|      0|        return _parent._scheduler.scheduleRecursive(0 as O.E) { i, recurse in
   47|      0|            if i < self._parent._count {
   48|      0|                self.forwardOn(.next(self._parent._start + i))
   49|      0|                recurse(i + 1)
   50|      0|            }
   51|      0|            else {
   52|      0|                self.forwardOn(.completed)
   53|      0|                self.dispose()
   54|      0|            }
   55|      0|        }
   56|      0|    }
   57|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Reduce.swift:
    1|       |//
    2|       |//  Reduce.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ReduceSink<SourceType, AccumulateType, O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias ResultType = O.E
   11|       |    typealias Parent = Reduce<SourceType, AccumulateType, ResultType>
   12|       |    
   13|       |    private let _parent: Parent
   14|       |    private var _accumulation: AccumulateType
   15|       |    
   16|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   17|      0|        _parent = parent
   18|      0|        _accumulation = parent._seed
   19|      0|        
   20|      0|        super.init(observer: observer, cancel: cancel)
   21|      0|    }
   22|       |    
   23|      0|    func on(_ event: Event<SourceType>) {
   24|      0|        switch event {
   25|      0|        case .next(let value):
   26|      0|            do {
   27|      0|                _accumulation = try _parent._accumulator(_accumulation, value)
   28|      0|            }
   29|      0|            catch let e {
   30|      0|                forwardOn(.error(e))
   31|      0|                dispose()
   32|      0|            }
   33|      0|        case .error(let e):
   34|      0|            forwardOn(.error(e))
   35|      0|            dispose()
   36|      0|        case .completed:
   37|      0|            do {
   38|      0|                let result = try _parent._mapResult(_accumulation)
   39|      0|                forwardOn(.next(result))
   40|      0|                forwardOn(.completed)
   41|      0|                dispose()
   42|      0|            }
   43|      0|            catch let e {
   44|      0|                forwardOn(.error(e))
   45|      0|                dispose()
   46|      0|            }
   47|      0|        }
   48|      0|    }
   49|       |}
   50|       |
   51|       |final class Reduce<SourceType, AccumulateType, ResultType> : Producer<ResultType> {
   52|       |    typealias AccumulatorType = (AccumulateType, SourceType) throws -> AccumulateType
   53|       |    typealias ResultSelectorType = (AccumulateType) throws -> ResultType
   54|       |    
   55|       |    fileprivate let _source: Observable<SourceType>
   56|       |    fileprivate let _seed: AccumulateType
   57|       |    fileprivate let _accumulator: AccumulatorType
   58|       |    fileprivate let _mapResult: ResultSelectorType
   59|       |    
   60|      0|    init(source: Observable<SourceType>, seed: AccumulateType, accumulator: @escaping AccumulatorType, mapResult: @escaping ResultSelectorType) {
   61|      0|        _source = source
   62|      0|        _seed = seed
   63|      0|        _accumulator = accumulator
   64|      0|        _mapResult = mapResult
   65|      0|    }
   66|       |
   67|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
   68|      0|        let sink = ReduceSink(parent: self, observer: observer, cancel: cancel)
   69|      0|        let subscription = _source.subscribe(sink)
   70|      0|        return (sink: sink, subscription: subscription)
   71|      0|    }
   72|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/RefCount.swift:
    1|       |//
    2|       |//  RefCount.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/5/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class RefCountSink<CO: ConnectableObservableType, O: ObserverType>
   10|       |    : Sink<O>
   11|       |    , ObserverType where CO.E == O.E {
   12|       |    typealias Element = O.E
   13|       |    typealias Parent = RefCount<CO>
   14|       |    
   15|       |    private let _parent: Parent
   16|       |
   17|     42|    init(parent: Parent, observer: O, cancel: Cancelable) {
   18|     42|        _parent = parent
   19|     42|        super.init(observer: observer, cancel: cancel)
   20|     42|    }
   21|       |    
   22|     42|    func run() -> Disposable {
   23|     42|        let subscription = _parent._source.subscribe(self)
   24|     42|        
   25|     42|        _parent._lock.lock(); defer { _parent._lock.unlock() } // {
   26|     42|            if _parent._count == 0 {
   27|     42|                _parent._count = 1
   28|     42|                _parent._connectableSubscription = _parent._source.connect()
   29|     42|            }
   30|      0|            else {
   31|      0|                _parent._count = _parent._count + 1
   32|     42|            }
   33|     42|        // }
   34|     42|        
   35|      0|        return Disposables.create {
   36|      0|            subscription.dispose()
   37|      0|            self._parent._lock.lock(); defer { self._parent._lock.unlock() } // {
   38|      0|                if self._parent._count == 1 {
   39|      0|                    self._parent._count = 0
   40|      0|                    guard let connectableSubscription = self._parent._connectableSubscription else {
   41|      0|                        return
   42|      0|                    }
   43|      0|
   44|      0|                    connectableSubscription.dispose()
   45|      0|                    self._parent._connectableSubscription = nil
   46|      0|                }
   47|      0|                else if self._parent._count > 1 {
   48|      0|                    self._parent._count = self._parent._count - 1
   49|      0|                }
   50|      0|                else {
   51|      0|                    rxFatalError("Something went wrong with RefCount disposing mechanism")
   52|      0|                }
   53|      0|            // }
   54|      0|        }
   55|     42|    }
   56|       |
   57|      0|    func on(_ event: Event<Element>) {
   58|      0|        switch event {
   59|      0|        case .next:
   60|      0|            forwardOn(event)
   61|      0|        case .error, .completed:
   62|      0|            forwardOn(event)
   63|      0|            dispose()
   64|      0|        }
   65|      0|    }
   66|       |}
   67|       |
   68|       |final class RefCount<CO: ConnectableObservableType>: Producer<CO.E> {
   69|       |    fileprivate let _lock = RecursiveLock()
   70|       |    
   71|       |    // state
   72|       |    fileprivate var _count = 0
   73|       |    fileprivate var _connectableSubscription = nil as Disposable?
   74|       |    
   75|       |    fileprivate let _source: CO
   76|       |    
   77|     42|    init(source: CO) {
   78|     42|        _source = source
   79|     42|    }
   80|       |    
   81|     42|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == CO.E {
   82|     42|        let sink = RefCountSink(parent: self, observer: observer, cancel: cancel)
   83|     42|        let subscription = sink.run()
   84|     42|        return (sink: sink, subscription: subscription)
   85|     42|    }
   86|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Repeat.swift:
    1|       |//
    2|       |//  Repeat.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class RepeatElement<Element> : Producer<Element> {
   10|       |    fileprivate let _element: Element
   11|       |    fileprivate let _scheduler: ImmediateSchedulerType
   12|       |    
   13|      0|    init(element: Element, scheduler: ImmediateSchedulerType) {
   14|      0|        _element = element
   15|      0|        _scheduler = scheduler
   16|      0|    }
   17|       |    
   18|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   19|      0|        let sink = RepeatElementSink(parent: self, observer: observer, cancel: cancel)
   20|      0|        let subscription = sink.run()
   21|      0|
   22|      0|        return (sink: sink, subscription: subscription)
   23|      0|    }
   24|       |}
   25|       |
   26|       |final class RepeatElementSink<O: ObserverType> : Sink<O> {
   27|       |    typealias Parent = RepeatElement<O.E>
   28|       |    
   29|       |    private let _parent: Parent
   30|       |    
   31|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   32|      0|        _parent = parent
   33|      0|        super.init(observer: observer, cancel: cancel)
   34|      0|    }
   35|       |    
   36|      0|    func run() -> Disposable {
   37|      0|        return _parent._scheduler.scheduleRecursive(_parent._element) { e, recurse in
   38|      0|            self.forwardOn(.next(e))
   39|      0|            recurse(e)
   40|      0|        }
   41|      0|    }
   42|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/RetryWhen.swift:
    1|       |//
    2|       |//  RetryWhen.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 06/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class RetryTriggerSink<S: Sequence, O: ObserverType, TriggerObservable: ObservableType, Error>
   10|       |    : ObserverType where S.Iterator.Element : ObservableType, S.Iterator.Element.E == O.E {
   11|       |    typealias E = TriggerObservable.E
   12|       |    
   13|       |    typealias Parent = RetryWhenSequenceSinkIter<S, O, TriggerObservable, Error>
   14|       |    
   15|       |    fileprivate let _parent: Parent
   16|       |
   17|      0|    init(parent: Parent) {
   18|      0|        _parent = parent
   19|      0|    }
   20|       |
   21|      0|    func on(_ event: Event<E>) {
   22|      0|        switch event {
   23|      0|        case .next:
   24|      0|            _parent._parent._lastError = nil
   25|      0|            _parent._parent.schedule(.moveNext)
   26|      0|        case .error(let e):
   27|      0|            _parent._parent.forwardOn(.error(e))
   28|      0|            _parent._parent.dispose()
   29|      0|        case .completed:
   30|      0|            _parent._parent.forwardOn(.completed)
   31|      0|            _parent._parent.dispose()
   32|      0|        }
   33|      0|    }
   34|       |}
   35|       |
   36|       |final class RetryWhenSequenceSinkIter<S: Sequence, O: ObserverType, TriggerObservable: ObservableType, Error>
   37|       |    : ObserverType
   38|       |    , Disposable where S.Iterator.Element : ObservableType, S.Iterator.Element.E == O.E {
   39|       |    typealias E = O.E
   40|       |    typealias Parent = RetryWhenSequenceSink<S, O, TriggerObservable, Error>
   41|       |
   42|       |    fileprivate let _parent: Parent
   43|       |    fileprivate let _errorHandlerSubscription = SingleAssignmentDisposable()
   44|       |    fileprivate let _subscription: Disposable
   45|       |
   46|      0|    init(parent: Parent, subscription: Disposable) {
   47|      0|        _parent = parent
   48|      0|        _subscription = subscription
   49|      0|    }
   50|       |
   51|      0|    func on(_ event: Event<E>) {
   52|      0|        switch event {
   53|      0|        case .next:
   54|      0|            _parent.forwardOn(event)
   55|      0|        case .error(let error):
   56|      0|            _parent._lastError = error
   57|      0|
   58|      0|            if let failedWith = error as? Error {
   59|      0|                // dispose current subscription
   60|      0|                _subscription.dispose()
   61|      0|
   62|      0|                let errorHandlerSubscription = _parent._notifier.subscribe(RetryTriggerSink(parent: self))
   63|      0|                _errorHandlerSubscription.setDisposable(errorHandlerSubscription)
   64|      0|                _parent._errorSubject.on(.next(failedWith))
   65|      0|            }
   66|      0|            else {
   67|      0|                _parent.forwardOn(.error(error))
   68|      0|                _parent.dispose()
   69|      0|            }
   70|      0|        case .completed:
   71|      0|            _parent.forwardOn(event)
   72|      0|            _parent.dispose()
   73|      0|        }
   74|      0|    }
   75|       |
   76|      0|    final func dispose() {
   77|      0|        _subscription.dispose()
   78|      0|        _errorHandlerSubscription.dispose()
   79|      0|    }
   80|       |}
   81|       |
   82|       |final class RetryWhenSequenceSink<S: Sequence, O: ObserverType, TriggerObservable: ObservableType, Error>
   83|       |    : TailRecursiveSink<S, O> where S.Iterator.Element : ObservableType, S.Iterator.Element.E == O.E {
   84|       |    typealias Element = O.E
   85|       |    typealias Parent = RetryWhenSequence<S, TriggerObservable, Error>
   86|       |    
   87|       |    let _lock = RecursiveLock()
   88|       |    
   89|       |    fileprivate let _parent: Parent
   90|       |    
   91|       |    fileprivate var _lastError: Swift.Error?
   92|       |    fileprivate let _errorSubject = PublishSubject<Error>()
   93|       |    fileprivate let _handler: Observable<TriggerObservable.E>
   94|       |    fileprivate let _notifier = PublishSubject<TriggerObservable.E>()
   95|       |
   96|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   97|      0|        _parent = parent
   98|      0|        _handler = parent._notificationHandler(_errorSubject).asObservable()
   99|      0|        super.init(observer: observer, cancel: cancel)
  100|      0|    }
  101|       |    
  102|      0|    override func done() {
  103|      0|        if let lastError = _lastError {
  104|      0|            forwardOn(.error(lastError))
  105|      0|            _lastError = nil
  106|      0|        }
  107|      0|        else {
  108|      0|            forwardOn(.completed)
  109|      0|        }
  110|      0|
  111|      0|        dispose()
  112|      0|    }
  113|       |    
  114|      0|    override func extract(_ observable: Observable<E>) -> SequenceGenerator? {
  115|      0|        // It is important to always return `nil` here because there are sideffects in the `run` method
  116|      0|        // that are dependant on particular `retryWhen` operator so single operator stack can't be reused in this
  117|      0|        // case.
  118|      0|        return nil
  119|      0|    }
  120|       |
  121|      0|    override func subscribeToNext(_ source: Observable<E>) -> Disposable {
  122|      0|        let subscription = SingleAssignmentDisposable()
  123|      0|        let iter = RetryWhenSequenceSinkIter(parent: self, subscription: subscription)
  124|      0|        subscription.setDisposable(source.subscribe(iter))
  125|      0|        return iter
  126|      0|    }
  127|       |
  128|      0|    override func run(_ sources: SequenceGenerator) -> Disposable {
  129|      0|        let triggerSubscription = _handler.subscribe(_notifier.asObserver())
  130|      0|        let superSubscription = super.run(sources)
  131|      0|        return Disposables.create(superSubscription, triggerSubscription)
  132|      0|    }
  133|       |}
  134|       |
  135|       |final class RetryWhenSequence<S: Sequence, TriggerObservable: ObservableType, Error> : Producer<S.Iterator.Element.E> where S.Iterator.Element : ObservableType {
  136|       |    typealias Element = S.Iterator.Element.E
  137|       |    
  138|       |    fileprivate let _sources: S
  139|       |    fileprivate let _notificationHandler: (Observable<Error>) -> TriggerObservable
  140|       |    
  141|      0|    init(sources: S, notificationHandler: @escaping (Observable<Error>) -> TriggerObservable) {
  142|      0|        _sources = sources
  143|      0|        _notificationHandler = notificationHandler
  144|      0|    }
  145|       |    
  146|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  147|      0|        let sink = RetryWhenSequenceSink<S, O, TriggerObservable, Error>(parent: self, observer: observer, cancel: cancel)
  148|      0|        let subscription = sink.run((self._sources.makeIterator(), nil))
  149|      0|        return (sink: sink, subscription: subscription)
  150|      0|    }
  151|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Sample.swift:
    1|       |//
    2|       |//  Sample.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class SamplerSink<O: ObserverType, SampleType>
   10|       |    : ObserverType
   11|       |    , LockOwnerType
   12|       |    , SynchronizedOnType {
   13|       |    typealias E = SampleType
   14|       |    
   15|       |    typealias Parent = SampleSequenceSink<O, SampleType>
   16|       |    
   17|       |    fileprivate let _parent: Parent
   18|       |
   19|      0|    var _lock: RecursiveLock {
   20|      0|        return _parent._lock
   21|      0|    }
   22|       |    
   23|      0|    init(parent: Parent) {
   24|      0|        _parent = parent
   25|      0|    }
   26|       |    
   27|      0|    func on(_ event: Event<E>) {
   28|      0|        synchronizedOn(event)
   29|      0|    }
   30|       |
   31|      0|    func _synchronized_on(_ event: Event<E>) {
   32|      0|        switch event {
   33|      0|        case .next:
   34|      0|            if let element = _parent._element {
   35|      0|                _parent._element = nil
   36|      0|                _parent.forwardOn(.next(element))
   37|      0|            }
   38|      0|
   39|      0|            if _parent._atEnd {
   40|      0|                _parent.forwardOn(.completed)
   41|      0|                _parent.dispose()
   42|      0|            }
   43|      0|        case .error(let e):
   44|      0|            _parent.forwardOn(.error(e))
   45|      0|            _parent.dispose()
   46|      0|        case .completed:
   47|      0|            if let element = _parent._element {
   48|      0|                _parent._element = nil
   49|      0|                _parent.forwardOn(.next(element))
   50|      0|            }
   51|      0|            if _parent._atEnd {
   52|      0|                _parent.forwardOn(.completed)
   53|      0|                _parent.dispose()
   54|      0|            }
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |
   59|       |final class SampleSequenceSink<O: ObserverType, SampleType>
   60|       |    : Sink<O>
   61|       |    , ObserverType
   62|       |    , LockOwnerType
   63|       |    , SynchronizedOnType {
   64|       |    typealias Element = O.E
   65|       |    typealias Parent = Sample<Element, SampleType>
   66|       |    
   67|       |    fileprivate let _parent: Parent
   68|       |
   69|       |    let _lock = RecursiveLock()
   70|       |    
   71|       |    // state
   72|       |    fileprivate var _element = nil as Element?
   73|       |    fileprivate var _atEnd = false
   74|       |    
   75|       |    fileprivate let _sourceSubscription = SingleAssignmentDisposable()
   76|       |    
   77|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   78|      0|        _parent = parent
   79|      0|        super.init(observer: observer, cancel: cancel)
   80|      0|    }
   81|       |    
   82|      0|    func run() -> Disposable {
   83|      0|        _sourceSubscription.setDisposable(_parent._source.subscribe(self))
   84|      0|        let samplerSubscription = _parent._sampler.subscribe(SamplerSink(parent: self))
   85|      0|        
   86|      0|        return Disposables.create(_sourceSubscription, samplerSubscription)
   87|      0|    }
   88|       |    
   89|      0|    func on(_ event: Event<Element>) {
   90|      0|        synchronizedOn(event)
   91|      0|    }
   92|       |
   93|      0|    func _synchronized_on(_ event: Event<Element>) {
   94|      0|        switch event {
   95|      0|        case .next(let element):
   96|      0|            _element = element
   97|      0|        case .error:
   98|      0|            forwardOn(event)
   99|      0|            dispose()
  100|      0|        case .completed:
  101|      0|            _atEnd = true
  102|      0|            _sourceSubscription.dispose()
  103|      0|        }
  104|      0|    }
  105|       |    
  106|       |}
  107|       |
  108|       |final class Sample<Element, SampleType> : Producer<Element> {
  109|       |    fileprivate let _source: Observable<Element>
  110|       |    fileprivate let _sampler: Observable<SampleType>
  111|       |
  112|      0|    init(source: Observable<Element>, sampler: Observable<SampleType>) {
  113|      0|        _source = source
  114|      0|        _sampler = sampler
  115|      0|    }
  116|       |    
  117|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  118|      0|        let sink = SampleSequenceSink(parent: self, observer: observer, cancel: cancel)
  119|      0|        let subscription = sink.run()
  120|      0|        return (sink: sink, subscription: subscription)
  121|      0|    }
  122|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Scan.swift:
    1|       |//
    2|       |//  Scan.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ScanSink<ElementType, O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias Accumulate = O.E
   11|       |    typealias Parent = Scan<ElementType, Accumulate>
   12|       |    typealias E = ElementType
   13|       |    
   14|       |    fileprivate let _parent: Parent
   15|       |    fileprivate var _accumulate: Accumulate
   16|       |    
   17|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   18|      0|        _parent = parent
   19|      0|        _accumulate = parent._seed
   20|      0|        super.init(observer: observer, cancel: cancel)
   21|      0|    }
   22|       |    
   23|      0|    func on(_ event: Event<ElementType>) {
   24|      0|        switch event {
   25|      0|        case .next(let element):
   26|      0|            do {
   27|      0|                _accumulate = try _parent._accumulator(_accumulate, element)
   28|      0|                forwardOn(.next(_accumulate))
   29|      0|            }
   30|      0|            catch let error {
   31|      0|                forwardOn(.error(error))
   32|      0|                dispose()
   33|      0|            }
   34|      0|        case .error(let error):
   35|      0|            forwardOn(.error(error))
   36|      0|            dispose()
   37|      0|        case .completed:
   38|      0|            forwardOn(.completed)
   39|      0|            dispose()
   40|      0|        }
   41|      0|    }
   42|       |    
   43|       |}
   44|       |
   45|       |final class Scan<Element, Accumulate>: Producer<Accumulate> {
   46|       |    typealias Accumulator = (Accumulate, Element) throws -> Accumulate
   47|       |    
   48|       |    fileprivate let _source: Observable<Element>
   49|       |    fileprivate let _seed: Accumulate
   50|       |    fileprivate let _accumulator: Accumulator
   51|       |    
   52|      0|    init(source: Observable<Element>, seed: Accumulate, accumulator: @escaping Accumulator) {
   53|      0|        _source = source
   54|      0|        _seed = seed
   55|      0|        _accumulator = accumulator
   56|      0|    }
   57|       |    
   58|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Accumulate {
   59|      0|        let sink = ScanSink(parent: self, observer: observer, cancel: cancel)
   60|      0|        let subscription = _source.subscribe(sink)
   61|      0|        return (sink: sink, subscription: subscription)
   62|      0|    }
   63|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Sequence.swift:
    1|       |//
    2|       |//  Sequence.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ObservableSequenceSink<S: Sequence, O: ObserverType> : Sink<O> where S.Iterator.Element == O.E {
   10|       |    typealias Parent = ObservableSequence<S>
   11|       |
   12|       |    private let _parent: Parent
   13|       |
   14|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   15|      0|        _parent = parent
   16|      0|        super.init(observer: observer, cancel: cancel)
   17|      0|    }
   18|       |
   19|      0|    func run() -> Disposable {
   20|      0|        return _parent._scheduler.scheduleRecursive((_parent._elements.makeIterator(), _parent._elements)) { (iterator, recurse) in
   21|      0|            var mutableIterator = iterator
   22|      0|            if let next = mutableIterator.0.next() {
   23|      0|                self.forwardOn(.next(next))
   24|      0|                recurse(mutableIterator)
   25|      0|            }
   26|      0|            else {
   27|      0|                self.forwardOn(.completed)
   28|      0|                self.dispose()
   29|      0|            }
   30|      0|        }
   31|      0|    }
   32|       |}
   33|       |
   34|       |final class ObservableSequence<S: Sequence> : Producer<S.Iterator.Element> {
   35|       |    fileprivate let _elements: S
   36|       |    fileprivate let _scheduler: ImmediateSchedulerType
   37|       |
   38|      0|    init(elements: S, scheduler: ImmediateSchedulerType) {
   39|      0|        _elements = elements
   40|      0|        _scheduler = scheduler
   41|      0|    }
   42|       |
   43|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   44|      0|        let sink = ObservableSequenceSink(parent: self, observer: observer, cancel: cancel)
   45|      0|        let subscription = sink.run()
   46|      0|        return (sink: sink, subscription: subscription)
   47|      0|    }
   48|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ShareReplay1.swift:
    1|       |//
    2|       |//  ShareReplay1.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// optimized version of share replay for most common case
   10|       |final class ShareReplay1<Element>
   11|       |    : Observable<Element>
   12|       |    , ObserverType
   13|       |    , SynchronizedUnsubscribeType {
   14|       |
   15|       |    typealias Observers = AnyObserver<Element>.s
   16|       |    typealias DisposeKey = Observers.KeyType
   17|       |
   18|       |    private let _source: Observable<Element>
   19|       |
   20|       |    private let _lock = RecursiveLock()
   21|       |
   22|       |    private var _connection: SingleAssignmentDisposable?
   23|       |    private var _element: Element?
   24|       |    private var _stopped = false
   25|       |    private var _stopEvent = nil as Event<Element>?
   26|       |    private var _observers = Observers()
   27|       |
   28|    250|    init(source: Observable<Element>) {
   29|    250|        self._source = source
   30|    250|    }
   31|       |
   32|    318|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   33|    318|        _lock.lock()
   34|    318|        let result = _synchronized_subscribe(observer)
   35|    318|        _lock.unlock()
   36|    318|        return result
   37|    318|    }
   38|       |
   39|    318|    func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   40|     68|        if let element = self._element {
   41|     68|            observer.on(.next(element))
   42|    318|        }
   43|    318|
   44|      0|        if let stopEvent = self._stopEvent {
   45|      0|            observer.on(stopEvent)
   46|      0|            return Disposables.create()
   47|    318|        }
   48|    318|
   49|    318|        let initialCount = self._observers.count
   50|    318|
   51|    318|        let disposeKey = self._observers.insert(observer.on)
   52|    318|
   53|    250|        if initialCount == 0 {
   54|    250|            let connection = SingleAssignmentDisposable()
   55|    250|            _connection = connection
   56|    250|
   57|    250|            connection.setDisposable(self._source.subscribe(self))
   58|    318|        }
   59|    318|
   60|    318|        return SubscriptionDisposable(owner: self, key: disposeKey)
   61|    318|    }
   62|       |
   63|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
   64|      0|        _lock.lock()
   65|      0|        _synchronized_unsubscribe(disposeKey)
   66|      0|        _lock.unlock()
   67|      0|    }
   68|       |
   69|      0|    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
   70|      0|        // if already unsubscribed, just return
   71|      0|        if self._observers.removeKey(disposeKey) == nil {
   72|      0|            return
   73|      0|        }
   74|      0|
   75|      0|        if _observers.count == 0 {
   76|      0|            _connection?.dispose()
   77|      0|            _connection = nil
   78|      0|        }
   79|      0|    }
   80|       |
   81|    252|    func on(_ event: Event<E>) {
   82|    252|        dispatch(_synchronized_on(event), event)
   83|    252|    }
   84|       |
   85|    252|    func _synchronized_on(_ event: Event<E>) -> Observers {
   86|    252|        _lock.lock(); defer { _lock.unlock() }
   87|      0|        if _stopped {
   88|      0|            return Observers()
   89|    252|        }
   90|    252|
   91|    252|        switch event {
   92|    252|        case .next(let element):
   93|    252|            _element = element
   94|      0|        case .error, .completed:
   95|      0|            _stopEvent = event
   96|      0|            _stopped = true
   97|      0|            _connection?.dispose()
   98|      0|            _connection = nil
   99|    252|        }
  100|    252|        
  101|    252|        return _observers
  102|    252|    }
  103|       |    
  104|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ShareReplay1WhileConnected.swift:
    1|       |//
    2|       |//  ShareReplay1WhileConnected.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class ShareReplay1WhileConnectedConnection<Element>
   10|       |    : ObserverType
   11|       |    , SynchronizedUnsubscribeType {
   12|       |    typealias E = Element
   13|       |    typealias Observers = AnyObserver<Element>.s
   14|       |    typealias DisposeKey = Observers.KeyType
   15|       |
   16|       |    typealias Parent = ShareReplay1WhileConnected<Element>
   17|       |    private let _parent: Parent
   18|       |    private let _subscription = SingleAssignmentDisposable()
   19|       |
   20|       |    private let _lock: RecursiveLock
   21|       |    private var _disposed: Bool = false
   22|       |    fileprivate var _observers = Observers()
   23|       |    fileprivate var _element: Element?
   24|       |
   25|     21|    init(parent: Parent, lock: RecursiveLock) {
   26|     21|        _parent = parent
   27|     21|        _lock = lock
   28|     21|
   29|     21|        #if TRACE_RESOURCES
   30|     21|            _ = Resources.incrementTotal()
   31|     21|        #endif
   32|     21|    }
   33|       |
   34|      4|    final func on(_ event: Event<E>) {
   35|      4|        _lock.lock()
   36|      4|        let observers = _synchronized_on(event)
   37|      4|        _lock.unlock()
   38|      4|        dispatch(observers, event)
   39|      4|    }
   40|       |
   41|      4|    final private func _synchronized_on(_ event: Event<E>) -> Observers {
   42|      0|        if _disposed {
   43|      0|            return Observers()
   44|      4|        }
   45|      4|
   46|      4|        switch event {
   47|      4|        case .next(let element):
   48|      4|            _element = element
   49|      4|            return _observers
   50|      0|        case .error, .completed:
   51|      0|            let observers = _observers
   52|      0|            self._synchronized_dispose()
   53|      0|            return observers
   54|      4|        }
   55|      4|    }
   56|       |
   57|     21|    final func connect() {
   58|     21|        _subscription.setDisposable(_parent._source.subscribe(self))
   59|     21|    }
   60|       |
   61|     21|    final func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   62|     21|        _lock.lock(); defer { _lock.unlock() }
   63|      0|        if let element = _element {
   64|      0|            observer.on(.next(element))
   65|     21|        }
   66|     21|
   67|     21|        let disposeKey = _observers.insert(observer.on)
   68|     21|
   69|     21|        return SubscriptionDisposable(owner: self, key: disposeKey)
   70|     21|    }
   71|       |
   72|      0|    final private func _synchronized_dispose() {
   73|      0|        _disposed = true
   74|      0|        if _parent._connection === self {
   75|      0|            _parent._connection = nil
   76|      0|        }
   77|      0|        _observers = Observers()
   78|      0|        _subscription.dispose()
   79|      0|    }
   80|       |
   81|      0|    final func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
   82|      0|        _lock.lock()
   83|      0|        _synchronized_unsubscribe(disposeKey)
   84|      0|        _lock.unlock()
   85|      0|    }
   86|       |
   87|       |    @inline(__always)
   88|      0|    final private func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
   89|      0|        // if already unsubscribed, just return
   90|      0|        if self._observers.removeKey(disposeKey) == nil {
   91|      0|            return
   92|      0|        }
   93|      0|
   94|      0|        if _observers.count == 0 {
   95|      0|            _synchronized_dispose()
   96|      0|        }
   97|      0|    }
   98|       |
   99|       |    #if TRACE_RESOURCES
  100|       |        deinit {
  101|       |            _ = Resources.decrementTotal()
  102|       |        }
  103|       |    #endif
  104|       |}
  105|       |
  106|       |// optimized version of share replay for most common case
  107|       |final class ShareReplay1WhileConnected<Element>
  108|       |    : Observable<Element> {
  109|       |
  110|       |    fileprivate typealias Connection = ShareReplay1WhileConnectedConnection<Element>
  111|       |
  112|       |    fileprivate let _source: Observable<Element>
  113|       |
  114|       |    fileprivate let _lock = RecursiveLock()
  115|       |
  116|       |    fileprivate var _connection: Connection?
  117|       |
  118|     31|    init(source: Observable<Element>) {
  119|     31|        self._source = source
  120|     31|    }
  121|       |
  122|     21|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
  123|     21|        _lock.lock()
  124|     21|
  125|     21|        let connection = _synchronized_subscribe(observer)
  126|     21|        let count = connection._observers.count
  127|     21|
  128|     21|        let disposable = connection._synchronized_subscribe(observer)
  129|     21|        
  130|     21|        if count == 0 {
  131|     21|            connection.connect()
  132|     21|        }
  133|     21|
  134|     21|        _lock.unlock()
  135|     21|
  136|     21|        return disposable
  137|     21|    }
  138|       |
  139|       |    @inline(__always)
  140|     21|    private func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Connection where O.E == E {
  141|     21|        let connection: Connection
  142|     21|
  143|      0|        if let existingConnection = _connection {
  144|      0|            connection = existingConnection
  145|     21|        }
  146|     21|        else {
  147|     21|            connection = ShareReplay1WhileConnectedConnection<Element>(
  148|     21|                parent: self,
  149|     21|                lock: _lock)
  150|     21|            _connection = connection
  151|     21|        }
  152|     21|
  153|     21|        return connection
  154|     21|    }
  155|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/SingleAsync.swift:
    1|       |//
    2|       |//  SingleAsync.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 09/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate final class SingleAsyncSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias ElementType = O.E
   11|       |    typealias Parent = SingleAsync<ElementType>
   12|       |    typealias E = ElementType
   13|       |    
   14|       |    private let _parent: Parent
   15|       |    private var _seenValue: Bool = false
   16|       |    
   17|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   18|      0|        _parent = parent
   19|      0|        super.init(observer: observer, cancel: cancel)
   20|      0|    }
   21|       |    
   22|      0|    func on(_ event: Event<E>) {
   23|      0|        switch event {
   24|      0|        case .next(let value):
   25|      0|            do {
   26|      0|                let forward = try _parent._predicate?(value) ?? true
   27|      0|                if !forward {
   28|      0|                    return
   29|      0|                }
   30|      0|            }
   31|      0|            catch let error {
   32|      0|                forwardOn(.error(error as Swift.Error))
   33|      0|                dispose()
   34|      0|                return
   35|      0|            }
   36|      0|
   37|      0|            if _seenValue {
   38|      0|                forwardOn(.error(RxError.moreThanOneElement))
   39|      0|                dispose()
   40|      0|                return
   41|      0|            }
   42|      0|
   43|      0|            _seenValue = true
   44|      0|            forwardOn(.next(value))
   45|      0|        case .error:
   46|      0|            forwardOn(event)
   47|      0|            dispose()
   48|      0|        case .completed:
   49|      0|            if (_seenValue) {
   50|      0|                forwardOn(.completed)
   51|      0|            } else {
   52|      0|                forwardOn(.error(RxError.noElements))
   53|      0|            }
   54|      0|            dispose()
   55|      0|        }
   56|      0|    }
   57|       |}
   58|       |
   59|       |final class SingleAsync<Element>: Producer<Element> {
   60|       |    typealias Predicate = (Element) throws -> Bool
   61|       |    
   62|       |    fileprivate let _source: Observable<Element>
   63|       |    fileprivate let _predicate: Predicate?
   64|       |    
   65|      0|    init(source: Observable<Element>, predicate: Predicate? = nil) {
   66|      0|        _source = source
   67|      0|        _predicate = predicate
   68|      0|    }
   69|       |    
   70|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   71|      0|        let sink = SingleAsyncSink(parent: self, observer: observer, cancel: cancel)
   72|      0|        let subscription = _source.subscribe(sink)
   73|      0|        return (sink: sink, subscription: subscription)
   74|      0|    }
   75|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Sink.swift:
    1|       |//
    2|       |//  Sink.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class Sink<O : ObserverType> : Disposable {
   10|       |    fileprivate let _observer: O
   11|       |    fileprivate let _cancel: Cancelable
   12|       |    fileprivate var _disposed: Bool
   13|       |
   14|       |    #if DEBUG
   15|       |        fileprivate var _numberOfConcurrentCalls: AtomicInt = 0
   16|       |    #endif
   17|       |
   18|  1.96k|    init(observer: O, cancel: Cancelable) {
   19|  1.96k|#if TRACE_RESOURCES
   20|  1.96k|        let _ = Resources.incrementTotal()
   21|  1.96k|#endif
   22|  1.96k|        _observer = observer
   23|  1.96k|        _cancel = cancel
   24|  1.96k|        _disposed = false
   25|  1.96k|    }
   26|       |    
   27|  1.23k|    final func forwardOn(_ event: Event<O.E>) {
   28|  1.23k|        #if DEBUG
   29|      0|            if AtomicIncrement(&_numberOfConcurrentCalls) > 1 {
   30|      0|                rxFatalError("Warning: Recursive call or synchronization error!")
   31|  1.23k|            }
   32|  1.23k|
   33|  1.23k|            defer {
   34|  1.23k|                _ = AtomicDecrement(&_numberOfConcurrentCalls)
   35|  1.23k|            }
   36|  1.23k|        #endif
   37|      0|        if _disposed {
   38|      0|            return
   39|  1.23k|        }
   40|  1.23k|        _observer.on(event)
   41|  1.23k|    }
   42|       |    
   43|      0|    final func forwarder() -> SinkForward<O> {
   44|      0|        return SinkForward(forward: self)
   45|      0|    }
   46|       |
   47|      0|    final var disposed: Bool {
   48|      0|        return _disposed
   49|      0|    }
   50|       |
   51|     79|    func dispose() {
   52|     79|        _disposed = true
   53|     79|        _cancel.dispose()
   54|     79|    }
   55|       |
   56|     35|    deinit {
   57|     35|#if TRACE_RESOURCES
   58|     35|       let _ =  Resources.decrementTotal()
   59|     35|#endif
   60|     35|    }
   61|       |}
   62|       |
   63|       |final class SinkForward<O: ObserverType>: ObserverType {
   64|       |    typealias E = O.E
   65|       |    
   66|       |    private let _forward: Sink<O>
   67|       |    
   68|      0|    init(forward: Sink<O>) {
   69|      0|        _forward = forward
   70|      0|    }
   71|       |    
   72|      0|    final func on(_ event: Event<E>) {
   73|      0|        switch event {
   74|      0|        case .next:
   75|      0|            _forward._observer.on(event)
   76|      0|        case .error, .completed:
   77|      0|            _forward._observer.on(event)
   78|      0|            _forward._cancel.dispose()
   79|      0|        }
   80|      0|    }
   81|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Skip.swift:
    1|       |//
    2|       |//  Skip.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/25/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// count version
   10|       |
   11|       |final class SkipCountSink<O: ObserverType> : Sink<O>, ObserverType {
   12|       |    typealias Element = O.E
   13|       |    typealias Parent = SkipCount<Element>
   14|       |    
   15|       |    let parent: Parent
   16|       |    
   17|       |    var remaining: Int
   18|       |    
   19|     14|    init(parent: Parent, observer: O, cancel: Cancelable) {
   20|     14|        self.parent = parent
   21|     14|        self.remaining = parent.count
   22|     14|        super.init(observer: observer, cancel: cancel)
   23|     14|    }
   24|       |    
   25|     10|    func on(_ event: Event<Element>) {
   26|     10|        switch event {
   27|     10|        case .next(let value):
   28|     10|            
   29|      1|            if remaining <= 0 {
   30|      1|                forwardOn(.next(value))
   31|     10|            }
   32|      9|            else {
   33|      9|                remaining -= 1
   34|      9|            }
   35|      0|        case .error:
   36|      0|            forwardOn(event)
   37|      0|            self.dispose()
   38|      0|        case .completed:
   39|      0|            forwardOn(event)
   40|      0|            self.dispose()
   41|     10|        }
   42|     10|    }
   43|       |    
   44|       |}
   45|       |
   46|       |final class SkipCount<Element>: Producer<Element> {
   47|       |    let source: Observable<Element>
   48|       |    let count: Int
   49|       |    
   50|     14|    init(source: Observable<Element>, count: Int) {
   51|     14|        self.source = source
   52|     14|        self.count = count
   53|     14|    }
   54|       |    
   55|     14|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   56|     14|        let sink = SkipCountSink(parent: self, observer: observer, cancel: cancel)
   57|     14|        let subscription = source.subscribe(sink)
   58|     14|
   59|     14|        return (sink: sink, subscription: subscription)
   60|     14|    }
   61|       |}
   62|       |
   63|       |// time version
   64|       |
   65|       |final class SkipTimeSink<ElementType, O: ObserverType> : Sink<O>, ObserverType where O.E == ElementType {
   66|       |    typealias Parent = SkipTime<ElementType>
   67|       |    typealias Element = ElementType
   68|       |
   69|       |    let parent: Parent
   70|       |    
   71|       |    // state
   72|       |    var open = false
   73|       |    
   74|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   75|      0|        self.parent = parent
   76|      0|        super.init(observer: observer, cancel: cancel)
   77|      0|    }
   78|       |    
   79|      0|    func on(_ event: Event<Element>) {
   80|      0|        switch event {
   81|      0|        case .next(let value):
   82|      0|            if open {
   83|      0|                forwardOn(.next(value))
   84|      0|            }
   85|      0|        case .error:
   86|      0|            forwardOn(event)
   87|      0|            self.dispose()
   88|      0|        case .completed:
   89|      0|            forwardOn(event)
   90|      0|            self.dispose()
   91|      0|        }
   92|      0|    }
   93|       |    
   94|      0|    func tick() {
   95|      0|        open = true
   96|      0|    }
   97|       |    
   98|      0|    func run() -> Disposable {
   99|      0|        let disposeTimer = parent.scheduler.scheduleRelative((), dueTime: self.parent.duration) {
  100|      0|            self.tick()
  101|      0|            return Disposables.create()
  102|      0|        }
  103|      0|        
  104|      0|        let disposeSubscription = parent.source.subscribe(self)
  105|      0|        
  106|      0|        return Disposables.create(disposeTimer, disposeSubscription)
  107|      0|    }
  108|       |}
  109|       |
  110|       |final class SkipTime<Element>: Producer<Element> {
  111|       |    let source: Observable<Element>
  112|       |    let duration: RxTimeInterval
  113|       |    let scheduler: SchedulerType
  114|       |    
  115|      0|    init(source: Observable<Element>, duration: RxTimeInterval, scheduler: SchedulerType) {
  116|      0|        self.source = source
  117|      0|        self.scheduler = scheduler
  118|      0|        self.duration = duration
  119|      0|    }
  120|       |    
  121|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  122|      0|        let sink = SkipTimeSink(parent: self, observer: observer, cancel: cancel)
  123|      0|        let subscription = sink.run()
  124|      0|        return (sink: sink, subscription: subscription)
  125|      0|    }
  126|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/SkipUntil.swift:
    1|       |//
    2|       |//  SkipUntil.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/3/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class SkipUntilSinkOther<Other, O: ObserverType>
   10|       |    : ObserverType
   11|       |    , LockOwnerType
   12|       |    , SynchronizedOnType {
   13|       |    typealias Parent = SkipUntilSink<Other, O>
   14|       |    typealias E = Other
   15|       |    
   16|       |    fileprivate let _parent: Parent
   17|       |
   18|      0|    var _lock: RecursiveLock {
   19|      0|        return _parent._lock
   20|      0|    }
   21|       |    
   22|       |    let _subscription = SingleAssignmentDisposable()
   23|       |
   24|      0|    init(parent: Parent) {
   25|      0|        _parent = parent
   26|      0|        #if TRACE_RESOURCES
   27|      0|            let _ = Resources.incrementTotal()
   28|      0|        #endif
   29|      0|    }
   30|       |
   31|      0|    func on(_ event: Event<E>) {
   32|      0|        synchronizedOn(event)
   33|      0|    }
   34|       |
   35|      0|    func _synchronized_on(_ event: Event<E>) {
   36|      0|        switch event {
   37|      0|        case .next:
   38|      0|            _parent._forwardElements = true
   39|      0|            _subscription.dispose()
   40|      0|        case .error(let e):
   41|      0|            _parent.forwardOn(.error(e))
   42|      0|            _parent.dispose()
   43|      0|        case .completed:
   44|      0|            _subscription.dispose()
   45|      0|        }
   46|      0|    }
   47|       |    
   48|       |    #if TRACE_RESOURCES
   49|       |    deinit {
   50|       |        let _ = Resources.decrementTotal()
   51|       |    }
   52|       |    #endif
   53|       |
   54|       |}
   55|       |
   56|       |
   57|       |final class SkipUntilSink<Other, O: ObserverType>
   58|       |    : Sink<O>
   59|       |    , ObserverType
   60|       |    , LockOwnerType
   61|       |    , SynchronizedOnType {
   62|       |    typealias E = O.E
   63|       |    typealias Parent = SkipUntil<E, Other>
   64|       |    
   65|       |    let _lock = RecursiveLock()
   66|       |    fileprivate let _parent: Parent
   67|       |    fileprivate var _forwardElements = false
   68|       |    
   69|       |    fileprivate let _sourceSubscription = SingleAssignmentDisposable()
   70|       |
   71|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   72|      0|        _parent = parent
   73|      0|        super.init(observer: observer, cancel: cancel)
   74|      0|    }
   75|       |    
   76|      0|    func on(_ event: Event<E>) {
   77|      0|        synchronizedOn(event)
   78|      0|    }
   79|       |
   80|      0|    func _synchronized_on(_ event: Event<E>) {
   81|      0|        switch event {
   82|      0|        case .next:
   83|      0|            if _forwardElements {
   84|      0|                forwardOn(event)
   85|      0|            }
   86|      0|        case .error:
   87|      0|            forwardOn(event)
   88|      0|            self.dispose()
   89|      0|        case .completed:
   90|      0|            if _forwardElements {
   91|      0|                forwardOn(event)
   92|      0|            }
   93|      0|            self.dispose()
   94|      0|        }
   95|      0|    }
   96|       |    
   97|      0|    func run() -> Disposable {
   98|      0|        let sourceSubscription = _parent._source.subscribe(self)
   99|      0|        let otherObserver = SkipUntilSinkOther(parent: self)
  100|      0|        let otherSubscription = _parent._other.subscribe(otherObserver)
  101|      0|        _sourceSubscription.setDisposable(sourceSubscription)
  102|      0|        otherObserver._subscription.setDisposable(otherSubscription)
  103|      0|        
  104|      0|        return Disposables.create(_sourceSubscription, otherObserver._subscription)
  105|      0|    }
  106|       |}
  107|       |
  108|       |final class SkipUntil<Element, Other>: Producer<Element> {
  109|       |    
  110|       |    fileprivate let _source: Observable<Element>
  111|       |    fileprivate let _other: Observable<Other>
  112|       |    
  113|      0|    init(source: Observable<Element>, other: Observable<Other>) {
  114|      0|        _source = source
  115|      0|        _other = other
  116|      0|    }
  117|       |    
  118|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  119|      0|        let sink = SkipUntilSink(parent: self, observer: observer, cancel: cancel)
  120|      0|        let subscription = sink.run()
  121|      0|        return (sink: sink, subscription: subscription)
  122|      0|    }
  123|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/SkipWhile.swift:
    1|       |//
    2|       |//  SkipWhile.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/9/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class SkipWhileSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |
   11|       |    typealias Element = O.E
   12|       |    typealias Parent = SkipWhile<Element>
   13|       |
   14|       |    fileprivate let _parent: Parent
   15|       |    fileprivate var _running = false
   16|       |
   17|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   18|      0|        _parent = parent
   19|      0|        super.init(observer: observer, cancel: cancel)
   20|      0|    }
   21|       |
   22|      0|    func on(_ event: Event<Element>) {
   23|      0|        switch event {
   24|      0|        case .next(let value):
   25|      0|            if !_running {
   26|      0|                do {
   27|      0|                    _running = try !_parent._predicate(value)
   28|      0|                } catch let e {
   29|      0|                    forwardOn(.error(e))
   30|      0|                    dispose()
   31|      0|                    return
   32|      0|                }
   33|      0|            }
   34|      0|
   35|      0|            if _running {
   36|      0|                forwardOn(.next(value))
   37|      0|            }
   38|      0|        case .error, .completed:
   39|      0|            forwardOn(event)
   40|      0|            dispose()
   41|      0|        }
   42|      0|    }
   43|       |}
   44|       |
   45|       |final class SkipWhileSinkWithIndex<O: ObserverType> : Sink<O>, ObserverType {
   46|       |
   47|       |    typealias Element = O.E
   48|       |    typealias Parent = SkipWhile<Element>
   49|       |
   50|       |    fileprivate let _parent: Parent
   51|       |    fileprivate var _index = 0
   52|       |    fileprivate var _running = false
   53|       |
   54|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   55|      0|        _parent = parent
   56|      0|        super.init(observer: observer, cancel: cancel)
   57|      0|    }
   58|       |
   59|      0|    func on(_ event: Event<Element>) {
   60|      0|        switch event {
   61|      0|        case .next(let value):
   62|      0|            if !_running {
   63|      0|                do {
   64|      0|                    _running = try !_parent._predicateWithIndex(value, _index)
   65|      0|                    let _ = try incrementChecked(&_index)
   66|      0|                } catch let e {
   67|      0|                    forwardOn(.error(e))
   68|      0|                    dispose()
   69|      0|                    return
   70|      0|                }
   71|      0|            }
   72|      0|
   73|      0|            if _running {
   74|      0|                forwardOn(.next(value))
   75|      0|            }
   76|      0|        case .error, .completed:
   77|      0|            forwardOn(event)
   78|      0|            dispose()
   79|      0|        }
   80|      0|    }
   81|       |}
   82|       |
   83|       |final class SkipWhile<Element>: Producer<Element> {
   84|       |    typealias Predicate = (Element) throws -> Bool
   85|       |    typealias PredicateWithIndex = (Element, Int) throws -> Bool
   86|       |
   87|       |    fileprivate let _source: Observable<Element>
   88|       |    fileprivate let _predicate: Predicate!
   89|       |    fileprivate let _predicateWithIndex: PredicateWithIndex!
   90|       |
   91|      0|    init(source: Observable<Element>, predicate: @escaping Predicate) {
   92|      0|        _source = source
   93|      0|        _predicate = predicate
   94|      0|        _predicateWithIndex = nil
   95|      0|    }
   96|       |
   97|      0|    init(source: Observable<Element>, predicate: @escaping PredicateWithIndex) {
   98|      0|        _source = source
   99|      0|        _predicate = nil
  100|      0|        _predicateWithIndex = predicate
  101|      0|    }
  102|       |
  103|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  104|      0|        if let _ = _predicate {
  105|      0|            let sink = SkipWhileSink(parent: self, observer: observer, cancel: cancel)
  106|      0|            let subscription = _source.subscribe(sink)
  107|      0|            return (sink: sink, subscription: subscription)
  108|      0|        }
  109|      0|        else {
  110|      0|            let sink = SkipWhileSinkWithIndex(parent: self, observer: observer, cancel: cancel)
  111|      0|            let subscription = _source.subscribe(sink)
  112|      0|            return (sink: sink, subscription: subscription)
  113|      0|        }
  114|      0|    }
  115|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/StartWith.swift:
    1|       |//
    2|       |//  StartWith.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class StartWith<Element>: Producer<Element> {
   10|       |    let elements: [Element]
   11|       |    let source: Observable<Element>
   12|       |
   13|      0|    init(source: Observable<Element>, elements: [Element]) {
   14|      0|        self.source = source
   15|      0|        self.elements = elements
   16|      0|        super.init()
   17|      0|    }
   18|       |
   19|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   20|      0|        for e in elements {
   21|      0|            observer.on(.next(e))
   22|      0|        }
   23|      0|
   24|      0|        return (sink: Disposables.create(), subscription: source.subscribe(observer))
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/SubscribeOn.swift:
    1|       |//
    2|       |//  SubscribeOn.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class SubscribeOnSink<Ob: ObservableType, O: ObserverType> : Sink<O>, ObserverType where Ob.E == O.E {
   10|       |    typealias Element = O.E
   11|       |    typealias Parent = SubscribeOn<Ob>
   12|       |    
   13|       |    let parent: Parent
   14|       |    
   15|    594|    init(parent: Parent, observer: O, cancel: Cancelable) {
   16|    594|        self.parent = parent
   17|    594|        super.init(observer: observer, cancel: cancel)
   18|    594|    }
   19|       |    
   20|    302|    func on(_ event: Event<Element>) {
   21|    302|        forwardOn(event)
   22|    302|        
   23|      0|        if event.isStopEvent {
   24|      0|            self.dispose()
   25|    302|        }
   26|    302|    }
   27|       |    
   28|    594|    func run() -> Disposable {
   29|    594|        let disposeEverything = SerialDisposable()
   30|    594|        let cancelSchedule = SingleAssignmentDisposable()
   31|    594|        
   32|    594|        disposeEverything.disposable = cancelSchedule
   33|    594|        
   34|    594|        let disposeSchedule = parent.scheduler.schedule(()) { (_) -> Disposable in
   35|    594|            let subscription = self.parent.source.subscribe(self)
   36|    594|            disposeEverything.disposable = ScheduledDisposable(scheduler: self.parent.scheduler, disposable: subscription)
   37|    594|            return Disposables.create()
   38|    594|        }
   39|    594|
   40|    594|        cancelSchedule.setDisposable(disposeSchedule)
   41|    594|    
   42|    594|        return disposeEverything
   43|    594|    }
   44|       |}
   45|       |
   46|       |final class SubscribeOn<Ob: ObservableType> : Producer<Ob.E> {
   47|       |    let source: Ob
   48|       |    let scheduler: ImmediateSchedulerType
   49|       |    
   50|    594|    init(source: Ob, scheduler: ImmediateSchedulerType) {
   51|    594|        self.source = source
   52|    594|        self.scheduler = scheduler
   53|    594|    }
   54|       |    
   55|    594|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Ob.E {
   56|    594|        let sink = SubscribeOnSink(parent: self, observer: observer, cancel: cancel)
   57|    594|        let subscription = sink.run()
   58|    594|        return (sink: sink, subscription: subscription)
   59|    594|    }
   60|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Switch.swift:
    1|       |//
    2|       |//  Switch.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class SwitchSink<SourceType, S: ObservableConvertibleType, O: ObserverType>
   10|       |    : Sink<O>
   11|       |    , ObserverType
   12|       |    , LockOwnerType
   13|       |    , SynchronizedOnType where S.E == O.E {
   14|       |    typealias E = SourceType
   15|       |
   16|       |    fileprivate let _subscriptions: SingleAssignmentDisposable = SingleAssignmentDisposable()
   17|       |    fileprivate let _innerSubscription: SerialDisposable = SerialDisposable()
   18|       |
   19|       |    let _lock = RecursiveLock()
   20|       |    
   21|       |    // state
   22|       |    fileprivate var _stopped = false
   23|       |    fileprivate var _latest = 0
   24|       |    fileprivate var _hasLatest = false
   25|       |    
   26|     43|    override init(observer: O, cancel: Cancelable) {
   27|     43|        super.init(observer: observer, cancel: cancel)
   28|     43|    }
   29|       |    
   30|     43|    func run(_ source: Observable<SourceType>) -> Disposable {
   31|     43|        let subscription = source.subscribe(self)
   32|     43|        _subscriptions.setDisposable(subscription)
   33|     43|        return Disposables.create(_subscriptions, _innerSubscription)
   34|     43|    }
   35|       |    
   36|     45|    func on(_ event: Event<E>) {
   37|     45|        synchronizedOn(event)
   38|     45|    }
   39|       |
   40|      0|    func performMap(_ element: SourceType) throws -> S {
   41|      0|        rxAbstractMethod()
   42|      0|    }
   43|       |
   44|     45|    func _synchronized_on(_ event: Event<E>) {
   45|     45|        switch event {
   46|     43|        case .next(let element):
   47|     43|            do {
   48|     43|                let observable = try performMap(element).asObservable()
   49|     43|                _hasLatest = true
   50|     43|                _latest = _latest &+ 1
   51|     43|                let latest = _latest
   52|     43|
   53|     43|                let d = SingleAssignmentDisposable()
   54|     43|                _innerSubscription.disposable = d
   55|     43|                   
   56|     43|                let observer = SwitchSinkIter(parent: self, id: latest, _self: d)
   57|     43|                let disposable = observable.subscribe(observer)
   58|     43|                d.setDisposable(disposable)
   59|     43|            }
   60|      0|            catch let error {
   61|      0|                forwardOn(.error(error))
   62|      0|                dispose()
   63|      0|            }
   64|      0|        case .error(let error):
   65|      0|            forwardOn(.error(error))
   66|      0|            dispose()
   67|      2|        case .completed:
   68|      2|            _stopped = true
   69|      2|            
   70|      2|            _subscriptions.dispose()
   71|      2|            
   72|      2|            if !_hasLatest {
   73|      2|                forwardOn(.completed)
   74|      2|                dispose()
   75|      2|            }
   76|     45|        }
   77|     45|    }
   78|       |}
   79|       |
   80|       |final class SwitchSinkIter<SourceType, S: ObservableConvertibleType, O: ObserverType>
   81|       |    : ObserverType
   82|       |    , LockOwnerType
   83|       |    , SynchronizedOnType where S.E == O.E {
   84|       |    typealias E = S.E
   85|       |    typealias Parent = SwitchSink<SourceType, S, O>
   86|       |    
   87|       |    fileprivate let _parent: Parent
   88|       |    fileprivate let _id: Int
   89|       |    fileprivate let _self: Disposable
   90|       |
   91|    172|    var _lock: RecursiveLock {
   92|    172|        return _parent._lock
   93|    172|    }
   94|       |
   95|     43|    init(parent: Parent, id: Int, _self: Disposable) {
   96|     43|        _parent = parent
   97|     43|        _id = id
   98|     43|        self._self = _self
   99|     43|    }
  100|       |    
  101|     86|    func on(_ event: Event<E>) {
  102|     86|        synchronizedOn(event)
  103|     86|    }
  104|       |
  105|     86|    func _synchronized_on(_ event: Event<E>) {
  106|     86|        switch event {
  107|     43|        case .next: break
  108|     43|        case .error, .completed:
  109|     43|            _self.dispose()
  110|     86|        }
  111|     86|        
  112|      0|        if _parent._latest != _id {
  113|      0|            return
  114|     86|        }
  115|     86|       
  116|     86|        switch event {
  117|     43|        case .next:
  118|     43|            _parent.forwardOn(event)
  119|      0|        case .error:
  120|      0|            _parent.forwardOn(event)
  121|      0|            _parent.dispose()
  122|     43|        case .completed:
  123|     43|            _parent._hasLatest = false
  124|      0|            if _parent._stopped {
  125|      0|                _parent.forwardOn(event)
  126|      0|                _parent.dispose()
  127|      0|            }
  128|     86|        }
  129|     86|    }
  130|       |}
  131|       |
  132|       |// MARK: Specializations
  133|       |
  134|       |final class SwitchIdentitySink<S: ObservableConvertibleType, O: ObserverType> : SwitchSink<S, S, O> where O.E == S.E {
  135|      0|    override init(observer: O, cancel: Cancelable) {
  136|      0|        super.init(observer: observer, cancel: cancel)
  137|      0|    }
  138|       |
  139|      0|    override func performMap(_ element: S) throws -> S {
  140|      0|        return element
  141|      0|    }
  142|       |}
  143|       |
  144|       |final class MapSwitchSink<SourceType, S: ObservableConvertibleType, O: ObserverType> : SwitchSink<SourceType, S, O> where O.E == S.E {
  145|       |    typealias Selector = (SourceType) throws -> S
  146|       |
  147|       |    fileprivate let _selector: Selector
  148|       |
  149|     43|    init(selector: @escaping Selector, observer: O, cancel: Cancelable) {
  150|     43|        _selector = selector
  151|     43|        super.init(observer: observer, cancel: cancel)
  152|     43|    }
  153|       |
  154|     43|    override func performMap(_ element: SourceType) throws -> S {
  155|     43|        return try _selector(element)
  156|     43|    }
  157|       |}
  158|       |
  159|       |// MARK: Producers
  160|       |
  161|       |final class Switch<S: ObservableConvertibleType> : Producer<S.E> {
  162|       |    fileprivate let _source: Observable<S>
  163|       |    
  164|      0|    init(source: Observable<S>) {
  165|      0|        _source = source
  166|      0|    }
  167|       |    
  168|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  169|      0|        let sink = SwitchIdentitySink<S, O>(observer: observer, cancel: cancel)
  170|      0|        let subscription = sink.run(_source)
  171|      0|        return (sink: sink, subscription: subscription)
  172|      0|    }
  173|       |}
  174|       |
  175|       |final class FlatMapLatest<SourceType, S: ObservableConvertibleType> : Producer<S.E> {
  176|       |    typealias Selector = (SourceType) throws -> S
  177|       |
  178|       |    fileprivate let _source: Observable<SourceType>
  179|       |    fileprivate let _selector: Selector
  180|       |
  181|     43|    init(source: Observable<SourceType>, selector: @escaping Selector) {
  182|     43|        _source = source
  183|     43|        _selector = selector
  184|     43|    }
  185|       |
  186|     43|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == S.E {
  187|     43|        let sink = MapSwitchSink<SourceType, S, O>(selector: _selector, observer: observer, cancel: cancel)
  188|     43|        let subscription = sink.run(_source)
  189|     43|        return (sink: sink, subscription: subscription)
  190|     43|    }
  191|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/SwitchIfEmpty.swift:
    1|       |//
    2|       |//  SwitchIfEmpty.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by sergdort on 23/12/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class SwitchIfEmpty<Element>: Producer<Element> {
   10|       |    
   11|       |    private let _source: Observable<E>
   12|       |    private let _ifEmpty: Observable<E>
   13|       |    
   14|      0|    init(source: Observable<E>, ifEmpty: Observable<E>) {
   15|      0|        _source = source
   16|      0|        _ifEmpty = ifEmpty
   17|      0|    }
   18|       |    
   19|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   20|      0|        let sink = SwitchIfEmptySink(ifEmpty: _ifEmpty,
   21|      0|                                     observer: observer,
   22|      0|                                     cancel: cancel)
   23|      0|        let subscription = sink.run(_source.asObservable())
   24|      0|        
   25|      0|        return (sink: sink, subscription: subscription)
   26|      0|    }
   27|       |}
   28|       |
   29|       |final class SwitchIfEmptySink<O: ObserverType>: Sink<O>
   30|       |    , ObserverType {
   31|       |    typealias E = O.E
   32|       |    
   33|       |    private let _ifEmpty: Observable<E>
   34|       |    private var _isEmpty = true
   35|       |    private let _ifEmptySubscription = SingleAssignmentDisposable()
   36|       |    
   37|      0|    init(ifEmpty: Observable<E>, observer: O, cancel: Cancelable) {
   38|      0|        _ifEmpty = ifEmpty
   39|      0|        super.init(observer: observer, cancel: cancel)
   40|      0|    }
   41|       |    
   42|      0|    func run(_ source: Observable<O.E>) -> Disposable {
   43|      0|        let subscription = source.subscribe(self)
   44|      0|        return Disposables.create(subscription, _ifEmptySubscription)
   45|      0|    }
   46|       |    
   47|      0|    func on(_ event: Event<E>) {
   48|      0|        switch event {
   49|      0|        case .next:
   50|      0|            _isEmpty = false
   51|      0|            forwardOn(event)
   52|      0|        case .error:
   53|      0|            forwardOn(event)
   54|      0|            dispose()
   55|      0|        case .completed:
   56|      0|            guard _isEmpty else {
   57|      0|                forwardOn(.completed)
   58|      0|                dispose()
   59|      0|                return
   60|      0|            }
   61|      0|            let ifEmptySink = SwitchIfEmptySinkIter(parent: self)
   62|      0|            _ifEmptySubscription.setDisposable(_ifEmpty.subscribe(ifEmptySink))
   63|      0|        }
   64|      0|    }
   65|       |}
   66|       |
   67|       |final class SwitchIfEmptySinkIter<O: ObserverType>
   68|       |    : ObserverType {
   69|       |    typealias E = O.E
   70|       |    typealias Parent = SwitchIfEmptySink<O>
   71|       |    
   72|       |    private let _parent: Parent
   73|       |
   74|      0|    init(parent: Parent) {
   75|      0|        _parent = parent
   76|      0|    }
   77|       |    
   78|      0|    func on(_ event: Event<E>) {
   79|      0|        switch event {
   80|      0|        case .next:
   81|      0|            _parent.forwardOn(event)
   82|      0|        case .error:
   83|      0|            _parent.forwardOn(event)
   84|      0|            _parent.dispose()
   85|      0|        case .completed:
   86|      0|            _parent.forwardOn(event)
   87|      0|            _parent.dispose()
   88|      0|        }
   89|      0|    }
   90|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Take.swift:
    1|       |//
    2|       |//  Take.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// count version
   10|       |
   11|       |final class TakeCountSink<O: ObserverType> : Sink<O>, ObserverType {
   12|       |    typealias E = O.E
   13|       |    typealias Parent = TakeCount<E>
   14|       |    
   15|       |    private let _parent: Parent
   16|       |    
   17|       |    private var _remaining: Int
   18|       |    
   19|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   20|      0|        _parent = parent
   21|      0|        _remaining = parent._count
   22|      0|        super.init(observer: observer, cancel: cancel)
   23|      0|    }
   24|       |    
   25|      0|    func on(_ event: Event<E>) {
   26|      0|        switch event {
   27|      0|        case .next(let value):
   28|      0|            
   29|      0|            if _remaining > 0 {
   30|      0|                _remaining -= 1
   31|      0|                
   32|      0|                forwardOn(.next(value))
   33|      0|            
   34|      0|                if _remaining == 0 {
   35|      0|                    forwardOn(.completed)
   36|      0|                    dispose()
   37|      0|                }
   38|      0|            }
   39|      0|        case .error:
   40|      0|            forwardOn(event)
   41|      0|            dispose()
   42|      0|        case .completed:
   43|      0|            forwardOn(event)
   44|      0|            dispose()
   45|      0|        }
   46|      0|    }
   47|       |    
   48|       |}
   49|       |
   50|       |final class TakeCount<Element>: Producer<Element> {
   51|       |    fileprivate let _source: Observable<Element>
   52|       |    fileprivate let _count: Int
   53|       |    
   54|      0|    init(source: Observable<Element>, count: Int) {
   55|      0|        if count < 0 {
   56|      0|            rxFatalError("count can't be negative")
   57|      0|        }
   58|      0|        _source = source
   59|      0|        _count = count
   60|      0|    }
   61|       |    
   62|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   63|      0|        let sink = TakeCountSink(parent: self, observer: observer, cancel: cancel)
   64|      0|        let subscription = _source.subscribe(sink)
   65|      0|        return (sink: sink, subscription: subscription)
   66|      0|    }
   67|       |}
   68|       |
   69|       |// time version
   70|       |
   71|       |final class TakeTimeSink<ElementType, O: ObserverType>
   72|       |    : Sink<O>
   73|       |    , LockOwnerType
   74|       |    , ObserverType
   75|       |    , SynchronizedOnType where O.E == ElementType {
   76|       |    typealias Parent = TakeTime<ElementType>
   77|       |    typealias E = ElementType
   78|       |
   79|       |    fileprivate let _parent: Parent
   80|       |    
   81|       |    let _lock = RecursiveLock()
   82|       |    
   83|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   84|      0|        _parent = parent
   85|      0|        super.init(observer: observer, cancel: cancel)
   86|      0|    }
   87|       |    
   88|      0|    func on(_ event: Event<E>) {
   89|      0|        synchronizedOn(event)
   90|      0|    }
   91|       |
   92|      0|    func _synchronized_on(_ event: Event<E>) {
   93|      0|        switch event {
   94|      0|        case .next(let value):
   95|      0|            forwardOn(.next(value))
   96|      0|        case .error:
   97|      0|            forwardOn(event)
   98|      0|            dispose()
   99|      0|        case .completed:
  100|      0|            forwardOn(event)
  101|      0|            dispose()
  102|      0|        }
  103|      0|    }
  104|       |    
  105|      0|    func tick() {
  106|      0|        _lock.lock(); defer { _lock.unlock() }
  107|      0|
  108|      0|        forwardOn(.completed)
  109|      0|        dispose()
  110|      0|    }
  111|       |    
  112|      0|    func run() -> Disposable {
  113|      0|        let disposeTimer = _parent._scheduler.scheduleRelative((), dueTime: _parent._duration) {
  114|      0|            self.tick()
  115|      0|            return Disposables.create()
  116|      0|        }
  117|      0|        
  118|      0|        let disposeSubscription = _parent._source.subscribe(self)
  119|      0|        
  120|      0|        return Disposables.create(disposeTimer, disposeSubscription)
  121|      0|    }
  122|       |}
  123|       |
  124|       |final class TakeTime<Element> : Producer<Element> {
  125|       |    typealias TimeInterval = RxTimeInterval
  126|       |    
  127|       |    fileprivate let _source: Observable<Element>
  128|       |    fileprivate let _duration: TimeInterval
  129|       |    fileprivate let _scheduler: SchedulerType
  130|       |    
  131|      0|    init(source: Observable<Element>, duration: TimeInterval, scheduler: SchedulerType) {
  132|      0|        _source = source
  133|      0|        _scheduler = scheduler
  134|      0|        _duration = duration
  135|      0|    }
  136|       |    
  137|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  138|      0|        let sink = TakeTimeSink(parent: self, observer: observer, cancel: cancel)
  139|      0|        let subscription = sink.run()
  140|      0|        return (sink: sink, subscription: subscription)
  141|      0|    }
  142|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/TakeLast.swift:
    1|       |//
    2|       |//  TakeLast.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 25/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class TakeLastSink<O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias E = O.E
   11|       |    typealias Parent = TakeLast<E>
   12|       |    
   13|       |    private let _parent: Parent
   14|       |    
   15|       |    private var _elements: Queue<E>
   16|       |    
   17|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   18|      0|        _parent = parent
   19|      0|        _elements = Queue<E>(capacity: parent._count + 1)
   20|      0|        super.init(observer: observer, cancel: cancel)
   21|      0|    }
   22|       |    
   23|      0|    func on(_ event: Event<E>) {
   24|      0|        switch event {
   25|      0|        case .next(let value):
   26|      0|            _elements.enqueue(value)
   27|      0|            if _elements.count > self._parent._count {
   28|      0|                let _ = _elements.dequeue()
   29|      0|            }
   30|      0|        case .error:
   31|      0|            forwardOn(event)
   32|      0|            dispose()
   33|      0|        case .completed:
   34|      0|            for e in _elements {
   35|      0|                forwardOn(.next(e))
   36|      0|            }
   37|      0|            forwardOn(.completed)
   38|      0|            dispose()
   39|      0|        }
   40|      0|    }
   41|       |}
   42|       |
   43|       |final class TakeLast<Element>: Producer<Element> {
   44|       |    fileprivate let _source: Observable<Element>
   45|       |    fileprivate let _count: Int
   46|       |    
   47|      0|    init(source: Observable<Element>, count: Int) {
   48|      0|        if count < 0 {
   49|      0|            rxFatalError("count can't be negative")
   50|      0|        }
   51|      0|        _source = source
   52|      0|        _count = count
   53|      0|    }
   54|       |    
   55|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
   56|      0|        let sink = TakeLastSink(parent: self, observer: observer, cancel: cancel)
   57|      0|        let subscription = _source.subscribe(sink)
   58|      0|        return (sink: sink, subscription: subscription)
   59|      0|    }
   60|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/TakeUntil.swift:
    1|       |//
    2|       |//  TakeUntil.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final fileprivate class TakeUntilSinkOther<Other, O: ObserverType>
   10|       |    : ObserverType
   11|       |    , LockOwnerType
   12|       |    , SynchronizedOnType {
   13|       |    typealias Parent = TakeUntilSink<Other, O>
   14|       |    typealias E = Other
   15|       |    
   16|       |    fileprivate let _parent: Parent
   17|       |
   18|      0|    var _lock: RecursiveLock {
   19|      0|        return _parent._lock
   20|      0|    }
   21|       |    
   22|       |    fileprivate let _subscription = SingleAssignmentDisposable()
   23|       |    
   24|    374|    init(parent: Parent) {
   25|    374|        _parent = parent
   26|    374|#if TRACE_RESOURCES
   27|    374|        let _ = Resources.incrementTotal()
   28|    374|#endif
   29|    374|    }
   30|       |    
   31|      0|    func on(_ event: Event<E>) {
   32|      0|        synchronizedOn(event)
   33|      0|    }
   34|       |
   35|      0|    func _synchronized_on(_ event: Event<E>) {
   36|      0|        switch event {
   37|      0|        case .next:
   38|      0|            _parent.forwardOn(.completed)
   39|      0|            _parent.dispose()
   40|      0|        case .error(let e):
   41|      0|            _parent.forwardOn(.error(e))
   42|      0|            _parent.dispose()
   43|      0|        case .completed:
   44|      0|            _subscription.dispose()
   45|      0|        }
   46|      0|    }
   47|       |    
   48|       |#if TRACE_RESOURCES
   49|       |    deinit {
   50|       |        let _ = Resources.decrementTotal()
   51|       |    }
   52|       |#endif
   53|       |}
   54|       |
   55|       |final class TakeUntilSink<Other, O: ObserverType>
   56|       |    : Sink<O>
   57|       |    , LockOwnerType
   58|       |    , ObserverType
   59|       |    , SynchronizedOnType {
   60|       |    typealias E = O.E
   61|       |    typealias Parent = TakeUntil<E, Other>
   62|       |    
   63|       |    fileprivate let _parent: Parent
   64|       | 
   65|       |    let _lock = RecursiveLock()
   66|       |    
   67|       |    
   68|    374|    init(parent: Parent, observer: O, cancel: Cancelable) {
   69|    374|        _parent = parent
   70|    374|        super.init(observer: observer, cancel: cancel)
   71|    374|    }
   72|       |    
   73|    191|    func on(_ event: Event<E>) {
   74|    191|        synchronizedOn(event)
   75|    191|    }
   76|       |
   77|    191|    func _synchronized_on(_ event: Event<E>) {
   78|    191|        switch event {
   79|    191|        case .next:
   80|    191|            forwardOn(event)
   81|      0|        case .error:
   82|      0|            forwardOn(event)
   83|      0|            dispose()
   84|      0|        case .completed:
   85|      0|            forwardOn(event)
   86|      0|            dispose()
   87|    191|        }
   88|    191|    }
   89|       |    
   90|    374|    func run() -> Disposable {
   91|    374|        let otherObserver = TakeUntilSinkOther(parent: self)
   92|    374|        let otherSubscription = _parent._other.subscribe(otherObserver)
   93|    374|        otherObserver._subscription.setDisposable(otherSubscription)
   94|    374|        let sourceSubscription = _parent._source.subscribe(self)
   95|    374|        
   96|    374|        return Disposables.create(sourceSubscription, otherObserver._subscription)
   97|    374|    }
   98|       |}
   99|       |
  100|       |final class TakeUntil<Element, Other>: Producer<Element> {
  101|       |    
  102|       |    fileprivate let _source: Observable<Element>
  103|       |    fileprivate let _other: Observable<Other>
  104|       |    
  105|    374|    init(source: Observable<Element>, other: Observable<Other>) {
  106|    374|        _source = source
  107|    374|        _other = other
  108|    374|    }
  109|       |    
  110|    374|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  111|    374|        let sink = TakeUntilSink(parent: self, observer: observer, cancel: cancel)
  112|    374|        let subscription = sink.run()
  113|    374|        return (sink: sink, subscription: subscription)
  114|    374|    }
  115|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/TakeWhile.swift:
    1|       |//
    2|       |//  TakeWhile.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class TakeWhileSink<O: ObserverType>
   10|       |    : Sink<O>
   11|       |    , ObserverType {
   12|       |    typealias Element = O.E
   13|       |    typealias Parent = TakeWhile<Element>
   14|       |
   15|       |    fileprivate let _parent: Parent
   16|       |
   17|       |    fileprivate var _running = true
   18|       |
   19|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   20|      0|        _parent = parent
   21|      0|        super.init(observer: observer, cancel: cancel)
   22|      0|    }
   23|       |    
   24|      0|    func on(_ event: Event<Element>) {
   25|      0|        switch event {
   26|      0|        case .next(let value):
   27|      0|            if !_running {
   28|      0|                return
   29|      0|            }
   30|      0|            
   31|      0|            do {
   32|      0|                _running = try _parent._predicate(value)
   33|      0|            } catch let e {
   34|      0|                forwardOn(.error(e))
   35|      0|                dispose()
   36|      0|                return
   37|      0|            }
   38|      0|            
   39|      0|            if _running {
   40|      0|                forwardOn(.next(value))
   41|      0|            } else {
   42|      0|                forwardOn(.completed)
   43|      0|                dispose()
   44|      0|            }
   45|      0|        case .error, .completed:
   46|      0|            forwardOn(event)
   47|      0|            dispose()
   48|      0|        }
   49|      0|    }
   50|       |    
   51|       |}
   52|       |
   53|       |final class TakeWhileSinkWithIndex<O: ObserverType>
   54|       |    : Sink<O>
   55|       |    , ObserverType {
   56|       |    typealias Element = O.E
   57|       |    typealias Parent = TakeWhile<Element>
   58|       |    
   59|       |    fileprivate let _parent: Parent
   60|       |    
   61|       |    fileprivate var _running = true
   62|       |    fileprivate var _index = 0
   63|       |    
   64|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   65|      0|        _parent = parent
   66|      0|        super.init(observer: observer, cancel: cancel)
   67|      0|    }
   68|       |    
   69|      0|    func on(_ event: Event<Element>) {
   70|      0|        switch event {
   71|      0|        case .next(let value):
   72|      0|            if !_running {
   73|      0|                return
   74|      0|            }
   75|      0|            
   76|      0|            do {
   77|      0|                _running = try _parent._predicateWithIndex(value, _index)
   78|      0|                let _ = try incrementChecked(&_index)
   79|      0|            } catch let e {
   80|      0|                forwardOn(.error(e))
   81|      0|                dispose()
   82|      0|                return
   83|      0|            }
   84|      0|            
   85|      0|            if _running {
   86|      0|                forwardOn(.next(value))
   87|      0|            } else {
   88|      0|                forwardOn(.completed)
   89|      0|                dispose()
   90|      0|            }
   91|      0|        case .error, .completed:
   92|      0|            forwardOn(event)
   93|      0|            dispose()
   94|      0|        }
   95|      0|    }
   96|       |    
   97|       |}
   98|       |
   99|       |final class TakeWhile<Element>: Producer<Element> {
  100|       |    typealias Predicate = (Element) throws -> Bool
  101|       |    typealias PredicateWithIndex = (Element, Int) throws -> Bool
  102|       |
  103|       |    fileprivate let _source: Observable<Element>
  104|       |    fileprivate let _predicate: Predicate!
  105|       |    fileprivate let _predicateWithIndex: PredicateWithIndex!
  106|       |
  107|      0|    init(source: Observable<Element>, predicate: @escaping Predicate) {
  108|      0|        _source = source
  109|      0|        _predicate = predicate
  110|      0|        _predicateWithIndex = nil
  111|      0|    }
  112|       |    
  113|      0|    init(source: Observable<Element>, predicate: @escaping PredicateWithIndex) {
  114|      0|        _source = source
  115|      0|        _predicate = nil
  116|      0|        _predicateWithIndex = predicate
  117|      0|    }
  118|       |    
  119|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  120|      0|        if let _ = _predicate {
  121|      0|            let sink = TakeWhileSink(parent: self, observer: observer, cancel: cancel)
  122|      0|            let subscription = _source.subscribe(sink)
  123|      0|            return (sink: sink, subscription: subscription)
  124|      0|        } else {
  125|      0|            let sink = TakeWhileSinkWithIndex(parent: self, observer: observer, cancel: cancel)
  126|      0|            let subscription = _source.subscribe(sink)
  127|      0|            return (sink: sink, subscription: subscription)
  128|      0|        }
  129|      0|    }
  130|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Throttle.swift:
    1|       |//
    2|       |//  Throttle.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/22/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |final class ThrottleSink<O: ObserverType>
   12|       |    : Sink<O>
   13|       |    , ObserverType
   14|       |    , LockOwnerType
   15|       |    , SynchronizedOnType {
   16|       |    typealias Element = O.E
   17|       |    typealias ParentType = Throttle<Element>
   18|       |    
   19|       |    private let _parent: ParentType
   20|       |    
   21|       |    let _lock = RecursiveLock()
   22|       |    
   23|       |    // state
   24|       |    private var _lastUnsentElement: Element? = nil
   25|       |    private var _lastSentTime: Date? = nil
   26|       |    private var _completed: Bool = false
   27|       |
   28|       |    let cancellable = SerialDisposable()
   29|       |    
   30|      0|    init(parent: ParentType, observer: O, cancel: Cancelable) {
   31|      0|        _parent = parent
   32|      0|        
   33|      0|        super.init(observer: observer, cancel: cancel)
   34|      0|    }
   35|       |    
   36|      0|    func run() -> Disposable {
   37|      0|        let subscription = _parent._source.subscribe(self)
   38|      0|        
   39|      0|        return Disposables.create(subscription, cancellable)
   40|      0|    }
   41|       |
   42|      0|    func on(_ event: Event<Element>) {
   43|      0|        synchronizedOn(event)
   44|      0|    }
   45|       |
   46|      0|    func _synchronized_on(_ event: Event<Element>) {
   47|      0|        switch event {
   48|      0|        case .next(let element):
   49|      0|            let now = _parent._scheduler.now
   50|      0|
   51|      0|            let timeIntervalSinceLast: RxTimeInterval
   52|      0|
   53|      0|            if let lastSendingTime = _lastSentTime {
   54|      0|                timeIntervalSinceLast = now.timeIntervalSince(lastSendingTime)
   55|      0|            }
   56|      0|            else {
   57|      0|                timeIntervalSinceLast = _parent._dueTime
   58|      0|            }
   59|      0|
   60|      0|            let couldSendNow = timeIntervalSinceLast >= _parent._dueTime
   61|      0|
   62|      0|            if couldSendNow {
   63|      0|                self.sendNow(element: element)
   64|      0|                return
   65|      0|            }
   66|      0|
   67|      0|            if !_parent._latest {
   68|      0|                return
   69|      0|            }
   70|      0|
   71|      0|            let isThereAlreadyInFlightRequest = _lastUnsentElement != nil
   72|      0|            
   73|      0|            _lastUnsentElement = element
   74|      0|
   75|      0|            if isThereAlreadyInFlightRequest {
   76|      0|                return
   77|      0|            }
   78|      0|
   79|      0|            let scheduler = _parent._scheduler
   80|      0|            let dueTime = _parent._dueTime
   81|      0|
   82|      0|            let d = SingleAssignmentDisposable()
   83|      0|            self.cancellable.disposable = d
   84|      0|
   85|      0|            d.setDisposable(scheduler.scheduleRelative(0, dueTime: dueTime - timeIntervalSinceLast, action: self.propagate))
   86|      0|        case .error:
   87|      0|            _lastUnsentElement = nil
   88|      0|            forwardOn(event)
   89|      0|            dispose()
   90|      0|        case .completed:
   91|      0|            if let _ = _lastUnsentElement {
   92|      0|                _completed = true
   93|      0|            }
   94|      0|            else {
   95|      0|                forwardOn(.completed)
   96|      0|                dispose()
   97|      0|            }
   98|      0|        }
   99|      0|    }
  100|       |
  101|      0|    private func sendNow(element: Element) {
  102|      0|        _lastUnsentElement = nil
  103|      0|        self.forwardOn(.next(element))
  104|      0|        // in case element processing takes a while, this should give some more room
  105|      0|        _lastSentTime = _parent._scheduler.now
  106|      0|    }
  107|       |    
  108|      0|    func propagate(_: Int) -> Disposable {
  109|      0|        _lock.lock(); defer { _lock.unlock() } // {
  110|      0|            if let lastUnsentElement = _lastUnsentElement {
  111|      0|                sendNow(element: lastUnsentElement)
  112|      0|            }
  113|      0|
  114|      0|            if _completed {
  115|      0|                forwardOn(.completed)
  116|      0|                dispose()
  117|      0|            }
  118|      0|        // }
  119|      0|        return Disposables.create()
  120|      0|    }
  121|       |}
  122|       |
  123|       |final class Throttle<Element> : Producer<Element> {
  124|       |    
  125|       |    fileprivate let _source: Observable<Element>
  126|       |    fileprivate let _dueTime: RxTimeInterval
  127|       |    fileprivate let _latest: Bool
  128|       |    fileprivate let _scheduler: SchedulerType
  129|       |
  130|      0|    init(source: Observable<Element>, dueTime: RxTimeInterval, latest: Bool, scheduler: SchedulerType) {
  131|      0|        _source = source
  132|      0|        _dueTime = dueTime
  133|      0|        _latest = latest
  134|      0|        _scheduler = scheduler
  135|      0|    }
  136|       |    
  137|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  138|      0|        let sink = ThrottleSink(parent: self, observer: observer, cancel: cancel)
  139|      0|        let subscription = sink.run()
  140|      0|        return (sink: sink, subscription: subscription)
  141|      0|    }
  142|       |    
  143|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Timeout.swift:
    1|       |//
    2|       |//  Timeout.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Tomi Koskinen on 13/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class TimeoutSink<O: ObserverType>: Sink<O>, LockOwnerType, ObserverType {
   10|       |    typealias E = O.E
   11|       |    typealias Parent = Timeout<E>
   12|       |    
   13|       |    private let _parent: Parent
   14|       |    
   15|       |    let _lock = RecursiveLock()
   16|       |
   17|       |    private let _timerD = SerialDisposable()
   18|       |    private let _subscription = SerialDisposable()
   19|       |    
   20|       |    private var _id = 0
   21|       |    private var _switched = false
   22|       |    
   23|      7|    init(parent: Parent, observer: O, cancel: Cancelable) {
   24|      7|        _parent = parent
   25|      7|        super.init(observer: observer, cancel: cancel)
   26|      7|    }
   27|       |    
   28|      7|    func run() -> Disposable {
   29|      7|        let original = SingleAssignmentDisposable()
   30|      7|        _subscription.disposable = original
   31|      7|        
   32|      7|        _createTimeoutTimer()
   33|      7|        
   34|      7|        original.setDisposable(_parent._source.subscribe(self))
   35|      7|        
   36|      7|        return Disposables.create(_subscription, _timerD)
   37|      7|    }
   38|       |
   39|     14|    func on(_ event: Event<E>) {
   40|     14|        switch event {
   41|      7|        case .next:
   42|      7|            var onNextWins = false
   43|      7|            
   44|      7|            _lock.performLocked() {
   45|      7|                onNextWins = !self._switched
   46|      7|                if onNextWins {
   47|      7|                    self._id = self._id &+ 1
   48|      7|                }
   49|      7|            }
   50|      7|            
   51|      7|            if onNextWins {
   52|      7|                forwardOn(event)
   53|      7|                self._createTimeoutTimer()
   54|      7|            }
   55|      7|        case .error, .completed:
   56|      7|            var onEventWins = false
   57|      7|            
   58|      7|            _lock.performLocked() {
   59|      7|                onEventWins = !self._switched
   60|      7|                if onEventWins {
   61|      7|                    self._id = self._id &+ 1
   62|      7|                }
   63|      7|            }
   64|      7|            
   65|      7|            if onEventWins {
   66|      7|                forwardOn(event)
   67|      7|                self.dispose()
   68|      7|            }
   69|     14|        }
   70|     14|    }
   71|       |    
   72|     14|    private func _createTimeoutTimer() {
   73|      0|        if _timerD.isDisposed {
   74|      0|            return
   75|     14|        }
   76|     14|        
   77|     14|        let nextTimer = SingleAssignmentDisposable()
   78|     14|        _timerD.disposable = nextTimer
   79|     14|        
   80|      0|        let disposeSchedule = _parent._scheduler.scheduleRelative(_id, dueTime: _parent._dueTime) { state in
   81|      0|            
   82|      0|            var timerWins = false
   83|      0|            
   84|      0|            self._lock.performLocked() {
   85|      0|                self._switched = (state == self._id)
   86|      0|                timerWins = self._switched
   87|      0|            }
   88|      0|            
   89|      0|            if timerWins {
   90|      0|                self._subscription.disposable = self._parent._other.subscribe(self.forwarder())
   91|      0|            }
   92|      0|            
   93|      0|            return Disposables.create()
   94|      0|        }
   95|     14|
   96|     14|        nextTimer.setDisposable(disposeSchedule)
   97|     14|    }
   98|       |}
   99|       |
  100|       |
  101|       |final class Timeout<Element> : Producer<Element> {
  102|       |    
  103|       |    fileprivate let _source: Observable<Element>
  104|       |    fileprivate let _dueTime: RxTimeInterval
  105|       |    fileprivate let _other: Observable<Element>
  106|       |    fileprivate let _scheduler: SchedulerType
  107|       |    
  108|      7|    init(source: Observable<Element>, dueTime: RxTimeInterval, other: Observable<Element>, scheduler: SchedulerType) {
  109|      7|        _source = source
  110|      7|        _dueTime = dueTime
  111|      7|        _other = other
  112|      7|        _scheduler = scheduler
  113|      7|    }
  114|       |    
  115|      7|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Element {
  116|      7|        let sink = TimeoutSink(parent: self, observer: observer, cancel: cancel)
  117|      7|        let subscription = sink.run()
  118|      7|        return (sink: sink, subscription: subscription)
  119|      7|    }
  120|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Timer.swift:
    1|       |//
    2|       |//  Timer.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class TimerSink<O: ObserverType> : Sink<O> where O.E : SignedInteger  {
   10|       |    typealias Parent = Timer<O.E>
   11|       |    
   12|       |    private let _parent: Parent
   13|       |    
   14|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   15|      0|        _parent = parent
   16|      0|        super.init(observer: observer, cancel: cancel)
   17|      0|    }
   18|       |    
   19|      0|    func run() -> Disposable {
   20|      0|        return _parent._scheduler.schedulePeriodic(0 as O.E, startAfter: _parent._dueTime, period: _parent._period!) { state in
   21|      0|            self.forwardOn(.next(state))
   22|      0|            return state &+ 1
   23|      0|        }
   24|      0|    }
   25|       |}
   26|       |
   27|       |final class TimerOneOffSink<O: ObserverType> : Sink<O> where O.E : SignedInteger {
   28|       |    typealias Parent = Timer<O.E>
   29|       |    
   30|       |    private let _parent: Parent
   31|       |    
   32|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   33|      0|        _parent = parent
   34|      0|        super.init(observer: observer, cancel: cancel)
   35|      0|    }
   36|       |    
   37|      0|    func run() -> Disposable {
   38|      0|        return _parent._scheduler.scheduleRelative(self, dueTime: _parent._dueTime) { (`self`) -> Disposable in
   39|      0|            self.forwardOn(.next(0))
   40|      0|            self.forwardOn(.completed)
   41|      0|            self.dispose()
   42|      0|
   43|      0|            return Disposables.create()
   44|      0|        }
   45|      0|    }
   46|       |}
   47|       |
   48|       |final class Timer<E: SignedInteger>: Producer<E> {
   49|       |    fileprivate let _scheduler: SchedulerType
   50|       |    fileprivate let _dueTime: RxTimeInterval
   51|       |    fileprivate let _period: RxTimeInterval?
   52|       |    
   53|      0|    init(dueTime: RxTimeInterval, period: RxTimeInterval?, scheduler: SchedulerType) {
   54|      0|        _scheduler = scheduler
   55|      0|        _dueTime = dueTime
   56|      0|        _period = period
   57|      0|    }
   58|       |    
   59|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   60|      0|        if let _ = _period {
   61|      0|            let sink = TimerSink(parent: self, observer: observer, cancel: cancel)
   62|      0|            let subscription = sink.run()
   63|      0|            return (sink: sink, subscription: subscription)
   64|      0|        }
   65|      0|        else {
   66|      0|            let sink = TimerOneOffSink(parent: self, observer: observer, cancel: cancel)
   67|      0|            let subscription = sink.run()
   68|      0|            return (sink: sink, subscription: subscription)
   69|      0|        }
   70|      0|    }
   71|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/ToArray.swift:
    1|       |//
    2|       |//  ToArray.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 20/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class ToArraySink<SourceType, O: ObserverType> : Sink<O>, ObserverType where O.E == [SourceType] {
   10|       |    typealias Parent = ToArray<SourceType>
   11|       |    
   12|       |    let _parent: Parent
   13|       |    var _list = Array<SourceType>()
   14|       |    
   15|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   16|      0|        _parent = parent
   17|      0|        
   18|      0|        super.init(observer: observer, cancel: cancel)
   19|      0|    }
   20|       |    
   21|      0|    func on(_ event: Event<SourceType>) {
   22|      0|        switch event {
   23|      0|        case .next(let value):
   24|      0|            self._list.append(value)
   25|      0|        case .error(let e):
   26|      0|            forwardOn(.error(e))
   27|      0|            self.dispose()
   28|      0|        case .completed:
   29|      0|            forwardOn(.next(_list))
   30|      0|            forwardOn(.completed)
   31|      0|            self.dispose()
   32|      0|        }
   33|      0|    }
   34|       |}
   35|       |
   36|       |final class ToArray<SourceType> : Producer<[SourceType]> {
   37|       |    let _source: Observable<SourceType>
   38|       |
   39|      0|    init(source: Observable<SourceType>) {
   40|      0|        _source = source
   41|      0|    }
   42|       |    
   43|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == [SourceType] {
   44|      0|        let sink = ToArraySink(parent: self, observer: observer, cancel: cancel)
   45|      0|        let subscription = _source.subscribe(sink)
   46|      0|        return (sink: sink, subscription: subscription)
   47|      0|    }
   48|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Using.swift:
    1|       |//
    2|       |//  Using.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class UsingSink<ResourceType: Disposable, O: ObserverType> : Sink<O>, ObserverType {
   10|       |    typealias SourceType = O.E
   11|       |    typealias Parent = Using<SourceType, ResourceType>
   12|       |
   13|       |    private let _parent: Parent
   14|       |    
   15|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   16|      0|        _parent = parent
   17|      0|        super.init(observer: observer, cancel: cancel)
   18|      0|    }
   19|       |    
   20|      0|    func run() -> Disposable {
   21|      0|        var disposable = Disposables.create()
   22|      0|        
   23|      0|        do {
   24|      0|            let resource = try _parent._resourceFactory()
   25|      0|            disposable = resource
   26|      0|            let source = try _parent._observableFactory(resource)
   27|      0|            
   28|      0|            return Disposables.create(
   29|      0|                source.subscribe(self),
   30|      0|                disposable
   31|      0|            )
   32|      0|        } catch let error {
   33|      0|            return Disposables.create(
   34|      0|                Observable.error(error).subscribe(self),
   35|      0|                disposable
   36|      0|            )
   37|      0|        }
   38|      0|    }
   39|       |    
   40|      0|    func on(_ event: Event<SourceType>) {
   41|      0|        switch event {
   42|      0|        case let .next(value):
   43|      0|            forwardOn(.next(value))
   44|      0|        case let .error(error):
   45|      0|            forwardOn(.error(error))
   46|      0|            dispose()
   47|      0|        case .completed:
   48|      0|            forwardOn(.completed)
   49|      0|            dispose()
   50|      0|        }
   51|      0|    }
   52|       |}
   53|       |
   54|       |class Using<SourceType, ResourceType: Disposable>: Producer<SourceType> {
   55|       |    
   56|       |    typealias E = SourceType
   57|       |    
   58|       |    typealias ResourceFactory = () throws -> ResourceType
   59|       |    typealias ObservableFactory = (ResourceType) throws -> Observable<SourceType>
   60|       |    
   61|       |    fileprivate let _resourceFactory: ResourceFactory
   62|       |    fileprivate let _observableFactory: ObservableFactory
   63|       |    
   64|       |    
   65|      0|    init(resourceFactory: @escaping ResourceFactory, observableFactory: @escaping ObservableFactory) {
   66|      0|        _resourceFactory = resourceFactory
   67|      0|        _observableFactory = observableFactory
   68|      0|    }
   69|       |    
   70|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == E {
   71|      0|        let sink = UsingSink(parent: self, observer: observer, cancel: cancel)
   72|      0|        let subscription = sink.run()
   73|      0|        return (sink: sink, subscription: subscription)
   74|      0|    }
   75|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Window.swift:
    1|       |//
    2|       |//  Window.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Junior B. on 29/10/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class WindowTimeCountSink<Element, O: ObserverType>
   10|       |    : Sink<O>
   11|       |    , ObserverType
   12|       |    , LockOwnerType
   13|       |    , SynchronizedOnType where O.E == Observable<Element> {
   14|       |    typealias Parent = WindowTimeCount<Element>
   15|       |    typealias E = Element
   16|       |    
   17|       |    private let _parent: Parent
   18|       |    
   19|       |    let _lock = RecursiveLock()
   20|       |    
   21|       |    private var _subject = PublishSubject<Element>()
   22|       |    private var _count = 0
   23|       |    private var _windowId = 0
   24|       |    
   25|       |    private let _timerD = SerialDisposable()
   26|       |    private let _refCountDisposable: RefCountDisposable
   27|       |    private let _groupDisposable = CompositeDisposable()
   28|       |    
   29|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   30|      0|        _parent = parent
   31|      0|        
   32|      0|        let _ = _groupDisposable.insert(_timerD)
   33|      0|        
   34|      0|        _refCountDisposable = RefCountDisposable(disposable: _groupDisposable)
   35|      0|        super.init(observer: observer, cancel: cancel)
   36|      0|    }
   37|       |    
   38|      0|    func run() -> Disposable {
   39|      0|        
   40|      0|        forwardOn(.next(AddRef(source: _subject, refCount: _refCountDisposable).asObservable()))
   41|      0|        createTimer(_windowId)
   42|      0|        
   43|      0|        let _ = _groupDisposable.insert(_parent._source.subscribe(self))
   44|      0|        return _refCountDisposable
   45|      0|    }
   46|       |    
   47|      0|    func startNewWindowAndCompleteCurrentOne() {
   48|      0|        _subject.on(.completed)
   49|      0|        _subject = PublishSubject<Element>()
   50|      0|        
   51|      0|        forwardOn(.next(AddRef(source: _subject, refCount: _refCountDisposable).asObservable()))
   52|      0|    }
   53|       |
   54|      0|    func on(_ event: Event<E>) {
   55|      0|        synchronizedOn(event)
   56|      0|    }
   57|       |
   58|      0|    func _synchronized_on(_ event: Event<E>) {
   59|      0|        var newWindow = false
   60|      0|        var newId = 0
   61|      0|        
   62|      0|        switch event {
   63|      0|        case .next(let element):
   64|      0|            _subject.on(.next(element))
   65|      0|            
   66|      0|            do {
   67|      0|                let _ = try incrementChecked(&_count)
   68|      0|            } catch (let e) {
   69|      0|                _subject.on(.error(e as Swift.Error))
   70|      0|                dispose()
   71|      0|            }
   72|      0|            
   73|      0|            if (_count == _parent._count) {
   74|      0|                newWindow = true
   75|      0|                _count = 0
   76|      0|                _windowId += 1
   77|      0|                newId = _windowId
   78|      0|                self.startNewWindowAndCompleteCurrentOne()
   79|      0|            }
   80|      0|            
   81|      0|        case .error(let error):
   82|      0|            _subject.on(.error(error))
   83|      0|            forwardOn(.error(error))
   84|      0|            dispose()
   85|      0|        case .completed:
   86|      0|            _subject.on(.completed)
   87|      0|            forwardOn(.completed)
   88|      0|            dispose()
   89|      0|        }
   90|      0|
   91|      0|        if newWindow {
   92|      0|            createTimer(newId)
   93|      0|        }
   94|      0|    }
   95|       |    
   96|      0|    func createTimer(_ windowId: Int) {
   97|      0|        if _timerD.isDisposed {
   98|      0|            return
   99|      0|        }
  100|      0|        
  101|      0|        if _windowId != windowId {
  102|      0|            return
  103|      0|        }
  104|      0|
  105|      0|        let nextTimer = SingleAssignmentDisposable()
  106|      0|
  107|      0|        _timerD.disposable = nextTimer
  108|      0|
  109|      0|        let scheduledRelative = _parent._scheduler.scheduleRelative(windowId, dueTime: _parent._timeSpan) { previousWindowId in
  110|      0|            
  111|      0|            var newId = 0
  112|      0|            
  113|      0|            self._lock.performLocked {
  114|      0|                if previousWindowId != self._windowId {
  115|      0|                    return
  116|      0|                }
  117|      0|                
  118|      0|                self._count = 0
  119|      0|                self._windowId = self._windowId &+ 1
  120|      0|                newId = self._windowId
  121|      0|                self.startNewWindowAndCompleteCurrentOne()
  122|      0|            }
  123|      0|            
  124|      0|            self.createTimer(newId)
  125|      0|            
  126|      0|            return Disposables.create()
  127|      0|        }
  128|      0|
  129|      0|        nextTimer.setDisposable(scheduledRelative)
  130|      0|    }
  131|       |}
  132|       |
  133|       |final class WindowTimeCount<Element> : Producer<Observable<Element>> {
  134|       |    
  135|       |    fileprivate let _timeSpan: RxTimeInterval
  136|       |    fileprivate let _count: Int
  137|       |    fileprivate let _scheduler: SchedulerType
  138|       |    fileprivate let _source: Observable<Element>
  139|       |    
  140|      0|    init(source: Observable<Element>, timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType) {
  141|      0|        _source = source
  142|      0|        _timeSpan = timeSpan
  143|      0|        _count = count
  144|      0|        _scheduler = scheduler
  145|      0|    }
  146|       |    
  147|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == Observable<Element> {
  148|      0|        let sink = WindowTimeCountSink(parent: self, observer: observer, cancel: cancel)
  149|      0|        let subscription = sink.run()
  150|      0|        return (sink: sink, subscription: subscription)
  151|      0|    }
  152|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/WithLatestFrom.swift:
    1|       |//
    2|       |//  WithLatestFrom.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 10/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class WithLatestFromSink<FirstType, SecondType, O: ObserverType>
   10|       |    : Sink<O>
   11|       |    , ObserverType
   12|       |    , LockOwnerType
   13|       |    , SynchronizedOnType {
   14|       |    typealias ResultType = O.E
   15|       |    typealias Parent = WithLatestFrom<FirstType, SecondType, ResultType>
   16|       |    typealias E = FirstType
   17|       |    
   18|       |    fileprivate let _parent: Parent
   19|       |    
   20|       |    var _lock = RecursiveLock()
   21|       |    fileprivate var _latest: SecondType?
   22|       |
   23|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   24|      0|        _parent = parent
   25|      0|        
   26|      0|        super.init(observer: observer, cancel: cancel)
   27|      0|    }
   28|       |    
   29|      0|    func run() -> Disposable {
   30|      0|        let sndSubscription = SingleAssignmentDisposable()
   31|      0|        let sndO = WithLatestFromSecond(parent: self, disposable: sndSubscription)
   32|      0|        
   33|      0|        sndSubscription.setDisposable(_parent._second.subscribe(sndO))
   34|      0|        let fstSubscription = _parent._first.subscribe(self)
   35|      0|
   36|      0|        return Disposables.create(fstSubscription, sndSubscription)
   37|      0|    }
   38|       |
   39|      0|    func on(_ event: Event<E>) {
   40|      0|        synchronizedOn(event)
   41|      0|    }
   42|       |
   43|      0|    func _synchronized_on(_ event: Event<E>) {
   44|      0|        switch event {
   45|      0|        case let .next(value):
   46|      0|            guard let latest = _latest else { return }
   47|      0|            do {
   48|      0|                let res = try _parent._resultSelector(value, latest)
   49|      0|                
   50|      0|                forwardOn(.next(res))
   51|      0|            } catch let e {
   52|      0|                forwardOn(.error(e))
   53|      0|                dispose()
   54|      0|            }
   55|      0|        case .completed:
   56|      0|            forwardOn(.completed)
   57|      0|            dispose()
   58|      0|        case let .error(error):
   59|      0|            forwardOn(.error(error))
   60|      0|            dispose()
   61|      0|        }
   62|      0|    }
   63|       |}
   64|       |
   65|       |final class WithLatestFromSecond<FirstType, SecondType, O: ObserverType>
   66|       |    : ObserverType
   67|       |    , LockOwnerType
   68|       |    , SynchronizedOnType {
   69|       |    
   70|       |    typealias ResultType = O.E
   71|       |    typealias Parent = WithLatestFromSink<FirstType, SecondType, O>
   72|       |    typealias E = SecondType
   73|       |    
   74|       |    private let _parent: Parent
   75|       |    private let _disposable: Disposable
   76|       |
   77|      0|    var _lock: RecursiveLock {
   78|      0|        return _parent._lock
   79|      0|    }
   80|       |
   81|      0|    init(parent: Parent, disposable: Disposable) {
   82|      0|        _parent = parent
   83|      0|        _disposable = disposable
   84|      0|    }
   85|       |    
   86|      0|    func on(_ event: Event<E>) {
   87|      0|        synchronizedOn(event)
   88|      0|    }
   89|       |
   90|      0|    func _synchronized_on(_ event: Event<E>) {
   91|      0|        switch event {
   92|      0|        case let .next(value):
   93|      0|            _parent._latest = value
   94|      0|        case .completed:
   95|      0|            _disposable.dispose()
   96|      0|        case let .error(error):
   97|      0|            _parent.forwardOn(.error(error))
   98|      0|            _parent.dispose()
   99|      0|        }
  100|      0|    }
  101|       |}
  102|       |
  103|       |final class WithLatestFrom<FirstType, SecondType, ResultType>: Producer<ResultType> {
  104|       |    typealias ResultSelector = (FirstType, SecondType) throws -> ResultType
  105|       |    
  106|       |    fileprivate let _first: Observable<FirstType>
  107|       |    fileprivate let _second: Observable<SecondType>
  108|       |    fileprivate let _resultSelector: ResultSelector
  109|       |
  110|      0|    init(first: Observable<FirstType>, second: Observable<SecondType>, resultSelector: @escaping ResultSelector) {
  111|      0|        _first = first
  112|      0|        _second = second
  113|      0|        _resultSelector = resultSelector
  114|      0|    }
  115|       |    
  116|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == ResultType {
  117|      0|        let sink = WithLatestFromSink(parent: self, observer: observer, cancel: cancel)
  118|      0|        let subscription = sink.run()
  119|      0|        return (sink: sink, subscription: subscription)
  120|      0|    }
  121|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Zip+Collection.swift:
    1|       |//
    2|       |//  Zip+Collection.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final fileprivate class ZipCollectionTypeSink<C: Collection, O: ObserverType>
   10|       |    : Sink<O> where C.Iterator.Element : ObservableConvertibleType {
   11|       |    typealias R = O.E
   12|       |    typealias Parent = ZipCollectionType<C, R>
   13|       |    typealias SourceElement = C.Iterator.Element.E
   14|       |    
   15|       |    private let _parent: Parent
   16|       |    
   17|       |    private let _lock = RecursiveLock()
   18|       |    
   19|       |    // state
   20|       |    private var _numberOfValues = 0
   21|       |    private var _values: [Queue<SourceElement>]
   22|       |    private var _isDone: [Bool]
   23|       |    private var _numberOfDone = 0
   24|       |    private var _subscriptions: [SingleAssignmentDisposable]
   25|       |    
   26|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   27|      0|        _parent = parent
   28|      0|        _values = [Queue<SourceElement>](repeating: Queue(capacity: 4), count: parent.count)
   29|      0|        _isDone = [Bool](repeating: false, count: parent.count)
   30|      0|        _subscriptions = Array<SingleAssignmentDisposable>()
   31|      0|        _subscriptions.reserveCapacity(parent.count)
   32|      0|        
   33|      0|        for _ in 0 ..< parent.count {
   34|      0|            _subscriptions.append(SingleAssignmentDisposable())
   35|      0|        }
   36|      0|        
   37|      0|        super.init(observer: observer, cancel: cancel)
   38|      0|    }
   39|       |    
   40|      0|    func on(_ event: Event<SourceElement>, atIndex: Int) {
   41|      0|        _lock.lock(); defer { _lock.unlock() } // {
   42|      0|            switch event {
   43|      0|            case .next(let element):
   44|      0|                _values[atIndex].enqueue(element)
   45|      0|                
   46|      0|                if _values[atIndex].count == 1 {
   47|      0|                    _numberOfValues += 1
   48|      0|                }
   49|      0|                
   50|      0|                if _numberOfValues < _parent.count {
   51|      0|                    if _numberOfDone == _parent.count - 1 {
   52|      0|                        self.forwardOn(.completed)
   53|      0|                        self.dispose()
   54|      0|                    }
   55|      0|                    return
   56|      0|                }
   57|      0|                
   58|      0|                do {
   59|      0|                    var arguments = [SourceElement]()
   60|      0|                    arguments.reserveCapacity(_parent.count)
   61|      0|                    
   62|      0|                    // recalculate number of values
   63|      0|                    _numberOfValues = 0
   64|      0|                    
   65|      0|                    for i in 0 ..< _values.count {
   66|      0|                        arguments.append(_values[i].dequeue()!)
   67|      0|                        if _values[i].count > 0 {
   68|      0|                            _numberOfValues += 1
   69|      0|                        }
   70|      0|                    }
   71|      0|                    
   72|      0|                    let result = try _parent.resultSelector(arguments)
   73|      0|                    self.forwardOn(.next(result))
   74|      0|                }
   75|      0|                catch let error {
   76|      0|                    self.forwardOn(.error(error))
   77|      0|                    self.dispose()
   78|      0|                }
   79|      0|                
   80|      0|            case .error(let error):
   81|      0|                self.forwardOn(.error(error))
   82|      0|                self.dispose()
   83|      0|            case .completed:
   84|      0|                if _isDone[atIndex] {
   85|      0|                    return
   86|      0|                }
   87|      0|                
   88|      0|                _isDone[atIndex] = true
   89|      0|                _numberOfDone += 1
   90|      0|                
   91|      0|                if _numberOfDone == _parent.count {
   92|      0|                    self.forwardOn(.completed)
   93|      0|                    self.dispose()
   94|      0|                }
   95|      0|                else {
   96|      0|                    _subscriptions[atIndex].dispose()
   97|      0|                }
   98|      0|            }
   99|      0|        // }
  100|      0|    }
  101|       |    
  102|      0|    func run() -> Disposable {
  103|      0|        var j = 0
  104|      0|        for i in _parent.sources {
  105|      0|            let index = j
  106|      0|            let source = i.asObservable()
  107|      0|
  108|      0|            let disposable = source.subscribe(AnyObserver { event in
  109|      0|                self.on(event, atIndex: index)
  110|      0|                })
  111|      0|            _subscriptions[j].setDisposable(disposable)
  112|      0|            j += 1
  113|      0|        }
  114|      0|        
  115|      0|        return Disposables.create(_subscriptions)
  116|      0|    }
  117|       |}
  118|       |
  119|       |final class ZipCollectionType<C: Collection, R> : Producer<R> where C.Iterator.Element : ObservableConvertibleType {
  120|       |    typealias ResultSelector = ([C.Iterator.Element.E]) throws -> R
  121|       |    
  122|       |    let sources: C
  123|       |    let resultSelector: ResultSelector
  124|       |    let count: Int
  125|       |    
  126|      0|    init(sources: C, resultSelector: @escaping ResultSelector) {
  127|      0|        self.sources = sources
  128|      0|        self.resultSelector = resultSelector
  129|      0|        self.count = Int(self.sources.count.toIntMax())
  130|      0|    }
  131|       |    
  132|      0|    override func run<O : ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  133|      0|        let sink = ZipCollectionTypeSink(parent: self, observer: observer, cancel: cancel)
  134|      0|        let subscription = sink.run()
  135|      0|        return (sink: sink, subscription: subscription)
  136|      0|    }
  137|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Zip+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  Zip+arity.swift
    4|       |//  RxSwift
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 5/23/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |
   11|       |
   12|       |// 2
   13|       |
   14|       |extension Observable {
   15|       |    /**
   16|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   17|       |
   18|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   19|       |
   20|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func zip<O1: ObservableType, O2: ObservableType>
   24|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   25|      0|        -> Observable<E> {
   26|      0|        return Zip2(
   27|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   28|      0|            resultSelector: resultSelector
   29|      0|        )
   30|      0|    }
   31|       |}
   32|       |
   33|       |extension ObservableType where E == Any {
   34|       |    /**
   35|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
   36|       |
   37|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   38|       |
   39|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   40|       |    */
   41|       |    public static func zip<O1: ObservableType, O2: ObservableType>
   42|       |        (_ source1: O1, _ source2: O2)
   43|      0|        -> Observable<(O1.E, O2.E)> {
   44|      0|        return Zip2(
   45|      0|            source1: source1.asObservable(), source2: source2.asObservable(),
   46|      0|            resultSelector: { ($0, $1) }
   47|      0|        )
   48|      0|    }
   49|       |}
   50|       |
   51|       |final class ZipSink2_<E1, E2, O: ObserverType> : ZipSink<O> {
   52|       |    typealias R = O.E
   53|       |    typealias Parent = Zip2<E1, E2, R>
   54|       |
   55|       |    let _parent: Parent
   56|       |
   57|       |    var _values1: Queue<E1> = Queue(capacity: 2)
   58|       |    var _values2: Queue<E2> = Queue(capacity: 2)
   59|       |
   60|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
   61|      0|        _parent = parent
   62|      0|        super.init(arity: 2, observer: observer, cancel: cancel)
   63|      0|    }
   64|       |
   65|      0|    override func hasElements(_ index: Int) -> Bool {
   66|      0|        switch (index) {
   67|      0|        case 0: return _values1.count > 0
   68|      0|        case 1: return _values2.count > 0
   69|      0|
   70|      0|        default:
   71|      0|            rxFatalError("Unhandled case (Function)")
   72|      0|        }
   73|      0|
   74|      0|        return false
   75|      0|    }
   76|       |
   77|      0|    func run() -> Disposable {
   78|      0|        let subscription1 = SingleAssignmentDisposable()
   79|      0|        let subscription2 = SingleAssignmentDisposable()
   80|      0|
   81|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
   82|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
   83|      0|
   84|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
   85|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
   86|      0|
   87|      0|        return Disposables.create([
   88|      0|           subscription1,
   89|      0|           subscription2
   90|      0|        ])
   91|      0|    }
   92|       |
   93|      0|    override func getResult() throws -> R {
   94|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!)
   95|      0|    }
   96|       |}
   97|       |
   98|       |final class Zip2<E1, E2, R> : Producer<R> {
   99|       |    typealias ResultSelector = (E1, E2) throws -> R
  100|       |
  101|       |    let source1: Observable<E1>
  102|       |    let source2: Observable<E2>
  103|       |
  104|       |    let _resultSelector: ResultSelector
  105|       |
  106|      0|    init(source1: Observable<E1>, source2: Observable<E2>, resultSelector: @escaping ResultSelector) {
  107|      0|        self.source1 = source1
  108|      0|        self.source2 = source2
  109|      0|
  110|      0|        _resultSelector = resultSelector
  111|      0|    }
  112|       |
  113|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  114|      0|        let sink = ZipSink2_(parent: self, observer: observer, cancel: cancel)
  115|      0|        let subscription = sink.run()
  116|      0|        return (sink: sink, subscription: subscription)
  117|      0|    }
  118|       |}
  119|       |
  120|       |
  121|       |
  122|       |// 3
  123|       |
  124|       |extension Observable {
  125|       |    /**
  126|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  127|       |
  128|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  129|       |
  130|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  131|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  132|       |    */
  133|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  134|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
  135|      0|        -> Observable<E> {
  136|      0|        return Zip3(
  137|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  138|      0|            resultSelector: resultSelector
  139|      0|        )
  140|      0|    }
  141|       |}
  142|       |
  143|       |extension ObservableType where E == Any {
  144|       |    /**
  145|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  146|       |
  147|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  148|       |
  149|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  150|       |    */
  151|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType>
  152|       |        (_ source1: O1, _ source2: O2, _ source3: O3)
  153|      0|        -> Observable<(O1.E, O2.E, O3.E)> {
  154|      0|        return Zip3(
  155|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(),
  156|      0|            resultSelector: { ($0, $1, $2) }
  157|      0|        )
  158|      0|    }
  159|       |}
  160|       |
  161|       |final class ZipSink3_<E1, E2, E3, O: ObserverType> : ZipSink<O> {
  162|       |    typealias R = O.E
  163|       |    typealias Parent = Zip3<E1, E2, E3, R>
  164|       |
  165|       |    let _parent: Parent
  166|       |
  167|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  168|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  169|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  170|       |
  171|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  172|      0|        _parent = parent
  173|      0|        super.init(arity: 3, observer: observer, cancel: cancel)
  174|      0|    }
  175|       |
  176|      0|    override func hasElements(_ index: Int) -> Bool {
  177|      0|        switch (index) {
  178|      0|        case 0: return _values1.count > 0
  179|      0|        case 1: return _values2.count > 0
  180|      0|        case 2: return _values3.count > 0
  181|      0|
  182|      0|        default:
  183|      0|            rxFatalError("Unhandled case (Function)")
  184|      0|        }
  185|      0|
  186|      0|        return false
  187|      0|    }
  188|       |
  189|      0|    func run() -> Disposable {
  190|      0|        let subscription1 = SingleAssignmentDisposable()
  191|      0|        let subscription2 = SingleAssignmentDisposable()
  192|      0|        let subscription3 = SingleAssignmentDisposable()
  193|      0|
  194|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  195|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  196|      0|        let observer3 = ZipObserver(lock: _lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  197|      0|
  198|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
  199|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
  200|      0|        subscription3.setDisposable(_parent.source3.subscribe(observer3))
  201|      0|
  202|      0|        return Disposables.create([
  203|      0|           subscription1,
  204|      0|           subscription2,
  205|      0|           subscription3
  206|      0|        ])
  207|      0|    }
  208|       |
  209|      0|    override func getResult() throws -> R {
  210|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!, _values3.dequeue()!)
  211|      0|    }
  212|       |}
  213|       |
  214|       |final class Zip3<E1, E2, E3, R> : Producer<R> {
  215|       |    typealias ResultSelector = (E1, E2, E3) throws -> R
  216|       |
  217|       |    let source1: Observable<E1>
  218|       |    let source2: Observable<E2>
  219|       |    let source3: Observable<E3>
  220|       |
  221|       |    let _resultSelector: ResultSelector
  222|       |
  223|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, resultSelector: @escaping ResultSelector) {
  224|      0|        self.source1 = source1
  225|      0|        self.source2 = source2
  226|      0|        self.source3 = source3
  227|      0|
  228|      0|        _resultSelector = resultSelector
  229|      0|    }
  230|       |
  231|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  232|      0|        let sink = ZipSink3_(parent: self, observer: observer, cancel: cancel)
  233|      0|        let subscription = sink.run()
  234|      0|        return (sink: sink, subscription: subscription)
  235|      0|    }
  236|       |}
  237|       |
  238|       |
  239|       |
  240|       |// 4
  241|       |
  242|       |extension Observable {
  243|       |    /**
  244|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  245|       |
  246|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  247|       |
  248|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  249|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  250|       |    */
  251|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  252|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  253|      0|        -> Observable<E> {
  254|      0|        return Zip4(
  255|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  256|      0|            resultSelector: resultSelector
  257|      0|        )
  258|      0|    }
  259|       |}
  260|       |
  261|       |extension ObservableType where E == Any {
  262|       |    /**
  263|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  264|       |
  265|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  266|       |
  267|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  268|       |    */
  269|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType>
  270|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4)
  271|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E)> {
  272|      0|        return Zip4(
  273|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(),
  274|      0|            resultSelector: { ($0, $1, $2, $3) }
  275|      0|        )
  276|      0|    }
  277|       |}
  278|       |
  279|       |final class ZipSink4_<E1, E2, E3, E4, O: ObserverType> : ZipSink<O> {
  280|       |    typealias R = O.E
  281|       |    typealias Parent = Zip4<E1, E2, E3, E4, R>
  282|       |
  283|       |    let _parent: Parent
  284|       |
  285|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  286|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  287|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  288|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  289|       |
  290|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  291|      0|        _parent = parent
  292|      0|        super.init(arity: 4, observer: observer, cancel: cancel)
  293|      0|    }
  294|       |
  295|      0|    override func hasElements(_ index: Int) -> Bool {
  296|      0|        switch (index) {
  297|      0|        case 0: return _values1.count > 0
  298|      0|        case 1: return _values2.count > 0
  299|      0|        case 2: return _values3.count > 0
  300|      0|        case 3: return _values4.count > 0
  301|      0|
  302|      0|        default:
  303|      0|            rxFatalError("Unhandled case (Function)")
  304|      0|        }
  305|      0|
  306|      0|        return false
  307|      0|    }
  308|       |
  309|      0|    func run() -> Disposable {
  310|      0|        let subscription1 = SingleAssignmentDisposable()
  311|      0|        let subscription2 = SingleAssignmentDisposable()
  312|      0|        let subscription3 = SingleAssignmentDisposable()
  313|      0|        let subscription4 = SingleAssignmentDisposable()
  314|      0|
  315|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  316|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  317|      0|        let observer3 = ZipObserver(lock: _lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  318|      0|        let observer4 = ZipObserver(lock: _lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  319|      0|
  320|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
  321|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
  322|      0|        subscription3.setDisposable(_parent.source3.subscribe(observer3))
  323|      0|        subscription4.setDisposable(_parent.source4.subscribe(observer4))
  324|      0|
  325|      0|        return Disposables.create([
  326|      0|           subscription1,
  327|      0|           subscription2,
  328|      0|           subscription3,
  329|      0|           subscription4
  330|      0|        ])
  331|      0|    }
  332|       |
  333|      0|    override func getResult() throws -> R {
  334|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!, _values3.dequeue()!, _values4.dequeue()!)
  335|      0|    }
  336|       |}
  337|       |
  338|       |final class Zip4<E1, E2, E3, E4, R> : Producer<R> {
  339|       |    typealias ResultSelector = (E1, E2, E3, E4) throws -> R
  340|       |
  341|       |    let source1: Observable<E1>
  342|       |    let source2: Observable<E2>
  343|       |    let source3: Observable<E3>
  344|       |    let source4: Observable<E4>
  345|       |
  346|       |    let _resultSelector: ResultSelector
  347|       |
  348|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, resultSelector: @escaping ResultSelector) {
  349|      0|        self.source1 = source1
  350|      0|        self.source2 = source2
  351|      0|        self.source3 = source3
  352|      0|        self.source4 = source4
  353|      0|
  354|      0|        _resultSelector = resultSelector
  355|      0|    }
  356|       |
  357|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  358|      0|        let sink = ZipSink4_(parent: self, observer: observer, cancel: cancel)
  359|      0|        let subscription = sink.run()
  360|      0|        return (sink: sink, subscription: subscription)
  361|      0|    }
  362|       |}
  363|       |
  364|       |
  365|       |
  366|       |// 5
  367|       |
  368|       |extension Observable {
  369|       |    /**
  370|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  371|       |
  372|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  373|       |
  374|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  375|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  376|       |    */
  377|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  378|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  379|      0|        -> Observable<E> {
  380|      0|        return Zip5(
  381|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  382|      0|            resultSelector: resultSelector
  383|      0|        )
  384|      0|    }
  385|       |}
  386|       |
  387|       |extension ObservableType where E == Any {
  388|       |    /**
  389|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  390|       |
  391|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  392|       |
  393|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  394|       |    */
  395|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType>
  396|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5)
  397|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E)> {
  398|      0|        return Zip5(
  399|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(),
  400|      0|            resultSelector: { ($0, $1, $2, $3, $4) }
  401|      0|        )
  402|      0|    }
  403|       |}
  404|       |
  405|       |final class ZipSink5_<E1, E2, E3, E4, E5, O: ObserverType> : ZipSink<O> {
  406|       |    typealias R = O.E
  407|       |    typealias Parent = Zip5<E1, E2, E3, E4, E5, R>
  408|       |
  409|       |    let _parent: Parent
  410|       |
  411|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  412|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  413|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  414|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  415|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  416|       |
  417|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  418|      0|        _parent = parent
  419|      0|        super.init(arity: 5, observer: observer, cancel: cancel)
  420|      0|    }
  421|       |
  422|      0|    override func hasElements(_ index: Int) -> Bool {
  423|      0|        switch (index) {
  424|      0|        case 0: return _values1.count > 0
  425|      0|        case 1: return _values2.count > 0
  426|      0|        case 2: return _values3.count > 0
  427|      0|        case 3: return _values4.count > 0
  428|      0|        case 4: return _values5.count > 0
  429|      0|
  430|      0|        default:
  431|      0|            rxFatalError("Unhandled case (Function)")
  432|      0|        }
  433|      0|
  434|      0|        return false
  435|      0|    }
  436|       |
  437|      0|    func run() -> Disposable {
  438|      0|        let subscription1 = SingleAssignmentDisposable()
  439|      0|        let subscription2 = SingleAssignmentDisposable()
  440|      0|        let subscription3 = SingleAssignmentDisposable()
  441|      0|        let subscription4 = SingleAssignmentDisposable()
  442|      0|        let subscription5 = SingleAssignmentDisposable()
  443|      0|
  444|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  445|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  446|      0|        let observer3 = ZipObserver(lock: _lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  447|      0|        let observer4 = ZipObserver(lock: _lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  448|      0|        let observer5 = ZipObserver(lock: _lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  449|      0|
  450|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
  451|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
  452|      0|        subscription3.setDisposable(_parent.source3.subscribe(observer3))
  453|      0|        subscription4.setDisposable(_parent.source4.subscribe(observer4))
  454|      0|        subscription5.setDisposable(_parent.source5.subscribe(observer5))
  455|      0|
  456|      0|        return Disposables.create([
  457|      0|           subscription1,
  458|      0|           subscription2,
  459|      0|           subscription3,
  460|      0|           subscription4,
  461|      0|           subscription5
  462|      0|        ])
  463|      0|    }
  464|       |
  465|      0|    override func getResult() throws -> R {
  466|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!, _values3.dequeue()!, _values4.dequeue()!, _values5.dequeue()!)
  467|      0|    }
  468|       |}
  469|       |
  470|       |final class Zip5<E1, E2, E3, E4, E5, R> : Producer<R> {
  471|       |    typealias ResultSelector = (E1, E2, E3, E4, E5) throws -> R
  472|       |
  473|       |    let source1: Observable<E1>
  474|       |    let source2: Observable<E2>
  475|       |    let source3: Observable<E3>
  476|       |    let source4: Observable<E4>
  477|       |    let source5: Observable<E5>
  478|       |
  479|       |    let _resultSelector: ResultSelector
  480|       |
  481|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, resultSelector: @escaping ResultSelector) {
  482|      0|        self.source1 = source1
  483|      0|        self.source2 = source2
  484|      0|        self.source3 = source3
  485|      0|        self.source4 = source4
  486|      0|        self.source5 = source5
  487|      0|
  488|      0|        _resultSelector = resultSelector
  489|      0|    }
  490|       |
  491|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  492|      0|        let sink = ZipSink5_(parent: self, observer: observer, cancel: cancel)
  493|      0|        let subscription = sink.run()
  494|      0|        return (sink: sink, subscription: subscription)
  495|      0|    }
  496|       |}
  497|       |
  498|       |
  499|       |
  500|       |// 6
  501|       |
  502|       |extension Observable {
  503|       |    /**
  504|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  505|       |
  506|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  507|       |
  508|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  509|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  510|       |    */
  511|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  512|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  513|      0|        -> Observable<E> {
  514|      0|        return Zip6(
  515|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  516|      0|            resultSelector: resultSelector
  517|      0|        )
  518|      0|    }
  519|       |}
  520|       |
  521|       |extension ObservableType where E == Any {
  522|       |    /**
  523|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  524|       |
  525|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  526|       |
  527|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  528|       |    */
  529|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType>
  530|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6)
  531|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E)> {
  532|      0|        return Zip6(
  533|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(),
  534|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5) }
  535|      0|        )
  536|      0|    }
  537|       |}
  538|       |
  539|       |final class ZipSink6_<E1, E2, E3, E4, E5, E6, O: ObserverType> : ZipSink<O> {
  540|       |    typealias R = O.E
  541|       |    typealias Parent = Zip6<E1, E2, E3, E4, E5, E6, R>
  542|       |
  543|       |    let _parent: Parent
  544|       |
  545|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  546|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  547|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  548|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  549|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  550|       |    var _values6: Queue<E6> = Queue(capacity: 2)
  551|       |
  552|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  553|      0|        _parent = parent
  554|      0|        super.init(arity: 6, observer: observer, cancel: cancel)
  555|      0|    }
  556|       |
  557|      0|    override func hasElements(_ index: Int) -> Bool {
  558|      0|        switch (index) {
  559|      0|        case 0: return _values1.count > 0
  560|      0|        case 1: return _values2.count > 0
  561|      0|        case 2: return _values3.count > 0
  562|      0|        case 3: return _values4.count > 0
  563|      0|        case 4: return _values5.count > 0
  564|      0|        case 5: return _values6.count > 0
  565|      0|
  566|      0|        default:
  567|      0|            rxFatalError("Unhandled case (Function)")
  568|      0|        }
  569|      0|
  570|      0|        return false
  571|      0|    }
  572|       |
  573|      0|    func run() -> Disposable {
  574|      0|        let subscription1 = SingleAssignmentDisposable()
  575|      0|        let subscription2 = SingleAssignmentDisposable()
  576|      0|        let subscription3 = SingleAssignmentDisposable()
  577|      0|        let subscription4 = SingleAssignmentDisposable()
  578|      0|        let subscription5 = SingleAssignmentDisposable()
  579|      0|        let subscription6 = SingleAssignmentDisposable()
  580|      0|
  581|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  582|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  583|      0|        let observer3 = ZipObserver(lock: _lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  584|      0|        let observer4 = ZipObserver(lock: _lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  585|      0|        let observer5 = ZipObserver(lock: _lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  586|      0|        let observer6 = ZipObserver(lock: _lock, parent: self, index: 5, setNextValue: { self._values6.enqueue($0) }, this: subscription6)
  587|      0|
  588|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
  589|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
  590|      0|        subscription3.setDisposable(_parent.source3.subscribe(observer3))
  591|      0|        subscription4.setDisposable(_parent.source4.subscribe(observer4))
  592|      0|        subscription5.setDisposable(_parent.source5.subscribe(observer5))
  593|      0|        subscription6.setDisposable(_parent.source6.subscribe(observer6))
  594|      0|
  595|      0|        return Disposables.create([
  596|      0|           subscription1,
  597|      0|           subscription2,
  598|      0|           subscription3,
  599|      0|           subscription4,
  600|      0|           subscription5,
  601|      0|           subscription6
  602|      0|        ])
  603|      0|    }
  604|       |
  605|      0|    override func getResult() throws -> R {
  606|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!, _values3.dequeue()!, _values4.dequeue()!, _values5.dequeue()!, _values6.dequeue()!)
  607|      0|    }
  608|       |}
  609|       |
  610|       |final class Zip6<E1, E2, E3, E4, E5, E6, R> : Producer<R> {
  611|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6) throws -> R
  612|       |
  613|       |    let source1: Observable<E1>
  614|       |    let source2: Observable<E2>
  615|       |    let source3: Observable<E3>
  616|       |    let source4: Observable<E4>
  617|       |    let source5: Observable<E5>
  618|       |    let source6: Observable<E6>
  619|       |
  620|       |    let _resultSelector: ResultSelector
  621|       |
  622|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, resultSelector: @escaping ResultSelector) {
  623|      0|        self.source1 = source1
  624|      0|        self.source2 = source2
  625|      0|        self.source3 = source3
  626|      0|        self.source4 = source4
  627|      0|        self.source5 = source5
  628|      0|        self.source6 = source6
  629|      0|
  630|      0|        _resultSelector = resultSelector
  631|      0|    }
  632|       |
  633|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  634|      0|        let sink = ZipSink6_(parent: self, observer: observer, cancel: cancel)
  635|      0|        let subscription = sink.run()
  636|      0|        return (sink: sink, subscription: subscription)
  637|      0|    }
  638|       |}
  639|       |
  640|       |
  641|       |
  642|       |// 7
  643|       |
  644|       |extension Observable {
  645|       |    /**
  646|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  647|       |
  648|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  649|       |
  650|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  651|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  652|       |    */
  653|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  654|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  655|      0|        -> Observable<E> {
  656|      0|        return Zip7(
  657|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  658|      0|            resultSelector: resultSelector
  659|      0|        )
  660|      0|    }
  661|       |}
  662|       |
  663|       |extension ObservableType where E == Any {
  664|       |    /**
  665|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  666|       |
  667|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  668|       |
  669|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  670|       |    */
  671|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType>
  672|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7)
  673|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E)> {
  674|      0|        return Zip7(
  675|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(),
  676|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6) }
  677|      0|        )
  678|      0|    }
  679|       |}
  680|       |
  681|       |final class ZipSink7_<E1, E2, E3, E4, E5, E6, E7, O: ObserverType> : ZipSink<O> {
  682|       |    typealias R = O.E
  683|       |    typealias Parent = Zip7<E1, E2, E3, E4, E5, E6, E7, R>
  684|       |
  685|       |    let _parent: Parent
  686|       |
  687|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  688|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  689|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  690|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  691|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  692|       |    var _values6: Queue<E6> = Queue(capacity: 2)
  693|       |    var _values7: Queue<E7> = Queue(capacity: 2)
  694|       |
  695|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  696|      0|        _parent = parent
  697|      0|        super.init(arity: 7, observer: observer, cancel: cancel)
  698|      0|    }
  699|       |
  700|      0|    override func hasElements(_ index: Int) -> Bool {
  701|      0|        switch (index) {
  702|      0|        case 0: return _values1.count > 0
  703|      0|        case 1: return _values2.count > 0
  704|      0|        case 2: return _values3.count > 0
  705|      0|        case 3: return _values4.count > 0
  706|      0|        case 4: return _values5.count > 0
  707|      0|        case 5: return _values6.count > 0
  708|      0|        case 6: return _values7.count > 0
  709|      0|
  710|      0|        default:
  711|      0|            rxFatalError("Unhandled case (Function)")
  712|      0|        }
  713|      0|
  714|      0|        return false
  715|      0|    }
  716|       |
  717|      0|    func run() -> Disposable {
  718|      0|        let subscription1 = SingleAssignmentDisposable()
  719|      0|        let subscription2 = SingleAssignmentDisposable()
  720|      0|        let subscription3 = SingleAssignmentDisposable()
  721|      0|        let subscription4 = SingleAssignmentDisposable()
  722|      0|        let subscription5 = SingleAssignmentDisposable()
  723|      0|        let subscription6 = SingleAssignmentDisposable()
  724|      0|        let subscription7 = SingleAssignmentDisposable()
  725|      0|
  726|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  727|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  728|      0|        let observer3 = ZipObserver(lock: _lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  729|      0|        let observer4 = ZipObserver(lock: _lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  730|      0|        let observer5 = ZipObserver(lock: _lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  731|      0|        let observer6 = ZipObserver(lock: _lock, parent: self, index: 5, setNextValue: { self._values6.enqueue($0) }, this: subscription6)
  732|      0|        let observer7 = ZipObserver(lock: _lock, parent: self, index: 6, setNextValue: { self._values7.enqueue($0) }, this: subscription7)
  733|      0|
  734|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
  735|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
  736|      0|        subscription3.setDisposable(_parent.source3.subscribe(observer3))
  737|      0|        subscription4.setDisposable(_parent.source4.subscribe(observer4))
  738|      0|        subscription5.setDisposable(_parent.source5.subscribe(observer5))
  739|      0|        subscription6.setDisposable(_parent.source6.subscribe(observer6))
  740|      0|        subscription7.setDisposable(_parent.source7.subscribe(observer7))
  741|      0|
  742|      0|        return Disposables.create([
  743|      0|           subscription1,
  744|      0|           subscription2,
  745|      0|           subscription3,
  746|      0|           subscription4,
  747|      0|           subscription5,
  748|      0|           subscription6,
  749|      0|           subscription7
  750|      0|        ])
  751|      0|    }
  752|       |
  753|      0|    override func getResult() throws -> R {
  754|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!, _values3.dequeue()!, _values4.dequeue()!, _values5.dequeue()!, _values6.dequeue()!, _values7.dequeue()!)
  755|      0|    }
  756|       |}
  757|       |
  758|       |final class Zip7<E1, E2, E3, E4, E5, E6, E7, R> : Producer<R> {
  759|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7) throws -> R
  760|       |
  761|       |    let source1: Observable<E1>
  762|       |    let source2: Observable<E2>
  763|       |    let source3: Observable<E3>
  764|       |    let source4: Observable<E4>
  765|       |    let source5: Observable<E5>
  766|       |    let source6: Observable<E6>
  767|       |    let source7: Observable<E7>
  768|       |
  769|       |    let _resultSelector: ResultSelector
  770|       |
  771|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, resultSelector: @escaping ResultSelector) {
  772|      0|        self.source1 = source1
  773|      0|        self.source2 = source2
  774|      0|        self.source3 = source3
  775|      0|        self.source4 = source4
  776|      0|        self.source5 = source5
  777|      0|        self.source6 = source6
  778|      0|        self.source7 = source7
  779|      0|
  780|      0|        _resultSelector = resultSelector
  781|      0|    }
  782|       |
  783|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  784|      0|        let sink = ZipSink7_(parent: self, observer: observer, cancel: cancel)
  785|      0|        let subscription = sink.run()
  786|      0|        return (sink: sink, subscription: subscription)
  787|      0|    }
  788|       |}
  789|       |
  790|       |
  791|       |
  792|       |// 8
  793|       |
  794|       |extension Observable {
  795|       |    /**
  796|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  797|       |
  798|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  799|       |
  800|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  801|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  802|       |    */
  803|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  804|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  805|      0|        -> Observable<E> {
  806|      0|        return Zip8(
  807|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  808|      0|            resultSelector: resultSelector
  809|      0|        )
  810|      0|    }
  811|       |}
  812|       |
  813|       |extension ObservableType where E == Any {
  814|       |    /**
  815|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  816|       |
  817|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  818|       |
  819|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  820|       |    */
  821|       |    public static func zip<O1: ObservableType, O2: ObservableType, O3: ObservableType, O4: ObservableType, O5: ObservableType, O6: ObservableType, O7: ObservableType, O8: ObservableType>
  822|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8)
  823|      0|        -> Observable<(O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E)> {
  824|      0|        return Zip8(
  825|      0|            source1: source1.asObservable(), source2: source2.asObservable(), source3: source3.asObservable(), source4: source4.asObservable(), source5: source5.asObservable(), source6: source6.asObservable(), source7: source7.asObservable(), source8: source8.asObservable(),
  826|      0|            resultSelector: { ($0, $1, $2, $3, $4, $5, $6, $7) }
  827|      0|        )
  828|      0|    }
  829|       |}
  830|       |
  831|       |final class ZipSink8_<E1, E2, E3, E4, E5, E6, E7, E8, O: ObserverType> : ZipSink<O> {
  832|       |    typealias R = O.E
  833|       |    typealias Parent = Zip8<E1, E2, E3, E4, E5, E6, E7, E8, R>
  834|       |
  835|       |    let _parent: Parent
  836|       |
  837|       |    var _values1: Queue<E1> = Queue(capacity: 2)
  838|       |    var _values2: Queue<E2> = Queue(capacity: 2)
  839|       |    var _values3: Queue<E3> = Queue(capacity: 2)
  840|       |    var _values4: Queue<E4> = Queue(capacity: 2)
  841|       |    var _values5: Queue<E5> = Queue(capacity: 2)
  842|       |    var _values6: Queue<E6> = Queue(capacity: 2)
  843|       |    var _values7: Queue<E7> = Queue(capacity: 2)
  844|       |    var _values8: Queue<E8> = Queue(capacity: 2)
  845|       |
  846|      0|    init(parent: Parent, observer: O, cancel: Cancelable) {
  847|      0|        _parent = parent
  848|      0|        super.init(arity: 8, observer: observer, cancel: cancel)
  849|      0|    }
  850|       |
  851|      0|    override func hasElements(_ index: Int) -> Bool {
  852|      0|        switch (index) {
  853|      0|        case 0: return _values1.count > 0
  854|      0|        case 1: return _values2.count > 0
  855|      0|        case 2: return _values3.count > 0
  856|      0|        case 3: return _values4.count > 0
  857|      0|        case 4: return _values5.count > 0
  858|      0|        case 5: return _values6.count > 0
  859|      0|        case 6: return _values7.count > 0
  860|      0|        case 7: return _values8.count > 0
  861|      0|
  862|      0|        default:
  863|      0|            rxFatalError("Unhandled case (Function)")
  864|      0|        }
  865|      0|
  866|      0|        return false
  867|      0|    }
  868|       |
  869|      0|    func run() -> Disposable {
  870|      0|        let subscription1 = SingleAssignmentDisposable()
  871|      0|        let subscription2 = SingleAssignmentDisposable()
  872|      0|        let subscription3 = SingleAssignmentDisposable()
  873|      0|        let subscription4 = SingleAssignmentDisposable()
  874|      0|        let subscription5 = SingleAssignmentDisposable()
  875|      0|        let subscription6 = SingleAssignmentDisposable()
  876|      0|        let subscription7 = SingleAssignmentDisposable()
  877|      0|        let subscription8 = SingleAssignmentDisposable()
  878|      0|
  879|      0|        let observer1 = ZipObserver(lock: _lock, parent: self, index: 0, setNextValue: { self._values1.enqueue($0) }, this: subscription1)
  880|      0|        let observer2 = ZipObserver(lock: _lock, parent: self, index: 1, setNextValue: { self._values2.enqueue($0) }, this: subscription2)
  881|      0|        let observer3 = ZipObserver(lock: _lock, parent: self, index: 2, setNextValue: { self._values3.enqueue($0) }, this: subscription3)
  882|      0|        let observer4 = ZipObserver(lock: _lock, parent: self, index: 3, setNextValue: { self._values4.enqueue($0) }, this: subscription4)
  883|      0|        let observer5 = ZipObserver(lock: _lock, parent: self, index: 4, setNextValue: { self._values5.enqueue($0) }, this: subscription5)
  884|      0|        let observer6 = ZipObserver(lock: _lock, parent: self, index: 5, setNextValue: { self._values6.enqueue($0) }, this: subscription6)
  885|      0|        let observer7 = ZipObserver(lock: _lock, parent: self, index: 6, setNextValue: { self._values7.enqueue($0) }, this: subscription7)
  886|      0|        let observer8 = ZipObserver(lock: _lock, parent: self, index: 7, setNextValue: { self._values8.enqueue($0) }, this: subscription8)
  887|      0|
  888|      0|        subscription1.setDisposable(_parent.source1.subscribe(observer1))
  889|      0|        subscription2.setDisposable(_parent.source2.subscribe(observer2))
  890|      0|        subscription3.setDisposable(_parent.source3.subscribe(observer3))
  891|      0|        subscription4.setDisposable(_parent.source4.subscribe(observer4))
  892|      0|        subscription5.setDisposable(_parent.source5.subscribe(observer5))
  893|      0|        subscription6.setDisposable(_parent.source6.subscribe(observer6))
  894|      0|        subscription7.setDisposable(_parent.source7.subscribe(observer7))
  895|      0|        subscription8.setDisposable(_parent.source8.subscribe(observer8))
  896|      0|
  897|      0|        return Disposables.create([
  898|      0|           subscription1,
  899|      0|           subscription2,
  900|      0|           subscription3,
  901|      0|           subscription4,
  902|      0|           subscription5,
  903|      0|           subscription6,
  904|      0|           subscription7,
  905|      0|           subscription8
  906|      0|        ])
  907|      0|    }
  908|       |
  909|      0|    override func getResult() throws -> R {
  910|      0|        return try _parent._resultSelector(_values1.dequeue()!, _values2.dequeue()!, _values3.dequeue()!, _values4.dequeue()!, _values5.dequeue()!, _values6.dequeue()!, _values7.dequeue()!, _values8.dequeue()!)
  911|      0|    }
  912|       |}
  913|       |
  914|       |final class Zip8<E1, E2, E3, E4, E5, E6, E7, E8, R> : Producer<R> {
  915|       |    typealias ResultSelector = (E1, E2, E3, E4, E5, E6, E7, E8) throws -> R
  916|       |
  917|       |    let source1: Observable<E1>
  918|       |    let source2: Observable<E2>
  919|       |    let source3: Observable<E3>
  920|       |    let source4: Observable<E4>
  921|       |    let source5: Observable<E5>
  922|       |    let source6: Observable<E6>
  923|       |    let source7: Observable<E7>
  924|       |    let source8: Observable<E8>
  925|       |
  926|       |    let _resultSelector: ResultSelector
  927|       |
  928|      0|    init(source1: Observable<E1>, source2: Observable<E2>, source3: Observable<E3>, source4: Observable<E4>, source5: Observable<E5>, source6: Observable<E6>, source7: Observable<E7>, source8: Observable<E8>, resultSelector: @escaping ResultSelector) {
  929|      0|        self.source1 = source1
  930|      0|        self.source2 = source2
  931|      0|        self.source3 = source3
  932|      0|        self.source4 = source4
  933|      0|        self.source5 = source5
  934|      0|        self.source6 = source6
  935|      0|        self.source7 = source7
  936|      0|        self.source8 = source8
  937|      0|
  938|      0|        _resultSelector = resultSelector
  939|      0|    }
  940|       |
  941|      0|    override func run<O: ObserverType>(_ observer: O, cancel: Cancelable) -> (sink: Disposable, subscription: Disposable) where O.E == R {
  942|      0|        let sink = ZipSink8_(parent: self, observer: observer, cancel: cancel)
  943|      0|        let subscription = sink.run()
  944|      0|        return (sink: sink, subscription: subscription)
  945|      0|    }
  946|       |}
  947|       |
  948|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Implementations/Zip.swift:
    1|       |//
    2|       |//  Zip.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |protocol ZipSinkProtocol : class
   10|       |{
   11|       |    func next(_ index: Int)
   12|       |    func fail(_ error: Swift.Error)
   13|       |    func done(_ index: Int)
   14|       |}
   15|       |
   16|       |class ZipSink<O: ObserverType> : Sink<O>, ZipSinkProtocol {
   17|       |    typealias Element = O.E
   18|       |    
   19|       |    let _arity: Int
   20|       |
   21|       |    let _lock = RecursiveLock()
   22|       |
   23|       |    // state
   24|       |    private var _isDone: [Bool]
   25|       |    
   26|      0|    init(arity: Int, observer: O, cancel: Cancelable) {
   27|      0|        _isDone = [Bool](repeating: false, count: arity)
   28|      0|        _arity = arity
   29|      0|        
   30|      0|        super.init(observer: observer, cancel: cancel)
   31|      0|    }
   32|       |
   33|      0|    func getResult() throws -> Element {
   34|      0|        rxAbstractMethod()
   35|      0|    }
   36|       |    
   37|      0|    func hasElements(_ index: Int) -> Bool {
   38|      0|        rxAbstractMethod()
   39|      0|    }
   40|       |    
   41|      0|    func next(_ index: Int) {
   42|      0|        var hasValueAll = true
   43|      0|        
   44|      0|        for i in 0 ..< _arity {
   45|      0|            if !hasElements(i) {
   46|      0|                hasValueAll = false
   47|      0|                break
   48|      0|            }
   49|      0|        }
   50|      0|        
   51|      0|        if hasValueAll {
   52|      0|            do {
   53|      0|                let result = try getResult()
   54|      0|                self.forwardOn(.next(result))
   55|      0|            }
   56|      0|            catch let e {
   57|      0|                self.forwardOn(.error(e))
   58|      0|                dispose()
   59|      0|            }
   60|      0|        }
   61|      0|        else {
   62|      0|            var allOthersDone = true
   63|      0|            
   64|      0|            let arity = _isDone.count
   65|      0|            for i in 0 ..< arity {
   66|      0|                if i != index && !_isDone[i] {
   67|      0|                    allOthersDone = false
   68|      0|                    break
   69|      0|                }
   70|      0|            }
   71|      0|            
   72|      0|            if allOthersDone {
   73|      0|                forwardOn(.completed)
   74|      0|                self.dispose()
   75|      0|            }
   76|      0|        }
   77|      0|    }
   78|       |    
   79|      0|    func fail(_ error: Swift.Error) {
   80|      0|        forwardOn(.error(error))
   81|      0|        dispose()
   82|      0|    }
   83|       |    
   84|      0|    func done(_ index: Int) {
   85|      0|        _isDone[index] = true
   86|      0|        
   87|      0|        var allDone = true
   88|      0|        
   89|      0|        for done in _isDone {
   90|      0|            if !done {
   91|      0|                allDone = false
   92|      0|                break
   93|      0|            }
   94|      0|        }
   95|      0|        
   96|      0|        if allDone {
   97|      0|            forwardOn(.completed)
   98|      0|            dispose()
   99|      0|        }
  100|      0|    }
  101|       |}
  102|       |
  103|       |final class ZipObserver<ElementType>
  104|       |    : ObserverType
  105|       |    , LockOwnerType
  106|       |    , SynchronizedOnType {
  107|       |    typealias E = ElementType
  108|       |    typealias ValueSetter = (ElementType) -> ()
  109|       |
  110|       |    private var _parent: ZipSinkProtocol?
  111|       |    
  112|       |    let _lock: RecursiveLock
  113|       |    
  114|       |    // state
  115|       |    private let _index: Int
  116|       |    private let _this: Disposable
  117|       |    private let _setNextValue: ValueSetter
  118|       |    
  119|      0|    init(lock: RecursiveLock, parent: ZipSinkProtocol, index: Int, setNextValue: @escaping ValueSetter, this: Disposable) {
  120|      0|        _lock = lock
  121|      0|        _parent = parent
  122|      0|        _index = index
  123|      0|        _this = this
  124|      0|        _setNextValue = setNextValue
  125|      0|    }
  126|       |    
  127|      0|    func on(_ event: Event<E>) {
  128|      0|        synchronizedOn(event)
  129|      0|    }
  130|       |
  131|      0|    func _synchronized_on(_ event: Event<E>) {
  132|      0|        if let _ = _parent {
  133|      0|            switch event {
  134|      0|            case .next(_):
  135|      0|                break
  136|      0|            case .error(_):
  137|      0|                _this.dispose()
  138|      0|            case .completed:
  139|      0|                _this.dispose()
  140|      0|            }
  141|      0|        }
  142|      0|        
  143|      0|        if let parent = _parent {
  144|      0|            switch event {
  145|      0|            case .next(let value):
  146|      0|                _setNextValue(value)
  147|      0|                parent.next(_index)
  148|      0|            case .error(let error):
  149|      0|                parent.fail(error)
  150|      0|            case .completed:
  151|      0|                parent.done(_index)
  152|      0|            }
  153|      0|        }
  154|      0|    }
  155|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Aggregate.swift:
    1|       |//
    2|       |//  Observable+Aggregate.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/22/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: reduce
   10|       |
   11|       |extension ObservableType {
   12|       |    
   13|       |    /**
   14|       |    Applies an `accumulator` function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified `seed` value is used as the initial accumulator value.
   15|       |
   16|       |    For aggregation behavior with incremental intermediate results, see `scan`.
   17|       |
   18|       |    - seealso: [reduce operator on reactivex.io](http://reactivex.io/documentation/operators/reduce.html)
   19|       |
   20|       |    - parameter seed: The initial accumulator value.
   21|       |    - parameter accumulator: A accumulator function to be invoked on each element.
   22|       |    - parameter mapResult: A function to transform the final accumulator value into the result value.
   23|       |    - returns: An observable sequence containing a single element with the final accumulator value.
   24|       |    */
   25|       |    public func reduce<A, R>(_ seed: A, accumulator: @escaping (A, E) throws -> A, mapResult: @escaping (A) throws -> R)
   26|      0|        -> Observable<R> {
   27|      0|        return Reduce(source: self.asObservable(), seed: seed, accumulator: accumulator, mapResult: mapResult)
   28|      0|    }
   29|       |
   30|       |    /**
   31|       |    Applies an `accumulator` function over an observable sequence, returning the result of the aggregation as a single element in the result sequence. The specified `seed` value is used as the initial accumulator value.
   32|       |    
   33|       |    For aggregation behavior with incremental intermediate results, see `scan`.
   34|       |
   35|       |    - seealso: [reduce operator on reactivex.io](http://reactivex.io/documentation/operators/reduce.html)
   36|       |    
   37|       |    - parameter seed: The initial accumulator value.
   38|       |    - parameter accumulator: A accumulator function to be invoked on each element.
   39|       |    - returns: An observable sequence containing a single element with the final accumulator value.
   40|       |    */
   41|       |    public func reduce<A>(_ seed: A, accumulator: @escaping (A, E) throws -> A)
   42|      0|        -> Observable<A> {
   43|      0|        return Reduce(source: self.asObservable(), seed: seed, accumulator: accumulator, mapResult: { $0 })
   44|      0|    }
   45|       |
   46|       |    /**
   47|       |    Converts an Observable into another Observable that emits the whole sequence as a single array and then terminates.
   48|       |    
   49|       |    For aggregation behavior see `reduce`.
   50|       |
   51|       |    - seealso: [toArray operator on reactivex.io](http://reactivex.io/documentation/operators/to.html)
   52|       |    
   53|       |    - returns: An observable sequence containing all the emitted elements as array.
   54|       |    */
   55|       |    public func toArray()
   56|      0|        -> Observable<[E]> {
   57|      0|            return ToArray(source: self.asObservable())
   58|      0|    }
   59|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Binding.swift:
    1|       |//
    2|       |//  Observable+Binding.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: multicast
   10|       |
   11|       |extension ObservableType {
   12|       |    
   13|       |    /**
   14|       |    Multicasts the source sequence notifications through the specified subject to the resulting connectable observable. 
   15|       |    
   16|       |    Upon connection of the connectable observable, the subject is subscribed to the source exactly one, and messages are forwarded to the observers registered with the connectable observable.
   17|       |    
   18|       |    For specializations with fixed subject types, see `publish` and `replay`.
   19|       |
   20|       |    - seealso: [multicast operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
   21|       |    
   22|       |    - parameter subject: Subject to push source elements into.
   23|       |    - returns: A connectable observable sequence that upon connection causes the source sequence to push results into the specified subject.
   24|       |    */
   25|       |    public func multicast<S: SubjectType>(_ subject: S)
   26|     42|        -> ConnectableObservable<S.E> where S.SubjectObserverType.E == E {
   27|     42|        return ConnectableObservableAdapter(source: self.asObservable(), subject: subject)
   28|     42|    }
   29|       |
   30|       |    /**
   31|       |    Multicasts the source sequence notifications through an instantiated subject into all uses of the sequence within a selector function. 
   32|       |    
   33|       |    Each subscription to the resulting sequence causes a separate multicast invocation, exposing the sequence resulting from the selector function's invocation.
   34|       |
   35|       |    For specializations with fixed subject types, see `publish` and `replay`.
   36|       |
   37|       |    - seealso: [multicast operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
   38|       |    
   39|       |    - parameter subjectSelector: Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function.
   40|       |    - parameter selector: Selector function which can use the multicasted source sequence subject to the policies enforced by the created subject.
   41|       |    - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence within a selector function.
   42|       |    */
   43|       |    public func multicast<S: SubjectType, R>(_ subjectSelector: @escaping () throws -> S, selector: @escaping (Observable<S.E>) throws -> Observable<R>)
   44|      0|        -> Observable<R> where S.SubjectObserverType.E == E {
   45|      0|        return Multicast(
   46|      0|            source: self.asObservable(),
   47|      0|            subjectSelector: subjectSelector,
   48|      0|            selector: selector
   49|      0|        )
   50|      0|    }
   51|       |}
   52|       |
   53|       |// MARK: publish
   54|       |
   55|       |extension ObservableType {
   56|       |    
   57|       |    /**
   58|       |    Returns a connectable observable sequence that shares a single subscription to the underlying sequence. 
   59|       |    
   60|       |    This operator is a specialization of `multicast` using a `PublishSubject`.
   61|       |
   62|       |    - seealso: [publish operator on reactivex.io](http://reactivex.io/documentation/operators/publish.html)
   63|       |    
   64|       |    - returns: A connectable observable sequence that shares a single subscription to the underlying sequence.
   65|       |    */
   66|     42|    public func publish() -> ConnectableObservable<E> {
   67|     42|        return self.multicast(PublishSubject())
   68|     42|    }
   69|       |}
   70|       |
   71|       |// MARK: replay
   72|       |
   73|       |extension ObservableType {
   74|       |    
   75|       |    /**
   76|       |    Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying bufferSize elements.
   77|       |
   78|       |    This operator is a specialization of `multicast` using a `ReplaySubject`.
   79|       |
   80|       |    - seealso: [replay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
   81|       |    
   82|       |    - parameter bufferSize: Maximum element count of the replay buffer.
   83|       |    - returns: A connectable observable sequence that shares a single subscription to the underlying sequence.
   84|       |    */
   85|       |    public func replay(_ bufferSize: Int)
   86|      0|        -> ConnectableObservable<E> {
   87|      0|        return self.multicast(ReplaySubject.create(bufferSize: bufferSize))
   88|      0|    }
   89|       |
   90|       |    /**
   91|       |    Returns a connectable observable sequence that shares a single subscription to the underlying sequence replaying all elements.
   92|       |
   93|       |    This operator is a specialization of `multicast` using a `ReplaySubject`.
   94|       |
   95|       |    - seealso: [replay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
   96|       |
   97|       |    - returns: A connectable observable sequence that shares a single subscription to the underlying sequence.
   98|       |    */
   99|       |    public func replayAll()
  100|      0|        -> ConnectableObservable<E> {
  101|      0|        return self.multicast(ReplaySubject.createUnbounded())
  102|      0|    }
  103|       |}
  104|       |
  105|       |// MARK: refcount
  106|       |
  107|       |extension ConnectableObservableType {
  108|       |    
  109|       |    /**
  110|       |    Returns an observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.
  111|       |
  112|       |    - seealso: [refCount operator on reactivex.io](http://reactivex.io/documentation/operators/refCount.html)
  113|       |    
  114|       |    - returns: An observable sequence that stays connected to the source as long as there is at least one subscription to the observable sequence.
  115|       |    */
  116|     42|    public func refCount() -> Observable<E> {
  117|     42|        return RefCount(source: self)
  118|     42|    }
  119|       |}
  120|       |
  121|       |// MARK: share
  122|       |
  123|       |extension ObservableType {
  124|       |    
  125|       |    /**
  126|       |    Returns an observable sequence that shares a single subscription to the underlying sequence.
  127|       |    
  128|       |    This operator is a specialization of publish which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
  129|       |
  130|       |    - seealso: [share operator on reactivex.io](http://reactivex.io/documentation/operators/refcount.html)
  131|       |
  132|       |    - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
  133|       |    */
  134|     42|    public func share() -> Observable<E> {
  135|     42|        return self.publish().refCount()
  136|     42|    }
  137|       |}
  138|       |
  139|       |// MARK: shareReplay
  140|       |
  141|       |extension ObservableType {
  142|       |    
  143|       |    /**
  144|       |    Returns an observable sequence that shares a single subscription to the underlying sequence, and immediately upon subscription replays maximum number of elements in buffer.
  145|       |    
  146|       |    This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
  147|       |
  148|       |    - seealso: [shareReplay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
  149|       |    
  150|       |    - parameter bufferSize: Maximum element count of the replay buffer.
  151|       |    - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
  152|       |    */
  153|       |    public func shareReplay(_ bufferSize: Int)
  154|    250|        -> Observable<E> {
  155|    250|        if bufferSize == 1 {
  156|    250|            return ShareReplay1(source: self.asObservable())
  157|      0|        }
  158|      0|        else {
  159|      0|            return self.replay(bufferSize).refCount()
  160|      0|        }
  161|      0|    }
  162|       |
  163|       |    /**
  164|       |    Returns an observable sequence that shares a single subscription to the underlying sequence, and immediately upon subscription replays latest element in buffer.
  165|       |
  166|       |    This operator is a specialization of replay which creates a subscription when the number of observers goes from zero to one, then shares that subscription with all subsequent observers until the number of observers returns to zero, at which point the subscription is disposed.
  167|       |     
  168|       |    Unlike `shareReplay(bufferSize: Int)`, this operator will clear latest element from replay buffer in case number of subscribers drops from one to zero. In case sequence
  169|       |    completes or errors out replay buffer is also cleared.
  170|       |
  171|       |    - seealso: [shareReplay operator on reactivex.io](http://reactivex.io/documentation/operators/replay.html)
  172|       |    
  173|       |    - returns: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.
  174|       |    */
  175|       |    public func shareReplayLatestWhileConnected()
  176|     31|        -> Observable<E> {
  177|     31|        return ShareReplay1WhileConnected(source: self.asObservable())
  178|     31|    }
  179|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Concurrency.swift:
    1|       |//
    2|       |//  Observable+Concurrency.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: observeOn
   10|       |
   11|       |extension ObservableType {
   12|       |    
   13|       |    /**
   14|       |    Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
   15|       |    
   16|       |    This only invokes observer callbacks on a `scheduler`. In case the subscription and/or unsubscription
   17|       |    actions have side-effects that require to be run on a scheduler, use `subscribeOn`.
   18|       |
   19|       |    - seealso: [observeOn operator on reactivex.io](http://reactivex.io/documentation/operators/observeon.html)
   20|       |    
   21|       |    - parameter scheduler: Scheduler to notify observers on.
   22|       |    - returns: The source sequence whose observations happen on the specified scheduler.
   23|       |    */
   24|       |    public func observeOn(_ scheduler: ImmediateSchedulerType)
   25|     42|        -> Observable<E> {
   26|     42|        if let scheduler = scheduler as? SerialDispatchQueueScheduler {
   27|     42|            return ObserveOnSerialDispatchQueue(source: self.asObservable(), scheduler: scheduler)
   28|      0|        }
   29|      0|        else {
   30|      0|            return ObserveOn(source: self.asObservable(), scheduler: scheduler)
   31|      0|        }
   32|      0|    }
   33|       |}
   34|       |
   35|       |// MARK: subscribeOn
   36|       |
   37|       |extension ObservableType {
   38|       |    
   39|       |    /**
   40|       |    Wraps the source sequence in order to run its subscription and unsubscription logic on the specified 
   41|       |    scheduler. 
   42|       |    
   43|       |    This operation is not commonly used.
   44|       |    
   45|       |    This only performs the side-effects of subscription and unsubscription on the specified scheduler. 
   46|       |    
   47|       |    In order to invoke observer callbacks on a `scheduler`, use `observeOn`.
   48|       |
   49|       |    - seealso: [subscribeOn operator on reactivex.io](http://reactivex.io/documentation/operators/subscribeon.html)
   50|       |    
   51|       |    - parameter scheduler: Scheduler to perform subscription and unsubscription actions on.
   52|       |    - returns: The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
   53|       |    */
   54|       |    public func subscribeOn(_ scheduler: ImmediateSchedulerType)
   55|    594|        -> Observable<E> {
   56|    594|        return SubscribeOn(source: self, scheduler: scheduler)
   57|    594|    }
   58|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Creation.swift:
    1|       |//
    2|       |//  Observable+Creation.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |extension Observable {
   10|       |    // MARK: create
   11|       |
   12|       |    /**
   13|       |    Creates an observable sequence from a specified subscribe method implementation.
   14|       |
   15|       |    - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   16|       |
   17|       |    - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
   18|       |    - returns: The observable sequence with the specified implementation for the `subscribe` method.
   19|       |    */
   20|    387|    public static func create(_ subscribe: @escaping (AnyObserver<E>) -> Disposable) -> Observable<E> {
   21|    387|        return AnonymousObservable(subscribe)
   22|    387|    }
   23|       |
   24|       |    // MARK: empty
   25|       |
   26|       |    /**
   27|       |    Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
   28|       |
   29|       |    - seealso: [empty operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
   30|       |
   31|       |    - returns: An observable sequence with no elements.
   32|       |    */
   33|      0|    public static func empty() -> Observable<E> {
   34|      0|        return EmptyProducer<E>()
   35|      0|    }
   36|       |
   37|       |    // MARK: never
   38|       |
   39|       |    /**
   40|       |    Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
   41|       |
   42|       |    - seealso: [never operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
   43|       |
   44|       |    - returns: An observable sequence whose observers will never get called.
   45|       |    */
   46|      4|    public static func never() -> Observable<E> {
   47|      4|        return NeverProducer()
   48|      4|    }
   49|       |
   50|       |    // MARK: just
   51|       |
   52|       |    /**
   53|       |    Returns an observable sequence that contains a single element.
   54|       |
   55|       |    - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
   56|       |
   57|       |    - parameter element: Single element in the resulting observable sequence.
   58|       |    - returns: An observable sequence containing the single specified element.
   59|       |    */
   60|     51|    public static func just(_ element: E) -> Observable<E> {
   61|     51|        return Just(element: element)
   62|     51|    }
   63|       |
   64|       |    /**
   65|       |     Returns an observable sequence that contains a single element.
   66|       |
   67|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
   68|       |
   69|       |     - parameter element: Single element in the resulting observable sequence.
   70|       |     - parameter: Scheduler to send the single element on.
   71|       |     - returns: An observable sequence containing the single specified element.
   72|       |     */
   73|      0|    public static func just(_ element: E, scheduler: ImmediateSchedulerType) -> Observable<E> {
   74|      0|        return JustScheduled(element: element, scheduler: scheduler)
   75|      0|    }
   76|       |
   77|       |    // MARK: fail
   78|       |
   79|       |    /**
   80|       |    Returns an observable sequence that terminates with an `error`.
   81|       |
   82|       |    - seealso: [throw operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
   83|       |
   84|       |    - returns: The observable sequence that terminates with specified error.
   85|       |    */
   86|      7|    public static func error(_ error: Swift.Error) -> Observable<E> {
   87|      7|        return ErrorProducer(error: error)
   88|      7|    }
   89|       |
   90|       |    // MARK: of
   91|       |
   92|       |    /**
   93|       |    This method creates a new Observable instance with a variable number of elements.
   94|       |
   95|       |    - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
   96|       |
   97|       |    - parameter elements: Elements to generate.
   98|       |    - parameter scheduler: Scheduler to send elements on. If `nil`, elements are sent immediatelly on subscription.
   99|       |    - returns: The observable sequence whose elements are pulled from the given arguments.
  100|       |    */
  101|      0|    public static func of(_ elements: E ..., scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
  102|      0|        return ObservableSequence(elements: elements, scheduler: scheduler)
  103|      0|    }
  104|       |
  105|       |    // MARK: defer
  106|       |
  107|       |    /**
  108|       |    Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
  109|       |
  110|       |    - seealso: [defer operator on reactivex.io](http://reactivex.io/documentation/operators/defer.html)
  111|       |
  112|       |    - parameter observableFactory: Observable factory function to invoke for each observer that subscribes to the resulting sequence.
  113|       |    - returns: An observable sequence whose observers trigger an invocation of the given observable factory function.
  114|       |    */
  115|       |    public static func deferred(_ observableFactory: @escaping () throws -> Observable<E>)
  116|      0|        -> Observable<E> {
  117|      0|        return Deferred(observableFactory: observableFactory)
  118|      0|    }
  119|       |
  120|       |    /**
  121|       |    Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler
  122|       |    to run the loop send out observer messages.
  123|       |
  124|       |    - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
  125|       |
  126|       |    - parameter initialState: Initial state.
  127|       |    - parameter condition: Condition to terminate generation (upon returning `false`).
  128|       |    - parameter iterate: Iteration step function.
  129|       |    - parameter scheduler: Scheduler on which to run the generator loop.
  130|       |    - returns: The generated sequence.
  131|       |    */
  132|      0|    public static func generate(initialState: E, condition: @escaping (E) throws -> Bool, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance, iterate: @escaping (E) throws -> E) -> Observable<E> {
  133|      0|        return Generate(initialState: initialState, condition: condition, iterate: iterate, resultSelector: { $0 }, scheduler: scheduler)
  134|      0|    }
  135|       |
  136|       |    /**
  137|       |    Generates an observable sequence that repeats the given element infinitely, using the specified scheduler to send out observer messages.
  138|       |
  139|       |    - seealso: [repeat operator on reactivex.io](http://reactivex.io/documentation/operators/repeat.html)
  140|       |
  141|       |    - parameter element: Element to repeat.
  142|       |    - parameter scheduler: Scheduler to run the producer loop on.
  143|       |    - returns: An observable sequence that repeats the given element infinitely.
  144|       |    */
  145|      0|    public static func repeatElement(_ element: E, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
  146|      0|        return RepeatElement(element: element, scheduler: scheduler)
  147|      0|    }
  148|       |
  149|       |    /**
  150|       |    Constructs an observable sequence that depends on a resource object, whose lifetime is tied to the resulting observable sequence's lifetime.
  151|       |
  152|       |    - seealso: [using operator on reactivex.io](http://reactivex.io/documentation/operators/using.html)
  153|       |     
  154|       |    - parameter resourceFactory: Factory function to obtain a resource object.
  155|       |    - parameter observableFactory: Factory function to obtain an observable sequence that depends on the obtained resource.
  156|       |    - returns: An observable sequence whose lifetime controls the lifetime of the dependent resource object.
  157|       |    */
  158|      0|    public static func using<R: Disposable>(_ resourceFactory: @escaping () throws -> R, observableFactory: @escaping (R) throws -> Observable<E>) -> Observable<E> {
  159|      0|        return Using(resourceFactory: resourceFactory, observableFactory: observableFactory)
  160|      0|    }
  161|       |}
  162|       |
  163|       |extension Observable where Element : SignedInteger {
  164|       |    /**
  165|       |    Generates an observable sequence of integral numbers within a specified range, using the specified scheduler to generate and send out observer messages.
  166|       |
  167|       |    - seealso: [range operator on reactivex.io](http://reactivex.io/documentation/operators/range.html)
  168|       |
  169|       |    - parameter start: The value of the first integer in the sequence.
  170|       |    - parameter count: The number of sequential integers to generate.
  171|       |    - parameter scheduler: Scheduler to run the generator loop on.
  172|       |    - returns: An observable sequence that contains a range of sequential integral numbers.
  173|       |    */
  174|      0|    public static func range(start: E, count: E, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
  175|      0|        return RangeProducer<E>(start: start, count: count, scheduler: scheduler)
  176|      0|    }
  177|       |}
  178|       |
  179|       |extension Observable {
  180|       |    /**
  181|       |     Converts an array to an observable sequence.
  182|       |
  183|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  184|       |
  185|       |     - returns: The observable sequence whose elements are pulled from the given enumerable sequence.
  186|       |     */
  187|      0|    public static func from(_ array: [E], scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> {
  188|      0|        return ObservableSequence(elements: array, scheduler: scheduler)
  189|      0|    }
  190|       |
  191|       |    /**
  192|       |     Converts a sequence to an observable sequence.
  193|       |
  194|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  195|       |
  196|       |     - returns: The observable sequence whose elements are pulled from the given enumerable sequence.
  197|       |     */
  198|      0|    public static func from<S: Sequence>(_ sequence: S, scheduler: ImmediateSchedulerType = CurrentThreadScheduler.instance) -> Observable<E> where S.Iterator.Element == E {
  199|      0|        return ObservableSequence(elements: sequence, scheduler: scheduler)
  200|      0|    }
  201|       |    
  202|       |    /**
  203|       |     Converts a optional to an observable sequence.
  204|       |
  205|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  206|       |
  207|       |     - parameter optional: Optional element in the resulting observable sequence.
  208|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
  209|       |     */
  210|      0|    public static func from(optional: E?) -> Observable<E> {
  211|      0|        return ObservableOptional(optional: optional)
  212|      0|    }
  213|       |    
  214|       |    /**
  215|       |     Converts a optional to an observable sequence.
  216|       |     
  217|       |     - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  218|       |     
  219|       |     - parameter optional: Optional element in the resulting observable sequence.
  220|       |     - parameter: Scheduler to send the optional element on.
  221|       |     - returns: An observable sequence containing the wrapped value or not from given optional.
  222|       |     */
  223|      0|    public static func from(optional: E?, scheduler: ImmediateSchedulerType) -> Observable<E> {
  224|      0|        return ObservableOptionalScheduled(optional: optional, scheduler: scheduler)
  225|      0|    }
  226|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Debug.swift:
    1|       |//
    2|       |//  Observable+Debug.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: debug
   10|       |
   11|       |extension ObservableType {
   12|       |    
   13|       |    /**
   14|       |    Prints received events for all observers on standard output.
   15|       |
   16|       |    - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
   17|       |    
   18|       |    - parameter identifier: Identifier that is printed together with event description to standard output.
   19|       |    - parameter trimOutput: Should output be trimmed to max 40 characters.
   20|       |    - returns: An observable sequence whose events are printed to standard output.
   21|       |    */
   22|       |    public func debug(_ identifier: String? = nil, trimOutput: Bool = false, file: String = #file, line: UInt = #line, function: String = #function)
   23|      5|        -> Observable<E> {
   24|      5|        return Debug(source: self, identifier: identifier, trimOutput: trimOutput, file: file, line: line, function: function)
   25|      5|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Multiple.swift:
    1|       |//
    2|       |//  Observable+Multiple.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: combineLatest
   10|       |
   11|       |extension Observable {
   12|       |    /**
   13|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   14|       |
   15|       |     - seealso: [combinelatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   16|       |
   17|       |     - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   18|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   19|       |     */
   20|       |    public static func combineLatest<C: Collection>(_ collection: C, _ resultSelector: @escaping ([C.Iterator.Element.E]) throws -> Element) -> Observable<Element>
   21|      0|        where C.Iterator.Element: ObservableType {
   22|      0|        return CombineLatestCollectionType(sources: collection, resultSelector: resultSelector)
   23|      0|    }
   24|       |
   25|       |    /**
   26|       |     Merges the specified observable sequences into one observable sequence whenever any of the observable sequences produces an element.
   27|       |
   28|       |     - seealso: [combinelatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
   29|       |
   30|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   31|       |     */
   32|       |    public static func combineLatest<C: Collection>(_ collection: C) -> Observable<[Element]>
   33|     34|        where C.Iterator.Element: ObservableType, C.Iterator.Element.E == Element {
   34|     35|        return CombineLatestCollectionType(sources: collection, resultSelector: { $0 })
   35|     34|    }
   36|       |}
   37|       |
   38|       |// MARK: zip
   39|       |
   40|       |extension Observable {
   41|       |    /**
   42|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   43|       |
   44|       |     - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   45|       |
   46|       |     - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   47|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   48|       |     */
   49|       |    public static func zip<C: Collection>(_ collection: C, _ resultSelector: @escaping ([C.Iterator.Element.E]) throws -> Element) -> Observable<Element>
   50|      0|        where C.Iterator.Element: ObservableType {
   51|      0|            return ZipCollectionType(sources: collection, resultSelector: resultSelector)
   52|      0|    }
   53|       |
   54|       |    /**
   55|       |     Merges the specified observable sequences into one observable sequence whenever all of the observable sequences have produced an element at a corresponding index.
   56|       |
   57|       |     - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   58|       |
   59|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   60|       |     */
   61|       |    public static func zip<C: Collection>(_ collection: C) -> Observable<[Element]>
   62|      0|        where C.Iterator.Element: ObservableType, C.Iterator.Element.E == Element {
   63|      0|            return ZipCollectionType(sources: collection, resultSelector: { $0 })
   64|      0|    }
   65|       |
   66|       |}
   67|       |
   68|       |// MARK: switch
   69|       |
   70|       |extension ObservableType where E : ObservableConvertibleType {
   71|       |    
   72|       |    /**
   73|       |    Transforms an observable sequence of observable sequences into an observable sequence
   74|       |    producing values only from the most recent observable sequence.
   75|       |    
   76|       |    Each time a new inner observable sequence is received, unsubscribe from the
   77|       |    previous inner observable sequence.
   78|       |
   79|       |    - seealso: [switch operator on reactivex.io](http://reactivex.io/documentation/operators/switch.html)
   80|       |
   81|       |    - returns: The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   82|       |    */
   83|      0|    public func switchLatest() -> Observable<E.E> {
   84|      0|        return Switch(source: asObservable())
   85|      0|    }
   86|       |}
   87|       |
   88|       |// switchIfEmpty
   89|       |
   90|       |extension ObservableType {
   91|       |    /**
   92|       |     Returns the elements of the specified sequence or `switchTo` sequence if the sequence is empty.
   93|       |     
   94|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
   95|       |
   96|       |     - parameter switchTo: Observable sequence being returned when source sequence is empty.
   97|       |     - returns: Observable sequence that contains elements from switchTo sequence if source is empty, otherwise returns source sequence elements.
   98|       |     */
   99|      0|    public func ifEmpty(switchTo other: Observable<E>) -> Observable<E> {
  100|      0|        return SwitchIfEmpty(source: asObservable(), ifEmpty: other)
  101|      0|    }
  102|       |}
  103|       |
  104|       |// MARK: concat
  105|       |
  106|       |extension ObservableType {
  107|       |
  108|       |    /**
  109|       |    Concatenates the second observable sequence to `self` upon successful termination of `self`.
  110|       |
  111|       |    - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  112|       |    
  113|       |    - parameter second: Second observable sequence.
  114|       |    - returns: An observable sequence that contains the elements of `self`, followed by those of the second sequence.
  115|       |    */
  116|      4|    public func concat<O: ObservableConvertibleType>(_ second: O) -> Observable<E> where O.E == E {
  117|      4|        return Observable.concat([self.asObservable(), second.asObservable()])
  118|      4|    }
  119|       |}
  120|       |
  121|       |extension Observable {
  122|       |    /**
  123|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  124|       |
  125|       |     This operator has tail recursive optimizations that will prevent stack overflow.
  126|       |
  127|       |     Optimizations will be performed in cases equivalent to following:
  128|       |
  129|       |     [1, [2, [3, .....].concat()].concat].concat()
  130|       |
  131|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  132|       |
  133|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  134|       |     */
  135|       |    public static func concat<S: Sequence >(_ sequence: S) -> Observable<Element>
  136|      0|        where S.Iterator.Element == Observable<Element> {
  137|      0|            return Concat(sources: sequence, count: nil)
  138|      0|    }
  139|       |
  140|       |    /**
  141|       |     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.
  142|       |
  143|       |     This operator has tail recursive optimizations that will prevent stack overflow.
  144|       |
  145|       |     Optimizations will be performed in cases equivalent to following:
  146|       |
  147|       |     [1, [2, [3, .....].concat()].concat].concat()
  148|       |
  149|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  150|       |
  151|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  152|       |     */
  153|       |    public static func concat<S: Collection >(_ collection: S) -> Observable<Element>
  154|      4|        where S.Iterator.Element == Observable<Element> {
  155|      4|            return Concat(sources: collection, count: collection.count.toIntMax())
  156|      4|    }
  157|       |
  158|       |    /**
  159|       |     Concatenates all observable sequences in the given collection, as long as the previous observable sequence terminated successfully.
  160|       |
  161|       |     This operator has tail recursive optimizations that will prevent stack overflow.
  162|       |
  163|       |     Optimizations will be performed in cases equivalent to following:
  164|       |
  165|       |     [1, [2, [3, .....].concat()].concat].concat()
  166|       |
  167|       |     - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  168|       |
  169|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  170|       |     */
  171|      0|    public static func concat(_ sources: Observable<Element> ...) -> Observable<Element> {
  172|      0|        return Concat(sources: sources, count: sources.count.toIntMax())
  173|      0|    }
  174|       |}
  175|       |
  176|       |extension ObservableType where E : ObservableConvertibleType {
  177|       |    
  178|       |    /**
  179|       |    Concatenates all inner observable sequences, as long as the previous observable sequence terminated successfully.
  180|       |
  181|       |    - seealso: [concat operator on reactivex.io](http://reactivex.io/documentation/operators/concat.html)
  182|       |    
  183|       |    - returns: An observable sequence that contains the elements of each observed inner sequence, in sequential order.
  184|       |    */
  185|      0|    public func concat() -> Observable<E.E> {
  186|      0|        return merge(maxConcurrent: 1)
  187|      0|    }
  188|       |}
  189|       |
  190|       |// MARK: merge
  191|       |
  192|       |extension Observable {
  193|       |    /**
  194|       |     Merges elements from all observable sequences from collection into a single observable sequence.
  195|       |
  196|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  197|       |
  198|       |     - parameter sources: Collection of observable sequences to merge.
  199|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  200|       |     */
  201|      0|    public static func merge<C: Collection>(_ sources: C) -> Observable<E> where C.Iterator.Element == Observable<E> {
  202|      0|        return MergeArray(sources: Array(sources))
  203|      0|    }
  204|       |
  205|       |    /**
  206|       |     Merges elements from all observable sequences from array into a single observable sequence.
  207|       |
  208|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  209|       |
  210|       |     - parameter sources: Array of observable sequences to merge.
  211|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  212|       |     */
  213|      0|    public static func merge(_ sources: [Observable<E>]) -> Observable<E> {
  214|      0|        return MergeArray(sources: sources)
  215|      0|    }
  216|       |
  217|       |    /**
  218|       |     Merges elements from all observable sequences into a single observable sequence.
  219|       |
  220|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  221|       |
  222|       |     - parameter sources: Collection of observable sequences to merge.
  223|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  224|       |     */
  225|      0|    public static func merge(_ sources: Observable<E>...) -> Observable<E> {
  226|      0|        return MergeArray(sources: sources)
  227|      0|    }
  228|       |}
  229|       |
  230|       |extension ObservableType where E : ObservableConvertibleType {
  231|       |    
  232|       |    /**
  233|       |    Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.
  234|       |
  235|       |    - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  236|       |    
  237|       |    - returns: The observable sequence that merges the elements of the observable sequences.
  238|       |    */
  239|      0|    public func merge() -> Observable<E.E> {
  240|      0|        return Merge(source: asObservable())
  241|      0|    }
  242|       |
  243|       |    /**
  244|       |    Merges elements from all inner observable sequences into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences.
  245|       |
  246|       |    - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  247|       |
  248|       |    - parameter maxConcurrent: Maximum number of inner observable sequences being subscribed to concurrently.
  249|       |    - returns: The observable sequence that merges the elements of the inner sequences.
  250|       |    */
  251|       |    public func merge(maxConcurrent: Int)
  252|      0|        -> Observable<E.E> {
  253|      0|        return MergeLimited(source: asObservable(), maxConcurrent: maxConcurrent)
  254|      0|    }
  255|       |}
  256|       |
  257|       |// MARK: catch
  258|       |
  259|       |extension ObservableType {
  260|       |    
  261|       |    /**
  262|       |    Continues an observable sequence that is terminated by an error with the observable sequence produced by the handler.
  263|       |
  264|       |    - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  265|       |    
  266|       |    - parameter handler: Error handler function, producing another observable sequence.
  267|       |    - returns: An observable sequence containing the source sequence's elements, followed by the elements produced by the handler's resulting observable sequence in case an error occurred.
  268|       |    */
  269|       |    public func catchError(_ handler: @escaping (Swift.Error) throws -> Observable<E>)
  270|      4|        -> Observable<E> {
  271|      4|        return Catch(source: asObservable(), handler: handler)
  272|      4|    }
  273|       |
  274|       |    /**
  275|       |    Continues an observable sequence that is terminated by an error with a single element.
  276|       |
  277|       |    - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  278|       |    
  279|       |    - parameter element: Last element in an observable sequence in case error occurs.
  280|       |    - returns: An observable sequence containing the source sequence's elements, followed by the `element` in case an error occurred.
  281|       |    */
  282|       |    public func catchErrorJustReturn(_ element: E)
  283|      5|        -> Observable<E> {
  284|      0|        return Catch(source: asObservable(), handler: { _ in Observable.just(element) })
  285|      5|    }
  286|       |    
  287|       |}
  288|       |
  289|       |extension Observable {
  290|       |    /**
  291|       |     Continues an observable sequence that is terminated by an error with the next observable sequence.
  292|       |
  293|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  294|       |
  295|       |     - returns: An observable sequence containing elements from consecutive source sequences until a source sequence terminates successfully.
  296|       |     */
  297|       |    public static func catchError<S: Sequence>(_ sequence: S) -> Observable<Element>
  298|      0|        where S.Iterator.Element == Observable<Element> {
  299|      0|        return CatchSequence(sources: sequence)
  300|      0|    }
  301|       |}
  302|       |
  303|       |// MARK: takeUntil
  304|       |
  305|       |extension ObservableType {
  306|       |    
  307|       |    /**
  308|       |    Returns the elements from the source observable sequence until the other observable sequence produces an element.
  309|       |
  310|       |    - seealso: [takeUntil operator on reactivex.io](http://reactivex.io/documentation/operators/takeuntil.html)
  311|       |    
  312|       |    - parameter other: Observable sequence that terminates propagation of elements of the source sequence.
  313|       |    - returns: An observable sequence containing the elements of the source sequence up to the point the other sequence interrupted further propagation.
  314|       |    */
  315|       |    public func takeUntil<O: ObservableType>(_ other: O)
  316|    374|        -> Observable<E> {
  317|    374|        return TakeUntil(source: asObservable(), other: other.asObservable())
  318|    374|    }
  319|       |}
  320|       |
  321|       |// MARK: skipUntil
  322|       |
  323|       |extension ObservableType {
  324|       |    
  325|       |    /**
  326|       |    Returns the elements from the source observable sequence that are emitted after the other observable sequence produces an element.
  327|       |
  328|       |    - seealso: [skipUntil operator on reactivex.io](http://reactivex.io/documentation/operators/skipuntil.html)
  329|       |    
  330|       |    - parameter other: Observable sequence that starts propagation of elements of the source sequence.
  331|       |    - returns: An observable sequence containing the elements of the source sequence that are emitted after the other sequence emits an item.
  332|       |    */
  333|       |    public func skipUntil<O: ObservableType>(_ other: O)
  334|      0|        -> Observable<E> {
  335|      0|        return SkipUntil(source: asObservable(), other: other.asObservable())
  336|      0|    }
  337|       |}
  338|       |
  339|       |// MARK: amb
  340|       |
  341|       |extension ObservableType {
  342|       |    
  343|       |    /**
  344|       |    Propagates the observable sequence that reacts first.
  345|       |
  346|       |    - seealso: [amb operator on reactivex.io](http://reactivex.io/documentation/operators/amb.html)
  347|       |    
  348|       |    - parameter right: Second observable sequence.
  349|       |    - returns: An observable sequence that surfaces either of the given sequences, whichever reacted first.
  350|       |    */
  351|       |    public func amb<O2: ObservableType>
  352|       |        (_ right: O2)
  353|      0|        -> Observable<E> where O2.E == E {
  354|      0|        return Amb(left: asObservable(), right: right.asObservable())
  355|      0|    }
  356|       |}
  357|       |
  358|       |extension Observable {
  359|       |    /**
  360|       |     Propagates the observable sequence that reacts first.
  361|       |
  362|       |     - seealso: [amb operator on reactivex.io](http://reactivex.io/documentation/operators/amb.html)
  363|       |
  364|       |     - returns: An observable sequence that surfaces any of the given sequences, whichever reacted first.
  365|       |     */
  366|       |    public static func amb<S: Sequence>(_ sequence: S) -> Observable<Element>
  367|      0|        where S.Iterator.Element == Observable<Element> {
  368|      0|        return sequence.reduce(Observable<S.Iterator.Element.E>.never()) { a, o in
  369|      0|            return a.amb(o.asObservable())
  370|      0|        }
  371|      0|    }
  372|       |}
  373|       |
  374|       |// withLatestFrom
  375|       |
  376|       |extension ObservableType {
  377|       |    
  378|       |    /**
  379|       |    Merges two observable sequences into one observable sequence by combining each element from self with the latest element from the second source, if any.
  380|       |
  381|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  382|       |     
  383|       |    - parameter second: Second observable source.
  384|       |    - parameter resultSelector: Function to invoke for each element from the self combined with the latest element from the second source, if any.
  385|       |    - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
  386|       |    */
  387|      0|    public func withLatestFrom<SecondO: ObservableConvertibleType, ResultType>(_ second: SecondO, resultSelector: @escaping (E, SecondO.E) throws -> ResultType) -> Observable<ResultType> {
  388|      0|        return WithLatestFrom(first: asObservable(), second: second.asObservable(), resultSelector: resultSelector)
  389|      0|    }
  390|       |
  391|       |    /**
  392|       |    Merges two observable sequences into one observable sequence by using latest element from the second sequence every time when `self` emitts an element.
  393|       |
  394|       |    - seealso: [combineLatest operator on reactivex.io](http://reactivex.io/documentation/operators/combinelatest.html)
  395|       |     
  396|       |    - parameter second: Second observable source.
  397|       |    - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
  398|       |    */
  399|      0|    public func withLatestFrom<SecondO: ObservableConvertibleType>(_ second: SecondO) -> Observable<SecondO.E> {
  400|      0|        return WithLatestFrom(first: asObservable(), second: second.asObservable(), resultSelector: { $1 })
  401|      0|    }
  402|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Single.swift:
    1|       |//
    2|       |//  Observable+Single.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: distinct until changed
   10|       |
   11|       |extension ObservableType where E: Equatable {
   12|       |    
   13|       |    /**
   14|       |    Returns an observable sequence that contains only distinct contiguous elements according to equality operator.
   15|       |
   16|       |    - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   17|       |    
   18|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on equality operator, from the source sequence.
   19|       |    */
   20|       |    public func distinctUntilChanged()
   21|      7|        -> Observable<E> {
   22|      8|        return self.distinctUntilChanged({ $0 }, comparer: { ($0 == $1) })
   23|      7|    }
   24|       |}
   25|       |
   26|       |extension ObservableType {
   27|       |    /**
   28|       |    Returns an observable sequence that contains only distinct contiguous elements according to the `keySelector`.
   29|       |
   30|       |    - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   31|       |    
   32|       |    - parameter keySelector: A function to compute the comparison key for each element.
   33|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
   34|       |    */
   35|       |    public func distinctUntilChanged<K: Equatable>(_ keySelector: @escaping (E) throws -> K)
   36|      0|        -> Observable<E> {
   37|      0|        return self.distinctUntilChanged(keySelector, comparer: { $0 == $1 })
   38|      0|    }
   39|       |
   40|       |    /**
   41|       |    Returns an observable sequence that contains only distinct contiguous elements according to the `comparer`.
   42|       |
   43|       |    - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   44|       |    
   45|       |    - parameter comparer: Equality comparer for computed key values.
   46|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on `comparer`, from the source sequence.
   47|       |    */
   48|       |    public func distinctUntilChanged(_ comparer: @escaping (E, E) throws -> Bool)
   49|      0|        -> Observable<E> {
   50|      0|        return self.distinctUntilChanged({ $0 }, comparer: comparer)
   51|      0|    }
   52|       |    
   53|       |    /**
   54|       |    Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
   55|       |
   56|       |    - seealso: [distinct operator on reactivex.io](http://reactivex.io/documentation/operators/distinct.html)
   57|       |    
   58|       |    - parameter keySelector: A function to compute the comparison key for each element.
   59|       |    - parameter comparer: Equality comparer for computed key values.
   60|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value and the comparer, from the source sequence.
   61|       |    */
   62|       |    public func distinctUntilChanged<K>(_ keySelector: @escaping (E) throws -> K, comparer: @escaping (K, K) throws -> Bool)
   63|      7|        -> Observable<E> {
   64|      7|        return DistinctUntilChanged(source: self.asObservable(), selector: keySelector, comparer: comparer)
   65|      7|    }
   66|       |}
   67|       |
   68|       |// MARK: doOn
   69|       |
   70|       |extension ObservableType {
   71|       |    /**
   72|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
   73|       |
   74|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
   75|       |
   76|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
   77|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
   78|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
   79|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
   80|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
   81|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
   82|       |    - returns: The source sequence with the side-effecting behavior applied.
   83|       |     */
   84|       |    public func `do`(onNext: ((E) throws -> Void)? = nil, onError: ((Swift.Error) throws -> Void)? = nil, onCompleted: (() throws -> Void)? = nil, onSubscribe: (() -> ())? = nil, onSubscribed: (() -> ())? = nil, onDispose: (() -> ())? = nil)
   85|     45|        -> Observable<E> {
   86|      2|            return Do(source: self.asObservable(), eventHandler: { e in
   87|      2|                switch e {
   88|      1|                case .next(let element):
   89|      1|                    try onNext?(element)
   90|      0|                case .error(let e):
   91|      0|                    try onError?(e)
   92|      1|                case .completed:
   93|      1|                    try onCompleted?()
   94|      2|                }
   95|      2|            }, onSubscribe: onSubscribe, onSubscribed: onSubscribed, onDispose: onDispose)
   96|     45|    }
   97|       |}
   98|       |
   99|       |// MARK: startWith
  100|       |
  101|       |extension ObservableType {
  102|       |    
  103|       |    /**
  104|       |    Prepends a sequence of values to an observable sequence.
  105|       |
  106|       |    - seealso: [startWith operator on reactivex.io](http://reactivex.io/documentation/operators/startwith.html)
  107|       |    
  108|       |    - parameter elements: Elements to prepend to the specified sequence.
  109|       |    - returns: The source sequence prepended with the specified values.
  110|       |    */
  111|       |    public func startWith(_ elements: E ...)
  112|      0|        -> Observable<E> {
  113|      0|        return StartWith(source: self.asObservable(), elements: elements)
  114|      0|    }
  115|       |}
  116|       |
  117|       |// MARK: retry
  118|       |
  119|       |extension ObservableType {
  120|       |    
  121|       |    /**
  122|       |    Repeats the source observable sequence until it successfully terminates.
  123|       |    
  124|       |    **This could potentially create an infinite sequence.**
  125|       |
  126|       |    - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  127|       |    
  128|       |    - returns: Observable sequence to repeat until it successfully terminates.
  129|       |    */
  130|      0|    public func retry() -> Observable<E> {
  131|      0|        return CatchSequence(sources: InfiniteSequence(repeatedValue: self.asObservable()))
  132|      0|    }
  133|       |
  134|       |    /**
  135|       |    Repeats the source observable sequence the specified number of times in case of an error or until it successfully terminates.
  136|       |    
  137|       |    If you encounter an error and want it to retry once, then you must use `retry(2)`
  138|       |
  139|       |    - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  140|       |
  141|       |    - parameter maxAttemptCount: Maximum number of times to repeat the sequence.
  142|       |    - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
  143|       |    */
  144|       |    public func retry(_ maxAttemptCount: Int)
  145|      0|        -> Observable<E> {
  146|      0|        return CatchSequence(sources: repeatElement(self.asObservable(), count: maxAttemptCount))
  147|      0|    }
  148|       |    
  149|       |    /**
  150|       |    Repeats the source observable sequence on error when the notifier emits a next value.
  151|       |    If the source observable errors and the notifier completes, it will complete the source sequence.
  152|       |
  153|       |    - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  154|       |    
  155|       |    - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
  156|       |    - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
  157|       |    */
  158|       |    public func retryWhen<TriggerObservable: ObservableType, Error: Swift.Error>(_ notificationHandler: @escaping (Observable<Error>) -> TriggerObservable)
  159|      0|        -> Observable<E> {
  160|      0|            return RetryWhenSequence(sources: InfiniteSequence(repeatedValue: self.asObservable()), notificationHandler: notificationHandler)
  161|      0|    }
  162|       |
  163|       |    /**
  164|       |    Repeats the source observable sequence on error when the notifier emits a next value.
  165|       |    If the source observable errors and the notifier completes, it will complete the source sequence.
  166|       |
  167|       |    - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  168|       |    
  169|       |    - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
  170|       |    - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
  171|       |    */
  172|       |    public func retryWhen<TriggerObservable: ObservableType>(_ notificationHandler: @escaping (Observable<Swift.Error>) -> TriggerObservable)
  173|      0|        -> Observable<E> {
  174|      0|            return RetryWhenSequence(sources: InfiniteSequence(repeatedValue: self.asObservable()), notificationHandler: notificationHandler)
  175|      0|    }
  176|       |}
  177|       |
  178|       |// MARK: scan
  179|       |
  180|       |extension ObservableType {
  181|       |    
  182|       |    /**
  183|       |    Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.
  184|       |
  185|       |    For aggregation behavior with no intermediate results, see `reduce`.
  186|       |
  187|       |    - seealso: [scan operator on reactivex.io](http://reactivex.io/documentation/operators/scan.html)
  188|       |    
  189|       |    - parameter seed: The initial accumulator value.
  190|       |    - parameter accumulator: An accumulator function to be invoked on each element.
  191|       |    - returns: An observable sequence containing the accumulated values.
  192|       |    */
  193|       |    public func scan<A>(_ seed: A, accumulator: @escaping (A, E) throws -> A)
  194|      0|        -> Observable<A> {
  195|      0|        return Scan(source: self.asObservable(), seed: seed, accumulator: accumulator)
  196|      0|    }
  197|       |}
  198|       |
  199|       |// MARK: defaultIfEmpty
  200|       |
  201|       |extension ObservableType {
  202|       |    
  203|       |    /**
  204|       |     Emits elements from the source observable sequence, or a default element if the source observable sequence is empty.
  205|       |     
  206|       |     - seealso: [DefaultIfEmpty operator on reactivex.io](http://reactivex.io/documentation/operators/defaultifempty.html)
  207|       |     
  208|       |     - parameter default: Default element to be sent if the source does not emit any elements
  209|       |     - returns: An observable sequence which emits default element end completes in case the original sequence is empty
  210|       |     */
  211|      0|    public func ifEmpty(default: E) -> Observable<E> {
  212|      0|        return DefaultIfEmpty(source: self.asObservable(), default: `default`)
  213|      0|    }
  214|       |}
  215|       |
  216|       |extension ObservableType {
  217|       |
  218|       |    /**
  219|       |     Skips elements and completes (or errors) when the receiver completes (or errors). Equivalent to filter that always returns false.
  220|       |
  221|       |     - seealso: [ignoreElements operator on reactivex.io](http://reactivex.io/documentation/operators/ignoreelements.html)
  222|       |
  223|       |     - returns: An observable sequence that skips all elements of the source sequence.
  224|       |     */
  225|       |    public func ignoreElements()
  226|      0|        -> Observable<E> {
  227|      0|        return filter { _ -> Bool in
  228|      0|            return false
  229|      0|        }
  230|      0|    }
  231|       |}
  232|       |
  233|       |// MARK: materialize
  234|       |
  235|       |extension ObservableType {
  236|       |    /**
  237|       |     Convert any Observable into an Observable of its events.
  238|       |     - seealso: [materialize operator on reactivex.io](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
  239|       |     - returns: An observable sequence that wraps events in an Event<E>. The returned Observable never errors, but it does complete after observing all of the events of the underlying Observable.
  240|       |     */
  241|      0|    public func materialize() -> Observable<Event<E>> {
  242|      0|        return Materialize(source: self.asObservable())
  243|      0|    }
  244|       |}
  245|       |
  246|       |extension ObservableType where E: EventConvertible {
  247|       |    /**
  248|       |     Convert any previously materialized Observable into it's original form.
  249|       |     - seealso: [materialize operator on reactivex.io](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
  250|       |     - returns: The dematerialized observable sequence.
  251|       |     */
  252|      0|    public func dematerialize() -> Observable<E.ElementType> {
  253|      0|        return Dematerialize(source: self.asObservable())
  254|      0|    }
  255|       |    
  256|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+StandardSequenceOperators.swift:
    1|       |//
    2|       |//  Observable+StandardSequenceOperators.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/17/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: filter aka where
   10|       |
   11|       |extension ObservableType {
   12|       |    
   13|       |    /**
   14|       |    Filters the elements of an observable sequence based on a predicate.
   15|       |
   16|       |    - seealso: [filter operator on reactivex.io](http://reactivex.io/documentation/operators/filter.html)
   17|       |    
   18|       |    - parameter predicate: A function to test each source element for a condition.
   19|       |    - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
   20|       |    */
   21|       |    public func filter(_ predicate: @escaping (E) throws -> Bool)
   22|      0|        -> Observable<E> {
   23|      0|        return Filter(source: asObservable(), predicate: predicate)
   24|      0|    }
   25|       |}
   26|       |
   27|       |// MARK: takeWhile
   28|       |
   29|       |extension ObservableType {
   30|       |    
   31|       |    /**
   32|       |    Returns elements from an observable sequence as long as a specified condition is true.
   33|       |    
   34|       |    - seealso: [takeWhile operator on reactivex.io](http://reactivex.io/documentation/operators/takewhile.html)
   35|       |
   36|       |    - parameter predicate: A function to test each element for a condition.
   37|       |    - returns: An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   38|       |    */
   39|       |    public func takeWhile(_ predicate: @escaping (E) throws -> Bool)
   40|      0|        -> Observable<E> {
   41|      0|        return TakeWhile(source: asObservable(), predicate: predicate)
   42|      0|    }
   43|       |
   44|       |    /**
   45|       |    Returns elements from an observable sequence as long as a specified condition is true. 
   46|       |    
   47|       |    The element's index is used in the logic of the predicate function.
   48|       |   
   49|       |    - seealso: [takeWhile operator on reactivex.io](http://reactivex.io/documentation/operators/takewhile.html)
   50|       |
   51|       |    - parameter predicate: A function to test each element for a condition; the second parameter of the function represents the index of the source element.
   52|       |    - returns: An observable sequence that contains the elements from the input sequence that occur before the element at which the test no longer passes.
   53|       |    */
   54|       |    public func takeWhileWithIndex(_ predicate: @escaping (E, Int) throws -> Bool)
   55|      0|        -> Observable<E> {
   56|      0|        return TakeWhile(source: asObservable(), predicate: predicate)
   57|      0|    }
   58|       |}
   59|       |
   60|       |// MARK: take
   61|       |
   62|       |extension ObservableType {
   63|       |    
   64|       |    /**
   65|       |    Returns a specified number of contiguous elements from the start of an observable sequence.
   66|       |
   67|       |    - seealso: [take operator on reactivex.io](http://reactivex.io/documentation/operators/take.html)
   68|       |    
   69|       |    - parameter count: The number of elements to return.
   70|       |    - returns: An observable sequence that contains the specified number of elements from the start of the input sequence.
   71|       |    */
   72|       |    public func take(_ count: Int)
   73|      0|        -> Observable<E> {
   74|      0|        if count == 0 {
   75|      0|            return Observable.empty()
   76|      0|        }
   77|      0|        else {
   78|      0|            return TakeCount(source: asObservable(), count: count)
   79|      0|        }
   80|      0|    }
   81|       |}
   82|       |
   83|       |// MARK: takeLast
   84|       |
   85|       |extension ObservableType {
   86|       |    
   87|       |    /**
   88|       |    Returns a specified number of contiguous elements from the end of an observable sequence.
   89|       |     
   90|       |     This operator accumulates a buffer with a length enough to store elements count elements. Upon completion of the source sequence, this buffer is drained on the result sequence. This causes the elements to be delayed.
   91|       |
   92|       |     - seealso: [takeLast operator on reactivex.io](http://reactivex.io/documentation/operators/takelast.html)
   93|       |     
   94|       |     - parameter count: Number of elements to take from the end of the source sequence.
   95|       |     - returns: An observable sequence containing the specified number of elements from the end of the source sequence.
   96|       |     */
   97|       |    public func takeLast(_ count: Int)
   98|      0|        -> Observable<E> {
   99|      0|        return TakeLast(source: asObservable(), count: count)
  100|      0|    }
  101|       |}
  102|       |
  103|       |
  104|       |// MARK: skip
  105|       |
  106|       |extension ObservableType {
  107|       |    
  108|       |    /**
  109|       |    Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
  110|       |
  111|       |    - seealso: [skip operator on reactivex.io](http://reactivex.io/documentation/operators/skip.html)
  112|       |    
  113|       |    - parameter count: The number of elements to skip before returning the remaining elements.
  114|       |    - returns: An observable sequence that contains the elements that occur after the specified index in the input sequence.
  115|       |    */
  116|       |    public func skip(_ count: Int)
  117|     14|        -> Observable<E> {
  118|     14|        return SkipCount(source: asObservable(), count: count)
  119|     14|    }
  120|       |}
  121|       |
  122|       |// MARK: SkipWhile
  123|       |
  124|       |extension ObservableType {
  125|       |   
  126|       |    /**
  127|       |    Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
  128|       |
  129|       |    - seealso: [skipWhile operator on reactivex.io](http://reactivex.io/documentation/operators/skipwhile.html)
  130|       |    
  131|       |    - parameter predicate: A function to test each element for a condition.
  132|       |    - returns: An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
  133|       |    */
  134|      0|    public func skipWhile(_ predicate: @escaping (E) throws -> Bool) -> Observable<E> {
  135|      0|        return SkipWhile(source: asObservable(), predicate: predicate)
  136|      0|    }
  137|       |   
  138|       |    /**
  139|       |    Bypasses elements in an observable sequence as long as a specified condition is true and then returns the remaining elements.
  140|       |    The element's index is used in the logic of the predicate function.
  141|       |
  142|       |    - seealso: [skipWhile operator on reactivex.io](http://reactivex.io/documentation/operators/skipwhile.html)
  143|       |    
  144|       |    - parameter predicate: A function to test each element for a condition; the second parameter of the function represents the index of the source element.
  145|       |    - returns: An observable sequence that contains the elements from the input sequence starting at the first element in the linear series that does not pass the test specified by predicate.
  146|       |    */
  147|      0|    public func skipWhileWithIndex(_ predicate: @escaping (E, Int) throws -> Bool) -> Observable<E> {
  148|      0|        return SkipWhile(source: asObservable(), predicate: predicate)
  149|      0|    }
  150|       |}
  151|       |
  152|       |// MARK: map aka select
  153|       |
  154|       |extension ObservableType {
  155|       |    
  156|       |    /**
  157|       |    Projects each element of an observable sequence into a new form.
  158|       |    
  159|       |    - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
  160|       |
  161|       |    - parameter transform: A transform function to apply to each source element.
  162|       |    - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
  163|       |     
  164|       |    */
  165|       |    public func map<R>(_ transform: @escaping (E) throws -> R)
  166|    417|        -> Observable<R> {
  167|    417|        return self.asObservable().composeMap(transform)
  168|    417|    }
  169|       |
  170|       |    /**
  171|       |    Projects each element of an observable sequence into a new form by incorporating the element's index.
  172|       |
  173|       |    - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
  174|       |    
  175|       |    - parameter selector: A transform function to apply to each source element; the second parameter of the function represents the index of the source element.
  176|       |    - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
  177|       |    */
  178|       |    public func mapWithIndex<R>(_ selector: @escaping (E, Int) throws -> R)
  179|      0|        -> Observable<R> {
  180|      0|        return MapWithIndex(source: asObservable(), selector: selector)
  181|      0|    }
  182|       |}
  183|       |    
  184|       |// MARK: flatMap
  185|       |
  186|       |extension ObservableType {
  187|       |
  188|       |    /**
  189|       |    Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  190|       |
  191|       |    - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  192|       |    
  193|       |    - parameter selector: A transform function to apply to each element.
  194|       |    - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  195|       |    */
  196|       |    public func flatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
  197|     14|        -> Observable<O.E> {
  198|     14|        return FlatMap(source: asObservable(), selector: selector)
  199|     14|    }
  200|       |
  201|       |    /**
  202|       |    Projects each element of an observable sequence to an observable sequence by incorporating the element's index and merges the resulting observable sequences into one observable sequence.
  203|       |
  204|       |    - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  205|       |
  206|       |    - parameter selector: A transform function to apply to each element; the second parameter of the function represents the index of the source element.
  207|       |    - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  208|       |    */
  209|       |    public func flatMapWithIndex<O: ObservableConvertibleType>(_ selector: @escaping (E, Int) throws -> O)
  210|      0|        -> Observable<O.E> {
  211|      0|        return FlatMapWithIndex(source: asObservable(), selector: selector)
  212|      0|    }
  213|       |}
  214|       |
  215|       |// MARK: flatMapFirst
  216|       |
  217|       |extension ObservableType {
  218|       |
  219|       |    /**
  220|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  221|       |     If element is received while there is some projected observable sequence being merged it will simply be ignored.
  222|       |
  223|       |    - seealso: [flatMapFirst operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  224|       |
  225|       |    - parameter selector: A transform function to apply to element that was observed while no observable is executing in parallel.
  226|       |    - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence that was received while no other sequence was being calculated.
  227|       |    */
  228|       |    public func flatMapFirst<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
  229|      0|        -> Observable<O.E> {
  230|      0|        return FlatMapFirst(source: asObservable(), selector: selector)
  231|      0|    }
  232|       |}
  233|       |
  234|       |// MARK: flatMapLatest
  235|       |
  236|       |extension ObservableType {
  237|       |    /**
  238|       |     Projects each element of an observable sequence into a new sequence of observable sequences and then
  239|       |     transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
  240|       |     
  241|       |     It is a combination of `map` + `switchLatest` operator
  242|       |
  243|       |     - seealso: [flatMapLatest operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  244|       |
  245|       |     - parameter selector: A transform function to apply to each element.
  246|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source producing an 
  247|       |        Observable of Observable sequences and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
  248|       |     */
  249|       |    public func flatMapLatest<O: ObservableConvertibleType>(_ selector: @escaping (E) throws -> O)
  250|     43|        -> Observable<O.E> {
  251|     43|            return FlatMapLatest(source: asObservable(), selector: selector)
  252|     43|    }
  253|       |}
  254|       |
  255|       |// MARK: elementAt
  256|       |
  257|       |extension ObservableType {
  258|       |    
  259|       |    /**
  260|       |    Returns a sequence emitting only element _n_ emitted by an Observable
  261|       |
  262|       |    - seealso: [elementAt operator on reactivex.io](http://reactivex.io/documentation/operators/elementat.html)
  263|       |    
  264|       |    - parameter index: The index of the required element (starting from 0).
  265|       |    - returns: An observable sequence that emits the desired element as its own sole emission.
  266|       |    */
  267|       |    public func elementAt(_ index: Int)
  268|      0|        -> Observable<E> {
  269|      0|        return ElementAt(source: asObservable(), index: index, throwOnEmpty: true)
  270|      0|    }
  271|       |}
  272|       |
  273|       |// MARK: single
  274|       |
  275|       |extension ObservableType {
  276|       |    
  277|       |    /**
  278|       |    The single operator is similar to first, but throws a `RxError.noElements` or `RxError.moreThanOneElement`
  279|       |    if the source Observable does not emit exactly one element before successfully completing.
  280|       |
  281|       |    - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
  282|       |    
  283|       |    - returns: An observable sequence that emits a single element or throws an exception if more (or none) of them are emitted.
  284|       |    */
  285|       |    public func single()
  286|      0|        -> Observable<E> {
  287|      0|        return SingleAsync(source: asObservable())
  288|      0|    }
  289|       |    
  290|       |    /**
  291|       |    The single operator is similar to first, but throws a `RxError.NoElements` or `RxError.MoreThanOneElement`
  292|       |    if the source Observable does not emit exactly one element before successfully completing.
  293|       |
  294|       |    - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
  295|       |    
  296|       |    - parameter predicate: A function to test each source element for a condition.
  297|       |    - returns: An observable sequence that emits a single element or throws an exception if more (or none) of them are emitted.
  298|       |    */
  299|       |    public func single(_ predicate: @escaping (E) throws -> Bool)
  300|      0|        -> Observable<E> {
  301|      0|        return SingleAsync(source: asObservable(), predicate: predicate)
  302|      0|    }
  303|       |}
  304|       |
  305|       |// MARK: groupBy 
  306|       |
  307|       |extension ObservableType {
  308|       |    /*
  309|       |    Groups the elements of an observable sequence according to a specified key selector function.
  310|       |
  311|       |    - seealso: [groupBy operator on reactivex.io](http://reactivex.io/documentation/operators/groupby.html)
  312|       |     
  313|       |    - parameter keySelector: A function to extract the key for each element.
  314|       |    - returns: A sequence of observable groups, each of which corresponds to a unique key value, containing all elements that share that same key value.
  315|       |    */
  316|       |    public func groupBy<K: Hashable>(keySelector: @escaping (E) throws -> K)
  317|      0|        -> Observable<GroupedObservable<K,E>> {
  318|      0|        return GroupBy(source: self.asObservable(), selector: keySelector)
  319|      0|    }
  320|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observables/Observable+Time.swift:
    1|       |//
    2|       |//  Observable+Time.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/22/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |// MARK: throttle
   10|       |extension ObservableType {
   11|       |    
   12|       |    /**
   13|       |    Returns an Observable that emits the first and the latest item emitted by the source Observable during sequential time windows of a specified duration.
   14|       |    
   15|       |    This operator makes sure that no two elements are emitted in less then dueTime.
   16|       |     
   17|       |    - seealso: [debounce operator on reactivex.io](http://reactivex.io/documentation/operators/debounce.html)
   18|       |    
   19|       |    - parameter dueTime: Throttling duration for each element.
   20|       |    - parameter latest: Should latest element received in a dueTime wide time window since last element emission be emitted.
   21|       |    - parameter scheduler: Scheduler to run the throttle timers on.
   22|       |    - returns: The throttled sequence.
   23|       |    */
   24|       |    public func throttle(_ dueTime: RxTimeInterval, latest: Bool = true, scheduler: SchedulerType)
   25|      0|        -> Observable<E> {
   26|      0|        return Throttle(source: self.asObservable(), dueTime: dueTime, latest: latest, scheduler: scheduler)
   27|      0|    }
   28|       |
   29|       |    /**
   30|       |    Ignores elements from an observable sequence which are followed by another element within a specified relative time duration, using the specified scheduler to run throttling timers.
   31|       |    
   32|       |    - seealso: [debounce operator on reactivex.io](http://reactivex.io/documentation/operators/debounce.html)
   33|       |    
   34|       |    - parameter dueTime: Throttling duration for each element.
   35|       |    - parameter scheduler: Scheduler to run the throttle timers on.
   36|       |    - returns: The throttled sequence.
   37|       |    */
   38|       |    public func debounce(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
   39|      0|        -> Observable<E> {
   40|      0|        return Debounce(source: self.asObservable(), dueTime: dueTime, scheduler: scheduler)
   41|      0|    }
   42|       |}
   43|       |
   44|       |// MARK: sample
   45|       |
   46|       |extension ObservableType {
   47|       |   
   48|       |    /**
   49|       |    Samples the source observable sequence using a sampler observable sequence producing sampling ticks.
   50|       |    
   51|       |    Upon each sampling tick, the latest element (if any) in the source sequence during the last sampling interval is sent to the resulting sequence.
   52|       |    
   53|       |    **In case there were no new elements between sampler ticks, no element is sent to the resulting sequence.**
   54|       |
   55|       |    - seealso: [sample operator on reactivex.io](http://reactivex.io/documentation/operators/sample.html)
   56|       |    
   57|       |    - parameter sampler: Sampling tick sequence.
   58|       |    - returns: Sampled observable sequence.
   59|       |    */
   60|       |    public func sample<O: ObservableType>(_ sampler: O)
   61|      0|        -> Observable<E> {
   62|      0|        return Sample(source: self.asObservable(), sampler: sampler.asObservable())
   63|      0|    }
   64|       |}
   65|       |
   66|       |extension Observable where Element : SignedInteger {
   67|       |    /**
   68|       |    Returns an observable sequence that produces a value after each period, using the specified scheduler to run timers and to send out observer messages.
   69|       |
   70|       |    - seealso: [interval operator on reactivex.io](http://reactivex.io/documentation/operators/interval.html)
   71|       |
   72|       |    - parameter period: Period for producing the values in the resulting sequence.
   73|       |    - parameter scheduler: Scheduler to run the timer on.
   74|       |    - returns: An observable sequence that produces a value after each period.
   75|       |    */
   76|       |    public static func interval(_ period: RxTimeInterval, scheduler: SchedulerType)
   77|      0|        -> Observable<E> {
   78|      0|        return Timer(dueTime: period,
   79|      0|            period: period,
   80|      0|            scheduler: scheduler
   81|      0|        )
   82|      0|    }
   83|       |}
   84|       |
   85|       |// MARK: timer
   86|       |
   87|       |extension Observable where Element: SignedInteger {
   88|       |    /**
   89|       |    Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
   90|       |
   91|       |    - seealso: [timer operator on reactivex.io](http://reactivex.io/documentation/operators/timer.html)
   92|       |
   93|       |    - parameter dueTime: Relative time at which to produce the first value.
   94|       |    - parameter period: Period to produce subsequent values.
   95|       |    - parameter scheduler: Scheduler to run timers on.
   96|       |    - returns: An observable sequence that produces a value after due time has elapsed and then each period.
   97|       |    */
   98|       |    public static func timer(_ dueTime: RxTimeInterval, period: RxTimeInterval? = nil, scheduler: SchedulerType)
   99|      0|        -> Observable<E> {
  100|      0|        return Timer(
  101|      0|            dueTime: dueTime,
  102|      0|            period: period,
  103|      0|            scheduler: scheduler
  104|      0|        )
  105|      0|    }
  106|       |}
  107|       |
  108|       |// MARK: take
  109|       |
  110|       |extension ObservableType {
  111|       |
  112|       |    /**
  113|       |    Takes elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
  114|       |
  115|       |    - seealso: [take operator on reactivex.io](http://reactivex.io/documentation/operators/take.html)
  116|       |    
  117|       |    - parameter duration: Duration for taking elements from the start of the sequence.
  118|       |    - parameter scheduler: Scheduler to run the timer on.
  119|       |    - returns: An observable sequence with the elements taken during the specified duration from the start of the source sequence.
  120|       |    */
  121|       |    public func take(_ duration: RxTimeInterval, scheduler: SchedulerType)
  122|      0|        -> Observable<E> {
  123|      0|        return TakeTime(source: self.asObservable(), duration: duration, scheduler: scheduler)
  124|      0|    }
  125|       |}
  126|       |
  127|       |// MARK: skip
  128|       |
  129|       |extension ObservableType {
  130|       |    
  131|       |    /**
  132|       |    Skips elements for the specified duration from the start of the observable source sequence, using the specified scheduler to run timers.
  133|       |
  134|       |    - seealso: [skip operator on reactivex.io](http://reactivex.io/documentation/operators/skip.html)
  135|       |    
  136|       |    - parameter duration: Duration for skipping elements from the start of the sequence.
  137|       |    - parameter scheduler: Scheduler to run the timer on.
  138|       |    - returns: An observable sequence with the elements skipped during the specified duration from the start of the source sequence.
  139|       |    */
  140|       |    public func skip(_ duration: RxTimeInterval, scheduler: SchedulerType)
  141|      0|        -> Observable<E> {
  142|      0|        return SkipTime(source: self.asObservable(), duration: duration, scheduler: scheduler)
  143|      0|    }
  144|       |}
  145|       |
  146|       |// MARK: delaySubscription
  147|       |
  148|       |extension ObservableType {
  149|       |    
  150|       |    /**
  151|       |    Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
  152|       |
  153|       |    - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
  154|       |    
  155|       |    - parameter dueTime: Relative time shift of the subscription.
  156|       |    - parameter scheduler: Scheduler to run the subscription delay timer on.
  157|       |    - returns: Time-shifted sequence.
  158|       |    */
  159|       |    public func delaySubscription(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  160|      0|        -> Observable<E> {
  161|      0|        return DelaySubscription(source: self.asObservable(), dueTime: dueTime, scheduler: scheduler)
  162|      0|    }
  163|       |}
  164|       |
  165|       |// MARK: buffer
  166|       |
  167|       |extension ObservableType {
  168|       |
  169|       |    /**
  170|       |    Projects each element of an observable sequence into a buffer that's sent out when either it's full or a given amount of time has elapsed, using the specified scheduler to run timers.
  171|       |    
  172|       |    A useful real-world analogy of this overload is the behavior of a ferry leaving the dock when all seats are taken, or at the scheduled time of departure, whichever event occurs first.
  173|       |
  174|       |    - seealso: [buffer operator on reactivex.io](http://reactivex.io/documentation/operators/buffer.html)
  175|       |    
  176|       |    - parameter timeSpan: Maximum time length of a buffer.
  177|       |    - parameter count: Maximum element count of a buffer.
  178|       |    - parameter scheduler: Scheduler to run buffering timers on.
  179|       |    - returns: An observable sequence of buffers.
  180|       |    */
  181|       |    public func buffer(timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType)
  182|      0|        -> Observable<[E]> {
  183|      0|        return BufferTimeCount(source: self.asObservable(), timeSpan: timeSpan, count: count, scheduler: scheduler)
  184|      0|    }
  185|       |}
  186|       |
  187|       |// MARK: window
  188|       |
  189|       |extension ObservableType {
  190|       |    
  191|       |    /**
  192|       |     Projects each element of an observable sequence into a window that is completed when either it’s full or a given amount of time has elapsed.
  193|       |
  194|       |     - seealso: [window operator on reactivex.io](http://reactivex.io/documentation/operators/window.html)
  195|       |          
  196|       |     - parameter timeSpan: Maximum time length of a window.
  197|       |     - parameter count: Maximum element count of a window.
  198|       |     - parameter scheduler: Scheduler to run windowing timers on.
  199|       |     - returns: An observable sequence of windows (instances of `Observable`).
  200|       |     */
  201|       |    public func window(timeSpan: RxTimeInterval, count: Int, scheduler: SchedulerType)
  202|      0|        -> Observable<Observable<E>> {
  203|      0|            return WindowTimeCount(source: self.asObservable(), timeSpan: timeSpan, count: count, scheduler: scheduler)
  204|      0|    }
  205|       |}
  206|       |
  207|       |// MARK: timeout
  208|       |
  209|       |extension ObservableType {
  210|       |    
  211|       |    /**
  212|       |     Applies a timeout policy for each element in the observable sequence. If the next element isn't received within the specified timeout duration starting from its predecessor, a TimeoutError is propagated to the observer.
  213|       |
  214|       |     - seealso: [timeout operator on reactivex.io](http://reactivex.io/documentation/operators/timeout.html)
  215|       |     
  216|       |     - parameter dueTime: Maximum duration between values before a timeout occurs.
  217|       |     - parameter scheduler: Scheduler to run the timeout timer on.
  218|       |     - returns: An observable sequence with a `RxError.timeout` in case of a timeout.
  219|       |     */
  220|       |    public func timeout(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  221|      7|        -> Observable<E> {
  222|      7|            return Timeout(source: self.asObservable(), dueTime: dueTime, other: Observable.error(RxError.timeout), scheduler: scheduler)
  223|      7|    }
  224|       |
  225|       |    /**
  226|       |     Applies a timeout policy for each element in the observable sequence, using the specified scheduler to run timeout timers. If the next element isn't received within the specified timeout duration starting from its predecessor, the other observable sequence is used to produce future messages from that point on.
  227|       |
  228|       |     - seealso: [timeout operator on reactivex.io](http://reactivex.io/documentation/operators/timeout.html)
  229|       |     
  230|       |     - parameter dueTime: Maximum duration between values before a timeout occurs.
  231|       |     - parameter other: Sequence to return in case of a timeout.
  232|       |     - parameter scheduler: Scheduler to run the timeout timer on.
  233|       |     - returns: The source sequence switching to the other sequence in case of a timeout.
  234|       |     */
  235|       |    public func timeout<O: ObservableConvertibleType>(_ dueTime: RxTimeInterval, other: O, scheduler: SchedulerType)
  236|      0|        -> Observable<E> where E == O.E {
  237|      0|            return Timeout(source: self.asObservable(), dueTime: dueTime, other: other.asObservable(), scheduler: scheduler)
  238|      0|    }
  239|       |}
  240|       |
  241|       |// MARK: delay
  242|       |
  243|       |extension ObservableType {
  244|       |    
  245|       |    /**
  246|       |     Returns an observable sequence by the source observable sequence shifted forward in time by a specified delay. Error events from the source observable sequence are not delayed.
  247|       |     
  248|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
  249|       |     
  250|       |     - parameter dueTime: Relative time shift of the source by.
  251|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
  252|       |     - returns: the source Observable shifted in time by the specified delay.
  253|       |     */
  254|       |    public func delay(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  255|      0|        -> Observable<E> {
  256|      0|            return Delay(source: self.asObservable(), dueTime: dueTime, scheduler: scheduler)
  257|      0|    }
  258|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/ObserverType.swift:
    1|       |//
    2|       |//  ObserverType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Supports push-style iteration over an observable sequence.
   10|       |public protocol ObserverType {
   11|       |    /// The type of elements in sequence that observer can observe.
   12|       |    associatedtype E
   13|       |
   14|       |    /// Notify observer about sequence event.
   15|       |    ///
   16|       |    /// - parameter event: Event that occured.
   17|       |    func on(_ event: Event<E>)
   18|       |}
   19|       |
   20|       |/// Convenience API extensions to provide alternate next, error, completed events
   21|       |extension ObserverType {
   22|       |    
   23|       |    /// Convenience method equivalent to `on(.next(element: E))`
   24|       |    ///
   25|       |    /// - parameter element: Next element to send to observer(s)
   26|      0|    public final func onNext(_ element: E) {
   27|      0|        on(.next(element))
   28|      0|    }
   29|       |    
   30|       |    /// Convenience method equivalent to `on(.completed)`
   31|      0|    public final func onCompleted() {
   32|      0|        on(.completed)
   33|      0|    }
   34|       |    
   35|       |    /// Convenience method equivalent to `on(.error(Swift.Error))`
   36|       |    /// - parameter error: Swift.Error to send to observer(s)
   37|      0|    public final func onError(_ error: Swift.Error) {
   38|      0|        on(.error(error))
   39|      0|    }
   40|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observers/AnonymousObserver.swift:
    1|       |//
    2|       |//  AnonymousObserver.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |final class AnonymousObserver<ElementType> : ObserverBase<ElementType> {
   10|       |    typealias Element = ElementType
   11|       |    
   12|       |    typealias EventHandler = (Event<Element>) -> Void
   13|       |    
   14|       |    private let _eventHandler : EventHandler
   15|       |    
   16|    399|    init(_ eventHandler: @escaping EventHandler) {
   17|    399|#if TRACE_RESOURCES
   18|    399|        let _ = Resources.incrementTotal()
   19|    399|#endif
   20|    399|        _eventHandler = eventHandler
   21|    399|    }
   22|       |
   23|    202|    override func onCore(_ event: Event<Element>) {
   24|    202|        return _eventHandler(event)
   25|    202|    }
   26|       |    
   27|       |#if TRACE_RESOURCES
   28|       |    deinit {
   29|       |        let _ = Resources.decrementTotal()
   30|       |    }
   31|       |#endif
   32|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observers/ObserverBase.swift:
    1|       |//
    2|       |//  ObserverBase.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |class ObserverBase<ElementType> : Disposable, ObserverType {
   10|       |    typealias E = ElementType
   11|       |
   12|       |    private var _isStopped: AtomicInt = 0
   13|       |
   14|    284|    func on(_ event: Event<E>) {
   15|    284|        switch event {
   16|    265|        case .next:
   17|    265|            if _isStopped == 0 {
   18|    265|                onCore(event)
   19|    265|            }
   20|     19|        case .error, .completed:
   21|     19|            if AtomicCompareAndSwap(0, 1, &_isStopped) {
   22|     19|                onCore(event)
   23|     19|            }
   24|    284|        }
   25|    284|    }
   26|       |
   27|      0|    func onCore(_ event: Event<E>) {
   28|      0|        rxAbstractMethod()
   29|      0|    }
   30|       |
   31|     12|    func dispose() {
   32|     12|        _ = AtomicCompareAndSwap(0, 1, &_isStopped)
   33|     12|    }
   34|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Observers/TailRecursiveSink.swift:
    1|       |//
    2|       |//  TailRecursiveSink.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |enum TailRecursiveSinkCommand {
   10|       |    case moveNext
   11|       |    case dispose
   12|       |}
   13|       |
   14|       |#if DEBUG || TRACE_RESOURCES
   15|       |    public var maxTailRecursiveSinkStackSize = 0
   16|       |#endif
   17|       |
   18|       |/// This class is usually used with `Generator` version of the operators.
   19|       |class TailRecursiveSink<S: Sequence, O: ObserverType>
   20|       |    : Sink<O>
   21|       |    , InvocableWithValueType where S.Iterator.Element: ObservableConvertibleType, S.Iterator.Element.E == O.E {
   22|       |    typealias Value = TailRecursiveSinkCommand
   23|       |    typealias E = O.E
   24|       |    typealias SequenceGenerator = (generator: S.Iterator, remaining: IntMax?)
   25|       |
   26|       |    var _generators: [SequenceGenerator] = []
   27|       |    var _isDisposed = false
   28|       |    var _subscription = SerialDisposable()
   29|       |
   30|       |    // this is thread safe object
   31|       |    var _gate = AsyncLock<InvocableScheduledItem<TailRecursiveSink<S, O>>>()
   32|       |
   33|      4|    override init(observer: O, cancel: Cancelable) {
   34|      4|        super.init(observer: observer, cancel: cancel)
   35|      4|    }
   36|       |
   37|      4|    func run(_ sources: SequenceGenerator) -> Disposable {
   38|      4|        _generators.append(sources)
   39|      4|
   40|      4|        schedule(.moveNext)
   41|      4|
   42|      4|        return _subscription
   43|      4|    }
   44|       |
   45|      4|    func invoke(_ command: TailRecursiveSinkCommand) {
   46|      4|        switch command {
   47|      0|        case .dispose:
   48|      0|            disposeCommand()
   49|      4|        case .moveNext:
   50|      4|            moveNextCommand()
   51|      4|        }
   52|      4|    }
   53|       |
   54|       |    // simple implementation for now
   55|      4|    func schedule(_ command: TailRecursiveSinkCommand) {
   56|      4|        _gate.invoke(InvocableScheduledItem(invocable: self, state: command))
   57|      4|    }
   58|       |
   59|      0|    func done() {
   60|      0|        forwardOn(.completed)
   61|      0|        dispose()
   62|      0|    }
   63|       |
   64|      0|    func extract(_ observable: Observable<E>) -> SequenceGenerator? {
   65|      0|        rxAbstractMethod()
   66|      0|    }
   67|       |
   68|       |    // should be done on gate locked
   69|       |
   70|      4|    private func moveNextCommand() {
   71|      4|        var next: Observable<E>? = nil
   72|      4|
   73|      4|        repeat {
   74|      0|            guard let (g, left) = _generators.last else {
   75|      0|                break
   76|      4|            }
   77|      4|            
   78|      0|            if _isDisposed {
   79|      0|                return
   80|      4|            }
   81|      4|
   82|      4|            _generators.removeLast()
   83|      4|            
   84|      4|            var e = g
   85|      4|
   86|      0|            guard let nextCandidate = e.next()?.asObservable() else {
   87|      0|                continue
   88|      4|            }
   89|      4|
   90|      4|            // `left` is a hint of how many elements are left in generator.
   91|      4|            // In case this is the last element, then there is no need to push
   92|      4|            // that generator on stack.
   93|      4|            //
   94|      4|            // This is an optimization used to make sure in tail recursive case
   95|      4|            // there is no memory leak in case this operator is used to generate non terminating
   96|      4|            // sequence.
   97|      4|
   98|      4|            if let knownOriginalLeft = left {
   99|      4|                // `- 1` because generator.next() has just been called
  100|      4|                if knownOriginalLeft - 1 >= 1 {
  101|      4|                    _generators.append((e, knownOriginalLeft - 1))
  102|      4|                }
  103|      4|            }
  104|      0|            else {
  105|      0|                _generators.append((e, nil))
  106|      4|            }
  107|      4|
  108|      4|            let nextGenerator = extract(nextCandidate)
  109|      4|
  110|      0|            if let nextGenerator = nextGenerator {
  111|      0|                _generators.append(nextGenerator)
  112|      0|                #if DEBUG || TRACE_RESOURCES
  113|      0|                    if maxTailRecursiveSinkStackSize < _generators.count {
  114|      0|                        maxTailRecursiveSinkStackSize = _generators.count
  115|      0|                    }
  116|      0|                #endif
  117|      4|            }
  118|      4|            else {
  119|      4|                next = nextCandidate
  120|      4|            }
  121|      4|        } while next == nil
  122|      4|
  123|      0|        guard let existingNext = next else  {
  124|      0|            done()
  125|      0|            return
  126|      4|        }
  127|      4|
  128|      4|        let disposable = SingleAssignmentDisposable()
  129|      4|        _subscription.disposable = disposable
  130|      4|        disposable.setDisposable(subscribeToNext(existingNext))
  131|      4|    }
  132|       |
  133|      0|    func subscribeToNext(_ source: Observable<E>) -> Disposable {
  134|      0|        rxAbstractMethod()
  135|      0|    }
  136|       |
  137|      0|    func disposeCommand() {
  138|      0|        _isDisposed = true
  139|      0|        _generators.removeAll(keepingCapacity: false)
  140|      0|    }
  141|       |
  142|      0|    override func dispose() {
  143|      0|        super.dispose()
  144|      0|        
  145|      0|        _subscription.dispose()
  146|      0|        
  147|      0|        schedule(.dispose)
  148|      0|    }
  149|       |}
  150|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Reactive.swift:
    1|       |//
    2|       |//  Reactive.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Yury Korolev on 5/2/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       | Use `Reactive` proxy as customization point for constrained protocol extensions.
   11|       |
   12|       | General pattern would be:
   13|       |
   14|       | // 1. Extend Reactive protocol with constrain on Base
   15|       | // Read as: Reactive Extension where Base is a SomeType
   16|       | extension Reactive where Base: SomeType {
   17|       | // 2. Put any specific reactive extension for SomeType here
   18|       | }
   19|       |
   20|       | With this approach we can have more specialized methods and properties using
   21|       | `Base` and not just specialized on common base type.
   22|       |
   23|       | */
   24|       |
   25|       |public struct Reactive<Base> {
   26|       |    /// Base object to extend.
   27|       |    public let base: Base
   28|       |
   29|       |    /// Creates extensions with base object.
   30|       |    ///
   31|       |    /// - parameter base: Base object.
   32|    626|    public init(_ base: Base) {
   33|    626|        self.base = base
   34|    626|    }
   35|       |}
   36|       |
   37|       |/// A type that has reactive extensions.
   38|       |public protocol ReactiveCompatible {
   39|       |    /// Extended type
   40|       |    associatedtype CompatibleType
   41|       |
   42|       |    /// Reactive extensions.
   43|       |    static var rx: Reactive<CompatibleType>.Type { get set }
   44|       |
   45|       |    /// Reactive extensions.
   46|       |    var rx: Reactive<CompatibleType> { get set }
   47|       |}
   48|       |
   49|       |extension ReactiveCompatible {
   50|       |    /// Reactive extensions.
   51|       |    public static var rx: Reactive<Self>.Type {
   52|    155|        get {
   53|    155|            return Reactive<Self>.self
   54|    155|        }
   55|      0|        set {
   56|      0|            // this enables using Reactive to "mutate" base type
   57|      0|        }
   58|       |    }
   59|       |
   60|       |    /// Reactive extensions.
   61|       |    public var rx: Reactive<Self> {
   62|    626|        get {
   63|    626|            return Reactive(self)
   64|    626|        }
   65|      0|        set {
   66|      0|            // this enables using Reactive to "mutate" base object
   67|      0|        }
   68|       |    }
   69|       |}
   70|       |
   71|       |import class Foundation.NSObject
   72|       |
   73|       |/// Extend NSObject with `rx` proxy.
   74|       |extension NSObject: ReactiveCompatible { }

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Rx.swift:
    1|       |//
    2|       |//  Rx.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if TRACE_RESOURCES
   10|       |    fileprivate var resourceCount: AtomicInt = 0
   11|       |
   12|       |    /// Resource utilization information
   13|       |    public struct Resources {
   14|       |        /// Counts internal Rx resource allocations (Observables, Observers, Disposables, etc.). This provides a simple way to detect leaks during development.
   15|       |        public static var total: Int32 {
   16|       |            return resourceCount.valueSnapshot()
   17|       |        }
   18|       |
   19|       |        /// Increments `Resources.total` resource count.
   20|       |        ///
   21|       |        /// - returns: New resource count
   22|       |        public static func incrementTotal() -> Int32 {
   23|       |            return AtomicIncrement(&resourceCount)
   24|       |        }
   25|       |
   26|       |        /// Decrements `Resources.total` resource count
   27|       |        ///
   28|       |        /// - returns: New resource count
   29|       |        public static func decrementTotal() -> Int32 {
   30|       |            return AtomicDecrement(&resourceCount)
   31|       |        }
   32|       |    }
   33|       |#endif
   34|       |
   35|       |/// Swift does not implement abstract methods. This method is used as a runtime check to ensure that methods which intended to be abstract (i.e., they should be implemented in subclasses) are not called directly on the superclass.
   36|      0|func rxAbstractMethod(file: StaticString = #file, line: UInt = #line) -> Swift.Never {
   37|      0|    rxFatalError("Abstract method", file: file, line: line)
   38|      0|}
   39|       |
   40|      0|func rxFatalError(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) -> Swift.Never  {
   41|      0|    // The temptation to comment this line is great, but please don't, it's for your own good. The choice is yours.
   42|      0|    fatalError(lastMessage(), file: file, line: line)
   43|      0|}
   44|       |
   45|      0|func rxFatalErrorInDebug(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) {
   46|      0|    #if DEBUG
   47|      0|        fatalError(lastMessage(), file: file, line: line)
   48|      0|    #else
   49|      0|        print("\(file):\(line): \(lastMessage())")
   50|      0|    #endif
   51|      0|}
   52|       |
   53|      0|func incrementChecked(_ i: inout Int) throws -> Int {
   54|      0|    if i == Int.max {
   55|      0|        throw RxError.overflow
   56|      0|    }
   57|      0|    defer { i += 1 }
   58|      0|    return i
   59|      0|}
   60|       |
   61|      0|func decrementChecked(_ i: inout Int) throws -> Int {
   62|      0|    if i == Int.min {
   63|      0|        throw RxError.overflow
   64|      0|    }
   65|      0|    defer { i -= 1 }
   66|      0|    return i
   67|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/RxMutableBox.swift:
    1|       |//
    2|       |//  RxMutableBox.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/22/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Creates mutable reference wrapper for any type.
   10|       |final class RxMutableBox<T> : CustomDebugStringConvertible {
   11|       |    /// Wrapped value
   12|       |    var value : T
   13|       |    
   14|       |    /// Creates reference wrapper for `value`.
   15|       |    ///
   16|       |    /// - parameter value: Value to wrap.
   17|      0|    init (_ value: T) {
   18|      0|        self.value = value
   19|      0|    }
   20|       |}
   21|       |
   22|       |extension RxMutableBox {
   23|       |    /// - returns: Box description.
   24|      0|    var debugDescription: String {
   25|      0|        return "MutatingBox(\(self.value))"
   26|      0|    }
   27|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/SchedulerType.swift:
    1|       |//
    2|       |//  SchedulerType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.TimeInterval
   10|       |import struct Foundation.Date
   11|       |
   12|       |// Type that represents time interval in the context of RxSwift.
   13|       |public typealias RxTimeInterval = TimeInterval
   14|       |
   15|       |/// Type that represents absolute time in the context of RxSwift.
   16|       |public typealias RxTime = Date
   17|       |
   18|       |/// Represents an object that schedules units of work.
   19|       |public protocol SchedulerType: ImmediateSchedulerType {
   20|       |
   21|       |    /// - returns: Current time.
   22|       |    var now : RxTime {
   23|       |        get
   24|       |    }
   25|       |
   26|       |    /**
   27|       |    Schedules an action to be executed.
   28|       |    
   29|       |    - parameter state: State passed to the action to be executed.
   30|       |    - parameter dueTime: Relative time after which to execute the action.
   31|       |    - parameter action: Action to be executed.
   32|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   33|       |    */
   34|       |    func scheduleRelative<StateType>(_ state: StateType, dueTime: RxTimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable
   35|       | 
   36|       |    /**
   37|       |    Schedules a periodic piece of work.
   38|       |    
   39|       |    - parameter state: State passed to the action to be executed.
   40|       |    - parameter startAfter: Period after which initial work should be run.
   41|       |    - parameter period: Period for running the work periodically.
   42|       |    - parameter action: Action to be executed.
   43|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   44|       |    */
   45|       |    func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxTimeInterval, period: RxTimeInterval, action: @escaping (StateType) -> StateType) -> Disposable
   46|       |}
   47|       |
   48|       |extension SchedulerType {
   49|       |
   50|       |    /**
   51|       |    Periodic task will be emulated using recursive scheduling.
   52|       |
   53|       |    - parameter state: Initial state passed to the action upon the first iteration.
   54|       |    - parameter startAfter: Period after which initial work should be run.
   55|       |    - parameter period: Period for running the work periodically.
   56|       |    - returns: The disposable object used to cancel the scheduled recurring action (best effort).
   57|       |    */
   58|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: RxTimeInterval, period: RxTimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   59|      0|        let schedule = SchedulePeriodicRecursive(scheduler: self, startAfter: startAfter, period: period, action: action, state: state)
   60|      0|            
   61|      0|        return schedule.start()
   62|      0|    }
   63|       |
   64|      0|    func scheduleRecursive<State>(_ state: State, dueTime: RxTimeInterval, action: @escaping (State, AnyRecursiveScheduler<State>) -> ()) -> Disposable {
   65|      0|        let scheduler = AnyRecursiveScheduler(scheduler: self, action: action)
   66|      0|         
   67|      0|        scheduler.schedule(state, dueTime: dueTime)
   68|      0|            
   69|      0|        return Disposables.create(with: scheduler.dispose)
   70|      0|    }
   71|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/ConcurrentDispatchQueueScheduler.swift:
    1|       |//
    2|       |//  ConcurrentDispatchQueueScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/5/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import struct Foundation.TimeInterval
   11|       |import Dispatch
   12|       |
   13|       |/// Abstracts the work that needs to be performed on a specific `dispatch_queue_t`. You can also pass a serial dispatch queue, it shouldn't cause any problems.
   14|       |///
   15|       |/// This scheduler is suitable when some work needs to be performed in background.
   16|       |public class ConcurrentDispatchQueueScheduler: SchedulerType {
   17|       |    public typealias TimeInterval = Foundation.TimeInterval
   18|       |    public typealias Time = Date
   19|       |    
   20|      0|    public var now : Date {
   21|      0|        return Date()
   22|      0|    }
   23|       |
   24|       |    let configuration: DispatchQueueConfiguration
   25|       |    
   26|       |    /// Constructs new `ConcurrentDispatchQueueScheduler` that wraps `queue`.
   27|       |    ///
   28|       |    /// - parameter queue: Target dispatch queue.
   29|      0|    public init(queue: DispatchQueue, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   30|      0|        configuration = DispatchQueueConfiguration(queue: queue, leeway: leeway)
   31|      0|    }
   32|       |    
   33|       |    /// Convenience init for scheduler that wraps one of the global concurrent dispatch queues.
   34|       |    ///
   35|       |    /// - parameter qos: Target global dispatch queue, by quality of service class.
   36|       |    @available(iOS 8, OSX 10.10, *)
   37|      0|    public convenience init(qos: DispatchQoS, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   38|      0|        self.init(queue: DispatchQueue(
   39|      0|            label: "rxswift.queue.\(qos)",
   40|      0|            qos: qos,
   41|      0|            attributes: [DispatchQueue.Attributes.concurrent],
   42|      0|            target: nil),
   43|      0|            leeway: leeway
   44|      0|        )
   45|      0|    }
   46|       |
   47|       |    /**
   48|       |    Schedules an action to be executed immediatelly.
   49|       |    
   50|       |    - parameter state: State passed to the action to be executed.
   51|       |    - parameter action: Action to be executed.
   52|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   53|       |    */
   54|      0|    public final func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   55|      0|        return self.configuration.schedule(state, action: action)
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |    Schedules an action to be executed.
   60|       |    
   61|       |    - parameter state: State passed to the action to be executed.
   62|       |    - parameter dueTime: Relative time after which to execute the action.
   63|       |    - parameter action: Action to be executed.
   64|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   65|       |    */
   66|      0|    public final func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   67|      0|        return self.configuration.scheduleRelative(state, dueTime: dueTime, action: action)
   68|      0|    }
   69|       |    
   70|       |    /**
   71|       |    Schedules a periodic piece of work.
   72|       |    
   73|       |    - parameter state: State passed to the action to be executed.
   74|       |    - parameter startAfter: Period after which initial work should be run.
   75|       |    - parameter period: Period for running the work periodically.
   76|       |    - parameter action: Action to be executed.
   77|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   78|       |    */
   79|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   80|      0|        return self.configuration.schedulePeriodic(state, startAfter: startAfter, period: period, action: action)
   81|      0|    }
   82|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/ConcurrentMainScheduler.swift:
    1|       |//
    2|       |//  ConcurrentMainScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/17/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import struct Foundation.TimeInterval
   11|       |import Dispatch
   12|       |
   13|       |/**
   14|       |Abstracts work that needs to be performed on `MainThread`. In case `schedule` methods are called from main thread, it will perform action immediately without scheduling.
   15|       |
   16|       |This scheduler is optimized for `subscribeOn` operator. If you want to observe observable sequence elements on main thread using `observeOn` operator,
   17|       |`MainScheduler` is more suitable for that purpose.
   18|       |*/
   19|       |public final class ConcurrentMainScheduler : SchedulerType {
   20|       |    public typealias TimeInterval = Foundation.TimeInterval
   21|       |    public typealias Time = Date
   22|       |
   23|       |    private let _mainScheduler: MainScheduler
   24|       |    private let _mainQueue: DispatchQueue
   25|       |
   26|       |    /// - returns: Current time.
   27|      0|    public var now : Date {
   28|      0|        return _mainScheduler.now as Date
   29|      0|    }
   30|       |
   31|      1|    private init(mainScheduler: MainScheduler) {
   32|      1|        _mainQueue = DispatchQueue.main
   33|      1|        _mainScheduler = mainScheduler
   34|      1|    }
   35|       |
   36|       |    /// Singleton instance of `ConcurrentMainScheduler`
   37|       |    public static let instance = ConcurrentMainScheduler(mainScheduler: MainScheduler.instance)
   38|       |
   39|       |    /**
   40|       |    Schedules an action to be executed immediatelly.
   41|       |
   42|       |    - parameter state: State passed to the action to be executed.
   43|       |    - parameter action: Action to be executed.
   44|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   45|       |    */
   46|    557|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   47|    557|        if DispatchQueue.isMain {
   48|    557|            return action(state)
   49|      0|        }
   50|      0|
   51|      0|        let cancel = SingleAssignmentDisposable()
   52|      0|
   53|      0|        _mainQueue.async {
   54|      0|            if cancel.isDisposed {
   55|      0|                return
   56|      0|            }
   57|      0|
   58|      0|            cancel.setDisposable(action(state))
   59|      0|        }
   60|      0|
   61|      0|        return cancel
   62|    557|    }
   63|       |
   64|       |    /**
   65|       |    Schedules an action to be executed.
   66|       |
   67|       |    - parameter state: State passed to the action to be executed.
   68|       |    - parameter dueTime: Relative time after which to execute the action.
   69|       |    - parameter action: Action to be executed.
   70|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   71|       |    */
   72|      0|    public final func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   73|      0|        return _mainScheduler.scheduleRelative(state, dueTime: dueTime, action: action)
   74|      0|    }
   75|       |
   76|       |    /**
   77|       |    Schedules a periodic piece of work.
   78|       |
   79|       |    - parameter state: State passed to the action to be executed.
   80|       |    - parameter startAfter: Period after which initial work should be run.
   81|       |    - parameter period: Period for running the work periodically.
   82|       |    - parameter action: Action to be executed.
   83|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   84|       |    */
   85|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   86|      0|        return _mainScheduler.schedulePeriodic(state, startAfter: startAfter, period: period, action: action)
   87|      0|    }
   88|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/CurrentThreadScheduler.swift:
    1|       |//
    2|       |//  CurrentThreadScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSObject
   10|       |import protocol Foundation.NSCopying
   11|       |import class Foundation.Thread
   12|       |import Dispatch
   13|       |
   14|       |#if os(Linux)
   15|       |    import struct Foundation.pthread_key_t
   16|       |    import func Foundation.pthread_setspecific
   17|       |    import func Foundation.pthread_getspecific
   18|       |    import func Foundation.pthread_key_create
   19|       |    
   20|       |    fileprivate enum CurrentThreadSchedulerQueueKey {
   21|       |        fileprivate static let instance = "RxSwift.CurrentThreadScheduler.Queue"
   22|       |    }
   23|       |#else
   24|       |    fileprivate class CurrentThreadSchedulerQueueKey: NSObject, NSCopying {
   25|       |        static let instance = CurrentThreadSchedulerQueueKey()
   26|      1|        private override init() {
   27|      1|            super.init()
   28|      1|        }
   29|       |
   30|    704|        override var hash: Int {
   31|    704|            return 0
   32|    704|        }
   33|       |
   34|      0|        public func copy(with zone: NSZone? = nil) -> Any {
   35|      0|            return self
   36|      0|        }
   37|       |    }
   38|       |#endif
   39|       |
   40|       |/// Represents an object that schedules units of work on the current thread.
   41|       |///
   42|       |/// This is the default scheduler for operators that generate elements.
   43|       |///
   44|       |/// This scheduler is also sometimes called `trampoline scheduler`.
   45|       |public class CurrentThreadScheduler : ImmediateSchedulerType {
   46|       |    typealias ScheduleQueue = RxMutableBox<Queue<ScheduledItemType>>
   47|       |
   48|       |    /// The singleton instance of the current thread scheduler.
   49|       |    public static let instance = CurrentThreadScheduler()
   50|       |
   51|       |    private static var isScheduleRequiredKey: pthread_key_t = { () -> pthread_key_t in
   52|       |        let key = UnsafeMutablePointer<pthread_key_t>.allocate(capacity: 1)
   53|       |        if pthread_key_create(key, nil) != 0 {
   54|       |            rxFatalError("isScheduleRequired key creation failed")
   55|       |        }
   56|       |
   57|       |        return key.pointee
   58|       |    }()
   59|       |
   60|       |    private static var scheduleInProgressSentinel: UnsafeRawPointer = { () -> UnsafeRawPointer in
   61|       |        return UnsafeRawPointer(UnsafeMutablePointer<Int>.allocate(capacity: 1))
   62|       |    }()
   63|       |
   64|       |    static var queue : ScheduleQueue? {
   65|    352|        get {
   66|    352|            return Thread.getThreadLocalStorageValueForKey(CurrentThreadSchedulerQueueKey.instance)
   67|    352|        }
   68|    352|        set {
   69|    352|            Thread.setThreadLocalStorageValue(newValue, forKey: CurrentThreadSchedulerQueueKey.instance)
   70|    352|        }
   71|       |    }
   72|       |
   73|       |    /// Gets a value that indicates whether the caller must call a `schedule` method.
   74|       |    public static fileprivate(set) var isScheduleRequired: Bool {
   75|  2.35k|        get {
   76|  2.35k|            return pthread_getspecific(CurrentThreadScheduler.isScheduleRequiredKey) == nil
   77|  2.35k|        }
   78|    704|        set(isScheduleRequired) {
   79|    352|            if pthread_setspecific(CurrentThreadScheduler.isScheduleRequiredKey, isScheduleRequired ? nil : scheduleInProgressSentinel) != 0 {
   80|      0|                rxFatalError("pthread_setspecific failed")
   81|    704|            }
   82|    704|        }
   83|       |    }
   84|       |
   85|       |    /**
   86|       |    Schedules an action to be executed as soon as possible on current thread.
   87|       |
   88|       |    If this method is called on some thread that doesn't have `CurrentThreadScheduler` installed, scheduler will be
   89|       |    automatically installed and uninstalled after all work is performed.
   90|       |
   91|       |    - parameter state: State passed to the action to be executed.
   92|       |    - parameter action: Action to be executed.
   93|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   94|       |    */
   95|    352|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   96|    352|        if CurrentThreadScheduler.isScheduleRequired {
   97|    352|            CurrentThreadScheduler.isScheduleRequired = false
   98|    352|
   99|    352|            let disposable = action(state)
  100|    352|
  101|    352|            defer {
  102|    352|                CurrentThreadScheduler.isScheduleRequired = true
  103|    352|                CurrentThreadScheduler.queue = nil
  104|    352|            }
  105|    352|
  106|    352|            guard let queue = CurrentThreadScheduler.queue else {
  107|    352|                return disposable
  108|      0|            }
  109|      0|
  110|      0|            while let latest = queue.value.dequeue() {
  111|      0|                if latest.isDisposed {
  112|      0|                    continue
  113|      0|                }
  114|      0|                latest.invoke()
  115|      0|            }
  116|      0|
  117|      0|            return disposable
  118|      0|        }
  119|      0|
  120|      0|        let existingQueue = CurrentThreadScheduler.queue
  121|      0|
  122|      0|        let queue: RxMutableBox<Queue<ScheduledItemType>>
  123|      0|        if let existingQueue = existingQueue {
  124|      0|            queue = existingQueue
  125|      0|        }
  126|      0|        else {
  127|      0|            queue = RxMutableBox(Queue<ScheduledItemType>(capacity: 1))
  128|      0|            CurrentThreadScheduler.queue = queue
  129|      0|        }
  130|      0|
  131|      0|        let scheduledItem = ScheduledItem(action: action, state: state)
  132|      0|        queue.value.enqueue(scheduledItem)
  133|      0|
  134|      0|        return scheduledItem
  135|      0|    }
  136|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/HistoricalScheduler.swift:
    1|       |//
    2|       |//  HistoricalScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |/// Provides a virtual time scheduler that uses `Date` for absolute time and `NSTimeInterval` for relative time.
   12|       |public class HistoricalScheduler : VirtualTimeScheduler<HistoricalSchedulerTimeConverter> {
   13|       |
   14|       |    /**
   15|       |      Creates a new historical scheduler with initial clock value.
   16|       |     
   17|       |     - parameter initialClock: Initial value for virtual clock.
   18|       |    */
   19|      0|    public init(initialClock: RxTime = Date(timeIntervalSince1970: 0)) {
   20|      0|        super.init(initialClock: initialClock, converter: HistoricalSchedulerTimeConverter())
   21|      0|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/HistoricalSchedulerTimeConverter.swift:
    1|       |//
    2|       |//  HistoricalSchedulerTimeConverter.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |
   11|       |/// Converts historial virtual time into real time.
   12|       |///
   13|       |/// Since historical virtual time is also measured in `Date`, this converter is identity function.
   14|       |public struct HistoricalSchedulerTimeConverter : VirtualTimeConverterType {
   15|       |    /// Virtual time unit used that represents ticks of virtual clock.
   16|       |    public typealias VirtualTimeUnit = RxTime
   17|       |
   18|       |    /// Virtual time unit used to represent differences of virtual times.
   19|       |    public typealias VirtualTimeIntervalUnit = RxTimeInterval
   20|       |
   21|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   22|       |    /// decoupled from local machine clock.
   23|      0|    public func convertFromVirtualTime(_ virtualTime: VirtualTimeUnit) -> RxTime {
   24|      0|        return virtualTime
   25|      0|    }
   26|       |
   27|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   28|       |    /// decoupled from local machine clock.
   29|      0|    public func convertToVirtualTime(_ time: RxTime) -> VirtualTimeUnit {
   30|      0|        return time
   31|      0|    }
   32|       |
   33|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   34|       |    /// decoupled from local machine clock.
   35|      0|    public func convertFromVirtualTimeInterval(_ virtualTimeInterval: VirtualTimeIntervalUnit) -> RxTimeInterval {
   36|      0|        return virtualTimeInterval
   37|      0|    }
   38|       |
   39|       |    /// Returns identical value of argument passed because historical virtual time is equal to real time, just
   40|       |    /// decoupled from local machine clock.
   41|      0|    public func convertToVirtualTimeInterval(_ timeInterval: RxTimeInterval) -> VirtualTimeIntervalUnit {
   42|      0|        return timeInterval
   43|      0|    }
   44|       |
   45|       |    /**
   46|       |     Offsets `Date` by time interval.
   47|       |     
   48|       |     - parameter time: Time.
   49|       |     - parameter timeInterval: Time interval offset.
   50|       |     - returns: Time offsetted by time interval.
   51|       |    */
   52|      0|    public func offsetVirtualTime(_ time: VirtualTimeUnit, offset: VirtualTimeIntervalUnit) -> VirtualTimeUnit {
   53|      0|        return time.addingTimeInterval(offset)
   54|      0|    }
   55|       |
   56|       |    /// Compares two `Date`s.
   57|      0|    public func compareVirtualTime(_ lhs: VirtualTimeUnit, _ rhs: VirtualTimeUnit) -> VirtualTimeComparison {
   58|      0|        switch lhs.compare(rhs as Date) {
   59|      0|        case .orderedAscending:
   60|      0|            return .lessThan
   61|      0|        case .orderedSame:
   62|      0|            return .equal
   63|      0|        case .orderedDescending:
   64|      0|            return .greaterThan
   65|      0|        }
   66|      0|    }
   67|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/ImmediateScheduler.swift:
    1|       |//
    2|       |//  ImmediateScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/17/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that schedules units of work to run immediately on the current thread.
   10|       |private final class ImmediateScheduler : ImmediateSchedulerType {
   11|       |
   12|       |    private let _asyncLock = AsyncLock<AnonymousInvocable>()
   13|       |
   14|       |    /**
   15|       |    Schedules an action to be executed immediatelly.
   16|       |
   17|       |    In case `schedule` is called recursively from inside of `action` callback, scheduled `action` will be enqueued
   18|       |    and executed after current `action`. (`AsyncLock` behavior)
   19|       |
   20|       |    - parameter state: State passed to the action to be executed.
   21|       |    - parameter action: Action to be executed.
   22|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   23|       |    */
   24|      0|    func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   25|      0|        let disposable = SingleAssignmentDisposable()
   26|      0|        _asyncLock.invoke(AnonymousInvocable {
   27|      0|            if disposable.isDisposed {
   28|      0|                return
   29|      0|            }
   30|      0|            disposable.setDisposable(action(state))
   31|      0|        })
   32|      0|
   33|      0|        return disposable
   34|      0|    }
   35|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/AnonymousInvocable.swift:
    1|       |//
    2|       |//  AnonymousInvocable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct AnonymousInvocable : InvocableType {
   10|       |    private let _action: () -> ()
   11|       |
   12|      0|    init(_ action: @escaping () -> ()) {
   13|      0|        _action = action
   14|      0|    }
   15|       |
   16|      0|    func invoke() {
   17|      0|        _action()
   18|      0|    }
   19|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/DispatchQueueConfiguration.swift:
    1|       |//
    2|       |//  DispatchQueueConfiguration.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/23/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |import struct Foundation.TimeInterval
   11|       |
   12|       |struct DispatchQueueConfiguration {
   13|       |    let queue: DispatchQueue
   14|       |    let leeway: DispatchTimeInterval
   15|       |}
   16|       |
   17|     14|private func dispatchInterval(_ interval: Foundation.TimeInterval) -> DispatchTimeInterval {
   18|     14|    precondition(interval >= 0.0)
   19|     14|    // TODO: Replace 1000 with something that actually works 
   20|     14|    // NSEC_PER_MSEC returns 1000000
   21|     14|    return DispatchTimeInterval.milliseconds(Int(interval * 1000.0))
   22|     14|}
   23|       |
   24|       |extension DispatchQueueConfiguration {
   25|      0|    func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   26|      0|        let cancel = SingleAssignmentDisposable()
   27|      0|
   28|      0|        queue.async {
   29|      0|            if cancel.isDisposed {
   30|      0|                return
   31|      0|            }
   32|      0|
   33|      0|
   34|      0|            cancel.setDisposable(action(state))
   35|      0|        }
   36|      0|
   37|      0|        return cancel
   38|      0|    }
   39|       |
   40|     14|    func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   41|     14|        let deadline = DispatchTime.now() + dispatchInterval(dueTime)
   42|     14|
   43|     14|        let compositeDisposable = CompositeDisposable()
   44|     14|
   45|     14|        let timer = DispatchSource.makeTimerSource(queue: queue)
   46|     14|        timer.scheduleOneshot(deadline: deadline)
   47|     14|
   48|     14|        // TODO:
   49|     14|        // This looks horrible, and yes, it is.
   50|     14|        // It looks like Apple has made a conceputal change here, and I'm unsure why.
   51|     14|        // Need more info on this.
   52|     14|        // It looks like just setting timer to fire and not holding a reference to it
   53|     14|        // until deadline causes timer cancellation.
   54|     14|        var timerReference: DispatchSourceTimer? = timer
   55|     14|        let cancelTimer = Disposables.create {
   56|     14|            timerReference?.cancel()
   57|     14|            timerReference = nil
   58|     14|        }
   59|     14|
   60|      0|        timer.setEventHandler(handler: {
   61|      0|            if compositeDisposable.isDisposed {
   62|      0|                return
   63|      0|            }
   64|      0|            _ = compositeDisposable.insert(action(state))
   65|      0|            cancelTimer.dispose()
   66|      0|        })
   67|     14|        timer.resume()
   68|     14|
   69|     14|        _ = compositeDisposable.insert(cancelTimer)
   70|     14|
   71|     14|        return compositeDisposable
   72|     14|    }
   73|       |
   74|      0|    func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
   75|      0|        let initial = DispatchTime.now() + dispatchInterval(startAfter)
   76|      0|
   77|      0|        var timerState = state
   78|      0|
   79|      0|        let timer = DispatchSource.makeTimerSource(queue: queue)
   80|      0|        timer.scheduleRepeating(deadline: initial, interval: dispatchInterval(period), leeway: leeway)
   81|      0|
   82|      0|        // TODO:
   83|      0|        // This looks horrible, and yes, it is.
   84|      0|        // It looks like Apple has made a conceputal change here, and I'm unsure why.
   85|      0|        // Need more info on this.
   86|      0|        // It looks like just setting timer to fire and not holding a reference to it
   87|      0|        // until deadline causes timer cancellation.
   88|      0|        var timerReference: DispatchSourceTimer? = timer
   89|      0|        let cancelTimer = Disposables.create {
   90|      0|            timerReference?.cancel()
   91|      0|            timerReference = nil
   92|      0|        }
   93|      0|
   94|      0|        timer.setEventHandler(handler: {
   95|      0|            if cancelTimer.isDisposed {
   96|      0|                return
   97|      0|            }
   98|      0|            timerState = action(timerState)
   99|      0|        })
  100|      0|        timer.resume()
  101|      0|        
  102|      0|        return cancelTimer
  103|      0|    }
  104|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/InvocableScheduledItem.swift:
    1|       |//
    2|       |//  InvocableScheduledItem.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct InvocableScheduledItem<I: InvocableWithValueType> : InvocableType {
   10|       |
   11|       |    let _invocable: I
   12|       |    let _state: I.Value
   13|       |
   14|      4|    init(invocable: I, state: I.Value) {
   15|      4|        _invocable = invocable
   16|      4|        _state = state
   17|      4|    }
   18|       |
   19|      4|    func invoke() {
   20|      4|        _invocable.invoke(_state)
   21|      4|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/Internal/ScheduledItem.swift:
    1|       |//
    2|       |//  ScheduledItem.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct ScheduledItem<T>
   10|       |    : ScheduledItemType
   11|       |    , InvocableType {
   12|       |    typealias Action = (T) -> Disposable
   13|       |    
   14|       |    private let _action: Action
   15|       |    private let _state: T
   16|       |
   17|       |    private let _disposable = SingleAssignmentDisposable()
   18|       |
   19|      0|    var isDisposed: Bool {
   20|      0|        return _disposable.isDisposed
   21|      0|    }
   22|       |    
   23|      0|    init(action: @escaping Action, state: T) {
   24|      0|        _action = action
   25|      0|        _state = state
   26|      0|    }
   27|       |    
   28|      0|    func invoke() {
   29|      0|         _disposable.setDisposable(_action(_state))
   30|      0|    }
   31|       |    
   32|      0|    func dispose() {
   33|      0|        _disposable.dispose()
   34|      0|    }
   35|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/MainScheduler.swift:
    1|       |//
    2|       |//  MainScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |/**
   12|       |Abstracts work that needs to be performed on `DispatchQueue.main`. In case `schedule` methods are called from `DispatchQueue.main`, it will perform action immediately without scheduling.
   13|       |
   14|       |This scheduler is usually used to perform UI work.
   15|       |
   16|       |Main scheduler is a specialization of `SerialDispatchQueueScheduler`.
   17|       |
   18|       |This scheduler is optimized for `observeOn` operator. To ensure observable sequence is subscribed on main thread using `subscribeOn`
   19|       |operator please use `ConcurrentMainScheduler` because it is more optimized for that purpose.
   20|       |*/
   21|       |public final class MainScheduler : SerialDispatchQueueScheduler {
   22|       |
   23|       |    private let _mainQueue: DispatchQueue
   24|       |
   25|       |    var numberEnqueued: AtomicInt = 0
   26|       |
   27|       |    /// Initializes new instance of `MainScheduler`.
   28|      6|    public init() {
   29|      6|        _mainQueue = DispatchQueue.main
   30|      6|        super.init(serialQueue: _mainQueue)
   31|      6|    }
   32|       |
   33|       |    /// Singleton instance of `MainScheduler`
   34|       |    public static let instance = MainScheduler()
   35|       |
   36|       |    /// Singleton instance of `MainScheduler` that always schedules work asynchronously
   37|       |    /// and doesn't perform optimizations for calls scheduled from main queue.
   38|       |    public static let asyncInstance = SerialDispatchQueueScheduler(serialQueue: DispatchQueue.main)
   39|       |
   40|       |    /// In case this method is called on a background thread it will throw an exception.
   41|  1.19k|    public class func ensureExecutingOnScheduler(errorMessage: String? = nil) {
   42|      0|        if !DispatchQueue.isMain {
   43|      0|            rxFatalError(errorMessage ?? "Executing on backgound thread. Please use `MainScheduler.instance.schedule` to schedule work on main thread.")
   44|  1.19k|        }
   45|  1.19k|    }
   46|       |
   47|    120|    override func scheduleInternal<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   48|    120|        let currentNumberEnqueued = AtomicIncrement(&numberEnqueued)
   49|    120|
   50|     96|        if DispatchQueue.isMain && currentNumberEnqueued == 1 {
   51|     85|            let disposable = action(state)
   52|     85|            _ = AtomicDecrement(&numberEnqueued)
   53|     85|            return disposable
   54|     35|        }
   55|     35|
   56|     35|        let cancel = SingleAssignmentDisposable()
   57|     35|
   58|     12|        _mainQueue.async {
   59|     12|            if !cancel.isDisposed {
   60|     12|                _ = action(state)
   61|     12|            }
   62|     12|
   63|     12|            _ = AtomicDecrement(&self.numberEnqueued)
   64|     12|        }
   65|     35|
   66|     35|        return cancel
   67|    120|    }
   68|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/OperationQueueScheduler.swift:
    1|       |//
    2|       |//  OperationQueueScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.OperationQueue
   10|       |import class Foundation.BlockOperation
   11|       |import Dispatch
   12|       |
   13|       |/// Abstracts the work that needs to be performed on a specific `NSOperationQueue`.
   14|       |///
   15|       |/// This scheduler is suitable for cases when there is some bigger chunk of work that needs to be performed in background and you want to fine tune concurrent processing using `maxConcurrentOperationCount`.
   16|       |public class OperationQueueScheduler: ImmediateSchedulerType {
   17|       |    public let operationQueue: OperationQueue
   18|       |    
   19|       |    /// Constructs new instance of `OperationQueueScheduler` that performs work on `operationQueue`.
   20|       |    ///
   21|       |    /// - parameter operationQueue: Operation queue targeted to perform work on.
   22|      0|    public init(operationQueue: OperationQueue) {
   23|      0|        self.operationQueue = operationQueue
   24|      0|    }
   25|       |    
   26|       |    /**
   27|       |    Schedules an action to be executed recursively.
   28|       |    
   29|       |    - parameter state: State passed to the action to be executed.
   30|       |    - parameter action: Action to execute recursively. The last parameter passed to the action is used to trigger recursive scheduling of the action, passing in recursive invocation state.
   31|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   32|       |    */
   33|      0|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   34|      0|        let cancel = SingleAssignmentDisposable()
   35|      0|
   36|      0|        let operation = BlockOperation {
   37|      0|            if cancel.isDisposed {
   38|      0|                return
   39|      0|            }
   40|      0|
   41|      0|
   42|      0|            cancel.setDisposable(action(state))
   43|      0|        }
   44|      0|
   45|      0|        self.operationQueue.addOperation(operation)
   46|      0|        
   47|      0|        return cancel
   48|      0|    }
   49|       |
   50|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/RecursiveScheduler.swift:
    1|       |//
    2|       |//  RecursiveScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |fileprivate enum ScheduleState {
   10|       |    case initial
   11|       |    case added(CompositeDisposable.DisposeKey)
   12|       |    case done
   13|       |}
   14|       |
   15|       |/// Type erased recursive scheduler.
   16|       |final class AnyRecursiveScheduler<State> {
   17|       |    
   18|       |    typealias Action =  (State, AnyRecursiveScheduler<State>) -> Void
   19|       |
   20|       |    private let _lock = RecursiveLock()
   21|       |    
   22|       |    // state
   23|       |    private let _group = CompositeDisposable()
   24|       |
   25|       |    private var _scheduler: SchedulerType
   26|       |    private var _action: Action?
   27|       |    
   28|      0|    init(scheduler: SchedulerType, action: @escaping Action) {
   29|      0|        _action = action
   30|      0|        _scheduler = scheduler
   31|      0|    }
   32|       |
   33|       |    /**
   34|       |    Schedules an action to be executed recursively.
   35|       |    
   36|       |    - parameter state: State passed to the action to be executed.
   37|       |    - parameter dueTime: Relative time after which to execute the recursive action.
   38|       |    */
   39|      0|    func schedule(_ state: State, dueTime: RxTimeInterval) {
   40|      0|        var scheduleState: ScheduleState = .initial
   41|      0|
   42|      0|        let d = _scheduler.scheduleRelative(state, dueTime: dueTime) { (state) -> Disposable in
   43|      0|            // best effort
   44|      0|            if self._group.isDisposed {
   45|      0|                return Disposables.create()
   46|      0|            }
   47|      0|            
   48|      0|            let action = self._lock.calculateLocked { () -> Action? in
   49|      0|                switch scheduleState {
   50|      0|                case let .added(removeKey):
   51|      0|                    self._group.remove(for: removeKey)
   52|      0|                case .initial:
   53|      0|                    break
   54|      0|                case .done:
   55|      0|                    break
   56|      0|                }
   57|      0|
   58|      0|                scheduleState = .done
   59|      0|
   60|      0|                return self._action
   61|      0|            }
   62|      0|            
   63|      0|            if let action = action {
   64|      0|                action(state, self)
   65|      0|            }
   66|      0|            
   67|      0|            return Disposables.create()
   68|      0|        }
   69|      0|            
   70|      0|        _lock.performLocked {
   71|      0|            switch scheduleState {
   72|      0|            case .added:
   73|      0|                rxFatalError("Invalid state")
   74|      0|                break
   75|      0|            case .initial:
   76|      0|                if let removeKey = _group.insert(d) {
   77|      0|                    scheduleState = .added(removeKey)
   78|      0|                }
   79|      0|                else {
   80|      0|                    scheduleState = .done
   81|      0|                }
   82|      0|                break
   83|      0|            case .done:
   84|      0|                break
   85|      0|            }
   86|      0|        }
   87|      0|    }
   88|       |
   89|       |    /// Schedules an action to be executed recursively.
   90|       |    ///
   91|       |    /// - parameter state: State passed to the action to be executed.
   92|      0|    func schedule(_ state: State) {
   93|      0|        var scheduleState: ScheduleState = .initial
   94|      0|
   95|      0|        let d = _scheduler.schedule(state) { (state) -> Disposable in
   96|      0|            // best effort
   97|      0|            if self._group.isDisposed {
   98|      0|                return Disposables.create()
   99|      0|            }
  100|      0|            
  101|      0|            let action = self._lock.calculateLocked { () -> Action? in
  102|      0|                switch scheduleState {
  103|      0|                case let .added(removeKey):
  104|      0|                    self._group.remove(for: removeKey)
  105|      0|                case .initial:
  106|      0|                    break
  107|      0|                case .done:
  108|      0|                    break
  109|      0|                }
  110|      0|
  111|      0|                scheduleState = .done
  112|      0|                
  113|      0|                return self._action
  114|      0|            }
  115|      0|           
  116|      0|            if let action = action {
  117|      0|                action(state, self)
  118|      0|            }
  119|      0|            
  120|      0|            return Disposables.create()
  121|      0|        }
  122|      0|        
  123|      0|        _lock.performLocked {
  124|      0|            switch scheduleState {
  125|      0|            case .added:
  126|      0|                rxFatalError("Invalid state")
  127|      0|                break
  128|      0|            case .initial:
  129|      0|                if let removeKey = _group.insert(d) {
  130|      0|                    scheduleState = .added(removeKey)
  131|      0|                }
  132|      0|                else {
  133|      0|                    scheduleState = .done
  134|      0|                }
  135|      0|                break
  136|      0|            case .done:
  137|      0|                break
  138|      0|            }
  139|      0|        }
  140|      0|    }
  141|       |    
  142|      0|    func dispose() {
  143|      0|        _lock.performLocked {
  144|      0|            _action = nil
  145|      0|        }
  146|      0|        _group.dispose()
  147|      0|    }
  148|       |}
  149|       |
  150|       |/// Type erased recursive scheduler.
  151|       |final class RecursiveImmediateScheduler<State> {
  152|       |    typealias Action =  (_ state: State, _ recurse: (State) -> Void) -> Void
  153|       |    
  154|       |    private var _lock = SpinLock()
  155|       |    private let _group = CompositeDisposable()
  156|       |    
  157|       |    private var _action: Action?
  158|       |    private let _scheduler: ImmediateSchedulerType
  159|       |    
  160|      0|    init(action: @escaping Action, scheduler: ImmediateSchedulerType) {
  161|      0|        _action = action
  162|      0|        _scheduler = scheduler
  163|      0|    }
  164|       |    
  165|       |    // immediate scheduling
  166|       |    
  167|       |    /// Schedules an action to be executed recursively.
  168|       |    ///
  169|       |    /// - parameter state: State passed to the action to be executed.
  170|      0|    func schedule(_ state: State) {
  171|      0|        var scheduleState: ScheduleState = .initial
  172|      0|
  173|      0|        let d = _scheduler.schedule(state) { (state) -> Disposable in
  174|      0|            // best effort
  175|      0|            if self._group.isDisposed {
  176|      0|                return Disposables.create()
  177|      0|            }
  178|      0|            
  179|      0|            let action = self._lock.calculateLocked { () -> Action? in
  180|      0|                switch scheduleState {
  181|      0|                case let .added(removeKey):
  182|      0|                    self._group.remove(for: removeKey)
  183|      0|                case .initial:
  184|      0|                    break
  185|      0|                case .done:
  186|      0|                    break
  187|      0|                }
  188|      0|
  189|      0|                scheduleState = .done
  190|      0|
  191|      0|                return self._action
  192|      0|            }
  193|      0|            
  194|      0|            if let action = action {
  195|      0|                action(state, self.schedule)
  196|      0|            }
  197|      0|            
  198|      0|            return Disposables.create()
  199|      0|        }
  200|      0|        
  201|      0|        _lock.performLocked {
  202|      0|            switch scheduleState {
  203|      0|            case .added:
  204|      0|                rxFatalError("Invalid state")
  205|      0|                break
  206|      0|            case .initial:
  207|      0|                if let removeKey = _group.insert(d) {
  208|      0|                    scheduleState = .added(removeKey)
  209|      0|                }
  210|      0|                else {
  211|      0|                    scheduleState = .done
  212|      0|                }
  213|      0|                break
  214|      0|            case .done:
  215|      0|                break
  216|      0|            }
  217|      0|        }
  218|      0|    }
  219|       |    
  220|      0|    func dispose() {
  221|      0|        _lock.performLocked {
  222|      0|            _action = nil
  223|      0|        }
  224|      0|        _group.dispose()
  225|      0|    }
  226|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/SchedulerServices+Emulation.swift:
    1|       |//
    2|       |//  SchedulerServices+Emulation.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |enum SchedulePeriodicRecursiveCommand {
   10|       |    case tick
   11|       |    case dispatchStart
   12|       |}
   13|       |
   14|       |final class SchedulePeriodicRecursive<State> {
   15|       |    typealias RecursiveAction = (State) -> State
   16|       |    typealias RecursiveScheduler = AnyRecursiveScheduler<SchedulePeriodicRecursiveCommand>
   17|       |
   18|       |    private let _scheduler: SchedulerType
   19|       |    private let _startAfter: RxTimeInterval
   20|       |    private let _period: RxTimeInterval
   21|       |    private let _action: RecursiveAction
   22|       |
   23|       |    private var _state: State
   24|       |    private var _pendingTickCount: AtomicInt = 0
   25|       |
   26|      0|    init(scheduler: SchedulerType, startAfter: RxTimeInterval, period: RxTimeInterval, action: @escaping RecursiveAction, state: State) {
   27|      0|        _scheduler = scheduler
   28|      0|        _startAfter = startAfter
   29|      0|        _period = period
   30|      0|        _action = action
   31|      0|        _state = state
   32|      0|    }
   33|       |
   34|      0|    func start() -> Disposable {
   35|      0|        return _scheduler.scheduleRecursive(SchedulePeriodicRecursiveCommand.tick, dueTime: _startAfter, action: self.tick)
   36|      0|    }
   37|       |
   38|      0|    func tick(_ command: SchedulePeriodicRecursiveCommand, scheduler: RecursiveScheduler) -> Void {
   39|      0|        // Tries to emulate periodic scheduling as best as possible.
   40|      0|        // The problem that could arise is if handling periodic ticks take too long, or
   41|      0|        // tick interval is short.
   42|      0|        switch command {
   43|      0|        case .tick:
   44|      0|            scheduler.schedule(.tick, dueTime: _period)
   45|      0|
   46|      0|            // The idea is that if on tick there wasn't any item enqueued, schedule to perform work immediatelly.
   47|      0|            // Else work will be scheduled after previous enqueued work completes.
   48|      0|            if AtomicIncrement(&_pendingTickCount) == 1 {
   49|      0|                self.tick(.dispatchStart, scheduler: scheduler)
   50|      0|            }
   51|      0|
   52|      0|        case .dispatchStart:
   53|      0|            _state = _action(_state)
   54|      0|            // Start work and schedule check is this last batch of work
   55|      0|            if AtomicDecrement(&_pendingTickCount) > 0 {
   56|      0|                // This gives priority to scheduler emulation, it's not perfect, but helps
   57|      0|                scheduler.schedule(SchedulePeriodicRecursiveCommand.dispatchStart)
   58|      0|            }
   59|      0|        }
   60|      0|    }
   61|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/SerialDispatchQueueScheduler.swift:
    1|       |//
    2|       |//  SerialDispatchQueueScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.TimeInterval
   10|       |import struct Foundation.Date
   11|       |import Dispatch
   12|       |
   13|       |/**
   14|       |Abstracts the work that needs to be performed on a specific `dispatch_queue_t`. It will make sure 
   15|       |that even if concurrent dispatch queue is passed, it's transformed into a serial one.
   16|       |
   17|       |It is extremely important that this scheduler is serial, because
   18|       |certain operator perform optimizations that rely on that property.
   19|       |
   20|       |Because there is no way of detecting is passed dispatch queue serial or
   21|       |concurrent, for every queue that is being passed, worst case (concurrent)
   22|       |will be assumed, and internal serial proxy dispatch queue will be created.
   23|       |
   24|       |This scheduler can also be used with internal serial queue alone.
   25|       |
   26|       |In case some customization need to be made on it before usage,
   27|       |internal serial queue can be customized using `serialQueueConfiguration`
   28|       |callback.
   29|       |*/
   30|       |public class SerialDispatchQueueScheduler : SchedulerType {
   31|       |    public typealias TimeInterval = Foundation.TimeInterval
   32|       |    public typealias Time = Date
   33|       |    
   34|       |    /// - returns: Current time.
   35|      0|    public var now : Date {
   36|      0|        return Date()
   37|      0|    }
   38|       |
   39|       |    let configuration: DispatchQueueConfiguration
   40|       |    
   41|      6|    init(serialQueue: DispatchQueue, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   42|      6|        configuration = DispatchQueueConfiguration(queue: serialQueue, leeway: leeway)
   43|      6|    }
   44|       |
   45|       |    /**
   46|       |    Constructs new `SerialDispatchQueueScheduler` with internal serial queue named `internalSerialQueueName`.
   47|       |    
   48|       |    Additional dispatch queue properties can be set after dispatch queue is created using `serialQueueConfiguration`.
   49|       |    
   50|       |    - parameter internalSerialQueueName: Name of internal serial dispatch queue.
   51|       |    - parameter serialQueueConfiguration: Additional configuration of internal serial dispatch queue.
   52|       |    */
   53|      0|    public convenience init(internalSerialQueueName: String, serialQueueConfiguration: ((DispatchQueue) -> Void)? = nil, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   54|      0|        let queue = DispatchQueue(label: internalSerialQueueName, attributes: [])
   55|      0|        serialQueueConfiguration?(queue)
   56|      0|        self.init(serialQueue: queue, leeway: leeway)
   57|      0|    }
   58|       |    
   59|       |    /**
   60|       |    Constructs new `SerialDispatchQueueScheduler` named `internalSerialQueueName` that wraps `queue`.
   61|       |    
   62|       |    - parameter queue: Possibly concurrent dispatch queue used to perform work.
   63|       |    - parameter internalSerialQueueName: Name of internal serial dispatch queue proxy.
   64|       |    */
   65|      0|    public convenience init(queue: DispatchQueue, internalSerialQueueName: String, leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   66|      0|        // Swift 3.0 IUO
   67|      0|        let serialQueue = DispatchQueue(label: internalSerialQueueName,
   68|      0|                                        attributes: [],
   69|      0|                                        target: queue)
   70|      0|        self.init(serialQueue: serialQueue, leeway: leeway)
   71|      0|    }
   72|       |
   73|       |    /**
   74|       |     Constructs new `SerialDispatchQueueScheduler` that wraps on of the global concurrent dispatch queues.
   75|       |     
   76|       |     - parameter qos: Identifier for global dispatch queue with specified quality of service class.
   77|       |     - parameter internalSerialQueueName: Custom name for internal serial dispatch queue proxy.
   78|       |     */
   79|       |    @available(iOS 8, OSX 10.10, *)
   80|      0|    public convenience init(qos: DispatchQoS, internalSerialQueueName: String = "rx.global_dispatch_queue.serial", leeway: DispatchTimeInterval = DispatchTimeInterval.nanoseconds(0)) {
   81|      0|        self.init(queue: DispatchQueue.global(qos: qos.qosClass), internalSerialQueueName: internalSerialQueueName, leeway: leeway)
   82|      0|    }
   83|       |    
   84|       |    /**
   85|       |    Schedules an action to be executed immediatelly.
   86|       |    
   87|       |    - parameter state: State passed to the action to be executed.
   88|       |    - parameter action: Action to be executed.
   89|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   90|       |    */
   91|    120|    public final func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   92|    120|        return self.scheduleInternal(state, action: action)
   93|    120|    }
   94|       |
   95|      0|    func scheduleInternal<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   96|      0|        return self.configuration.schedule(state, action: action)
   97|      0|    }
   98|       |
   99|       |    /**
  100|       |    Schedules an action to be executed.
  101|       |    
  102|       |    - parameter state: State passed to the action to be executed.
  103|       |    - parameter dueTime: Relative time after which to execute the action.
  104|       |    - parameter action: Action to be executed.
  105|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
  106|       |    */
  107|     14|    public final func scheduleRelative<StateType>(_ state: StateType, dueTime: Foundation.TimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
  108|     14|        return self.configuration.scheduleRelative(state, dueTime: dueTime, action: action)
  109|     14|    }
  110|       |    
  111|       |    /**
  112|       |    Schedules a periodic piece of work.
  113|       |    
  114|       |    - parameter state: State passed to the action to be executed.
  115|       |    - parameter startAfter: Period after which initial work should be run.
  116|       |    - parameter period: Period for running the work periodically.
  117|       |    - parameter action: Action to be executed.
  118|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
  119|       |    */
  120|      0|    public func schedulePeriodic<StateType>(_ state: StateType, startAfter: TimeInterval, period: TimeInterval, action: @escaping (StateType) -> StateType) -> Disposable {
  121|      0|        return self.configuration.schedulePeriodic(state, startAfter: startAfter, period: period, action: action)
  122|      0|    }
  123|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/VirtualTimeConverterType.swift:
    1|       |//
    2|       |//  VirtualTimeConverterType.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Parametrization for virtual time used by `VirtualTimeScheduler`s.
   10|       |public protocol VirtualTimeConverterType {
   11|       |    /// Virtual time unit used that represents ticks of virtual clock.
   12|       |    associatedtype VirtualTimeUnit
   13|       |
   14|       |    /// Virtual time unit used to represent differences of virtual times.
   15|       |    associatedtype VirtualTimeIntervalUnit
   16|       |
   17|       |    /**
   18|       |     Converts virtual time to real time.
   19|       |     
   20|       |     - parameter virtualTime: Virtual time to convert to `Date`.
   21|       |     - returns: `Date` corresponding to virtual time.
   22|       |    */
   23|       |    func convertFromVirtualTime(_ virtualTime: VirtualTimeUnit) -> RxTime
   24|       |
   25|       |    /**
   26|       |     Converts real time to virtual time.
   27|       |     
   28|       |     - parameter time: `Date` to convert to virtual time.
   29|       |     - returns: Virtual time corresponding to `Date`.
   30|       |    */
   31|       |    func convertToVirtualTime(_ time: RxTime) -> VirtualTimeUnit
   32|       |
   33|       |    /**
   34|       |     Converts from virtual time interval to `NSTimeInterval`.
   35|       |     
   36|       |     - parameter virtualTimeInterval: Virtual time interval to convert to `NSTimeInterval`.
   37|       |     - returns: `NSTimeInterval` corresponding to virtual time interval.
   38|       |    */
   39|       |    func convertFromVirtualTimeInterval(_ virtualTimeInterval: VirtualTimeIntervalUnit) -> RxTimeInterval
   40|       |
   41|       |    /**
   42|       |     Converts from virtual time interval to `NSTimeInterval`.
   43|       |     
   44|       |     - parameter timeInterval: `NSTimeInterval` to convert to virtual time interval.
   45|       |     - returns: Virtual time interval corresponding to time interval.
   46|       |    */
   47|       |    func convertToVirtualTimeInterval(_ timeInterval: RxTimeInterval) -> VirtualTimeIntervalUnit
   48|       |
   49|       |    /**
   50|       |     Offsets virtual time by virtual time interval.
   51|       |     
   52|       |     - parameter time: Virtual time.
   53|       |     - parameter offset: Virtual time interval.
   54|       |     - returns: Time corresponding to time offsetted by virtual time interval.
   55|       |    */
   56|       |    func offsetVirtualTime(_ time: VirtualTimeUnit, offset: VirtualTimeIntervalUnit) -> VirtualTimeUnit
   57|       |
   58|       |    /**
   59|       |     This is aditional abstraction because `Date` is unfortunately not comparable.
   60|       |     Extending `Date` with `Comparable` would be too risky because of possible collisions with other libraries.
   61|       |    */
   62|       |    func compareVirtualTime(_ lhs: VirtualTimeUnit, _ rhs: VirtualTimeUnit) -> VirtualTimeComparison
   63|       |}
   64|       |
   65|       |/**
   66|       | Virtual time comparison result.
   67|       |
   68|       | This is aditional abstraction because `Date` is unfortunately not comparable.
   69|       | Extending `Date` with `Comparable` would be too risky because of possible collisions with other libraries.
   70|       |*/
   71|       |public enum VirtualTimeComparison {
   72|       |    /// lhs < rhs.
   73|       |    case lessThan
   74|       |    /// lhs == rhs.
   75|       |    case equal
   76|       |    /// lhs > rhs.
   77|       |    case greaterThan
   78|       |}
   79|       |
   80|       |extension VirtualTimeComparison {
   81|       |    /// lhs < rhs.
   82|      0|    var lessThen: Bool {
   83|      0|        return self == .lessThan
   84|      0|    }
   85|       |
   86|       |    /// lhs > rhs
   87|      1|    var greaterThan: Bool {
   88|      1|        return self == .greaterThan
   89|      1|    }
   90|       |
   91|       |    /// lhs == rhs
   92|      0|    var equal: Bool {
   93|      0|        return self == .equal
   94|      0|    }
   95|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Schedulers/VirtualTimeScheduler.swift:
    1|       |//
    2|       |//  VirtualTimeScheduler.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Base class for virtual time schedulers using a priority queue for scheduled items.
   10|       |open class VirtualTimeScheduler<Converter: VirtualTimeConverterType>
   11|       |    : SchedulerType {
   12|       |
   13|       |    public typealias VirtualTime = Converter.VirtualTimeUnit
   14|       |    public typealias VirtualTimeInterval = Converter.VirtualTimeIntervalUnit
   15|       |
   16|       |    private var _running : Bool
   17|       |
   18|       |    private var _clock: VirtualTime
   19|       |
   20|       |    fileprivate var _schedulerQueue : PriorityQueue<VirtualSchedulerItem<VirtualTime>>
   21|       |    private var _converter: Converter
   22|       |
   23|       |    private var _nextId = 0
   24|       |
   25|       |    /// - returns: Current time.
   26|      0|    public var now: RxTime {
   27|      0|        return _converter.convertFromVirtualTime(clock)
   28|      0|    }
   29|       |
   30|       |    /// - returns: Scheduler's absolute time clock value.
   31|      3|    public var clock: VirtualTime {
   32|      3|        return _clock
   33|      3|    }
   34|       |
   35|       |    /// Creates a new virtual time scheduler.
   36|       |    ///
   37|       |    /// - parameter initialClock: Initial value for the clock.
   38|      7|    public init(initialClock: VirtualTime, converter: Converter) {
   39|      7|        _clock = initialClock
   40|      7|        _running = false
   41|      7|        _converter = converter
   42|      0|        _schedulerQueue = PriorityQueue(hasHigherPriority: {
   43|      0|            switch converter.compareVirtualTime($0.time, $1.time) {
   44|      0|            case .lessThan:
   45|      0|                return true
   46|      0|            case .equal:
   47|      0|                return $0.id < $1.id
   48|      0|            case .greaterThan:
   49|      0|                return false
   50|      0|            }
   51|      1|        }, isEqual: { $0 === $1 })
   52|      7|        #if TRACE_RESOURCES
   53|      7|            let _ = Resources.incrementTotal()
   54|      7|        #endif
   55|      7|    }
   56|       |
   57|       |    /**
   58|       |    Schedules an action to be executed immediatelly.
   59|       |
   60|       |    - parameter state: State passed to the action to be executed.
   61|       |    - parameter action: Action to be executed.
   62|       |    - returns: The disposable object used to cancel the scheduled action (best effort).
   63|       |    */
   64|      0|    public func schedule<StateType>(_ state: StateType, action: @escaping (StateType) -> Disposable) -> Disposable {
   65|      0|        return self.scheduleRelative(state, dueTime: 0.0) { a in
   66|      0|            return action(a)
   67|      0|        }
   68|      0|    }
   69|       |
   70|       |    /**
   71|       |     Schedules an action to be executed.
   72|       |
   73|       |     - parameter state: State passed to the action to be executed.
   74|       |     - parameter dueTime: Relative time after which to execute the action.
   75|       |     - parameter action: Action to be executed.
   76|       |     - returns: The disposable object used to cancel the scheduled action (best effort).
   77|       |     */
   78|      0|    public func scheduleRelative<StateType>(_ state: StateType, dueTime: RxTimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   79|      0|        let time = self.now.addingTimeInterval(dueTime)
   80|      0|        let absoluteTime = _converter.convertToVirtualTime(time)
   81|      0|        let adjustedTime = self.adjustScheduledTime(absoluteTime)
   82|      0|        return scheduleAbsoluteVirtual(state, time: adjustedTime, action: action)
   83|      0|    }
   84|       |
   85|       |    /**
   86|       |     Schedules an action to be executed after relative time has passed.
   87|       |
   88|       |     - parameter state: State passed to the action to be executed.
   89|       |     - parameter time: Absolute time when to execute the action. If this is less or equal then `now`, `now + 1`  will be used.
   90|       |     - parameter action: Action to be executed.
   91|       |     - returns: The disposable object used to cancel the scheduled action (best effort).
   92|       |     */
   93|      0|    public func scheduleRelativeVirtual<StateType>(_ state: StateType, dueTime: VirtualTimeInterval, action: @escaping (StateType) -> Disposable) -> Disposable {
   94|      0|        let time = _converter.offsetVirtualTime(self.clock, offset: dueTime)
   95|      0|        return scheduleAbsoluteVirtual(state, time: time, action: action)
   96|      0|    }
   97|       |
   98|       |    /**
   99|       |     Schedules an action to be executed at absolute virtual time.
  100|       |
  101|       |     - parameter state: State passed to the action to be executed.
  102|       |     - parameter time: Absolute time when to execute the action.
  103|       |     - parameter action: Action to be executed.
  104|       |     - returns: The disposable object used to cancel the scheduled action (best effort).
  105|       |     */
  106|      1|    public func scheduleAbsoluteVirtual<StateType>(_ state: StateType, time: Converter.VirtualTimeUnit, action: @escaping (StateType) -> Disposable) -> Disposable {
  107|      1|        MainScheduler.ensureExecutingOnScheduler()
  108|      1|
  109|      1|        let compositeDisposable = CompositeDisposable()
  110|      1|
  111|      1|        let item = VirtualSchedulerItem(action: {
  112|      1|            let dispose = action(state)
  113|      1|            return dispose
  114|      1|        }, time: time, id: _nextId)
  115|      1|
  116|      1|        _nextId += 1
  117|      1|
  118|      1|        _schedulerQueue.enqueue(item)
  119|      1|        
  120|      1|        _ = compositeDisposable.insert(item)
  121|      1|        
  122|      1|        return compositeDisposable
  123|      1|    }
  124|       |
  125|       |    /// Adjusts time of scheduling before adding item to schedule queue.
  126|      0|    open func adjustScheduledTime(_ time: Converter.VirtualTimeUnit) -> Converter.VirtualTimeUnit {
  127|      0|        return time
  128|      0|    }
  129|       |
  130|       |    /// Starts the virtual time scheduler.
  131|      1|    public func start() {
  132|      1|        MainScheduler.ensureExecutingOnScheduler()
  133|      1|
  134|      0|        if _running {
  135|      0|            return
  136|      1|        }
  137|      1|
  138|      1|        _running = true
  139|      2|        repeat {
  140|      1|            guard let next = findNext() else {
  141|      1|                break
  142|      1|            }
  143|      1|
  144|      1|            if _converter.compareVirtualTime(next.time, self.clock).greaterThan  {
  145|      1|                _clock = next.time
  146|      1|            }
  147|      1|
  148|      1|            next.invoke()
  149|      1|            _schedulerQueue.remove(next)
  150|      1|        } while _running
  151|      0|
  152|      0|        _running = false
  153|      0|    }
  154|       |
  155|      2|    func findNext() -> VirtualSchedulerItem<VirtualTime>? {
  156|      1|        while let front = _schedulerQueue.peek() {
  157|      0|            if front.isDisposed {
  158|      0|                _schedulerQueue.remove(front)
  159|      0|                continue
  160|      1|            }
  161|      1|
  162|      1|            return front
  163|      1|        }
  164|      1|
  165|      1|        return nil
  166|      2|    }
  167|       |
  168|       |    /// Advances the scheduler's clock to the specified time, running all work till that point.
  169|       |    ///
  170|       |    /// - parameter virtualTime: Absolute time to advance the scheduler's clock to.
  171|      0|    public func advanceTo(_ virtualTime: VirtualTime) {
  172|      0|        MainScheduler.ensureExecutingOnScheduler()
  173|      0|
  174|      0|        if _running {
  175|      0|            fatalError("Scheduler is already running")
  176|      0|        }
  177|      0|
  178|      0|        _running = true
  179|      0|        repeat {
  180|      0|            guard let next = findNext() else {
  181|      0|                break
  182|      0|            }
  183|      0|
  184|      0|            if _converter.compareVirtualTime(next.time, virtualTime).greaterThan {
  185|      0|                break
  186|      0|            }
  187|      0|
  188|      0|            if _converter.compareVirtualTime(next.time, self.clock).greaterThan  {
  189|      0|                _clock = next.time
  190|      0|            }
  191|      0|
  192|      0|            next.invoke()
  193|      0|            _schedulerQueue.remove(next)
  194|      0|        } while _running
  195|      0|
  196|      0|        _clock = virtualTime
  197|      0|        _running = false
  198|      0|    }
  199|       |
  200|       |    /// Advances the scheduler's clock by the specified relative time.
  201|      0|    public func sleep(_ virtualInterval: VirtualTimeInterval) {
  202|      0|        MainScheduler.ensureExecutingOnScheduler()
  203|      0|
  204|      0|        let sleepTo = _converter.offsetVirtualTime(clock, offset: virtualInterval)
  205|      0|        if _converter.compareVirtualTime(sleepTo, clock).lessThen {
  206|      0|            fatalError("Can't sleep to past.")
  207|      0|        }
  208|      0|
  209|      0|        _clock = sleepTo
  210|      0|    }
  211|       |
  212|       |    /// Stops the virtual time scheduler.
  213|      0|    public func stop() {
  214|      0|        MainScheduler.ensureExecutingOnScheduler()
  215|      0|
  216|      0|        _running = false
  217|      0|    }
  218|       |
  219|       |    #if TRACE_RESOURCES
  220|       |        deinit {
  221|       |            _ = Resources.decrementTotal()
  222|       |        }
  223|       |    #endif
  224|       |}
  225|       |
  226|       |// MARK: description
  227|       |
  228|       |extension VirtualTimeScheduler: CustomDebugStringConvertible {
  229|       |    /// A textual representation of `self`, suitable for debugging.
  230|      0|    public var debugDescription: String {
  231|      0|        return self._schedulerQueue.debugDescription
  232|      0|    }
  233|       |}
  234|       |
  235|       |final class VirtualSchedulerItem<Time>
  236|       |    : Disposable {
  237|       |    typealias Action = () -> Disposable
  238|       |    
  239|       |    let action: Action
  240|       |    let time: Time
  241|       |    let id: Int
  242|       |
  243|      1|    var isDisposed: Bool {
  244|      1|        return disposable.isDisposed
  245|      1|    }
  246|       |    
  247|       |    var disposable = SingleAssignmentDisposable()
  248|       |    
  249|      1|    init(action: @escaping Action, time: Time, id: Int) {
  250|      1|        self.action = action
  251|      1|        self.time = time
  252|      1|        self.id = id
  253|      1|    }
  254|       |
  255|      1|    func invoke() {
  256|      1|         self.disposable.setDisposable(action())
  257|      1|    }
  258|       |    
  259|      0|    func dispose() {
  260|      0|        self.disposable.dispose()
  261|      0|    }
  262|       |}
  263|       |
  264|       |extension VirtualSchedulerItem
  265|       |    : CustomDebugStringConvertible {
  266|      0|    var debugDescription: String {
  267|      0|        return "\(time)"
  268|      0|    }
  269|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Subjects/AsyncSubject.swift:
    1|       |//
    2|       |//  AsyncSubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Victor Galán on 07/01/2017.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// An AsyncSubject emits the last value (and only the last value) emitted by the source Observable,
   10|       |/// and only after that source Observable completes.
   11|       |///
   12|       |/// (If the source Observable does not emit any values, the AsyncSubject also completes without emitting any values.)
   13|       |public final class AsyncSubject<Element>
   14|       |    : Observable<Element>
   15|       |    , SubjectType
   16|       |    , ObserverType
   17|       |    , SynchronizedUnsubscribeType {
   18|       |    public typealias SubjectObserverType = AsyncSubject<Element>
   19|       |
   20|       |    typealias Observers = AnyObserver<Element>.s
   21|       |    typealias DisposeKey = Observers.KeyType
   22|       |
   23|       |    /// Indicates whether the subject has any observers
   24|      0|    public var hasObservers: Bool {
   25|      0|        _lock.lock(); defer { _lock.unlock() }
   26|      0|        return _observers.count > 0
   27|      0|    }
   28|       |
   29|       |    let _lock = RecursiveLock()
   30|       |
   31|       |    // state
   32|       |    private var _observers = Observers()
   33|       |    private var _isStopped = false
   34|       |    private var _stoppedEvent = nil as Event<Element>? {
   35|      0|        didSet {
   36|      0|            _isStopped = _stoppedEvent != nil
   37|      0|        }
   38|       |    }
   39|       |    private var _lastElement: Element?
   40|       |
   41|       |    /// Creates a subject.
   42|      0|    public override init() {
   43|      0|        #if TRACE_RESOURCES
   44|      0|            _ = Resources.incrementTotal()
   45|      0|        #endif
   46|      0|        super.init()
   47|      0|    }
   48|       |
   49|       |    /// Notifies all subscribed observers about next event.
   50|       |    ///
   51|       |    /// - parameter event: Event to send to the observers.
   52|      0|    public func on(_ event: Event<E>) {
   53|      0|        let (observers, event) = _synchronized_on(event)
   54|      0|        switch event {
   55|      0|        case .next:
   56|      0|            dispatch(observers, event)
   57|      0|            dispatch(observers, .completed)
   58|      0|        case .completed:
   59|      0|            dispatch(observers, event)
   60|      0|        case .error:
   61|      0|            dispatch(observers, event)
   62|      0|        }
   63|      0|    }
   64|       |
   65|      0|    func _synchronized_on(_ event: Event<E>) -> (Observers, Event<E>) {
   66|      0|        _lock.lock(); defer { _lock.unlock() }
   67|      0|        if _isStopped {
   68|      0|            return (Observers(), .completed)
   69|      0|        }
   70|      0|
   71|      0|        switch event {
   72|      0|        case .next(let element):
   73|      0|            _lastElement = element
   74|      0|            return (Observers(), .completed)
   75|      0|        case .error:
   76|      0|            _stoppedEvent = event
   77|      0|
   78|      0|            let observers = _observers
   79|      0|            _observers.removeAll()
   80|      0|
   81|      0|            return (observers, event)
   82|      0|        case .completed:
   83|      0|
   84|      0|            let observers = _observers
   85|      0|            _observers.removeAll()
   86|      0|
   87|      0|            if let lastElement = _lastElement {
   88|      0|                _stoppedEvent = .next(lastElement)
   89|      0|                return (observers, .next(lastElement))
   90|      0|            }
   91|      0|            else {
   92|      0|                _stoppedEvent = event
   93|      0|                return (observers, .completed)
   94|      0|            }
   95|      0|        }
   96|      0|    }
   97|       |
   98|       |    /// Subscribes an observer to the subject.
   99|       |    ///
  100|       |    /// - parameter observer: Observer to subscribe to the subject.
  101|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from the subject.
  102|      0|    public override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  103|      0|        _lock.lock(); defer { _lock.unlock() }
  104|      0|        return _synchronized_subscribe(observer)
  105|      0|    }
  106|       |
  107|      0|    func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
  108|      0|        if let stoppedEvent = _stoppedEvent {
  109|      0|            switch stoppedEvent {
  110|      0|            case .next:
  111|      0|                observer.on(stoppedEvent)
  112|      0|                observer.on(.completed)
  113|      0|            case .completed:
  114|      0|                observer.on(stoppedEvent)
  115|      0|            case .error:
  116|      0|                observer.on(stoppedEvent)
  117|      0|            }
  118|      0|            return Disposables.create()
  119|      0|        }
  120|      0|
  121|      0|        let key = _observers.insert(observer.on)
  122|      0|
  123|      0|        return SubscriptionDisposable(owner: self, key: key)
  124|      0|    }
  125|       |
  126|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  127|      0|        _lock.lock(); defer { _lock.unlock() }
  128|      0|        _synchronized_unsubscribe(disposeKey)
  129|      0|    }
  130|       |    
  131|      0|    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  132|      0|        _ = _observers.removeKey(disposeKey)
  133|      0|    }
  134|       |    
  135|       |    /// Returns observer interface for subject.
  136|      0|    public func asObserver() -> AsyncSubject<Element> {
  137|      0|        return self
  138|      0|    }
  139|       |
  140|       |    #if TRACE_RESOURCES
  141|       |    deinit {
  142|       |        _ = Resources.decrementTotal()
  143|       |    }
  144|       |    #endif
  145|       |}
  146|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Subjects/BehaviorSubject.swift:
    1|       |//
    2|       |//  BehaviorSubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents a value that changes over time.
   10|       |///
   11|       |/// Observers can subscribe to the subject to receive the last (or initial) value and all subsequent notifications.
   12|       |public final class BehaviorSubject<Element>
   13|       |    : Observable<Element>
   14|       |    , SubjectType
   15|       |    , ObserverType
   16|       |    , SynchronizedUnsubscribeType
   17|       |    , Disposable {
   18|       |    public typealias SubjectObserverType = BehaviorSubject<Element>
   19|       |
   20|       |    typealias Observers = AnyObserver<Element>.s
   21|       |    typealias DisposeKey = Observers.KeyType
   22|       |    
   23|       |    /// Indicates whether the subject has any observers
   24|      0|    public var hasObservers: Bool {
   25|      0|        _lock.lock()
   26|      0|        let value = _observers.count > 0
   27|      0|        _lock.unlock()
   28|      0|        return value
   29|      0|    }
   30|       |    
   31|       |    let _lock = RecursiveLock()
   32|       |    
   33|       |    // state
   34|       |    private var _isDisposed = false
   35|       |    private var _element: Element
   36|       |    private var _observers = Observers()
   37|       |    private var _stoppedEvent: Event<Element>?
   38|       |
   39|       |    /// Indicates whether the subject has been disposed.
   40|      0|    public var isDisposed: Bool {
   41|      0|        return _isDisposed
   42|      0|    }
   43|       | 
   44|       |    /// Initializes a new instance of the subject that caches its last value and starts with the specified value.
   45|       |    ///
   46|       |    /// - parameter value: Initial value sent to observers when no other value has been received by the subject yet.
   47|    295|    public init(value: Element) {
   48|    295|        _element = value
   49|    295|
   50|    295|        #if TRACE_RESOURCES
   51|    295|            _ = Resources.incrementTotal()
   52|    295|        #endif
   53|    295|    }
   54|       |    
   55|       |    /// Gets the current value or throws an error.
   56|       |    ///
   57|       |    /// - returns: Latest value.
   58|      0|    public func value() throws -> Element {
   59|      0|        _lock.lock(); defer { _lock.unlock() } // {
   60|      0|            if _isDisposed {
   61|      0|                throw RxError.disposed(object: self)
   62|      0|            }
   63|      0|            
   64|      0|            if let error = _stoppedEvent?.error {
   65|      0|                // intentionally throw exception
   66|      0|                throw error
   67|      0|            }
   68|      0|            else {
   69|      0|                return _element
   70|      0|            }
   71|      0|        //}
   72|      0|    }
   73|       |    
   74|       |    /// Notifies all subscribed observers about next event.
   75|       |    ///
   76|       |    /// - parameter event: Event to send to the observers.
   77|    147|    public func on(_ event: Event<E>) {
   78|    147|        _lock.lock()
   79|    147|        dispatch(_synchronized_on(event), event)
   80|    147|        _lock.unlock()
   81|    147|    }
   82|       |
   83|    147|    func _synchronized_on(_ event: Event<E>) -> Observers {
   84|    147|        if _stoppedEvent != nil || _isDisposed {
   85|      0|            return Observers()
   86|    147|        }
   87|    147|        
   88|    147|        switch event {
   89|     89|        case .next(let element):
   90|     89|            _element = element
   91|     58|        case .error, .completed:
   92|     58|            _stoppedEvent = event
   93|    147|        }
   94|    147|        
   95|    147|        return _observers
   96|    147|    }
   97|       |    
   98|       |    /// Subscribes an observer to the subject.
   99|       |    ///
  100|       |    /// - parameter observer: Observer to subscribe to the subject.
  101|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from the subject.
  102|    127|    public override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  103|    127|        _lock.lock()
  104|    127|        let subscription = _synchronized_subscribe(observer)
  105|    127|        _lock.unlock()
  106|    127|        return subscription
  107|    127|    }
  108|       |
  109|    127|    func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
  110|      0|        if _isDisposed {
  111|      0|            observer.on(.error(RxError.disposed(object: self)))
  112|      0|            return Disposables.create()
  113|    127|        }
  114|    127|        
  115|      0|        if let stoppedEvent = _stoppedEvent {
  116|      0|            observer.on(stoppedEvent)
  117|      0|            return Disposables.create()
  118|    127|        }
  119|    127|        
  120|    127|        let key = _observers.insert(observer.on)
  121|    127|        observer.on(.next(_element))
  122|    127|    
  123|    127|        return SubscriptionDisposable(owner: self, key: key)
  124|    127|    }
  125|       |
  126|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  127|      0|        _lock.lock()
  128|      0|        _synchronized_unsubscribe(disposeKey)
  129|      0|        _lock.unlock()
  130|      0|    }
  131|       |
  132|      0|    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  133|      0|        if _isDisposed {
  134|      0|            return
  135|      0|        }
  136|      0|
  137|      0|        _ = _observers.removeKey(disposeKey)
  138|      0|    }
  139|       |
  140|       |    /// Returns observer interface for subject.
  141|      0|    public func asObserver() -> BehaviorSubject<Element> {
  142|      0|        return self
  143|      0|    }
  144|       |
  145|       |    /// Unsubscribe all observers and release resources.
  146|      0|    public func dispose() {
  147|      0|        _lock.lock()
  148|      0|        _isDisposed = true
  149|      0|        _observers.removeAll()
  150|      0|        _stoppedEvent = nil
  151|      0|        _lock.unlock()
  152|      0|    }
  153|       |
  154|       |    #if TRACE_RESOURCES
  155|       |        deinit {
  156|       |        _ = Resources.decrementTotal()
  157|       |        }
  158|       |    #endif
  159|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Subjects/PublishSubject.swift:
    1|       |//
    2|       |//  PublishSubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that is both an observable sequence as well as an observer.
   10|       |///
   11|       |/// Each notification is broadcasted to all subscribed observers.
   12|       |public final class PublishSubject<Element>
   13|       |    : Observable<Element>
   14|       |    , SubjectType
   15|       |    , Cancelable
   16|       |    , ObserverType
   17|       |    , SynchronizedUnsubscribeType {
   18|       |    public typealias SubjectObserverType = PublishSubject<Element>
   19|       |
   20|       |    typealias Observers = AnyObserver<Element>.s
   21|       |    typealias DisposeKey = Observers.KeyType
   22|       |    
   23|       |    /// Indicates whether the subject has any observers
   24|     42|    public var hasObservers: Bool {
   25|     42|        _lock.lock()
   26|     42|        let count = _observers.count > 0
   27|     42|        _lock.unlock()
   28|     42|        return count
   29|     42|    }
   30|       |    
   31|       |    private let _lock = RecursiveLock()
   32|       |    
   33|       |    // state
   34|       |    private var _isDisposed = false
   35|       |    private var _observers = Observers()
   36|       |    private var _stopped = false
   37|       |    private var _stoppedEvent = nil as Event<Element>?
   38|       |    
   39|       |    /// Indicates whether the subject has been isDisposed.
   40|      0|    public var isDisposed: Bool {
   41|      0|        return _isDisposed
   42|      0|    }
   43|       |    
   44|       |    /// Creates a subject.
   45|     81|    public override init() {
   46|     81|        super.init()
   47|     81|        #if TRACE_RESOURCES
   48|     81|            _ = Resources.incrementTotal()
   49|     81|        #endif
   50|     81|    }
   51|       |    
   52|       |    /// Notifies all subscribed observers about next event.
   53|       |    ///
   54|       |    /// - parameter event: Event to send to the observers.
   55|      0|    public func on(_ event: Event<Element>) {
   56|      0|        dispatch(_synchronized_on(event), event)
   57|      0|    }
   58|       |
   59|      0|    func _synchronized_on(_ event: Event<E>) -> Observers {
   60|      0|        _lock.lock(); defer { _lock.unlock() }
   61|      0|        switch event {
   62|      0|        case .next(_):
   63|      0|            if _isDisposed || _stopped {
   64|      0|                return Observers()
   65|      0|            }
   66|      0|            
   67|      0|            return _observers
   68|      0|        case .completed, .error:
   69|      0|            if _stoppedEvent == nil {
   70|      0|                _stoppedEvent = event
   71|      0|                _stopped = true
   72|      0|                let observers = _observers
   73|      0|                _observers.removeAll()
   74|      0|                return observers
   75|      0|            }
   76|      0|
   77|      0|            return Observers()
   78|      0|        }
   79|      0|    }
   80|       |    
   81|       |    /**
   82|       |    Subscribes an observer to the subject.
   83|       |    
   84|       |    - parameter observer: Observer to subscribe to the subject.
   85|       |    - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   86|       |    */
   87|     80|    public override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   88|     80|        _lock.lock()
   89|     80|        let subscription = _synchronized_subscribe(observer)
   90|     80|        _lock.unlock()
   91|     80|        return subscription
   92|     80|    }
   93|       |
   94|     80|    func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   95|      0|        if let stoppedEvent = _stoppedEvent {
   96|      0|            observer.on(stoppedEvent)
   97|      0|            return Disposables.create()
   98|     80|        }
   99|     80|        
  100|      0|        if _isDisposed {
  101|      0|            observer.on(.error(RxError.disposed(object: self)))
  102|      0|            return Disposables.create()
  103|     80|        }
  104|     80|        
  105|     80|        let key = _observers.insert(observer.on)
  106|     80|        return SubscriptionDisposable(owner: self, key: key)
  107|     80|    }
  108|       |
  109|      0|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  110|      0|        _lock.lock()
  111|      0|        _synchronized_unsubscribe(disposeKey)
  112|      0|        _lock.unlock()
  113|      0|    }
  114|       |
  115|      0|    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  116|      0|        _ = _observers.removeKey(disposeKey)
  117|      0|    }
  118|       |    
  119|       |    /// Returns observer interface for subject.
  120|     42|    public func asObserver() -> PublishSubject<Element> {
  121|     42|        return self
  122|     42|    }
  123|       |    
  124|       |    /// Unsubscribe all observers and release resources.
  125|      0|    public func dispose() {
  126|      0|        _lock.lock()
  127|      0|        _synchronized_dispose()
  128|      0|        _lock.unlock()
  129|      0|    }
  130|       |
  131|      0|    final func _synchronized_dispose() {
  132|      0|        _isDisposed = true
  133|      0|        _observers.removeAll()
  134|      0|        _stoppedEvent = nil
  135|      0|    }
  136|       |
  137|       |    #if TRACE_RESOURCES
  138|       |        deinit {
  139|       |            _ = Resources.decrementTotal()
  140|       |        }
  141|       |    #endif
  142|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Subjects/ReplaySubject.swift:
    1|       |//
    2|       |//  ReplaySubject.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Represents an object that is both an observable sequence as well as an observer.
   10|       |///
   11|       |/// Each notification is broadcasted to all subscribed and future observers, subject to buffer trimming policies.
   12|       |public class ReplaySubject<Element>
   13|       |    : Observable<Element>
   14|       |    , SubjectType
   15|       |    , ObserverType
   16|       |    , Disposable {
   17|       |    public typealias SubjectObserverType = ReplaySubject<Element>
   18|       |
   19|       |    typealias Observers = AnyObserver<Element>.s
   20|       |    typealias DisposeKey = Observers.KeyType
   21|       |
   22|       |    /// Indicates whether the subject has any observers
   23|      0|    public var hasObservers: Bool {
   24|      0|        _lock.lock()
   25|      0|        let value = _observers.count > 0
   26|      0|        _lock.unlock()
   27|      0|        return value
   28|      0|    }
   29|       |    
   30|       |    fileprivate let _lock = RecursiveLock()
   31|       |    
   32|       |    // state
   33|       |    fileprivate var _isDisposed = false
   34|       |    fileprivate var _isStopped = false
   35|       |    fileprivate var _stoppedEvent = nil as Event<Element>? {
   36|      0|        didSet {
   37|      0|            _isStopped = _stoppedEvent != nil
   38|      0|        }
   39|       |    }
   40|       |    fileprivate var _observers = Observers()
   41|       |
   42|      0|    func unsubscribe(_ key: DisposeKey) {
   43|      0|        rxAbstractMethod()
   44|      0|    }
   45|       |
   46|      0|    final var isStopped: Bool {
   47|      0|        return _isStopped
   48|      0|    }
   49|       |    
   50|       |    /// Notifies all subscribed observers about next event.
   51|       |    ///
   52|       |    /// - parameter event: Event to send to the observers.
   53|      0|    public func on(_ event: Event<E>) {
   54|      0|        rxAbstractMethod()
   55|      0|    }
   56|       |    
   57|       |    /// Returns observer interface for subject.
   58|      0|    public func asObserver() -> SubjectObserverType {
   59|      0|        return self
   60|      0|    }
   61|       |    
   62|       |    /// Unsubscribe all observers and release resources.
   63|      0|    public func dispose() {
   64|      0|    }
   65|       |
   66|       |    /// Creates new instance of `ReplaySubject` that replays at most `bufferSize` last elements of sequence.
   67|       |    ///
   68|       |    /// - parameter bufferSize: Maximal number of elements to replay to observer after subscription.
   69|       |    /// - returns: New instance of replay subject.
   70|    282|    public static func create(bufferSize: Int) -> ReplaySubject<Element> {
   71|    282|        if bufferSize == 1 {
   72|    282|            return ReplayOne()
   73|      0|        }
   74|      0|        else {
   75|      0|            return ReplayMany(bufferSize: bufferSize)
   76|      0|        }
   77|      0|    }
   78|       |
   79|       |    /// Creates a new instance of `ReplaySubject` that buffers all the elements of a sequence.
   80|       |    /// To avoid filling up memory, developer needs to make sure that the use case will only ever store a 'reasonable'
   81|       |    /// number of elements.
   82|      0|    public static func createUnbounded() -> ReplaySubject<Element> {
   83|      0|        return ReplayAll()
   84|      0|    }
   85|       |
   86|       |    #if TRACE_RESOURCES
   87|       |        override init() {
   88|       |            _ = Resources.incrementTotal()
   89|       |        }
   90|       |
   91|       |        deinit {
   92|       |            _ = Resources.decrementTotal()
   93|       |        }
   94|       |    #endif
   95|       |}
   96|       |
   97|       |fileprivate class ReplayBufferBase<Element>
   98|       |    : ReplaySubject<Element>
   99|       |    , SynchronizedUnsubscribeType {
  100|       |    
  101|      0|    func trim() {
  102|      0|        rxAbstractMethod()
  103|      0|    }
  104|       |    
  105|      0|    func addValueToBuffer(_ value: Element) {
  106|      0|        rxAbstractMethod()
  107|      0|    }
  108|       |    
  109|      0|    func replayBuffer<O: ObserverType>(_ observer: O) where O.E == Element {
  110|      0|        rxAbstractMethod()
  111|      0|    }
  112|       |    
  113|      0|    override func on(_ event: Event<Element>) {
  114|      0|        dispatch(_synchronized_on(event), event)
  115|      0|    }
  116|       |
  117|      0|    func _synchronized_on(_ event: Event<E>) -> Observers {
  118|      0|        _lock.lock(); defer { _lock.unlock() }
  119|      0|        if _isDisposed {
  120|      0|            return Observers()
  121|      0|        }
  122|      0|        
  123|      0|        if _isStopped {
  124|      0|            return Observers()
  125|      0|        }
  126|      0|        
  127|      0|        switch event {
  128|      0|        case .next(let element):
  129|      0|            addValueToBuffer(element)
  130|      0|            trim()
  131|      0|            return _observers
  132|      0|        case .error, .completed:
  133|      0|            _stoppedEvent = event
  134|      0|            trim()
  135|      0|            let observers = _observers
  136|      0|            _observers.removeAll()
  137|      0|            return observers
  138|      0|        }
  139|      0|    }
  140|       |    
  141|    374|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
  142|    374|        _lock.lock()
  143|    374|        let subscription = _synchronized_subscribe(observer)
  144|    374|        _lock.unlock()
  145|    374|        return subscription
  146|    374|    }
  147|       |
  148|    374|    func _synchronized_subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
  149|      0|        if _isDisposed {
  150|      0|            observer.on(.error(RxError.disposed(object: self)))
  151|      0|            return Disposables.create()
  152|    374|        }
  153|    374|     
  154|    374|        let anyObserver = observer.asObserver()
  155|    374|        
  156|    374|        replayBuffer(anyObserver)
  157|      0|        if let stoppedEvent = _stoppedEvent {
  158|      0|            observer.on(stoppedEvent)
  159|      0|            return Disposables.create()
  160|    374|        }
  161|    374|        else {
  162|    374|            let key = _observers.insert(observer.on)
  163|    374|            return SubscriptionDisposable(owner: self, key: key)
  164|      0|        }
  165|      0|    }
  166|       |
  167|      1|    func synchronizedUnsubscribe(_ disposeKey: DisposeKey) {
  168|      1|        _lock.lock()
  169|      1|        _synchronized_unsubscribe(disposeKey)
  170|      1|        _lock.unlock()
  171|      1|    }
  172|       |
  173|      1|    func _synchronized_unsubscribe(_ disposeKey: DisposeKey) {
  174|      0|        if _isDisposed {
  175|      0|            return
  176|      1|        }
  177|      1|        
  178|      1|        _ = _observers.removeKey(disposeKey)
  179|      1|    }
  180|       |    
  181|      0|    override func dispose() {
  182|      0|        super.dispose()
  183|      0|
  184|      0|        synchronizedDispose()
  185|      0|    }
  186|       |
  187|      0|    func synchronizedDispose() {
  188|      0|        _lock.lock()
  189|      0|        _synchronized_dispose()
  190|      0|        _lock.unlock()
  191|      0|    }
  192|       |
  193|      0|    func _synchronized_dispose() {
  194|      0|        _isDisposed = true
  195|      0|        _observers.removeAll()
  196|      0|    }
  197|       |}
  198|       |
  199|       |final class ReplayOne<Element> : ReplayBufferBase<Element> {
  200|       |    private var _value: Element?
  201|       |    
  202|    282|    override init() {
  203|    282|        super.init()
  204|    282|    }
  205|       |    
  206|      0|    override func trim() {
  207|      0|        
  208|      0|    }
  209|       |    
  210|      0|    override func addValueToBuffer(_ value: Element) {
  211|      0|        _value = value
  212|      0|    }
  213|       |
  214|    374|    override func replayBuffer<O: ObserverType>(_ observer: O) where O.E == Element {
  215|      0|        if let value = _value {
  216|      0|            observer.on(.next(value))
  217|    374|        }
  218|    374|    }
  219|       |
  220|      0|    override func _synchronized_dispose() {
  221|      0|        super._synchronized_dispose()
  222|      0|        _value = nil
  223|      0|    }
  224|       |}
  225|       |
  226|       |class ReplayManyBase<Element> : ReplayBufferBase<Element> {
  227|       |    fileprivate var _queue: Queue<Element>
  228|       |    
  229|      0|    init(queueSize: Int) {
  230|      0|        _queue = Queue(capacity: queueSize + 1)
  231|      0|    }
  232|       |    
  233|      0|    override func addValueToBuffer(_ value: Element) {
  234|      0|        _queue.enqueue(value)
  235|      0|    }
  236|       |
  237|      0|    override func replayBuffer<O: ObserverType>(_ observer: O) where O.E == Element {
  238|      0|        for item in _queue {
  239|      0|            observer.on(.next(item))
  240|      0|        }
  241|      0|    }
  242|       |
  243|      0|    override func _synchronized_dispose() {
  244|      0|        super._synchronized_dispose()
  245|      0|        _queue = Queue(capacity: 0)
  246|      0|    }
  247|       |}
  248|       |
  249|       |final class ReplayMany<Element> : ReplayManyBase<Element> {
  250|       |    private let _bufferSize: Int
  251|       |    
  252|      0|    init(bufferSize: Int) {
  253|      0|        _bufferSize = bufferSize
  254|      0|        
  255|      0|        super.init(queueSize: bufferSize)
  256|      0|    }
  257|       |    
  258|      0|    override func trim() {
  259|      0|        while _queue.count > _bufferSize {
  260|      0|            _ = _queue.dequeue()
  261|      0|        }
  262|      0|    }
  263|       |}
  264|       |
  265|       |final class ReplayAll<Element> : ReplayManyBase<Element> {
  266|      0|    init() {
  267|      0|        super.init(queueSize: 0)
  268|      0|    }
  269|       |    
  270|      0|    override func trim() {
  271|      0|        
  272|      0|    }
  273|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Subjects/Variable.swift:
    1|       |//
    2|       |//  Variable.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Variable is a wrapper for `BehaviorSubject`.
   10|       |///
   11|       |/// Unlike `BehaviorSubject` it can't terminate with error, and when variable is deallocated
   12|       |/// it will complete its observable sequence (`asObservable`).
   13|       |public final class Variable<Element> {
   14|       |
   15|       |    public typealias E = Element
   16|       |    
   17|       |    private let _subject: BehaviorSubject<Element>
   18|       |    
   19|       |    private var _lock = SpinLock()
   20|       | 
   21|       |    // state
   22|       |    private var _value: E
   23|       |
   24|       |    #if DEBUG
   25|       |        fileprivate var _numberOfConcurrentCalls: AtomicInt = 0
   26|       |    #endif
   27|       |
   28|       |    /// Gets or sets current value of variable.
   29|       |    ///
   30|       |    /// Whenever a new value is set, all the observers are notified of the change.
   31|       |    ///
   32|       |    /// Even if the newly set value is same as the old value, observers are still notified for change.
   33|       |    public var value: E {
   34|     23|        get {
   35|     23|            _lock.lock(); defer { _lock.unlock() }
   36|     23|            return _value
   37|     23|        }
   38|     89|        set(newValue) {
   39|     89|            #if DEBUG
   40|      0|                if AtomicIncrement(&_numberOfConcurrentCalls) > 1 {
   41|      0|                    rxFatalError("Warning: Recursive call or synchronization error!")
   42|     89|                }
   43|     89|
   44|     89|                defer {
   45|     89|                    _ = AtomicDecrement(&_numberOfConcurrentCalls)
   46|     89|                }
   47|     89|            #endif
   48|     89|            _lock.lock()
   49|     89|            _value = newValue
   50|     89|            _lock.unlock()
   51|     89|
   52|     89|            _subject.on(.next(newValue))
   53|     89|        }
   54|       |    }
   55|       |    
   56|       |    /// Initializes variable with initial value.
   57|       |    ///
   58|       |    /// - parameter value: Initial variable value.
   59|    295|    public init(_ value: Element) {
   60|    295|        _value = value
   61|    295|        _subject = BehaviorSubject(value: value)
   62|    295|    }
   63|       |    
   64|       |    /// - returns: Canonical interface for push style sequence
   65|    127|    public func asObservable() -> Observable<E> {
   66|    127|        return _subject
   67|    127|    }
   68|       |
   69|     58|    deinit {
   70|     58|        _subject.on(.completed)
   71|     58|    }
   72|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Traits/PrimitiveSequence+Zip+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  PrimitiveSequence+Zip+arity.swift
    4|       |//  RxSwift
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 5/23/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |
   11|       |
   12|       |// 2
   13|       |
   14|       |extension PrimitiveSequenceType {
   15|       |    /**
   16|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   17|       |
   18|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   19|       |
   20|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   21|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   22|       |    */
   23|       |    public static func zip<E1, E2>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, resultSelector: @escaping (E1, E2) throws -> ElementType)
   24|      0|        -> PrimitiveSequence<TraitType, ElementType> {
   25|      0|            return PrimitiveSequence(raw: Observable.zip(
   26|      0|            source1.asObservable(), source2.asObservable(),
   27|      0|                resultSelector: resultSelector)
   28|      0|            )
   29|      0|    }
   30|       |}
   31|       |
   32|       |extension PrimitiveSequenceType where ElementType == Any {
   33|       |    /**
   34|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
   35|       |
   36|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   37|       |
   38|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   39|       |    */
   40|       |    public static func zip<E1, E2>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>)
   41|      0|        -> PrimitiveSequence<TraitType, (E1, E2)> {
   42|      0|        return PrimitiveSequence(raw: Observable.zip(
   43|      0|                source1.asObservable(), source2.asObservable())
   44|      0|            )
   45|      0|    }
   46|       |}
   47|       |
   48|       |
   49|       |
   50|       |// 3
   51|       |
   52|       |extension PrimitiveSequenceType {
   53|       |    /**
   54|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   55|       |
   56|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   57|       |
   58|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   59|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   60|       |    */
   61|       |    public static func zip<E1, E2, E3>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, resultSelector: @escaping (E1, E2, E3) throws -> ElementType)
   62|      0|        -> PrimitiveSequence<TraitType, ElementType> {
   63|      0|            return PrimitiveSequence(raw: Observable.zip(
   64|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(),
   65|      0|                resultSelector: resultSelector)
   66|      0|            )
   67|      0|    }
   68|       |}
   69|       |
   70|       |extension PrimitiveSequenceType where ElementType == Any {
   71|       |    /**
   72|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
   73|       |
   74|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   75|       |
   76|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   77|       |    */
   78|       |    public static func zip<E1, E2, E3>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>)
   79|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3)> {
   80|      0|        return PrimitiveSequence(raw: Observable.zip(
   81|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable())
   82|      0|            )
   83|      0|    }
   84|       |}
   85|       |
   86|       |
   87|       |
   88|       |// 4
   89|       |
   90|       |extension PrimitiveSequenceType {
   91|       |    /**
   92|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   93|       |
   94|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
   95|       |
   96|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   97|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   98|       |    */
   99|       |    public static func zip<E1, E2, E3, E4>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, resultSelector: @escaping (E1, E2, E3, E4) throws -> ElementType)
  100|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  101|      0|            return PrimitiveSequence(raw: Observable.zip(
  102|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(),
  103|      0|                resultSelector: resultSelector)
  104|      0|            )
  105|      0|    }
  106|       |}
  107|       |
  108|       |extension PrimitiveSequenceType where ElementType == Any {
  109|       |    /**
  110|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  111|       |
  112|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  113|       |
  114|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  115|       |    */
  116|       |    public static func zip<E1, E2, E3, E4>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>)
  117|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4)> {
  118|      0|        return PrimitiveSequence(raw: Observable.zip(
  119|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable())
  120|      0|            )
  121|      0|    }
  122|       |}
  123|       |
  124|       |
  125|       |
  126|       |// 5
  127|       |
  128|       |extension PrimitiveSequenceType {
  129|       |    /**
  130|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  131|       |
  132|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  133|       |
  134|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  135|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  136|       |    */
  137|       |    public static func zip<E1, E2, E3, E4, E5>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, resultSelector: @escaping (E1, E2, E3, E4, E5) throws -> ElementType)
  138|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  139|      0|            return PrimitiveSequence(raw: Observable.zip(
  140|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(),
  141|      0|                resultSelector: resultSelector)
  142|      0|            )
  143|      0|    }
  144|       |}
  145|       |
  146|       |extension PrimitiveSequenceType where ElementType == Any {
  147|       |    /**
  148|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  149|       |
  150|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  151|       |
  152|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  153|       |    */
  154|       |    public static func zip<E1, E2, E3, E4, E5>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>)
  155|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5)> {
  156|      0|        return PrimitiveSequence(raw: Observable.zip(
  157|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable())
  158|      0|            )
  159|      0|    }
  160|       |}
  161|       |
  162|       |
  163|       |
  164|       |// 6
  165|       |
  166|       |extension PrimitiveSequenceType {
  167|       |    /**
  168|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  169|       |
  170|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  171|       |
  172|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  173|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  174|       |    */
  175|       |    public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6) throws -> ElementType)
  176|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  177|      0|            return PrimitiveSequence(raw: Observable.zip(
  178|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(),
  179|      0|                resultSelector: resultSelector)
  180|      0|            )
  181|      0|    }
  182|       |}
  183|       |
  184|       |extension PrimitiveSequenceType where ElementType == Any {
  185|       |    /**
  186|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  187|       |
  188|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  189|       |
  190|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  191|       |    */
  192|       |    public static func zip<E1, E2, E3, E4, E5, E6>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>)
  193|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6)> {
  194|      0|        return PrimitiveSequence(raw: Observable.zip(
  195|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable())
  196|      0|            )
  197|      0|    }
  198|       |}
  199|       |
  200|       |
  201|       |
  202|       |// 7
  203|       |
  204|       |extension PrimitiveSequenceType {
  205|       |    /**
  206|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  207|       |
  208|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  209|       |
  210|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  211|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  212|       |    */
  213|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7) throws -> ElementType)
  214|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  215|      0|            return PrimitiveSequence(raw: Observable.zip(
  216|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(),
  217|      0|                resultSelector: resultSelector)
  218|      0|            )
  219|      0|    }
  220|       |}
  221|       |
  222|       |extension PrimitiveSequenceType where ElementType == Any {
  223|       |    /**
  224|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  225|       |
  226|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  227|       |
  228|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  229|       |    */
  230|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>)
  231|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6, E7)> {
  232|      0|        return PrimitiveSequence(raw: Observable.zip(
  233|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable())
  234|      0|            )
  235|      0|    }
  236|       |}
  237|       |
  238|       |
  239|       |
  240|       |// 8
  241|       |
  242|       |extension PrimitiveSequenceType {
  243|       |    /**
  244|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  245|       |
  246|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  247|       |
  248|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  249|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  250|       |    */
  251|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, _ source8: PrimitiveSequence<TraitType, E8>, resultSelector: @escaping (E1, E2, E3, E4, E5, E6, E7, E8) throws -> ElementType)
  252|      0|        -> PrimitiveSequence<TraitType, ElementType> {
  253|      0|            return PrimitiveSequence(raw: Observable.zip(
  254|      0|            source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(), source8.asObservable(),
  255|      0|                resultSelector: resultSelector)
  256|      0|            )
  257|      0|    }
  258|       |}
  259|       |
  260|       |extension PrimitiveSequenceType where ElementType == Any {
  261|       |    /**
  262|       |    Merges the specified observable sequences into one observable sequence of tuples whenever all of the observable sequences have produced an element at a corresponding index.
  263|       |
  264|       |    - seealso: [zip operator on reactivex.io](http://reactivex.io/documentation/operators/zip.html)
  265|       |
  266|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  267|       |    */
  268|       |    public static func zip<E1, E2, E3, E4, E5, E6, E7, E8>(_ source1: PrimitiveSequence<TraitType, E1>, _ source2: PrimitiveSequence<TraitType, E2>, _ source3: PrimitiveSequence<TraitType, E3>, _ source4: PrimitiveSequence<TraitType, E4>, _ source5: PrimitiveSequence<TraitType, E5>, _ source6: PrimitiveSequence<TraitType, E6>, _ source7: PrimitiveSequence<TraitType, E7>, _ source8: PrimitiveSequence<TraitType, E8>)
  269|      0|        -> PrimitiveSequence<TraitType, (E1, E2, E3, E4, E5, E6, E7, E8)> {
  270|      0|        return PrimitiveSequence(raw: Observable.zip(
  271|      0|                source1.asObservable(), source2.asObservable(), source3.asObservable(), source4.asObservable(), source5.asObservable(), source6.asObservable(), source7.asObservable(), source8.asObservable())
  272|      0|            )
  273|      0|    }
  274|       |}
  275|       |
  276|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxSwift/RxSwift/Traits/PrimitiveSequence.swift:
    1|       |//
    2|       |//  PrimitiveSequence.swift
    3|       |//  RxSwift
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/5/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Observable sequences containing 0 or 1 element.
   10|       |public struct PrimitiveSequence<Trait, Element> {
   11|       |    fileprivate let source: Observable<Element>
   12|       |
   13|      0|    init(raw: Observable<Element>) {
   14|      0|        self.source = raw
   15|      0|    }
   16|       |}
   17|       |
   18|       |/// Sequence containing exactly 1 element
   19|       |public enum SingleTrait { }
   20|       |/// Represents a push style sequence containing 1 element.
   21|       |public typealias Single<Element> = PrimitiveSequence<SingleTrait, Element>
   22|       |
   23|       |/// Sequence containing 0 or 1 elements
   24|       |public enum MaybeTrait { }
   25|       |/// Represents a push style sequence containing 0 or 1 element.
   26|       |public typealias Maybe<Element> = PrimitiveSequence<MaybeTrait, Element>
   27|       |
   28|       |/// Sequence containing 0 elements
   29|       |public enum CompletableTrait { }
   30|       |/// Represents a push style sequence containing 0 elements.
   31|       |public typealias Completable = PrimitiveSequence<CompletableTrait, Swift.Never>
   32|       |
   33|       |/// Observable sequences containing 0 or 1 element
   34|       |public protocol PrimitiveSequenceType {
   35|       |    /// Additional constraints
   36|       |    associatedtype TraitType
   37|       |    /// Sequence element type
   38|       |    associatedtype ElementType
   39|       |
   40|       |    // Converts `self` to primitive sequence.
   41|       |    ///
   42|       |    /// - returns: Observable sequence that represents `self`.
   43|       |    var primitiveSequence: PrimitiveSequence<TraitType, ElementType> { get }
   44|       |}
   45|       |
   46|       |extension PrimitiveSequence: PrimitiveSequenceType {
   47|       |    /// Additional constraints
   48|       |    public typealias TraitType = Trait
   49|       |    /// Sequence element type
   50|       |    public typealias ElementType = Element
   51|       |
   52|       |    // Converts `self` to primitive sequence.
   53|       |    ///
   54|       |    /// - returns: Observable sequence that represents `self`.
   55|      0|    public var primitiveSequence: PrimitiveSequence<TraitType, ElementType> {
   56|      0|        return self
   57|      0|    }
   58|       |}
   59|       |
   60|       |extension PrimitiveSequence: ObservableConvertibleType {
   61|       |    /// Type of elements in sequence.
   62|       |    public typealias E = Element
   63|       |
   64|       |    /// Converts `self` to `Observable` sequence.
   65|       |    ///
   66|       |    /// - returns: Observable sequence that represents `self`.
   67|      0|    public func asObservable() -> Observable<E> {
   68|      0|        return source
   69|      0|    }
   70|       |}
   71|       |
   72|       |// <Single>
   73|       |
   74|       |public enum SingleEvent<Element> {
   75|       |    /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)
   76|       |    case success(Element)
   77|       |
   78|       |    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
   79|       |    case error(Swift.Error)
   80|       |}
   81|       |
   82|       |extension PrimitiveSequenceType where TraitType == SingleTrait {
   83|       |    public typealias SingleObserver = (SingleEvent<ElementType>) -> ()
   84|       |
   85|       |    /**
   86|       |     Creates an observable sequence from a specified subscribe method implementation.
   87|       |
   88|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
   89|       |
   90|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
   91|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
   92|       |     */
   93|      0|    public static func create(subscribe: @escaping (@escaping SingleObserver) -> Disposable) -> PrimitiveSequence<TraitType, ElementType> {
   94|      0|        let source = Observable<ElementType>.create { observer in
   95|      0|            return subscribe { event in
   96|      0|                switch event {
   97|      0|                case .success(let element):
   98|      0|                    observer.on(.next(element))
   99|      0|                    observer.on(.completed)
  100|      0|                case .error(let error):
  101|      0|                    observer.on(.error(error))
  102|      0|                }
  103|      0|            }
  104|      0|        }
  105|      0|
  106|      0|        return PrimitiveSequence(raw: source)
  107|      0|    }
  108|       |
  109|       |
  110|       |    /**
  111|       |     Subscribes `observer` to receive events for this sequence.
  112|       |
  113|       |     - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
  114|       |     */
  115|      0|    public func subscribe(_ observer: @escaping (SingleEvent<ElementType>) -> ()) -> Disposable {
  116|      0|        var stopped = false
  117|      0|        return self.primitiveSequence.asObservable().subscribe { event in
  118|      0|            if stopped { return }
  119|      0|            stopped = true
  120|      0|
  121|      0|            switch event {
  122|      0|            case .next(let element):
  123|      0|                observer(.success(element))
  124|      0|            case .error(let error):
  125|      0|                observer(.error(error))
  126|      0|            case .completed:
  127|      0|                rxFatalError("Singles can't emit a completion event")
  128|      0|            }
  129|      0|        }
  130|      0|    }
  131|       |
  132|       |    /**
  133|       |     Subscribes a success handler, and an error handler for this sequence.
  134|       |
  135|       |     - parameter onSuccess: Action to invoke for each element in the observable sequence.
  136|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  137|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
  138|       |     */
  139|      0|    public func subscribe(onSuccess: ((ElementType) -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil) -> Disposable {
  140|      0|        return self.primitiveSequence.subscribe { event in
  141|      0|            switch event {
  142|      0|            case .success(let element):
  143|      0|                onSuccess?(element)
  144|      0|            case .error(let error):
  145|      0|                onError?(error)
  146|      0|            }
  147|      0|        }
  148|      0|    }
  149|       |}
  150|       |
  151|       |// </Single>
  152|       |
  153|       |// <Maybe>
  154|       |
  155|       |public enum MaybeEvent<Element> {
  156|       |    /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)
  157|       |    case success(Element)
  158|       |
  159|       |    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
  160|       |    case error(Swift.Error)
  161|       |
  162|       |    /// Sequence completed successfully.
  163|       |    case completed
  164|       |}
  165|       |
  166|       |public extension PrimitiveSequenceType where TraitType == MaybeTrait {
  167|       |    public typealias MaybeObserver = (MaybeEvent<ElementType>) -> ()
  168|       |
  169|       |    /**
  170|       |     Creates an observable sequence from a specified subscribe method implementation.
  171|       |
  172|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
  173|       |
  174|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
  175|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
  176|       |     */
  177|      0|    public static func create(subscribe: @escaping (@escaping MaybeObserver) -> Disposable) -> PrimitiveSequence<TraitType, ElementType> {
  178|      0|        let source = Observable<ElementType>.create { observer in
  179|      0|            return subscribe { event in
  180|      0|                switch event {
  181|      0|                case .success(let element):
  182|      0|                    observer.on(.next(element))
  183|      0|                    observer.on(.completed)
  184|      0|                case .error(let error):
  185|      0|                    observer.on(.error(error))
  186|      0|                case .completed:
  187|      0|                    observer.on(.completed)
  188|      0|                }
  189|      0|            }
  190|      0|        }
  191|      0|
  192|      0|        return PrimitiveSequence(raw: source)
  193|      0|    }
  194|       |
  195|       |    /**
  196|       |     Subscribes `observer` to receive events for this sequence.
  197|       |
  198|       |     - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
  199|       |     */
  200|      0|    public func subscribe(_ observer: @escaping (MaybeEvent<ElementType>) -> ()) -> Disposable {
  201|      0|        var stopped = false
  202|      0|        return self.primitiveSequence.asObservable().subscribe { event in
  203|      0|            if stopped { return }
  204|      0|            stopped = true
  205|      0|
  206|      0|            switch event {
  207|      0|            case .next(let element):
  208|      0|                observer(.success(element))
  209|      0|            case .error(let error):
  210|      0|                observer(.error(error))
  211|      0|            case .completed:
  212|      0|                observer(.completed)
  213|      0|            }
  214|      0|        }
  215|      0|    }
  216|       |
  217|       |    /**
  218|       |     Subscribes a success handler, an error handler, and a completion handler for this sequence.
  219|       |
  220|       |     - parameter onSuccess: Action to invoke for each element in the observable sequence.
  221|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  222|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  223|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
  224|       |     */
  225|      0|    public func subscribe(onSuccess: ((ElementType) -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil, onCompleted: (() -> Void)? = nil) -> Disposable {
  226|      0|        return self.primitiveSequence.subscribe { event in
  227|      0|            switch event {
  228|      0|            case .success(let element):
  229|      0|                onSuccess?(element)
  230|      0|            case .error(let error):
  231|      0|                onError?(error)
  232|      0|            case .completed:
  233|      0|                onCompleted?()
  234|      0|            }
  235|      0|        }
  236|      0|    }
  237|       |}
  238|       |
  239|       |// </Maybe>
  240|       |
  241|       |// <Completable>
  242|       |
  243|       |public enum CompletableEvent {
  244|       |    /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)
  245|       |    case error(Swift.Error)
  246|       |
  247|       |    /// Sequence completed successfully.
  248|       |    case completed
  249|       |}
  250|       |
  251|       |public extension PrimitiveSequenceType where TraitType == CompletableTrait, ElementType == Swift.Never {
  252|       |    public typealias CompletableObserver = (CompletableEvent) -> ()
  253|       |
  254|       |    /**
  255|       |     Creates an observable sequence from a specified subscribe method implementation.
  256|       |
  257|       |     - seealso: [create operator on reactivex.io](http://reactivex.io/documentation/operators/create.html)
  258|       |
  259|       |     - parameter subscribe: Implementation of the resulting observable sequence's `subscribe` method.
  260|       |     - returns: The observable sequence with the specified implementation for the `subscribe` method.
  261|       |     */
  262|      0|    public static func create(subscribe: @escaping (@escaping CompletableObserver) -> Disposable) -> PrimitiveSequence<TraitType, ElementType> {
  263|      0|        let source = Observable<ElementType>.create { observer in
  264|      0|            return subscribe { event in
  265|      0|                switch event {
  266|      0|                case .error(let error):
  267|      0|                    observer.on(.error(error))
  268|      0|                case .completed:
  269|      0|                    observer.on(.completed)
  270|      0|                }
  271|      0|            }
  272|      0|        }
  273|      0|
  274|      0|        return PrimitiveSequence(raw: source)
  275|      0|    }
  276|       |
  277|       |    /**
  278|       |     Subscribes `observer` to receive events for this sequence.
  279|       |
  280|       |     - returns: Subscription for `observer` that can be used to cancel production of sequence elements and free resources.
  281|       |     */
  282|      0|    public func subscribe(_ observer: @escaping (CompletableEvent) -> ()) -> Disposable {
  283|      0|        var stopped = false
  284|      0|        return self.primitiveSequence.asObservable().subscribe { event in
  285|      0|            if stopped { return }
  286|      0|            stopped = true
  287|      0|
  288|      0|            switch event {
  289|      0|            case .next:
  290|      0|                rxFatalError("Completables can't emit values")
  291|      0|            case .error(let error):
  292|      0|                observer(.error(error))
  293|      0|            case .completed:
  294|      0|                observer(.completed)
  295|      0|            }
  296|      0|        }
  297|      0|    }
  298|       |
  299|       |    /**
  300|       |     Subscribes a completion handler and an error handler for this sequence.
  301|       |
  302|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  303|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  304|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
  305|       |     */
  306|      0|    public func subscribe(onCompleted: (() -> Void)? = nil, onError: ((Swift.Error) -> Void)? = nil) -> Disposable {
  307|      0|        return self.primitiveSequence.subscribe { event in
  308|      0|            switch event {
  309|      0|            case .error(let error):
  310|      0|                onError?(error)
  311|      0|            case .completed:
  312|      0|                onCompleted?()
  313|      0|            }
  314|      0|        }
  315|      0|    }
  316|       |}
  317|       |
  318|       |// </Completable>
  319|       |
  320|       |extension PrimitiveSequence {
  321|       |    /**
  322|       |     Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
  323|       |
  324|       |     - seealso: [defer operator on reactivex.io](http://reactivex.io/documentation/operators/defer.html)
  325|       |
  326|       |     - parameter observableFactory: Observable factory function to invoke for each observer that subscribes to the resulting sequence.
  327|       |     - returns: An observable sequence whose observers trigger an invocation of the given observable factory function.
  328|       |     */
  329|       |    public static func deferred(_ observableFactory: @escaping () throws -> PrimitiveSequence<Trait, Element>)
  330|      0|        -> PrimitiveSequence<Trait, Element> {
  331|      0|        return PrimitiveSequence(raw: Observable.deferred {
  332|      0|            try observableFactory().asObservable()
  333|      0|        })
  334|      0|    }
  335|       |
  336|       |    /**
  337|       |     Returns an observable sequence that contains a single element.
  338|       |
  339|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
  340|       |
  341|       |     - parameter element: Single element in the resulting observable sequence.
  342|       |     - returns: An observable sequence containing the single specified element.
  343|       |     */
  344|      0|    public static func just(_ element: Element) -> PrimitiveSequence<Trait, ElementType> {
  345|      0|        return PrimitiveSequence(raw: Observable.just(element))
  346|      0|    }
  347|       |
  348|       |    /**
  349|       |     Returns an observable sequence that contains a single element.
  350|       |
  351|       |     - seealso: [just operator on reactivex.io](http://reactivex.io/documentation/operators/just.html)
  352|       |
  353|       |     - parameter element: Single element in the resulting observable sequence.
  354|       |     - parameter: Scheduler to send the single element on.
  355|       |     - returns: An observable sequence containing the single specified element.
  356|       |     */
  357|      0|    public static func just(_ element: Element, scheduler: ImmediateSchedulerType) -> PrimitiveSequence<Trait, ElementType> {
  358|      0|        return PrimitiveSequence(raw: Observable.just(element, scheduler: scheduler))
  359|      0|    }
  360|       |
  361|       |    /**
  362|       |     Returns an observable sequence that terminates with an `error`.
  363|       |
  364|       |     - seealso: [throw operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  365|       |
  366|       |     - returns: The observable sequence that terminates with specified error.
  367|       |     */
  368|      0|    public static func error(_ error: Swift.Error) -> PrimitiveSequence<Trait, Element> {
  369|      0|        return PrimitiveSequence(raw: Observable.error(error))
  370|      0|    }
  371|       |
  372|       |
  373|       |    /**
  374|       |     Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
  375|       |
  376|       |     - seealso: [never operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  377|       |
  378|       |     - returns: An observable sequence whose observers will never get called.
  379|       |     */
  380|      0|    public static func never() -> PrimitiveSequence<Trait, Element> {
  381|      0|        return PrimitiveSequence(raw: Observable.never())
  382|      0|    }
  383|       |
  384|       |    /**
  385|       |     Time shifts the observable sequence by delaying the subscription with the specified relative time duration, using the specified scheduler to run timers.
  386|       |
  387|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
  388|       |
  389|       |     - parameter dueTime: Relative time shift of the subscription.
  390|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
  391|       |     - returns: Time-shifted sequence.
  392|       |     */
  393|       |    public func delaySubscription(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  394|      0|        -> PrimitiveSequence<Trait, Element> {
  395|      0|        return PrimitiveSequence(raw: source.delaySubscription(dueTime, scheduler: scheduler))
  396|      0|    }
  397|       |
  398|       |    /**
  399|       |     Returns an observable sequence by the source observable sequence shifted forward in time by a specified delay. Error events from the source observable sequence are not delayed.
  400|       |
  401|       |     - seealso: [delay operator on reactivex.io](http://reactivex.io/documentation/operators/delay.html)
  402|       |
  403|       |     - parameter dueTime: Relative time shift of the source by.
  404|       |     - parameter scheduler: Scheduler to run the subscription delay timer on.
  405|       |     - returns: the source Observable shifted in time by the specified delay.
  406|       |     */
  407|       |    public func delay(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  408|      0|        -> PrimitiveSequence<Trait, Element> {
  409|      0|        return PrimitiveSequence(raw: source.delay(dueTime, scheduler: scheduler))
  410|      0|    }
  411|       |
  412|       |    /**
  413|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  414|       |
  415|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  416|       |
  417|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  418|       |     - parameter onError: Action to invoke upon errored termination of the observable sequence.
  419|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  420|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  421|       |     - parameter onSubscribed: Action to invoke after subscribing to source observable sequence.
  422|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  423|       |     - returns: The source sequence with the side-effecting behavior applied.
  424|       |     */
  425|       |    public func `do`(onNext: ((E) throws -> Void)? = nil, onError: ((Swift.Error) throws -> Void)? = nil, onCompleted: (() throws -> Void)? = nil, onSubscribe: (() -> ())? = nil, onSubscribed: (() -> ())? = nil, onDispose: (() -> ())? = nil)
  426|      0|        -> PrimitiveSequence<Trait, Element> {
  427|      0|            return PrimitiveSequence(raw: source.do(
  428|      0|                onNext: onNext,
  429|      0|                onError: onError,
  430|      0|                onCompleted: onCompleted,
  431|      0|                onSubscribe: onSubscribe,
  432|      0|                onSubscribed: onSubscribed,
  433|      0|                onDispose: onDispose)
  434|      0|            )
  435|      0|    }
  436|       |
  437|       |    /**
  438|       |     Filters the elements of an observable sequence based on a predicate.
  439|       |
  440|       |     - seealso: [filter operator on reactivex.io](http://reactivex.io/documentation/operators/filter.html)
  441|       |
  442|       |     - parameter predicate: A function to test each source element for a condition.
  443|       |     - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
  444|       |     */
  445|       |    public func filter(_ predicate: @escaping (E) throws -> Bool)
  446|      0|        -> Maybe<Element> {
  447|      0|        return Maybe(raw: source.filter(predicate))
  448|      0|    }
  449|       |
  450|       |    /**
  451|       |     Projects each element of an observable sequence into a new form.
  452|       |
  453|       |     - seealso: [map operator on reactivex.io](http://reactivex.io/documentation/operators/map.html)
  454|       |
  455|       |     - parameter transform: A transform function to apply to each source element.
  456|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
  457|       |
  458|       |     */
  459|       |    public func map<R>(_ transform: @escaping (E) throws -> R)
  460|      0|        -> PrimitiveSequence<Trait, R> {
  461|      0|        return PrimitiveSequence<Trait, R>(raw: source.map(transform))
  462|      0|    }
  463|       |
  464|       |    /**
  465|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  466|       |
  467|       |     - seealso: [flatMap operator on reactivex.io](http://reactivex.io/documentation/operators/flatmap.html)
  468|       |
  469|       |     - parameter selector: A transform function to apply to each element.
  470|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  471|       |     */
  472|       |    public func flatMap<R>(_ selector: @escaping (ElementType) throws -> PrimitiveSequence<Trait, R>)
  473|      0|        -> PrimitiveSequence<Trait, R> {
  474|      0|        return PrimitiveSequence<Trait, R>(raw: source.flatMap(selector))
  475|      0|    }
  476|       |
  477|       |    /**
  478|       |     Wraps the source sequence in order to run its observer callbacks on the specified scheduler.
  479|       |
  480|       |     This only invokes observer callbacks on a `scheduler`. In case the subscription and/or unsubscription
  481|       |     actions have side-effects that require to be run on a scheduler, use `subscribeOn`.
  482|       |
  483|       |     - seealso: [observeOn operator on reactivex.io](http://reactivex.io/documentation/operators/observeon.html)
  484|       |
  485|       |     - parameter scheduler: Scheduler to notify observers on.
  486|       |     - returns: The source sequence whose observations happen on the specified scheduler.
  487|       |     */
  488|       |    public func observeOn(_ scheduler: ImmediateSchedulerType)
  489|      0|        -> PrimitiveSequence<Trait, Element> {
  490|      0|        return PrimitiveSequence(raw: source.observeOn(scheduler))
  491|      0|    }
  492|       |
  493|       |    /**
  494|       |    Wraps the source sequence in order to run its subscription and unsubscription logic on the specified 
  495|       |    scheduler. 
  496|       |    
  497|       |    This operation is not commonly used.
  498|       |    
  499|       |    This only performs the side-effects of subscription and unsubscription on the specified scheduler. 
  500|       |    
  501|       |    In order to invoke observer callbacks on a `scheduler`, use `observeOn`.
  502|       |
  503|       |    - seealso: [subscribeOn operator on reactivex.io](http://reactivex.io/documentation/operators/subscribeon.html)
  504|       |    
  505|       |    - parameter scheduler: Scheduler to perform subscription and unsubscription actions on.
  506|       |    - returns: The source sequence whose subscriptions and unsubscriptions happen on the specified scheduler.
  507|       |    */
  508|       |    public func subscribeOn(_ scheduler: ImmediateSchedulerType)
  509|      0|        -> PrimitiveSequence<Trait, Element> {
  510|      0|        return PrimitiveSequence(raw: source.subscribeOn(scheduler))
  511|      0|    }
  512|       |
  513|       |    /**
  514|       |     Continues an observable sequence that is terminated by an error with the observable sequence produced by the handler.
  515|       |
  516|       |     - seealso: [catch operator on reactivex.io](http://reactivex.io/documentation/operators/catch.html)
  517|       |
  518|       |     - parameter handler: Error handler function, producing another observable sequence.
  519|       |     - returns: An observable sequence containing the source sequence's elements, followed by the elements produced by the handler's resulting observable sequence in case an error occurred.
  520|       |     */
  521|       |    public func catchError(_ handler: @escaping (Swift.Error) throws -> PrimitiveSequence<Trait, Element>)
  522|      0|        -> PrimitiveSequence<Trait, Element> {
  523|      0|        return PrimitiveSequence(raw: source.catchError { try handler($0).asObservable() })
  524|      0|    }
  525|       |
  526|       |    /**
  527|       |     Repeats the source observable sequence the specified number of times in case of an error or until it successfully terminates.
  528|       |
  529|       |     If you encounter an error and want it to retry once, then you must use `retry(2)`
  530|       |
  531|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  532|       |
  533|       |     - parameter maxAttemptCount: Maximum number of times to repeat the sequence.
  534|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
  535|       |     */
  536|       |    public func retry(_ maxAttemptCount: Int)
  537|      0|        -> PrimitiveSequence<Trait, Element> {
  538|      0|        return PrimitiveSequence(raw: source.retry(maxAttemptCount))
  539|      0|    }
  540|       |
  541|       |    /**
  542|       |     Repeats the source observable sequence on error when the notifier emits a next value.
  543|       |     If the source observable errors and the notifier completes, it will complete the source sequence.
  544|       |
  545|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  546|       |
  547|       |     - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
  548|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
  549|       |     */
  550|       |    public func retryWhen<TriggerObservable: ObservableType, Error: Swift.Error>(_ notificationHandler: @escaping (Observable<Error>) -> TriggerObservable)
  551|      0|        -> PrimitiveSequence<Trait, Element> {
  552|      0|        return PrimitiveSequence(raw: source.retryWhen(notificationHandler))
  553|      0|    }
  554|       |
  555|       |    /**
  556|       |     Repeats the source observable sequence on error when the notifier emits a next value.
  557|       |     If the source observable errors and the notifier completes, it will complete the source sequence.
  558|       |
  559|       |     - seealso: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
  560|       |
  561|       |     - parameter notificationHandler: A handler that is passed an observable sequence of errors raised by the source observable and returns and observable that either continues, completes or errors. This behavior is then applied to the source observable.
  562|       |     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully or is notified to error or complete.
  563|       |     */
  564|       |    public func retryWhen<TriggerObservable: ObservableType>(_ notificationHandler: @escaping (Observable<Swift.Error>) -> TriggerObservable)
  565|      0|        -> PrimitiveSequence<Trait, Element> {
  566|      0|        return PrimitiveSequence(raw: source.retryWhen(notificationHandler))
  567|      0|    }
  568|       |
  569|       |    /**
  570|       |     Prints received events for all observers on standard output.
  571|       |
  572|       |     - seealso: [do operator on reactivex.io](http://reactivex.io/documentation/operators/do.html)
  573|       |
  574|       |     - parameter identifier: Identifier that is printed together with event description to standard output.
  575|       |     - parameter trimOutput: Should output be trimmed to max 40 characters.
  576|       |     - returns: An observable sequence whose events are printed to standard output.
  577|       |     */
  578|       |    public func debug(_ identifier: String? = nil, trimOutput: Bool = false, file: String = #file, line: UInt = #line, function: String = #function)
  579|      0|        -> PrimitiveSequence<Trait, Element> {
  580|      0|            return PrimitiveSequence(raw: source.debug(identifier, trimOutput: trimOutput, file: file, line: line, function: function))
  581|      0|    }
  582|       |}
  583|       |
  584|       |extension PrimitiveSequenceType where ElementType: SignedInteger
  585|       |{
  586|       |    /**
  587|       |     Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
  588|       |
  589|       |     - seealso: [timer operator on reactivex.io](http://reactivex.io/documentation/operators/timer.html)
  590|       |
  591|       |     - parameter dueTime: Relative time at which to produce the first value.
  592|       |     - parameter scheduler: Scheduler to run timers on.
  593|       |     - returns: An observable sequence that produces a value after due time has elapsed and then each period.
  594|       |     */
  595|       |    public static func timer(_ dueTime: RxTimeInterval, scheduler: SchedulerType)
  596|      0|        -> PrimitiveSequence<TraitType, ElementType>  {
  597|      0|        return PrimitiveSequence(raw: Observable<ElementType>.timer(dueTime, scheduler: scheduler))
  598|      0|    }
  599|       |}
  600|       |
  601|       |extension PrimitiveSequenceType where TraitType == MaybeTrait {
  602|       |    /**
  603|       |     Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
  604|       |
  605|       |     - seealso: [empty operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  606|       |
  607|       |     - returns: An observable sequence with no elements.
  608|       |     */
  609|      0|    public static func empty() -> PrimitiveSequence<MaybeTrait, ElementType> {
  610|      0|        return PrimitiveSequence(raw: Observable.empty())
  611|      0|    }
  612|       |}
  613|       |
  614|       |extension PrimitiveSequenceType where TraitType == CompletableTrait, ElementType == Never {
  615|       |    /**
  616|       |     Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
  617|       |
  618|       |     - seealso: [empty operator on reactivex.io](http://reactivex.io/documentation/operators/empty-never-throw.html)
  619|       |
  620|       |     - returns: An observable sequence with no elements.
  621|       |     */
  622|      0|    public static func empty() -> PrimitiveSequence<CompletableTrait, Never> {
  623|      0|        return PrimitiveSequence(raw: Observable.empty())
  624|      0|    }
  625|       |}
  626|       |
  627|       |extension ObservableType {
  628|       |    /**
  629|       |     The `asSingle` operator throws a `RxError.noElements` or `RxError.moreThanOneElement`
  630|       |     if the source Observable does not emit exactly one element before successfully completing.
  631|       |
  632|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
  633|       |
  634|       |     - returns: An observable sequence that emits a single element or throws an exception if more (or none) of them are emitted.
  635|       |     */
  636|      0|    public func asSingle() -> Single<E> {
  637|      0|        return PrimitiveSequence(raw: AsSingle(source: self.asObservable()))
  638|      0|    }
  639|       |
  640|       |    /**
  641|       |     The `asMaybe` operator throws a ``RxError.moreThanOneElement`
  642|       |     if the source Observable does not emit at most one element before successfully completing.
  643|       |
  644|       |     - seealso: [single operator on reactivex.io](http://reactivex.io/documentation/operators/first.html)
  645|       |
  646|       |     - returns: An observable sequence that emits a single element, completes or throws an exception if more of them are emitted.
  647|       |     */
  648|      0|    public func asMaybe() -> Maybe<E> {
  649|      0|        return PrimitiveSequence(raw: AsMaybe(source: self.asObservable()))
  650|      0|    }
  651|       |}
  652|       |
  653|       |extension ObservableType where E == Never {
  654|       |    /**
  655|       |    - returns: An observable sequence that completes.
  656|       |     */
  657|       |    public func asCompletable()
  658|      0|        -> Completable {
  659|      0|        return PrimitiveSequence(raw: self.asObservable())
  660|      0|    }
  661|       |}

