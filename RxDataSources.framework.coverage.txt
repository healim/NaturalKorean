/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources+Rx/RxCollectionViewSectionedAnimatedDataSource.swift:
    1|       |//
    2|       |//  RxCollectionViewSectionedAnimatedDataSource.swift
    3|       |//  RxExample
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |import RxCocoa
   14|       |#endif
   15|       |
   16|       |/*
   17|       | This is commented becuse collection view has bugs when doing animated updates. 
   18|       | Take a look at randomized sections.
   19|       |*/
   20|       |open class RxCollectionViewSectionedAnimatedDataSource<S: AnimatableSectionModelType>
   21|       |    : CollectionViewSectionedDataSource<S>
   22|       |    , RxCollectionViewDataSourceType {
   23|       |    public typealias Element = [S]
   24|       |    public var animationConfiguration = AnimationConfiguration()
   25|       |    
   26|       |    // For some inexplicable reason, when doing animated updates first time
   27|       |    // it crashes. Still need to figure out that one.
   28|       |    var dataSet = false
   29|       |
   30|       |    private let disposeBag = DisposeBag()
   31|       |
   32|       |    // This subject and throttle are here
   33|       |    // because collection view has problems processing animated updates fast.
   34|       |    // This should somewhat help to alleviate the problem.
   35|       |    private let partialUpdateEvent = PublishSubject<(UICollectionView, Event<Element>)>()
   36|       |
   37|      0|    public override init() {
   38|      0|        super.init()
   39|      0|
   40|      0|        self.partialUpdateEvent
   41|      0|            // so in case it does produce a crash, it will be after the data has changed
   42|      0|            .observeOn(MainScheduler.asyncInstance)
   43|      0|            // Collection view has issues digesting fast updates, this should
   44|      0|            // help to alleviate the issues with them.
   45|      0|            .throttle(0.5, scheduler: MainScheduler.instance)
   46|      0|            .subscribe(onNext: { [weak self] event in
   47|      0|                self?.collectionView(event.0, throttledObservedEvent: event.1)
   48|      0|            })
   49|      0|            .addDisposableTo(disposeBag)
   50|      0|    }
   51|       |
   52|       |    /**
   53|       |     This method exists because collection view updates are throttled because of internal collection view bugs.
   54|       |     Collection view behaves poorly during fast updates, so this should remedy those issues.
   55|       |    */
   56|      0|    open func collectionView(_ collectionView: UICollectionView, throttledObservedEvent event: Event<Element>) {
   57|      0|        UIBindingObserver(UIElement: self) { dataSource, newSections in
   58|      0|            let oldSections = dataSource.sectionModels
   59|      0|            do {
   60|      0|                // if view is not in view hierarchy, performing batch updates will crash the app
   61|      0|                if collectionView.window == nil {
   62|      0|                    dataSource.setSections(newSections)
   63|      0|                    collectionView.reloadData()
   64|      0|                    return
   65|      0|                }
   66|      0|                let differences = try differencesForSectionedView(initialSections: oldSections, finalSections: newSections)
   67|      0|
   68|      0|                for difference in differences {
   69|      0|                    dataSource.setSections(difference.finalSections)
   70|      0|
   71|      0|                    collectionView.performBatchUpdates(difference, animationConfiguration: self.animationConfiguration)
   72|      0|                }
   73|      0|            }
   74|      0|            catch let e {
   75|      0|                #if DEBUG
   76|      0|                    print("Error while binding data animated: \(e)\nFallback to normal `reloadData` behavior.")
   77|      0|                    rxDebugFatalError(e)
   78|      0|                #endif
   79|      0|                self.setSections(newSections)
   80|      0|                collectionView.reloadData()
   81|      0|            }
   82|      0|        }.on(event)
   83|      0|    }
   84|       |
   85|      0|    open func collectionView(_ collectionView: UICollectionView, observedEvent: Event<Element>) {
   86|      0|        UIBindingObserver(UIElement: self) { dataSource, newSections in
   87|      0|            #if DEBUG
   88|      0|                self._dataSourceBound = true
   89|      0|            #endif
   90|      0|            if !self.dataSet {
   91|      0|                self.dataSet = true
   92|      0|                dataSource.setSections(newSections)
   93|      0|                collectionView.reloadData()
   94|      0|            }
   95|      0|            else {
   96|      0|                let element = (collectionView, observedEvent)
   97|      0|                dataSource.partialUpdateEvent.on(.next(element))
   98|      0|            }
   99|      0|        }.on(observedEvent)
  100|      0|    }
  101|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources+Rx/RxCollectionViewSectionedReloadDataSource.swift:
    1|       |//
    2|       |//  RxCollectionViewSectionedReloadDataSource.swift
    3|       |//  RxExample
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |import RxCocoa
   14|       |#endif
   15|       |
   16|       |open class RxCollectionViewSectionedReloadDataSource<S: SectionModelType>
   17|       |    : CollectionViewSectionedDataSource<S>
   18|       |    , RxCollectionViewDataSourceType {
   19|       |    
   20|       |    public typealias Element = [S]
   21|       |
   22|      0|    public override init() {
   23|      0|        super.init()
   24|      0|    }
   25|       |
   26|      0|    open func collectionView(_ collectionView: UICollectionView, observedEvent: Event<Element>) {
   27|      0|        UIBindingObserver(UIElement: self) { dataSource, element in
   28|      0|            #if DEBUG
   29|      0|                self._dataSourceBound = true
   30|      0|            #endif
   31|      0|            dataSource.setSections(element)
   32|      0|            collectionView.reloadData()
   33|      0|            collectionView.collectionViewLayout.invalidateLayout()
   34|      0|        }.on(observedEvent)
   35|      0|    }
   36|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources+Rx/RxTableViewSectionedAnimatedDataSource.swift:
    1|       |//
    2|       |//  RxTableViewSectionedAnimatedDataSource.swift
    3|       |//  RxExample
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |import RxCocoa
   14|       |#endif
   15|       |
   16|       |open class RxTableViewSectionedAnimatedDataSource<S: AnimatableSectionModelType>
   17|       |    : TableViewSectionedDataSource<S>
   18|       |    , RxTableViewDataSourceType {
   19|       |    
   20|       |    public typealias Element = [S]
   21|       |    public var animationConfiguration = AnimationConfiguration()
   22|       |
   23|       |    var dataSet = false
   24|       |
   25|      0|    public override init() {
   26|      0|        super.init()
   27|      0|    }
   28|       |
   29|      0|    open func tableView(_ tableView: UITableView, observedEvent: Event<Element>) {
   30|      0|        UIBindingObserver(UIElement: self) { dataSource, newSections in
   31|      0|            #if DEBUG
   32|      0|                self._dataSourceBound = true
   33|      0|            #endif
   34|      0|            if !self.dataSet {
   35|      0|                self.dataSet = true
   36|      0|                dataSource.setSections(newSections)
   37|      0|                tableView.reloadData()
   38|      0|            }
   39|      0|            else {
   40|      0|                DispatchQueue.main.async {
   41|      0|                    // if view is not in view hierarchy, performing batch updates will crash the app
   42|      0|                    if tableView.window == nil {
   43|      0|                        dataSource.setSections(newSections)
   44|      0|                        tableView.reloadData()
   45|      0|                        return
   46|      0|                    }
   47|      0|                    let oldSections = dataSource.sectionModels
   48|      0|                    do {
   49|      0|                        let differences = try differencesForSectionedView(initialSections: oldSections, finalSections: newSections)
   50|      0|
   51|      0|                        for difference in differences {
   52|      0|                            dataSource.setSections(difference.finalSections)
   53|      0|
   54|      0|                            tableView.performBatchUpdates(difference, animationConfiguration: self.animationConfiguration)
   55|      0|                        }
   56|      0|                    }
   57|      0|                    catch let e {
   58|      0|                        rxDebugFatalError(e)
   59|      0|                        self.setSections(newSections)
   60|      0|                        tableView.reloadData()
   61|      0|                    }
   62|      0|                }
   63|      0|            }
   64|      0|        }.on(observedEvent)
   65|      0|    }
   66|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources+Rx/RxTableViewSectionedReloadDataSource.swift:
    1|       |//
    2|       |//  RxTableViewSectionedReloadDataSource.swift
    3|       |//  RxExample
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |import RxCocoa
   14|       |#endif
   15|       |
   16|       |open class RxTableViewSectionedReloadDataSource<S: SectionModelType>
   17|       |    : TableViewSectionedDataSource<S>
   18|       |    , RxTableViewDataSourceType {
   19|       |    public typealias Element = [S]
   20|       |
   21|      5|    public override init() {
   22|      5|        super.init()
   23|      5|    }
   24|       |
   25|     37|    open func tableView(_ tableView: UITableView, observedEvent: Event<Element>) {
   26|     37|        UIBindingObserver(UIElement: self) { dataSource, element in
   27|     37|            #if DEBUG
   28|     37|                self._dataSourceBound = true
   29|     37|            #endif
   30|     37|            dataSource.setSections(element)
   31|     37|            tableView.reloadData()
   32|     37|        }.on(observedEvent)
   33|     37|    }
   34|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/AnimatableSectionModel.swift:
    1|       |//
    2|       |//  AnimatableSectionModel.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 1/10/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct AnimatableSectionModel<Section: IdentifiableType, ItemType: IdentifiableType & Equatable> {
   12|       |    public var model: Section
   13|       |    public var items: [Item]
   14|       |
   15|      0|    public init(model: Section, items: [ItemType]) {
   16|      0|        self.model = model
   17|      0|        self.items = items
   18|      0|    }
   19|       |    
   20|       |}
   21|       |
   22|       |extension AnimatableSectionModel
   23|       |    : AnimatableSectionModelType {
   24|       |    public typealias Item = ItemType
   25|       |    public typealias Identity = Section.Identity
   26|       |
   27|      0|    public var identity: Section.Identity {
   28|      0|        return model.identity
   29|      0|    }
   30|       |
   31|      0|    public init(original: AnimatableSectionModel, items: [Item]) {
   32|      0|        self.model = original.model
   33|      0|        self.items = items
   34|      0|    }
   35|       |    
   36|      0|    public var hashValue: Int {
   37|      0|        return self.model.identity.hashValue
   38|      0|    }
   39|       |}
   40|       |
   41|       |
   42|       |extension AnimatableSectionModel
   43|       |    : CustomStringConvertible {
   44|       |
   45|      0|    public var description: String {
   46|      0|        return "HashableSectionModel(model: \"\(self.model)\", items: \(items))"
   47|      0|    }
   48|       |
   49|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/AnimatableSectionModelType+ItemPath.swift:
    1|       |//
    2|       |//  AnimatableSectionModelType+ItemPath.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 1/9/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Array where Element: AnimatableSectionModelType {
   12|      0|    subscript(index: ItemPath) -> Element.Item {
   13|      0|        return self[index.sectionIndex].items[index.itemIndex]
   14|      0|    }
   15|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/AnimationConfiguration.swift:
    1|       |//
    2|       |//  AnimationConfiguration.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Esteban Torres on 5/2/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|       |/**
   13|       |   Exposes custom animation styles for insertion, deletion and reloading behavior.
   14|       |*/
   15|       |public struct AnimationConfiguration {
   16|       |  let insertAnimation: UITableViewRowAnimation
   17|       |  let reloadAnimation: UITableViewRowAnimation
   18|       |  let deleteAnimation: UITableViewRowAnimation
   19|       |  
   20|       |  public init(insertAnimation: UITableViewRowAnimation = .automatic,
   21|       |    reloadAnimation: UITableViewRowAnimation = .automatic,
   22|      0|    deleteAnimation: UITableViewRowAnimation = .automatic) {
   23|      0|      self.insertAnimation = insertAnimation
   24|      0|      self.reloadAnimation = reloadAnimation
   25|      0|      self.deleteAnimation = deleteAnimation
   26|      0|  }
   27|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/Array+Extensions.swift:
    1|       |//
    2|       |//  Array+Extensions.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/26/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |import Foundation
   12|       |
   13|       |extension Array where Element: SectionModelType {
   14|      0|    mutating func moveFromSourceIndexPath(_ sourceIndexPath: IndexPath, destinationIndexPath: IndexPath) {
   15|      0|        let sourceSection = self[sourceIndexPath.section]
   16|      0|        var sourceItems = sourceSection.items
   17|      0|
   18|      0|        let sourceItem = sourceItems.remove(at: sourceIndexPath.item)
   19|      0|
   20|      0|        let sourceSectionNew = Element(original: sourceSection, items: sourceItems)
   21|      0|        self[sourceIndexPath.section] = sourceSectionNew
   22|      0|
   23|      0|        let destinationSection = self[destinationIndexPath.section]
   24|      0|        var destinationItems = destinationSection.items
   25|      0|        destinationItems.insert(sourceItem, at: destinationIndexPath.item)
   26|      0|
   27|      0|        self[destinationIndexPath.section] = Element(original: destinationSection, items: destinationItems)
   28|      0|    }
   29|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/Changeset.swift:
    1|       |//
    2|       |//  Changeset.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import CoreData
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |import RxCocoa
   14|       |#endif
   15|       |
   16|       |public struct Changeset<S: SectionModelType> {
   17|       |    public typealias I = S.Item
   18|       |
   19|       |    public let reloadData: Bool
   20|       |
   21|       |    public let originalSections: [S]
   22|       |    public let finalSections: [S]
   23|       |
   24|       |    public let insertedSections: [Int]
   25|       |    public let deletedSections: [Int]
   26|       |    public let movedSections: [(from: Int, to: Int)]
   27|       |    public let updatedSections: [Int]
   28|       |
   29|       |    public let insertedItems: [ItemPath]
   30|       |    public let deletedItems: [ItemPath]
   31|       |    public let movedItems: [(from: ItemPath, to: ItemPath)]
   32|       |    public let updatedItems: [ItemPath]
   33|       |
   34|       |    init(reloadData: Bool = false,
   35|       |        originalSections: [S] = [],
   36|       |        finalSections: [S] = [],
   37|       |        insertedSections: [Int] = [],
   38|       |        deletedSections: [Int] = [],
   39|       |        movedSections: [(from: Int, to: Int)] = [],
   40|       |        updatedSections: [Int] = [],
   41|       |
   42|       |        insertedItems: [ItemPath] = [],
   43|       |        deletedItems: [ItemPath] = [],
   44|       |        movedItems: [(from: ItemPath, to: ItemPath)] = [],
   45|       |        updatedItems: [ItemPath] = []
   46|      0|    ) {
   47|      0|        self.reloadData = reloadData
   48|      0|
   49|      0|        self.originalSections = originalSections
   50|      0|        self.finalSections = finalSections
   51|      0|
   52|      0|        self.insertedSections = insertedSections
   53|      0|        self.deletedSections = deletedSections
   54|      0|        self.movedSections = movedSections
   55|      0|        self.updatedSections = updatedSections
   56|      0|
   57|      0|        self.insertedItems = insertedItems
   58|      0|        self.deletedItems = deletedItems
   59|      0|        self.movedItems = movedItems
   60|      0|        self.updatedItems = updatedItems
   61|      0|    }
   62|       |
   63|      0|    public static func initialValue(_ sections: [S]) -> Changeset<S> {
   64|      0|        return Changeset<S>(
   65|      0|            reloadData: true,
   66|      0|            finalSections: sections,
   67|      0|            insertedSections: Array(0 ..< sections.count) as [Int]
   68|      0|        )
   69|      0|    }
   70|       |}
   71|       |
   72|       |extension ItemPath
   73|       |    : CustomDebugStringConvertible {
   74|      0|    public var debugDescription : String {
   75|      0|        return "(\(sectionIndex), \(itemIndex))"
   76|      0|    }
   77|       |}
   78|       |
   79|       |extension Changeset
   80|       |    : CustomDebugStringConvertible {
   81|       |
   82|      0|    public var debugDescription : String {
   83|      0|        let serializedSections = "[\n" + finalSections.map { "\($0)" }.joined(separator: ",\n") + "\n]\n"
   84|      0|        return " >> Final sections"
   85|      0|        + "   \n\(serializedSections)"
   86|      0|        + (insertedSections.count > 0 || deletedSections.count > 0 || movedSections.count > 0 || updatedSections.count > 0 ? "\nSections:" : "")
   87|      0|        + (insertedSections.count > 0 ? "\ninsertedSections:\n\t\(insertedSections)" : "")
   88|      0|        + (deletedSections.count > 0 ?  "\ndeletedSections:\n\t\(deletedSections)" : "")
   89|      0|        + (movedSections.count > 0 ? "\nmovedSections:\n\t\(movedSections)" : "")
   90|      0|        + (updatedSections.count > 0 ? "\nupdatesSections:\n\t\(updatedSections)" : "")
   91|      0|            + (insertedItems.count > 0 || deletedItems.count > 0 || movedItems.count > 0 || updatedItems.count > 0 ? "\nItems:" : "")
   92|      0|        + (insertedItems.count > 0 ? "\ninsertedItems:\n\t\(insertedItems)" : "")
   93|      0|        + (deletedItems.count > 0 ? "\ndeletedItems:\n\t\(deletedItems)" : "")
   94|      0|        + (movedItems.count > 0 ? "\nmovedItems:\n\t\(movedItems)" : "")
   95|      0|        + (updatedItems.count > 0 ? "\nupdatedItems:\n\t\(updatedItems)" : "")
   96|      0|    }
   97|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/CollectionViewSectionedDataSource.swift:
    1|       |//
    2|       |//  CollectionViewSectionedDataSource.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |#if !RX_NO_MODULE
   12|       |import RxCocoa
   13|       |#endif
   14|       |    
   15|       |open class _CollectionViewSectionedDataSource
   16|       |    : NSObject
   17|       |    , UICollectionViewDataSource {
   18|       |    
   19|      0|    open func _rx_numberOfSections(in collectionView: UICollectionView) -> Int {
   20|      0|        return 0
   21|      0|    }
   22|       |    
   23|      0|    open func numberOfSections(in collectionView: UICollectionView) -> Int {
   24|      0|        return _rx_numberOfSections(in: collectionView)
   25|      0|    }
   26|       |
   27|      0|    open func _rx_collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   28|      0|        return 0
   29|      0|    }
   30|       |    
   31|      0|    open func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   32|      0|        return _rx_collectionView(collectionView, numberOfItemsInSection: section)
   33|      0|    }
   34|       |
   35|      0|    open func _rx_collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   36|      0|        return (nil as UICollectionViewCell?)!
   37|      0|    }
   38|       |    
   39|      0|    open func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   40|      0|        return _rx_collectionView(collectionView, cellForItemAt: indexPath)
   41|      0|    }
   42|       |
   43|      0|    open func _rx_collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: IndexPath) -> UICollectionReusableView {
   44|      0|        return (nil as UICollectionReusableView?)!
   45|      0|    }
   46|       |    
   47|      0|    open func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {
   48|      0|        return _rx_collectionView(collectionView, viewForSupplementaryElementOfKind: kind, atIndexPath: indexPath)
   49|      0|    }
   50|       |    
   51|      0|    open func _rx_collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -> Bool {
   52|      0|        return true
   53|      0|    }
   54|       |    
   55|      0|    public func collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -> Bool {
   56|      0|        return _rx_collectionView(collectionView, canMoveItemAt: indexPath)
   57|      0|    }
   58|       |    
   59|      0|    open func _rx_collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
   60|      0|        
   61|      0|    }
   62|      0|    public func collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
   63|      0|        _rx_collectionView(collectionView, moveItemAt: sourceIndexPath, to: destinationIndexPath)
   64|      0|    }
   65|       |    
   66|       |}
   67|       |
   68|       |open class CollectionViewSectionedDataSource<S: SectionModelType>
   69|       |    : _CollectionViewSectionedDataSource
   70|       |    , SectionedViewDataSourceType {
   71|       |    public typealias I = S.Item
   72|       |    public typealias Section = S
   73|       |    public typealias CellFactory = (CollectionViewSectionedDataSource<S>, UICollectionView, IndexPath, I) -> UICollectionViewCell
   74|       |    public typealias SupplementaryViewFactory = (CollectionViewSectionedDataSource<S>, UICollectionView, String, IndexPath) -> UICollectionReusableView
   75|       |
   76|       |    #if DEBUG
   77|       |    // If data source has already been bound, then mutating it
   78|       |    // afterwards isn't something desired.
   79|       |    // This simulates immutability after binding
   80|       |    var _dataSourceBound: Bool = false
   81|       |
   82|      0|    private func ensureNotMutatedAfterBinding() {
   83|      0|        assert(!_dataSourceBound, "Data source is already bound. Please write this line before binding call (`bindTo`, `drive`). Data source must first be completely configured, and then bound after that, otherwise there could be runtime bugs, glitches, or partial malfunctions.")
   84|      0|    }
   85|       |    
   86|       |    #endif
   87|       |
   88|       |    // This structure exists because model can be mutable
   89|       |    // In that case current state value should be preserved.
   90|       |    // The state that needs to be preserved is ordering of items in section
   91|       |    // and their relationship with section.
   92|       |    // If particular item is mutable, that is irrelevant for this logic to function
   93|       |    // properly.
   94|       |    public typealias SectionModelSnapshot = SectionModel<S, I>
   95|       |    
   96|       |    private var _sectionModels: [SectionModelSnapshot] = []
   97|       |
   98|      0|    open var sectionModels: [S] {
   99|      0|        return _sectionModels.map { Section(original: $0.model, items: $0.items) }
  100|      0|    }
  101|       |
  102|      0|    open subscript(section: Int) -> S {
  103|      0|        let sectionModel = self._sectionModels[section]
  104|      0|        return S(original: sectionModel.model, items: sectionModel.items)
  105|      0|    }
  106|       |    
  107|       |    open subscript(indexPath: IndexPath) -> I {
  108|      0|        get {
  109|      0|            return self._sectionModels[indexPath.section].items[indexPath.item]
  110|      0|        }
  111|      0|        set(item) {
  112|      0|            var section = self._sectionModels[indexPath.section]
  113|      0|            section.items[indexPath.item] = item
  114|      0|            self._sectionModels[indexPath.section] = section
  115|      0|        }
  116|       |    }
  117|       |    
  118|      0|    open func model(at indexPath: IndexPath) throws -> Any {
  119|      0|        return self[indexPath]
  120|      0|    }
  121|       |    
  122|      0|    open func setSections(_ sections: [S]) {
  123|      0|        self._sectionModels = sections.map { SectionModelSnapshot(model: $0, items: $0.items) }
  124|      0|    }
  125|       |    
  126|       |    open var configureCell: CellFactory! = nil {
  127|      0|        didSet {
  128|      0|            #if DEBUG
  129|      0|            ensureNotMutatedAfterBinding()
  130|      0|            #endif
  131|      0|        }
  132|       |    }
  133|       |
  134|       |    open var supplementaryViewFactory: SupplementaryViewFactory {
  135|      0|        didSet {
  136|      0|            #if DEBUG
  137|      0|            ensureNotMutatedAfterBinding()
  138|      0|            #endif
  139|      0|        }
  140|       |    }
  141|       |    
  142|       |    open var moveItem: ((CollectionViewSectionedDataSource<S>, _ sourceIndexPath:IndexPath, _ destinationIndexPath:IndexPath) -> Void)? {
  143|      0|        didSet {
  144|      0|            #if DEBUG
  145|      0|                ensureNotMutatedAfterBinding()
  146|      0|            #endif
  147|      0|        }
  148|       |    }
  149|       |    open var canMoveItemAtIndexPath: ((CollectionViewSectionedDataSource<S>, IndexPath) -> Bool)? {
  150|      0|        didSet {
  151|      0|            #if DEBUG
  152|      0|            ensureNotMutatedAfterBinding()
  153|      0|            #endif
  154|      0|        }
  155|       |    }
  156|       |    
  157|      0|    public override init() {
  158|      0|        self.configureCell = {_, _, _, _ in return (nil as UICollectionViewCell?)! }
  159|      0|        self.supplementaryViewFactory = {_, _, _, _ in (nil as UICollectionReusableView?)! }
  160|      0|        
  161|      0|        super.init()
  162|      0|        
  163|      0|        self.configureCell = { [weak self] _ in
  164|      0|            precondition(false, "There is a minor problem. `cellFactory` property on \(self!) was not set. Please set it manually, or use one of the `rx_bindTo` methods.")
  165|      0|            
  166|      0|            return (nil as UICollectionViewCell!)!
  167|      0|        }
  168|      0|        
  169|      0|        self.supplementaryViewFactory = { [weak self] _ in
  170|      0|            precondition(false, "There is a minor problem. `supplementaryViewFactory` property on \(self!) was not set.")
  171|      0|            return (nil as UICollectionReusableView?)!
  172|      0|        }
  173|      0|    }
  174|       |    
  175|       |    // UICollectionViewDataSource
  176|       |    
  177|      0|    open override func _rx_numberOfSections(in collectionView: UICollectionView) -> Int {
  178|      0|        return _sectionModels.count
  179|      0|    }
  180|       |    
  181|      0|    open override func _rx_collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
  182|      0|        return _sectionModels[section].items.count
  183|      0|    }
  184|       |    
  185|      0|    open override func _rx_collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
  186|      0|        precondition(indexPath.item < _sectionModels[indexPath.section].items.count)
  187|      0|        
  188|      0|        return configureCell(self, collectionView, indexPath, self[indexPath])
  189|      0|    }
  190|       |    
  191|      0|    open override func _rx_collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, atIndexPath indexPath: IndexPath) -> UICollectionReusableView {
  192|      0|        return supplementaryViewFactory(self, collectionView, kind, indexPath)
  193|      0|    }
  194|       |    
  195|      0|    open override func _rx_collectionView(_ collectionView: UICollectionView, canMoveItemAt indexPath: IndexPath) -> Bool {
  196|      0|        guard let canMoveItem = canMoveItemAtIndexPath?(self, indexPath) else {
  197|      0|            return super._rx_collectionView(collectionView, canMoveItemAt: indexPath)
  198|      0|        }
  199|      0|        
  200|      0|        return canMoveItem
  201|      0|    }
  202|       |    
  203|      0|    open override func _rx_collectionView(_ collectionView: UICollectionView, moveItemAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
  204|      0|        self._sectionModels.moveFromSourceIndexPath(sourceIndexPath, destinationIndexPath: destinationIndexPath)
  205|      0|        self.moveItem?(self, sourceIndexPath, destinationIndexPath)
  206|      0|    }
  207|       |    
  208|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/DataSources.swift:
    1|       |//
    2|       |//  DataSources.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 1/8/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |enum RxDataSourceError : Error {
   12|       |    case unwrappingOptional
   13|       |    case preconditionFailed(message: String)
   14|       |}
   15|       |
   16|      0|func rxPrecondition(_ condition: Bool, _ message: @autoclosure() -> String) throws -> () {
   17|      0|    if condition {
   18|      0|        return
   19|      0|    }
   20|      0|    rxDebugFatalError("Precondition failed")
   21|      0|
   22|      0|    throw RxDataSourceError.preconditionFailed(message: message())
   23|      0|}
   24|       |
   25|      0|func rxDebugFatalError(_ error: Error) {
   26|      0|    rxDebugFatalError("\(error)")
   27|      0|}
   28|       |
   29|      0|func rxDebugFatalError(_ message: String) {
   30|      0|    #if DEBUG
   31|      0|        fatalError(message)
   32|      0|    #else
   33|      0|        print(message)
   34|      0|    #endif
   35|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/Differentiator.swift:
    1|       |//
    2|       |//  Differentiator.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public enum DifferentiatorError
   12|       |    : Error
   13|       |    , CustomDebugStringConvertible {
   14|       |    case duplicateItem(item: Any)
   15|       |    case duplicateSection(section: Any)
   16|       |    case invalidInitializerImplementation(section: Any, expectedItems: Any, expectedIdentifier: Any)
   17|       |}
   18|       |
   19|       |extension DifferentiatorError {
   20|      0|    public var debugDescription: String {
   21|      0|        switch self {
   22|      0|        case let .duplicateItem(item):
   23|      0|            return "Duplicate item \(item)"
   24|      0|        case let .duplicateSection(section):
   25|      0|            return "Duplicate section \(section)"
   26|      0|        case let .invalidInitializerImplementation(section, expectedItems, expectedIdentifier):
   27|      0|            return "Wrong initializer implementation for: \(section)\n" +
   28|      0|                "Expected it should return items: \(expectedItems)\n" +
   29|      0|                "Expected it should have id: \(expectedIdentifier)"
   30|      0|        }
   31|      0|    }
   32|       |}
   33|       |
   34|       |fileprivate enum EditEvent : CustomDebugStringConvertible {
   35|       |    case inserted           // can't be found in old sections
   36|       |    case insertedAutomatically           // Item inside section being inserted
   37|       |    case deleted            // Was in old, not in new, in it's place is something "not new" :(, otherwise it's Updated
   38|       |    case deletedAutomatically            // Item inside section that is being deleted
   39|       |    case moved              // same item, but was on different index, and needs explicit move
   40|       |    case movedAutomatically // don't need to specify any changes for those rows
   41|       |    case untouched
   42|       |}
   43|       |
   44|       |extension EditEvent {
   45|       |    fileprivate var debugDescription: String {
   46|      0|        get {
   47|      0|            switch self {
   48|      0|            case .inserted:
   49|      0|                return "Inserted"
   50|      0|            case .insertedAutomatically:
   51|      0|                return "InsertedAutomatically"
   52|      0|            case .deleted:
   53|      0|                return "Deleted"
   54|      0|            case .deletedAutomatically:
   55|      0|                return "DeletedAutomatically"
   56|      0|            case .moved:
   57|      0|                return "Moved"
   58|      0|            case .movedAutomatically:
   59|      0|                return "MovedAutomatically"
   60|      0|            case .untouched:
   61|      0|                return "Untouched"
   62|      0|            }
   63|      0|        }
   64|       |    }
   65|       |}
   66|       |
   67|       |fileprivate struct SectionAssociatedData {
   68|       |    var event: EditEvent
   69|       |    var indexAfterDelete: Int?
   70|       |    var moveIndex: Int?
   71|       |    var itemCount: Int
   72|       |}
   73|       |
   74|       |extension SectionAssociatedData : CustomDebugStringConvertible {
   75|       |    fileprivate var debugDescription: String {
   76|      0|        get {
   77|      0|            return "\(event), \(String(describing: indexAfterDelete))"
   78|      0|        }
   79|       |    }
   80|       |}
   81|       |
   82|       |extension SectionAssociatedData {
   83|      0|    fileprivate static var initial: SectionAssociatedData {
   84|      0|        return SectionAssociatedData(event: .untouched, indexAfterDelete: nil, moveIndex: nil, itemCount: 0)
   85|      0|    }
   86|       |}
   87|       |
   88|       |fileprivate struct ItemAssociatedData {
   89|       |    var event: EditEvent
   90|       |    var indexAfterDelete: Int?
   91|       |    var moveIndex: ItemPath?
   92|       |}
   93|       |
   94|       |extension ItemAssociatedData : CustomDebugStringConvertible {
   95|       |    fileprivate var debugDescription: String {
   96|      0|        get {
   97|      0|            return "\(event) \(String(describing: indexAfterDelete))"
   98|      0|        }
   99|       |    }
  100|       |}
  101|       |
  102|       |extension ItemAssociatedData {
  103|      0|    static var initial : ItemAssociatedData {
  104|      0|        return ItemAssociatedData(event: .untouched, indexAfterDelete: nil, moveIndex: nil)
  105|      0|    }
  106|       |}
  107|       |
  108|      0|fileprivate func indexSections<S: AnimatableSectionModelType>(_ sections: [S]) throws -> [S.Identity : Int] {
  109|      0|    var indexedSections: [S.Identity : Int] = [:]
  110|      0|    for (i, section) in sections.enumerated() {
  111|      0|        guard indexedSections[section.identity] == nil else {
  112|      0|            #if DEBUG
  113|      0|                if indexedSections[section.identity] != nil {
  114|      0|                    print("Section \(section) has already been indexed at \(indexedSections[section.identity]!)")
  115|      0|                }
  116|      0|            #endif
  117|      0|            throw DifferentiatorError.duplicateSection(section: section)
  118|      0|        }
  119|      0|        indexedSections[section.identity] = i
  120|      0|    }
  121|      0|    
  122|      0|    return indexedSections
  123|      0|}
  124|       |
  125|       |//================================================================================
  126|       |//  Optimizations because Swift dictionaries are extremely slow (ARC, bridging ...)
  127|       |//================================================================================
  128|       |// swift dictionary optimizations {
  129|       |
  130|       |fileprivate struct OptimizedIdentity<E: Hashable> {
  131|       |    let hashValue: Int
  132|       |    let identity: UnsafePointer<E>
  133|       |
  134|      0|    init(_ identity: UnsafePointer<E>) {
  135|      0|        self.identity = identity
  136|      0|        self.hashValue = identity.pointee.hashValue
  137|      0|    }
  138|       |}
  139|       |
  140|       |extension OptimizedIdentity: Hashable {
  141|       |
  142|       |}
  143|       |
  144|      0|fileprivate func == <E: Hashable>(lhs: OptimizedIdentity<E>, rhs: OptimizedIdentity<E>) -> Bool {
  145|      0|    if lhs.hashValue != rhs.hashValue {
  146|      0|        return false
  147|      0|    }
  148|      0|
  149|      0|    if lhs.identity.distance(to: rhs.identity) == 0 {
  150|      0|        return true
  151|      0|    }
  152|      0|
  153|      0|    return lhs.identity.pointee == rhs.identity.pointee
  154|      0|}
  155|       |
  156|       |fileprivate func calculateAssociatedData<Item: IdentifiableType>(
  157|       |    initialItemCache: ContiguousArray<ContiguousArray<Item>>,
  158|       |    finalItemCache: ContiguousArray<ContiguousArray<Item>>
  159|       |    ) throws
  160|      0|    -> (ContiguousArray<ContiguousArray<ItemAssociatedData>>, ContiguousArray<ContiguousArray<ItemAssociatedData>>) {
  161|      0|
  162|      0|    typealias Identity = Item.Identity
  163|      0|    let totalInitialItems = initialItemCache.map { $0.count }.reduce(0, +)
  164|      0|
  165|      0|    var initialIdentities: ContiguousArray<Identity> = ContiguousArray()
  166|      0|    var initialItemPaths: ContiguousArray<ItemPath> = ContiguousArray()
  167|      0|
  168|      0|    initialIdentities.reserveCapacity(totalInitialItems)
  169|      0|    initialItemPaths.reserveCapacity(totalInitialItems)
  170|      0|
  171|      0|    for (i, items) in initialItemCache.enumerated() {
  172|      0|        for j in 0 ..< items.count {
  173|      0|            let item = items[j]
  174|      0|            initialIdentities.append(item.identity)
  175|      0|            initialItemPaths.append(ItemPath(sectionIndex: i, itemIndex: j))
  176|      0|        }
  177|      0|    }
  178|      0|
  179|      0|    var initialItemData = ContiguousArray(initialItemCache.map { items in
  180|      0|        return ContiguousArray<ItemAssociatedData>(repeating: ItemAssociatedData.initial, count: items.count)
  181|      0|    })
  182|      0|
  183|      0|    var finalItemData = ContiguousArray(finalItemCache.map { items in
  184|      0|        return ContiguousArray<ItemAssociatedData>(repeating: ItemAssociatedData.initial, count: items.count)
  185|      0|    })
  186|      0|
  187|      0|    try initialIdentities.withUnsafeBufferPointer { (identitiesBuffer: UnsafeBufferPointer<Identity>) -> () in
  188|      0|        var dictionary: [OptimizedIdentity<Identity>: Int] = Dictionary(minimumCapacity: totalInitialItems * 2)
  189|      0|
  190|      0|        for i in 0 ..< initialIdentities.count {
  191|      0|            let identityPointer = identitiesBuffer.baseAddress!.advanced(by: i)
  192|      0|
  193|      0|            let key = OptimizedIdentity(identityPointer)
  194|      0|
  195|      0|            if let existingValueItemPathIndex = dictionary[key] {
  196|      0|                let itemPath = initialItemPaths[existingValueItemPathIndex]
  197|      0|                let item = initialItemCache[itemPath.sectionIndex][itemPath.itemIndex]
  198|      0|                #if DEBUG
  199|      0|                    print("Item \(item) has already been indexed at \(itemPath)" )
  200|      0|                #endif
  201|      0|                throw DifferentiatorError.duplicateItem(item: item)
  202|      0|            }
  203|      0|
  204|      0|            dictionary[key] = i
  205|      0|        }
  206|      0|
  207|      0|        for (i, items) in finalItemCache.enumerated() {
  208|      0|            for j in 0 ..< items.count {
  209|      0|                let item = items[j]
  210|      0|                var identity = item.identity
  211|      0|                let key = OptimizedIdentity(&identity)
  212|      0|                guard let initialItemPathIndex = dictionary[key] else {
  213|      0|                    continue
  214|      0|                }
  215|      0|                let itemPath = initialItemPaths[initialItemPathIndex]
  216|      0|                if initialItemData[itemPath.sectionIndex][itemPath.itemIndex].moveIndex != nil {
  217|      0|                    throw DifferentiatorError.duplicateItem(item: item)
  218|      0|                }
  219|      0|
  220|      0|                initialItemData[itemPath.sectionIndex][itemPath.itemIndex].moveIndex = ItemPath(sectionIndex: i, itemIndex: j)
  221|      0|                finalItemData[i][j].moveIndex = itemPath
  222|      0|            }
  223|      0|        }
  224|      0|
  225|      0|        return ()
  226|      0|    }
  227|      0|
  228|      0|    return (initialItemData, finalItemData)
  229|      0|}
  230|       |
  231|       |// } swift dictionary optimizations
  232|       |
  233|       |/*
  234|       |
  235|       |I've uncovered this case during random stress testing of logic.
  236|       |This is the hardest generic update case that causes two passes, first delete, and then move/insert
  237|       |
  238|       |[
  239|       |NumberSection(model: "1", items: [1111]),
  240|       |NumberSection(model: "2", items: [2222]),
  241|       |]
  242|       |
  243|       |[
  244|       |NumberSection(model: "2", items: [0]),
  245|       |NumberSection(model: "1", items: []),
  246|       |]
  247|       |
  248|       |If update is in the form
  249|       |
  250|       |* Move section from 2 to 1
  251|       |* Delete Items at paths 0 - 0, 1 - 0
  252|       |* Insert Items at paths 0 - 0
  253|       |
  254|       |or
  255|       |
  256|       |* Move section from 2 to 1
  257|       |* Delete Items at paths 0 - 0
  258|       |* Reload Items at paths 1 - 0
  259|       |
  260|       |or
  261|       |
  262|       |* Move section from 2 to 1
  263|       |* Delete Items at paths 0 - 0
  264|       |* Reload Items at paths 0 - 0
  265|       |
  266|       |it crashes table view.
  267|       |
  268|       |No matter what change is performed, it fails for me.
  269|       |If anyone knows how to make this work for one Changeset, PR is welcome.
  270|       |
  271|       |*/
  272|       |
  273|       |// If you are considering working out your own algorithm, these are tricky
  274|       |// transition cases that you can use.
  275|       |
  276|       |// case 1
  277|       |/*
  278|       |from = [
  279|       |    NumberSection(model: "section 4", items: [10, 11, 12]),
  280|       |    NumberSection(model: "section 9", items: [25, 26, 27]),
  281|       |]
  282|       |to = [
  283|       |    HashableSectionModel(model: "section 9", items: [11, 26, 27]),
  284|       |    HashableSectionModel(model: "section 4", items: [10, 12])
  285|       |]
  286|       |*/
  287|       |
  288|       |// case 2
  289|       |/*
  290|       |from = [
  291|       |    HashableSectionModel(model: "section 10", items: [26]),
  292|       |    HashableSectionModel(model: "section 7", items: [5, 29]),
  293|       |    HashableSectionModel(model: "section 1", items: [14]),
  294|       |    HashableSectionModel(model: "section 5", items: [16]),
  295|       |    HashableSectionModel(model: "section 4", items: []),
  296|       |    HashableSectionModel(model: "section 8", items: [3, 15, 19, 23]),
  297|       |    HashableSectionModel(model: "section 3", items: [20])
  298|       |]
  299|       |to = [
  300|       |    HashableSectionModel(model: "section 10", items: [26]),
  301|       |    HashableSectionModel(model: "section 1", items: [14]),
  302|       |    HashableSectionModel(model: "section 9", items: [3]),
  303|       |    HashableSectionModel(model: "section 5", items: [16, 8]),
  304|       |    HashableSectionModel(model: "section 8", items: [15, 19, 23]),
  305|       |    HashableSectionModel(model: "section 3", items: [20]),
  306|       |    HashableSectionModel(model: "Section 2", items: [7])
  307|       |]
  308|       |*/
  309|       |
  310|       |// case 3
  311|       |/*
  312|       |from = [
  313|       |    HashableSectionModel(model: "section 4", items: [5]),
  314|       |    HashableSectionModel(model: "section 6", items: [20, 14]),
  315|       |    HashableSectionModel(model: "section 9", items: []),
  316|       |    HashableSectionModel(model: "section 2", items: [2, 26]),
  317|       |    HashableSectionModel(model: "section 8", items: [23]),
  318|       |    HashableSectionModel(model: "section 10", items: [8, 18, 13]),
  319|       |    HashableSectionModel(model: "section 1", items: [28, 25, 6, 11, 10, 29, 24, 7, 19])
  320|       |]
  321|       |to = [
  322|       |    HashableSectionModel(model: "section 4", items: [5]),
  323|       |    HashableSectionModel(model: "section 6", items: [20, 14]),
  324|       |    HashableSectionModel(model: "section 9", items: [16]),
  325|       |    HashableSectionModel(model: "section 7", items: [17, 15, 4]),
  326|       |    HashableSectionModel(model: "section 2", items: [2, 26, 23]),
  327|       |    HashableSectionModel(model: "section 8", items: []),
  328|       |    HashableSectionModel(model: "section 10", items: [8, 18, 13]),
  329|       |    HashableSectionModel(model: "section 1", items: [28, 25, 6, 11, 10, 29, 24, 7, 19])
  330|       |]
  331|       |*/
  332|       |
  333|       |// Generates differential changes suitable for sectioned view consumption.
  334|       |// It will not only detect changes between two states, but it will also try to compress those changes into
  335|       |// almost minimal set of changes.
  336|       |//
  337|       |// I know, I know, it's ugly :( Totally agree, but this is the only general way I could find that works 100%, and
  338|       |// avoids UITableView quirks.
  339|       |//
  340|       |// Please take into consideration that I was also convinced about 20 times that I've found a simple general
  341|       |// solution, but then UITableView falls apart under stress testing :(
  342|       |//
  343|       |// Sincerely, if somebody else would present me this 250 lines of code, I would call him a mad man. I would think
  344|       |// that there has to be a simpler solution. Well, after 3 days, I'm not convinced any more :)
  345|       |//
  346|       |// Maybe it can be made somewhat simpler, but don't think it can be made much simpler.
  347|       |//
  348|       |// The algorithm could take anywhere from 1 to 3 table view transactions to finish the updates.
  349|       |//
  350|       |//  * stage 1 - remove deleted sections and items
  351|       |//  * stage 2 - move sections into place
  352|       |//  * stage 3 - fix moved and new items
  353|       |//
  354|       |// There maybe exists a better division, but time will tell.
  355|       |//
  356|       |public func differencesForSectionedView<S: AnimatableSectionModelType>(
  357|       |    initialSections: [S],
  358|       |    finalSections: [S])
  359|      0|    throws -> [Changeset<S>] {
  360|      0|    typealias I = S.Item
  361|      0|
  362|      0|    var result: [Changeset<S>] = []
  363|      0|
  364|      0|    var sectionCommands = try CommandGenerator<S>.generatorForInitialSections(initialSections, finalSections: finalSections)
  365|      0|
  366|      0|    result.append(contentsOf: try sectionCommands.generateDeleteSectionsDeletedItemsAndUpdatedItems())
  367|      0|    result.append(contentsOf: try sectionCommands.generateInsertAndMoveSections())
  368|      0|    result.append(contentsOf: try sectionCommands.generateInsertAndMovedItems())
  369|      0|
  370|      0|    return result
  371|      0|}
  372|       |
  373|       |
  374|       |@available(*, deprecated, renamed: "differencesForSectionedView(initialSections:finalSections:)")
  375|       |public func differencesForSectionedView<S: AnimatableSectionModelType>(
  376|       |    _ initialSections: [S],
  377|       |    finalSections: [S])
  378|      0|    throws -> [Changeset<S>] {
  379|      0|    return try differencesForSectionedView(initialSections: initialSections, finalSections: finalSections)
  380|      0|}
  381|       |
  382|       |private extension AnimatableSectionModelType {
  383|      0|    init(safeOriginal: Self, safeItems: [Item]) throws {
  384|      0|        self.init(original: safeOriginal, items: safeItems)
  385|      0|
  386|      0|        if self.items != safeItems || self.identity != safeOriginal.identity {
  387|      0|            throw DifferentiatorError.invalidInitializerImplementation(section: self, expectedItems: safeItems, expectedIdentifier: safeOriginal.identity)
  388|      0|        }
  389|      0|    }
  390|       |}
  391|       |
  392|       |fileprivate struct CommandGenerator<S: AnimatableSectionModelType> {
  393|       |    typealias Item = S.Item
  394|       |
  395|       |    let initialSections: [S]
  396|       |    let finalSections: [S]
  397|       |
  398|       |    let initialSectionData: ContiguousArray<SectionAssociatedData>
  399|       |    let finalSectionData: ContiguousArray<SectionAssociatedData>
  400|       |
  401|       |    let initialItemData: ContiguousArray<ContiguousArray<ItemAssociatedData>>
  402|       |    let finalItemData: ContiguousArray<ContiguousArray<ItemAssociatedData>>
  403|       |
  404|       |    let initialItemCache: ContiguousArray<ContiguousArray<Item>>
  405|       |    let finalItemCache: ContiguousArray<ContiguousArray<Item>>
  406|       |    
  407|       |    static func generatorForInitialSections(
  408|       |        _ initialSections: [S],
  409|       |        finalSections: [S]
  410|      0|    ) throws -> CommandGenerator<S> {
  411|      0|
  412|      0|        let (initialSectionData, finalSectionData) = try calculateSectionMovements(initialSections: initialSections, finalSections: finalSections)
  413|      0|
  414|      0|        let initialItemCache = ContiguousArray(initialSections.map {
  415|      0|            ContiguousArray($0.items)
  416|      0|        })
  417|      0|
  418|      0|        let finalItemCache = ContiguousArray(finalSections.map {
  419|      0|            ContiguousArray($0.items)
  420|      0|        })
  421|      0|        
  422|      0|        let (initialItemData, finalItemData) = try calculateItemMovements(
  423|      0|            initialItemCache: initialItemCache,
  424|      0|            finalItemCache: finalItemCache,
  425|      0|            initialSectionData: initialSectionData,
  426|      0|            finalSectionData: finalSectionData
  427|      0|        )
  428|      0|        
  429|      0|        return CommandGenerator<S>(
  430|      0|            initialSections: initialSections,
  431|      0|            finalSections: finalSections,
  432|      0|
  433|      0|            initialSectionData: initialSectionData,
  434|      0|            finalSectionData: finalSectionData,
  435|      0|
  436|      0|            initialItemData: initialItemData,
  437|      0|            finalItemData: finalItemData,
  438|      0|
  439|      0|            initialItemCache: initialItemCache,
  440|      0|            finalItemCache: finalItemCache
  441|      0|        )
  442|      0|    }
  443|       |
  444|       |    static func calculateItemMovements(
  445|       |        initialItemCache: ContiguousArray<ContiguousArray<Item>>,
  446|       |        finalItemCache: ContiguousArray<ContiguousArray<Item>>,
  447|       |        initialSectionData: ContiguousArray<SectionAssociatedData>,
  448|       |        finalSectionData: ContiguousArray<SectionAssociatedData>) throws
  449|      0|        -> (ContiguousArray<ContiguousArray<ItemAssociatedData>>, ContiguousArray<ContiguousArray<ItemAssociatedData>>) {
  450|      0|
  451|      0|        var (initialItemData, finalItemData) = try calculateAssociatedData(
  452|      0|            initialItemCache: initialItemCache,
  453|      0|            finalItemCache: finalItemCache
  454|      0|        )
  455|      0|
  456|      0|        let findNextUntouchedOldIndex = { (initialSectionIndex: Int, initialSearchIndex: Int?) -> Int? in
  457|      0|            guard var i2 = initialSearchIndex else {
  458|      0|                return nil
  459|      0|            }
  460|      0|
  461|      0|            while i2 < initialSectionData[initialSectionIndex].itemCount {
  462|      0|                if initialItemData[initialSectionIndex][i2].event == .untouched {
  463|      0|                    return i2
  464|      0|                }
  465|      0|
  466|      0|                i2 = i2 + 1
  467|      0|            }
  468|      0|
  469|      0|            return nil
  470|      0|        }
  471|      0|
  472|      0|        // first mark deleted items
  473|      0|        for i in 0 ..< initialItemCache.count {
  474|      0|            guard let _ = initialSectionData[i].moveIndex else {
  475|      0|                continue
  476|      0|            }
  477|      0|
  478|      0|            var indexAfterDelete = 0
  479|      0|            for j in 0 ..< initialItemCache[i].count {
  480|      0|
  481|      0|                guard let finalIndexPath = initialItemData[i][j].moveIndex else {
  482|      0|                    initialItemData[i][j].event = .deleted
  483|      0|                    continue
  484|      0|                }
  485|      0|
  486|      0|                // from this point below, section has to be move type because it's initial and not deleted
  487|      0|
  488|      0|                // because there is no move to inserted section
  489|      0|                if finalSectionData[finalIndexPath.sectionIndex].event == .inserted {
  490|      0|                    initialItemData[i][j].event = .deleted
  491|      0|                    continue
  492|      0|                }
  493|      0|
  494|      0|                initialItemData[i][j].indexAfterDelete = indexAfterDelete
  495|      0|                indexAfterDelete += 1
  496|      0|            }
  497|      0|        }
  498|      0|
  499|      0|        // mark moved or moved automatically
  500|      0|        for i in 0 ..< finalItemCache.count {
  501|      0|            guard let originalSectionIndex = finalSectionData[i].moveIndex else {
  502|      0|                continue
  503|      0|            }
  504|      0|
  505|      0|            var untouchedIndex: Int? = 0
  506|      0|            for j in 0 ..< finalItemCache[i].count {
  507|      0|                untouchedIndex = findNextUntouchedOldIndex(originalSectionIndex, untouchedIndex)
  508|      0|
  509|      0|                guard let originalIndex = finalItemData[i][j].moveIndex else {
  510|      0|                    finalItemData[i][j].event = .inserted
  511|      0|                    continue
  512|      0|                }
  513|      0|
  514|      0|                // In case trying to move from deleted section, abort, otherwise it will crash table view
  515|      0|                if initialSectionData[originalIndex.sectionIndex].event == .deleted {
  516|      0|                    finalItemData[i][j].event = .inserted
  517|      0|                    continue
  518|      0|                }
  519|      0|                // original section can't be inserted
  520|      0|                else if initialSectionData[originalIndex.sectionIndex].event == .inserted {
  521|      0|                    try rxPrecondition(false, "New section in initial sections, that is wrong")
  522|      0|                }
  523|      0|
  524|      0|                let initialSectionEvent = initialSectionData[originalIndex.sectionIndex].event
  525|      0|                try rxPrecondition(initialSectionEvent == .moved || initialSectionEvent == .movedAutomatically, "Section not moved")
  526|      0|
  527|      0|                let eventType = originalIndex == ItemPath(sectionIndex: originalSectionIndex, itemIndex: untouchedIndex ?? -1)
  528|      0|                    ? EditEvent.movedAutomatically : EditEvent.moved
  529|      0|
  530|      0|                initialItemData[originalIndex.sectionIndex][originalIndex.itemIndex].event = eventType
  531|      0|                finalItemData[i][j].event = eventType
  532|      0|            }
  533|      0|        }
  534|      0|
  535|      0|        return (initialItemData, finalItemData)
  536|      0|    }
  537|       |
  538|       |    static func calculateSectionMovements(initialSections: [S], finalSections: [S]) throws
  539|      0|        -> (ContiguousArray<SectionAssociatedData>, ContiguousArray<SectionAssociatedData>) {
  540|      0|
  541|      0|        let initialSectionIndexes = try indexSections(initialSections)
  542|      0|
  543|      0|        var initialSectionData = ContiguousArray<SectionAssociatedData>(repeating: SectionAssociatedData.initial, count: initialSections.count)
  544|      0|        var finalSectionData = ContiguousArray<SectionAssociatedData>(repeating: SectionAssociatedData.initial, count: finalSections.count)
  545|      0|
  546|      0|        for (i, section) in finalSections.enumerated() {
  547|      0|            finalSectionData[i].itemCount = finalSections[i].items.count
  548|      0|            guard let initialSectionIndex = initialSectionIndexes[section.identity] else {
  549|      0|                continue
  550|      0|            }
  551|      0|
  552|      0|            if initialSectionData[initialSectionIndex].moveIndex != nil {
  553|      0|                throw DifferentiatorError.duplicateSection(section: section)
  554|      0|            }
  555|      0|
  556|      0|            initialSectionData[initialSectionIndex].moveIndex = i
  557|      0|            finalSectionData[i].moveIndex = initialSectionIndex
  558|      0|        }
  559|      0|
  560|      0|        var sectionIndexAfterDelete = 0
  561|      0|
  562|      0|        // deleted sections
  563|      0|        for i in 0 ..< initialSectionData.count {
  564|      0|            initialSectionData[i].itemCount = initialSections[i].items.count
  565|      0|            if initialSectionData[i].moveIndex == nil {
  566|      0|                initialSectionData[i].event = .deleted
  567|      0|                continue
  568|      0|            }
  569|      0|
  570|      0|            initialSectionData[i].indexAfterDelete = sectionIndexAfterDelete
  571|      0|            sectionIndexAfterDelete += 1
  572|      0|        }
  573|      0|
  574|      0|        // moved sections
  575|      0|
  576|      0|        var untouchedOldIndex: Int? = 0
  577|      0|        let findNextUntouchedOldIndex = { (initialSearchIndex: Int?) -> Int? in
  578|      0|            guard var i = initialSearchIndex else {
  579|      0|                return nil
  580|      0|            }
  581|      0|
  582|      0|            while i < initialSections.count {
  583|      0|                if initialSectionData[i].event == .untouched {
  584|      0|                    return i
  585|      0|                }
  586|      0|
  587|      0|                i = i + 1
  588|      0|            }
  589|      0|
  590|      0|            return nil
  591|      0|        }
  592|      0|
  593|      0|        // inserted and moved sections {
  594|      0|        // this should fix all sections and move them into correct places
  595|      0|        // 2nd stage
  596|      0|        for i in 0 ..< finalSections.count {
  597|      0|            untouchedOldIndex = findNextUntouchedOldIndex(untouchedOldIndex)
  598|      0|
  599|      0|            // oh, it did exist
  600|      0|            if let oldSectionIndex = finalSectionData[i].moveIndex {
  601|      0|                let moveType = oldSectionIndex != untouchedOldIndex ? EditEvent.moved : EditEvent.movedAutomatically
  602|      0|
  603|      0|                finalSectionData[i].event = moveType
  604|      0|                initialSectionData[oldSectionIndex].event = moveType
  605|      0|            }
  606|      0|            else {
  607|      0|                finalSectionData[i].event = .inserted
  608|      0|            }
  609|      0|        }
  610|      0|
  611|      0|        // inserted sections
  612|      0|        for (i, section) in finalSectionData.enumerated() {
  613|      0|            if section.moveIndex == nil {
  614|      0|                _ = finalSectionData[i].event == .inserted
  615|      0|            }
  616|      0|        }
  617|      0|        
  618|      0|        return (initialSectionData, finalSectionData)
  619|      0|    }
  620|       |
  621|      0|    mutating func generateDeleteSectionsDeletedItemsAndUpdatedItems() throws -> [Changeset<S>] {
  622|      0|        var deletedSections = [Int]()
  623|      0|
  624|      0|        var deletedItems = [ItemPath]()
  625|      0|        var updatedItems = [ItemPath]()
  626|      0|
  627|      0|        var afterDeleteState = [S]()
  628|      0|
  629|      0|        // mark deleted items {
  630|      0|        // 1rst stage again (I know, I know ...)
  631|      0|        for (i, initialItems) in initialItemCache.enumerated() {
  632|      0|            let event = initialSectionData[i].event
  633|      0|
  634|      0|            // Deleted section will take care of deleting child items.
  635|      0|            // In case of moving an item from deleted section, tableview will
  636|      0|            // crash anyway, so this is not limiting anything.
  637|      0|            if event == .deleted {
  638|      0|                deletedSections.append(i)
  639|      0|                continue
  640|      0|            }
  641|      0|
  642|      0|            var afterDeleteItems: [S.Item] = []
  643|      0|            for j in 0 ..< initialItems.count {
  644|      0|                let event = initialItemData[i][j].event
  645|      0|                switch event {
  646|      0|                case .deleted:
  647|      0|                    deletedItems.append(ItemPath(sectionIndex: i, itemIndex: j))
  648|      0|                case .moved, .movedAutomatically:
  649|      0|                    let finalItemIndex = try initialItemData[i][j].moveIndex.unwrap()
  650|      0|                    let finalItem = finalItemCache[finalItemIndex.sectionIndex][finalItemIndex.itemIndex]
  651|      0|                    if finalItem != initialSections[i].items[j] {
  652|      0|                        updatedItems.append(ItemPath(sectionIndex: i, itemIndex: j))
  653|      0|                    }
  654|      0|                    afterDeleteItems.append(finalItem)
  655|      0|                default:
  656|      0|                    try rxPrecondition(false, "Unhandled case")
  657|      0|                }
  658|      0|            }
  659|      0|
  660|      0|            afterDeleteState.append(try S(safeOriginal: initialSections[i], safeItems: afterDeleteItems))
  661|      0|        }
  662|      0|        // }
  663|      0|
  664|      0|        if deletedItems.count == 0 && deletedSections.count == 0 && updatedItems.count == 0 {
  665|      0|            return []
  666|      0|        }
  667|      0|
  668|      0|        return [Changeset(
  669|      0|            finalSections: afterDeleteState,
  670|      0|            deletedSections: deletedSections,
  671|      0|            deletedItems: deletedItems,
  672|      0|            updatedItems: updatedItems
  673|      0|        )]
  674|      0|    }
  675|       |
  676|      0|    func generateInsertAndMoveSections() throws -> [Changeset<S>] {
  677|      0|
  678|      0|        var movedSections = [(from: Int, to: Int)]()
  679|      0|        var insertedSections = [Int]()
  680|      0|
  681|      0|        for i in 0 ..< initialSections.count {
  682|      0|            switch initialSectionData[i].event {
  683|      0|            case .deleted:
  684|      0|                break
  685|      0|            case .moved:
  686|      0|                movedSections.append((from: try initialSectionData[i].indexAfterDelete.unwrap(), to: try initialSectionData[i].moveIndex.unwrap()))
  687|      0|            case .movedAutomatically:
  688|      0|                break
  689|      0|            default:
  690|      0|                try rxPrecondition(false, "Unhandled case in initial sections")
  691|      0|            }
  692|      0|        }
  693|      0|
  694|      0|        for i in 0 ..< finalSections.count {
  695|      0|            switch finalSectionData[i].event {
  696|      0|            case .inserted:
  697|      0|                insertedSections.append(i)
  698|      0|            default:
  699|      0|                break
  700|      0|            }
  701|      0|        }
  702|      0|
  703|      0|        if insertedSections.count ==  0 && movedSections.count == 0 {
  704|      0|            return []
  705|      0|        }
  706|      0|
  707|      0|        // sections should be in place, but items should be original without deleted ones
  708|      0|        let sectionsAfterChange: [S] = try self.finalSections.enumerated().map { i, s -> S in
  709|      0|            let event = self.finalSectionData[i].event
  710|      0|            
  711|      0|            if event == .inserted {
  712|      0|                // it's already set up
  713|      0|                return s
  714|      0|            }
  715|      0|            else if event == .moved || event == .movedAutomatically {
  716|      0|                let originalSectionIndex = try finalSectionData[i].moveIndex.unwrap()
  717|      0|                let originalSection = initialSections[originalSectionIndex]
  718|      0|                
  719|      0|                var items: [S.Item] = []
  720|      0|                items.reserveCapacity(originalSection.items.count)
  721|      0|                let itemAssociatedData = self.initialItemData[originalSectionIndex]
  722|      0|                for j in 0 ..< originalSection.items.count {
  723|      0|                    let initialData = itemAssociatedData[j]
  724|      0|
  725|      0|                    guard initialData.event != .deleted else {
  726|      0|                        continue
  727|      0|                    }
  728|      0|
  729|      0|                    guard let finalIndex = initialData.moveIndex else {
  730|      0|                        try rxPrecondition(false, "Item was moved, but no final location.")
  731|      0|                        continue
  732|      0|                    }
  733|      0|
  734|      0|                    items.append(finalItemCache[finalIndex.sectionIndex][finalIndex.itemIndex])
  735|      0|                }
  736|      0|                
  737|      0|                let modifiedSection = try S(safeOriginal: s, safeItems: items)
  738|      0|
  739|      0|                return modifiedSection
  740|      0|            }
  741|      0|            else {
  742|      0|                try rxPrecondition(false, "This is weird, this shouldn't happen")
  743|      0|                return s
  744|      0|            }
  745|      0|        }
  746|      0|
  747|      0|        return [Changeset(
  748|      0|            finalSections: sectionsAfterChange,
  749|      0|            insertedSections:  insertedSections,
  750|      0|            movedSections: movedSections
  751|      0|        )]
  752|      0|    }
  753|       |
  754|      0|    mutating func generateInsertAndMovedItems() throws -> [Changeset<S>] {
  755|      0|        var insertedItems = [ItemPath]()
  756|      0|        var movedItems = [(from: ItemPath, to: ItemPath)]()
  757|      0|
  758|      0|        // mark new and moved items {
  759|      0|        // 3rd stage
  760|      0|        for i in 0 ..< finalSections.count {
  761|      0|            let finalSection = finalSections[i]
  762|      0|            
  763|      0|            let sectionEvent = finalSectionData[i].event
  764|      0|            // new and deleted sections cause reload automatically
  765|      0|            if sectionEvent != .moved && sectionEvent != .movedAutomatically {
  766|      0|                continue
  767|      0|            }
  768|      0|            
  769|      0|            for j in 0 ..< finalSection.items.count {
  770|      0|                let currentItemEvent = finalItemData[i][j].event
  771|      0|                
  772|      0|                try rxPrecondition(currentItemEvent != .untouched, "Current event is not untouched")
  773|      0|
  774|      0|                let event = finalItemData[i][j].event
  775|      0|
  776|      0|                switch event {
  777|      0|                case .inserted:
  778|      0|                    insertedItems.append(ItemPath(sectionIndex: i, itemIndex: j))
  779|      0|                case .moved:
  780|      0|                    let originalIndex = try finalItemData[i][j].moveIndex.unwrap()
  781|      0|                    let finalSectionIndex = try initialSectionData[originalIndex.sectionIndex].moveIndex.unwrap()
  782|      0|                    let moveFromItemWithIndex = try initialItemData[originalIndex.sectionIndex][originalIndex.itemIndex].indexAfterDelete.unwrap()
  783|      0|
  784|      0|                    let moveCommand = (
  785|      0|                        from: ItemPath(sectionIndex: finalSectionIndex, itemIndex: moveFromItemWithIndex),
  786|      0|                        to: ItemPath(sectionIndex: i, itemIndex: j)
  787|      0|                    )
  788|      0|                    movedItems.append(moveCommand)
  789|      0|                default:
  790|      0|                    break
  791|      0|                }
  792|      0|            }
  793|      0|        }
  794|      0|        // }
  795|      0|
  796|      0|        if insertedItems.count == 0 && movedItems.count == 0 {
  797|      0|            return []
  798|      0|        }
  799|      0|        return [Changeset(
  800|      0|            finalSections: finalSections,
  801|      0|            insertedItems: insertedItems,
  802|      0|            movedItems: movedItems
  803|      0|        )]
  804|      0|    }
  805|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/FloatingPointType+IdentifiableType.swift:
    1|       |//
    2|       |//  FloatingPointType+IdentifiableType.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension FloatingPoint {
   12|       |    typealias identity = Self
   13|       |
   14|      0|    public var identity: Self {
   15|      0|        return self
   16|      0|    }
   17|       |}
   18|       |
   19|       |extension Float : IdentifiableType {
   20|       |
   21|       |}
   22|       |
   23|       |extension Double : IdentifiableType {
   24|       |
   25|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/IdentifiableValue.swift:
    1|       |//
    2|       |//  IdentifiableValue.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 1/7/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct IdentifiableValue<Value: Hashable> {
   12|       |    public let value: Value
   13|       |}
   14|       |
   15|       |extension IdentifiableValue
   16|       |    : IdentifiableType {
   17|       |
   18|       |    public typealias Identity = Value
   19|       |
   20|      0|    public var identity : Identity {
   21|      0|        return value
   22|      0|    }
   23|       |}
   24|       |
   25|       |extension IdentifiableValue
   26|       |    : Equatable
   27|       |    , CustomStringConvertible
   28|       |    , CustomDebugStringConvertible {
   29|       |
   30|      0|    public var description: String {
   31|      0|        return "\(value)"
   32|      0|    }
   33|       |
   34|      0|    public var debugDescription: String {
   35|      0|        return "\(value)"
   36|      0|    }
   37|       |}
   38|       |
   39|      0|public func == <V: Hashable>(lhs: IdentifiableValue<V>, rhs: IdentifiableValue<V>) -> Bool {
   40|      0|    return lhs.value == rhs.value
   41|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/IntegerType+IdentifiableType.swift:
    1|       |//
    2|       |//  IntegerType+IdentifiableType.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Integer {
   12|       |    typealias identity = Self
   13|       |
   14|      0|    public var identity: Self {
   15|      0|        return self
   16|      0|    }
   17|       |}
   18|       |
   19|       |extension Int : IdentifiableType {
   20|       |
   21|       |}
   22|       |
   23|       |extension Int8 : IdentifiableType {
   24|       |
   25|       |}
   26|       |
   27|       |extension Int16 : IdentifiableType {
   28|       |
   29|       |}
   30|       |
   31|       |extension Int32 : IdentifiableType {
   32|       |
   33|       |}
   34|       |
   35|       |extension Int64 : IdentifiableType {
   36|       |
   37|       |}
   38|       |
   39|       |
   40|       |extension UInt : IdentifiableType {
   41|       |
   42|       |}
   43|       |
   44|       |extension UInt8 : IdentifiableType {
   45|       |
   46|       |}
   47|       |
   48|       |extension UInt16 : IdentifiableType {
   49|       |
   50|       |}
   51|       |
   52|       |extension UInt32 : IdentifiableType {
   53|       |
   54|       |}
   55|       |
   56|       |extension UInt64 : IdentifiableType {
   57|       |    
   58|       |}
   59|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/ItemPath.swift:
    1|       |//
    2|       |//  ItemPath.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 1/9/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct ItemPath {
   12|       |    public let sectionIndex: Int
   13|       |    public let itemIndex: Int
   14|       |
   15|      0|    public init(sectionIndex: Int, itemIndex: Int) {
   16|      0|        self.sectionIndex = sectionIndex
   17|      0|        self.itemIndex = itemIndex
   18|      0|    }
   19|       |}
   20|       |
   21|       |extension ItemPath : Equatable {
   22|       |    
   23|       |}
   24|       |
   25|      0|public func == (lhs: ItemPath, rhs: ItemPath) -> Bool {
   26|      0|    return lhs.sectionIndex == rhs.sectionIndex && lhs.itemIndex == rhs.itemIndex
   27|      0|}
   28|       |
   29|       |extension ItemPath: Hashable {
   30|       |
   31|      0|    public var hashValue: Int {
   32|      0|        return sectionIndex.byteSwapped.hashValue ^ itemIndex.hashValue
   33|      0|    }
   34|       |    
   35|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/Optional+Extensions.swift:
    1|       |//
    2|       |//  Optional+Extensions.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 1/8/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension Optional {
   12|      0|    func unwrap() throws -> Wrapped {
   13|      0|        if let unwrapped = self {
   14|      0|            return unwrapped
   15|      0|        }
   16|      0|        else {
   17|      0|            rxDebugFatalError("Error during unwrapping optional")
   18|      0|            throw RxDataSourceError.unwrappingOptional
   19|      0|        }
   20|      0|   }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/SectionModel.swift:
    1|       |//
    2|       |//  SectionModel.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/16/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |public struct SectionModel<Section, ItemType> {
   12|       |    public var model: Section
   13|       |    public var items: [Item]
   14|       |
   15|    498|    public init(model: Section, items: [Item]) {
   16|    498|        self.model = model
   17|    498|        self.items = items
   18|    498|    }
   19|       |}
   20|       |
   21|       |extension SectionModel
   22|       |    : SectionModelType {
   23|       |    public typealias Identity = Section
   24|       |    public typealias Item = ItemType
   25|       |    
   26|      0|    public var identity: Section {
   27|      0|        return model
   28|      0|    }
   29|       |}
   30|       |
   31|       |extension SectionModel
   32|       |    : CustomStringConvertible {
   33|       |
   34|      0|    public var description: String {
   35|      0|        return "\(self.model) > \(items)"
   36|      0|    }
   37|       |}
   38|       |
   39|       |extension SectionModel {
   40|      0|    public init(original: SectionModel<Section, Item>, items: [Item]) {
   41|      0|        self.model = original.model
   42|      0|        self.items = items
   43|      0|    }
   44|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/String+IdentifiableType.swift:
    1|       |//
    2|       |//  String+IdentifiableType.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |
   11|       |extension String : IdentifiableType {
   12|       |    public typealias Identity = String
   13|       |
   14|      0|    public var identity: String {
   15|      0|        return self
   16|      0|    }
   17|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/TableViewSectionedDataSource.swift:
    1|       |//
    2|       |//  TableViewSectionedDataSource.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |#if !RX_NO_MODULE
   12|       |import RxCocoa
   13|       |#endif
   14|       |
   15|       |// objc monkey business
   16|       |open class _TableViewSectionedDataSource
   17|       |    : NSObject
   18|       |    , UITableViewDataSource {
   19|       |    
   20|      0|    open func _rx_numberOfSections(in tableView: UITableView) -> Int {
   21|      0|        return 1
   22|      0|    }
   23|       |    
   24|     42|    open func numberOfSections(in tableView: UITableView) -> Int {
   25|     42|        return _rx_numberOfSections(in: tableView)
   26|     42|    }
   27|       |
   28|      0|    open func _rx_tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   29|      0|        return 0
   30|      0|    }
   31|       |    
   32|    228|    open func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   33|    228|        return _rx_tableView(tableView, numberOfRowsInSection: section)
   34|    228|    }
   35|       |
   36|      0|    open func _rx_tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   37|      0|        return (nil as UITableViewCell?)!
   38|      0|    }
   39|       |    
   40|      0|    open func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   41|      0|        return _rx_tableView(tableView, cellForRowAt: indexPath)
   42|      0|    }
   43|       |
   44|      0|    open func _rx_tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
   45|      0|        return nil
   46|      0|    }
   47|       |    
   48|    228|    open func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
   49|    228|        return _rx_tableView(tableView, titleForHeaderInSection: section)
   50|    228|    }
   51|       |
   52|      0|    open func _rx_tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String? {
   53|      0|        return nil
   54|      0|    }
   55|       |    
   56|    228|    open func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String? {
   57|    228|        return _rx_tableView(tableView, titleForFooterInSection: section)
   58|    228|    }
   59|       |    
   60|      0|    open func _rx_tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
   61|      0|        return false
   62|      0|    }
   63|       |    
   64|      0|    open func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
   65|      0|        return _rx_tableView(tableView, canEditRowAt: indexPath)
   66|      0|    }
   67|       |    
   68|      0|    open func _rx_tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
   69|      0|        return false
   70|      0|    }
   71|       |    
   72|      0|    open func tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
   73|      0|        return _rx_tableView(tableView, canMoveRowAt: indexPath)
   74|      0|    }
   75|       |
   76|       |    #if os(iOS)
   77|     42|    open func _rx_sectionIndexTitles(for tableView: UITableView) -> [String]? {
   78|     42|        return nil
   79|     42|    }
   80|       |    
   81|     42|    open func sectionIndexTitles(for tableView: UITableView) -> [String]? {
   82|     42|        return _rx_sectionIndexTitles(for: tableView)
   83|     42|    }
   84|       |
   85|      0|    open func _rx_tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int {
   86|      0|        return 0
   87|      0|    }
   88|       |
   89|      0|    open func tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int {
   90|      0|        return _rx_tableView(tableView, sectionForSectionIndexTitle: title, at: index)
   91|      0|    }
   92|       |    #endif
   93|       |
   94|      0|    open func _rx_tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
   95|      0|    }
   96|       |
   97|      0|    open func tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
   98|      0|        _rx_tableView(tableView, moveRowAt: sourceIndexPath, to: destinationIndexPath)
   99|      0|    }
  100|       |
  101|       |}
  102|       |
  103|       |open class TableViewSectionedDataSource<S: SectionModelType>
  104|       |    : _TableViewSectionedDataSource
  105|       |    , SectionedViewDataSourceType {
  106|       |    
  107|       |    public typealias I = S.Item
  108|       |    public typealias Section = S
  109|       |    public typealias CellFactory = (TableViewSectionedDataSource<S>, UITableView, IndexPath, I) -> UITableViewCell
  110|       |
  111|       |    #if DEBUG
  112|       |    // If data source has already been bound, then mutating it
  113|       |    // afterwards isn't something desired.
  114|       |    // This simulates immutability after binding
  115|       |    var _dataSourceBound: Bool = false
  116|       |
  117|      4|    private func ensureNotMutatedAfterBinding() {
  118|      4|        assert(!_dataSourceBound, "Data source is already bound. Please write this line before binding call (`bindTo`, `drive`). Data source must first be completely configured, and then bound after that, otherwise there could be runtime bugs, glitches, or partial malfunctions.")
  119|      4|    }
  120|       |    
  121|       |    #endif
  122|       |
  123|       |    // This structure exists because model can be mutable
  124|       |    // In that case current state value should be preserved.
  125|       |    // The state that needs to be preserved is ordering of items in section
  126|       |    // and their relationship with section.
  127|       |    // If particular item is mutable, that is irrelevant for this logic to function
  128|       |    // properly.
  129|       |    public typealias SectionModelSnapshot = SectionModel<S, I>
  130|       |    
  131|       |    private var _sectionModels: [SectionModelSnapshot] = []
  132|       |
  133|      0|    open var sectionModels: [S] {
  134|      0|        return _sectionModels.map { Section(original: $0.model, items: $0.items) }
  135|      0|    }
  136|       |
  137|      0|    open subscript(section: Int) -> S {
  138|      0|        let sectionModel = self._sectionModels[section]
  139|      0|        return S(original: sectionModel.model, items: sectionModel.items)
  140|      0|    }
  141|       |
  142|       |    open subscript(indexPath: IndexPath) -> I {
  143|      0|        get {
  144|      0|            return self._sectionModels[indexPath.section].items[indexPath.item]
  145|      0|        }
  146|      0|        set(item) {
  147|      0|            var section = self._sectionModels[indexPath.section]
  148|      0|            section.items[indexPath.item] = item
  149|      0|            self._sectionModels[indexPath.section] = section
  150|      0|        }
  151|       |    }
  152|       |
  153|      0|    open func model(at indexPath: IndexPath) throws -> Any {
  154|      0|        return self[indexPath]
  155|      0|    }
  156|       |
  157|     37|    open func setSections(_ sections: [S]) {
  158|    222|        self._sectionModels = sections.map { SectionModelSnapshot(model: $0, items: $0.items) }
  159|     37|    }
  160|       |
  161|       |    open var configureCell: CellFactory! = nil {
  162|      4|        didSet {
  163|      4|            #if DEBUG
  164|      4|                ensureNotMutatedAfterBinding()
  165|      4|            #endif
  166|      4|        }
  167|       |    }
  168|       |    
  169|       |    open var titleForHeaderInSection: ((TableViewSectionedDataSource<S>, Int) -> String?)? {
  170|      0|        didSet {
  171|      0|            #if DEBUG
  172|      0|                ensureNotMutatedAfterBinding()
  173|      0|            #endif
  174|      0|        }
  175|       |    }
  176|       |    open var titleForFooterInSection: ((TableViewSectionedDataSource<S>, Int) -> String?)? {
  177|      0|        didSet {
  178|      0|            #if DEBUG
  179|      0|                ensureNotMutatedAfterBinding()
  180|      0|            #endif
  181|      0|        }
  182|       |    }
  183|       |    
  184|       |    open var canEditRowAtIndexPath: ((TableViewSectionedDataSource<S>, IndexPath) -> Bool)? {
  185|      0|        didSet {
  186|      0|            #if DEBUG
  187|      0|                ensureNotMutatedAfterBinding()
  188|      0|            #endif
  189|      0|        }
  190|       |    }
  191|       |    open var canMoveRowAtIndexPath: ((TableViewSectionedDataSource<S>, IndexPath) -> Bool)? {
  192|      0|        didSet {
  193|      0|            #if DEBUG
  194|      0|                ensureNotMutatedAfterBinding()
  195|      0|            #endif
  196|      0|        }
  197|       |    }
  198|       |
  199|       |    open var rowAnimation: UITableViewRowAnimation = .automatic
  200|       |
  201|       |    #if os(iOS)
  202|       |    open var sectionIndexTitles: ((TableViewSectionedDataSource<S>) -> [String]?)? {
  203|      0|        didSet {
  204|      0|            #if DEBUG
  205|      0|            ensureNotMutatedAfterBinding()
  206|      0|            #endif
  207|      0|        }
  208|       |    }
  209|       |    open var sectionForSectionIndexTitle:((TableViewSectionedDataSource<S>, _ title: String, _ index: Int) -> Int)? {
  210|      0|        didSet {
  211|      0|            #if DEBUG
  212|      0|            ensureNotMutatedAfterBinding()
  213|      0|            #endif
  214|      0|        }
  215|       |    }
  216|       |    #endif
  217|       |    
  218|      5|    public override init() {
  219|      5|        super.init()
  220|      0|        self.configureCell = { [weak self] _ in
  221|      0|            if let strongSelf = self {
  222|      0|                precondition(false, "There is a minor problem. `cellFactory` property on \(strongSelf) was not set. Please set it manually, or use one of the `rx_bindTo` methods.")
  223|      0|            }
  224|      0|            
  225|      0|            return (nil as UITableViewCell!)!
  226|      0|        }
  227|      5|    }
  228|       |    
  229|       |    // UITableViewDataSource
  230|       |    
  231|     42|    open override func _rx_numberOfSections(in tableView: UITableView) -> Int {
  232|     42|        return _sectionModels.count
  233|     42|    }
  234|       |    
  235|    228|    open override func _rx_tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
  236|    228|        return _sectionModels[section].items.count
  237|    228|    }
  238|       |    
  239|      0|    open override func _rx_tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
  240|      0|        precondition(indexPath.item < _sectionModels[indexPath.section].items.count)
  241|      0|        
  242|      0|        return configureCell(self, tableView, indexPath, self[indexPath])
  243|      0|    }
  244|       |    
  245|    228|    open override func _rx_tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
  246|    228|        return titleForHeaderInSection?(self, section)
  247|    228|    }
  248|       |    
  249|    228|    open override func _rx_tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -> String? {
  250|    228|        return titleForFooterInSection?(self, section)
  251|    228|    }
  252|       |    
  253|      0|    open override func _rx_tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -> Bool {
  254|      0|        guard let canEditRow = canEditRowAtIndexPath?(self, indexPath) else {
  255|      0|            return super._rx_tableView(tableView, canEditRowAt: indexPath)
  256|      0|        }
  257|      0|        
  258|      0|        return canEditRow
  259|      0|    }
  260|       |   
  261|      0|    open override func _rx_tableView(_ tableView: UITableView, canMoveRowAt indexPath: IndexPath) -> Bool {
  262|      0|        guard let canMoveRow = canMoveRowAtIndexPath?(self, indexPath) else {
  263|      0|            return super._rx_tableView(tableView, canMoveRowAt: indexPath)
  264|      0|        }
  265|      0|        
  266|      0|        return canMoveRow
  267|      0|    }
  268|       |
  269|      0|    open override func _rx_tableView(_ tableView: UITableView, moveRowAt sourceIndexPath: IndexPath, to destinationIndexPath: IndexPath) {
  270|      0|        self._sectionModels.moveFromSourceIndexPath(sourceIndexPath, destinationIndexPath: destinationIndexPath)
  271|      0|    }
  272|       |
  273|       |    #if os(iOS)
  274|     42|    open override func _rx_sectionIndexTitles(for tableView: UITableView) -> [String]? {
  275|     42|        guard let titles = sectionIndexTitles?(self) else {
  276|     42|            return super._rx_sectionIndexTitles(for: tableView)
  277|      0|        }
  278|      0|        
  279|      0|        return titles
  280|     42|    }
  281|       |    
  282|      0|    open override func _rx_tableView(_ tableView: UITableView, sectionForSectionIndexTitle title: String, at index: Int) -> Int {
  283|      0|        guard let section = sectionForSectionIndexTitle?(self, title, index) else {
  284|      0|            return super._rx_tableView(tableView, sectionForSectionIndexTitle: title, at: index)
  285|      0|        }
  286|      0|        
  287|      0|        return section
  288|      0|    }
  289|       |    #endif
  290|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxDataSources/Sources/DataSources/UI+SectionedViewType.swift:
    1|       |//
    2|       |//  UI+SectionedViewType.swift
    3|       |//  RxDataSources
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Foundation
   10|       |import UIKit
   11|       |
   12|      0|func indexSet(_ values: [Int]) -> IndexSet {
   13|      0|    let indexSet = NSMutableIndexSet()
   14|      0|    for i in values {
   15|      0|        indexSet.add(i)
   16|      0|    }
   17|      0|    return indexSet as IndexSet
   18|      0|}
   19|       |
   20|       |extension UITableView : SectionedViewType {
   21|       |  
   22|      0|    public func insertItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation) {
   23|      0|        self.insertRows(at: paths, with: animationStyle)
   24|      0|    }
   25|       |    
   26|      0|    public func deleteItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation) {
   27|      0|        self.deleteRows(at: paths, with: animationStyle)
   28|      0|    }
   29|       |    
   30|      0|    public func moveItemAtIndexPath(_ from: IndexPath, to: IndexPath) {
   31|      0|        self.moveRow(at: from, to: to)
   32|      0|    }
   33|       |    
   34|      0|    public func reloadItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation) {
   35|      0|        self.reloadRows(at: paths, with: animationStyle)
   36|      0|    }
   37|       |    
   38|      0|    public func insertSections(_ sections: [Int], animationStyle: UITableViewRowAnimation) {
   39|      0|        self.insertSections(indexSet(sections), with: animationStyle)
   40|      0|    }
   41|       |    
   42|      0|    public func deleteSections(_ sections: [Int], animationStyle: UITableViewRowAnimation) {
   43|      0|        self.deleteSections(indexSet(sections), with: animationStyle)
   44|      0|    }
   45|       |    
   46|      0|    public func moveSection(_ from: Int, to: Int) {
   47|      0|        self.moveSection(from, toSection: to)
   48|      0|    }
   49|       |    
   50|      0|    public func reloadSections(_ sections: [Int], animationStyle: UITableViewRowAnimation) {
   51|      0|        self.reloadSections(indexSet(sections), with: animationStyle)
   52|      0|    }
   53|       |
   54|      0|  public func performBatchUpdates<S: SectionModelType>(_ changes: Changeset<S>, animationConfiguration: AnimationConfiguration) {
   55|      0|        self.beginUpdates()
   56|      0|        _performBatchUpdates(self, changes: changes, animationConfiguration: animationConfiguration)
   57|      0|        self.endUpdates()
   58|      0|    }
   59|       |}
   60|       |
   61|       |extension UICollectionView : SectionedViewType {
   62|      0|    public func insertItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation) {
   63|      0|        self.insertItems(at: paths)
   64|      0|    }
   65|       |    
   66|      0|    public func deleteItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation) {
   67|      0|        self.deleteItems(at: paths)
   68|      0|    }
   69|       |
   70|      0|    public func moveItemAtIndexPath(_ from: IndexPath, to: IndexPath) {
   71|      0|        self.moveItem(at: from, to: to)
   72|      0|    }
   73|       |    
   74|      0|    public func reloadItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation) {
   75|      0|        self.reloadItems(at: paths)
   76|      0|    }
   77|       |    
   78|      0|    public func insertSections(_ sections: [Int], animationStyle: UITableViewRowAnimation) {
   79|      0|        self.insertSections(indexSet(sections))
   80|      0|    }
   81|       |    
   82|      0|    public func deleteSections(_ sections: [Int], animationStyle: UITableViewRowAnimation) {
   83|      0|        self.deleteSections(indexSet(sections))
   84|      0|    }
   85|       |    
   86|      0|    public func moveSection(_ from: Int, to: Int) {
   87|      0|        self.moveSection(from, toSection: to)
   88|      0|    }
   89|       |    
   90|      0|    public func reloadSections(_ sections: [Int], animationStyle: UITableViewRowAnimation) {
   91|      0|        self.reloadSections(indexSet(sections))
   92|      0|    }
   93|       |    
   94|      0|  public func performBatchUpdates<S: SectionModelType>(_ changes: Changeset<S>, animationConfiguration: AnimationConfiguration) {
   95|      0|        self.performBatchUpdates({ () -> Void in
   96|      0|            _performBatchUpdates(self, changes: changes, animationConfiguration: animationConfiguration)
   97|      0|        }, completion: { (completed: Bool) -> Void in
   98|      0|        })
   99|      0|    }
  100|       |}
  101|       |
  102|       |public protocol SectionedViewType {
  103|       |    func insertItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation)
  104|       |    func deleteItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation)
  105|       |    func moveItemAtIndexPath(_ from: IndexPath, to: IndexPath)
  106|       |    func reloadItemsAtIndexPaths(_ paths: [IndexPath], animationStyle: UITableViewRowAnimation)
  107|       |    
  108|       |    func insertSections(_ sections: [Int], animationStyle: UITableViewRowAnimation)
  109|       |    func deleteSections(_ sections: [Int], animationStyle: UITableViewRowAnimation)
  110|       |    func moveSection(_ from: Int, to: Int)
  111|       |    func reloadSections(_ sections: [Int], animationStyle: UITableViewRowAnimation)
  112|       |
  113|       |    func performBatchUpdates<S>(_ changes: Changeset<S>, animationConfiguration: AnimationConfiguration)
  114|       |}
  115|       |
  116|      0|func _performBatchUpdates<V: SectionedViewType, S: SectionModelType>(_ view: V, changes: Changeset<S>, animationConfiguration:AnimationConfiguration) {
  117|      0|    typealias I = S.Item
  118|      0|  
  119|      0|    view.deleteSections(changes.deletedSections, animationStyle: animationConfiguration.deleteAnimation)
  120|      0|    // Updated sections doesn't mean reload entire section, somebody needs to update the section view manually
  121|      0|    // otherwise all cells will be reloaded for nothing.
  122|      0|    //view.reloadSections(changes.updatedSections, animationStyle: rowAnimation)
  123|      0|    view.insertSections(changes.insertedSections, animationStyle: animationConfiguration.insertAnimation)
  124|      0|    for (from, to) in changes.movedSections {
  125|      0|        view.moveSection(from, to: to)
  126|      0|    }
  127|      0|    
  128|      0|    view.deleteItemsAtIndexPaths(
  129|      0|        changes.deletedItems.map { IndexPath(item: $0.itemIndex, section: $0.sectionIndex) },
  130|      0|        animationStyle: animationConfiguration.deleteAnimation
  131|      0|    )
  132|      0|    view.insertItemsAtIndexPaths(
  133|      0|        changes.insertedItems.map { IndexPath(item: $0.itemIndex, section: $0.sectionIndex) },
  134|      0|        animationStyle: animationConfiguration.insertAnimation
  135|      0|    )
  136|      0|    view.reloadItemsAtIndexPaths(
  137|      0|        changes.updatedItems.map { IndexPath(item: $0.itemIndex, section: $0.sectionIndex) },
  138|      0|        animationStyle: animationConfiguration.reloadAnimation
  139|      0|    )
  140|      0|    
  141|      0|    for (from, to) in changes.movedItems {
  142|      0|        view.moveItemAtIndexPath(
  143|      0|            IndexPath(item: from.itemIndex, section: from.sectionIndex),
  144|      0|            to: IndexPath(item: to.itemIndex, section: to.sectionIndex)
  145|      0|        )
  146|      0|    }
  147|      0|}

