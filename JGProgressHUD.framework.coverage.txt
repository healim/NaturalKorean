/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUD-Defines.h:
    1|       |//
    2|       |//  JGProgressHUD-Defines.h
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 28.04.15.
    6|       |//  Copyright (c) 2015 Jonas Gessner. All rights reserved.
    7|       |//
    8|       |
    9|       |#import <Foundation/Foundation.h>
   10|       |
   11|       |/**
   12|       | Positions of the HUD.
   13|       | */
   14|       |typedef NS_ENUM(NSUInteger, JGProgressHUDPosition) {
   15|       |    /** Center position. */
   16|       |    JGProgressHUDPositionCenter = 0,
   17|       |    /** Top left position. */
   18|       |    JGProgressHUDPositionTopLeft,
   19|       |    /** Top center position. */
   20|       |    JGProgressHUDPositionTopCenter,
   21|       |    /** Top right position. */
   22|       |    JGProgressHUDPositionTopRight,
   23|       |    /** Center left position. */
   24|       |    JGProgressHUDPositionCenterLeft,
   25|       |    /** Center right position. */
   26|       |    JGProgressHUDPositionCenterRight,
   27|       |    /** Bottom left position. */
   28|       |    JGProgressHUDPositionBottomLeft,
   29|       |    /** Bottom center position. */
   30|       |    JGProgressHUDPositionBottomCenter,
   31|       |    /** Bottom right position. */
   32|       |    JGProgressHUDPositionBottomRight
   33|       |};
   34|       |
   35|       |/**
   36|       | Appearance styles of the HUD.
   37|       | */
   38|       |typedef NS_ENUM(NSUInteger, JGProgressHUDStyle) {
   39|       |    /** Extra light HUD with dark elements. */
   40|       |    JGProgressHUDStyleExtraLight = 0,
   41|       |    /** Light HUD with dark elemets. */
   42|       |    JGProgressHUDStyleLight,
   43|       |    /** Dark HUD with light elements. */
   44|       |    JGProgressHUDStyleDark
   45|       |};
   46|       |
   47|       |/**
   48|       | Interaction types.
   49|       | */
   50|       |typedef NS_ENUM(NSUInteger, JGProgressHUDInteractionType) {
   51|       |    /** Block all touches. No interaction behin the HUD is possible. */
   52|       |    JGProgressHUDInteractionTypeBlockAllTouches = 0,
   53|       |    /** Block touches on the HUD view. */
   54|       |    JGProgressHUDInteractionTypeBlockTouchesOnHUDView,
   55|       |    /** Block no touches. */
   56|       |    JGProgressHUDInteractionTypeBlockNoTouches
   57|       |};
   58|       |
   59|       |/**
   60|       | Parallax Modes.
   61|       | */
   62|       |typedef NS_ENUM(NSUInteger, JGProgressHUDParallaxMode) {
   63|       |    /** Follows the device setting for parallax. If "Reduce Motion" is enabled, no parallax effect is added to the HUD, if "Reduce Motion" is disabled the HUD will have a parallax effect. This behaviour is only supported on iOS 8 and higher. */
   64|       |    JGProgressHUDParallaxModeDevice = 0,
   65|       |    /** Always adds a parallax effect to the HUD. Parallax is only supported on iOS 7 and higher. */
   66|       |    JGProgressHUDParallaxModeAlwaysOn,
   67|       |    /** Never adds a parallax effect to the HUD. */
   68|       |    JGProgressHUDParallaxModeAlwaysOff
   69|       |};
   70|       |
   71|       |#ifndef fequal
   72|       |/**
   73|       | Macro for safe floating point comparison (for internal use in JGProgressHUD).
   74|       | */
   75|      1|#define fequal(a,b) (fabs((a) - (b)) < FLT_EPSILON)
   76|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUD.m:
    1|       |//
    2|       |//  JGProgressHUD.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 20.7.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUD.h"
   10|       |#import <QuartzCore/QuartzCore.h>
   11|       |#import "JGProgressHUDFadeAnimation.h"
   12|       |#import "JGProgressHUDIndeterminateIndicatorView.h"
   13|       |
   14|       |#if !__has_feature(objc_arc)
   15|       |#error "JGProgressHUD requires ARC!"
   16|       |#endif
   17|       |
   18|       |#ifndef iPad
   19|      0|#define iPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)
   20|       |#endif
   21|       |
   22|       |#ifndef NSFoundationVersionNumber_iOS_7_0
   23|       |#define NSFoundationVersionNumber_iOS_7_0 1047.20
   24|       |#endif
   25|       |
   26|       |#ifndef NSFoundationVersionNumber_iOS_8_0
   27|       |#define NSFoundationVersionNumber_iOS_8_0 1134.10
   28|       |#endif
   29|       |
   30|       |#ifndef iOS7
   31|      0|#define iOS7 (NSFoundationVersionNumber >= NSFoundationVersionNumber_iOS_7_0)
   32|       |#endif
   33|       |
   34|       |#ifndef iOS8
   35|      0|#define iOS8 (NSFoundationVersionNumber >= NSFoundationVersionNumber_iOS_8_0)
   36|       |#endif
   37|       |
   38|      0|NS_INLINE CGRect JGProgressHUD_CGRectIntegral(CGRect rect) {
   39|      0|    CGFloat scale = [[UIScreen mainScreen] scale];
   40|      0|    
   41|      0|    return (CGRect){{((CGFloat)floor(rect.origin.x*scale))/scale, ((CGFloat)floor(rect.origin.y*scale))/scale}, {((CGFloat)ceil(rect.size.width*scale))/scale, ((CGFloat)ceil(rect.size.height*scale))/scale}};
   42|      0|}
   43|       |
   44|       |@interface JGProgressHUD () {
   45|       |    BOOL _transitioning;
   46|       |    BOOL _updateAfterAppear;
   47|       |    
   48|       |    BOOL _dismissAfterTransitionFinished;
   49|       |    BOOL _dismissAfterTransitionFinishedWithAnimation;
   50|       |    
   51|       |    BOOL _observeTraitCollectionChange;
   52|       |    BOOL _presentingFull;
   53|       |    
   54|       |    CFAbsoluteTime _displayTimestamp;
   55|       |    
   56|       |    JGProgressHUDIndicatorView *_indicatorViewAfterTransitioning;
   57|       |    
   58|       |    UIView *_hostForActualHUDView;
   59|       |}
   60|       |
   61|       |@property (nonatomic, strong, readonly) UIView *actualHUDView;
   62|       |
   63|       |@end
   64|       |
   65|       |@interface JGProgressHUDAnimation (Private)
   66|       |
   67|       |@property (nonatomic, weak) JGProgressHUD *progressHUD;
   68|       |
   69|       |@end
   70|       |
   71|       |@implementation JGProgressHUD
   72|       |
   73|       |@synthesize HUDView = _HUDView;
   74|       |@synthesize actualHUDView = _actualHUDView;
   75|       |@synthesize textLabel = _textLabel;
   76|       |@synthesize detailTextLabel = _detailTextLabel;
   77|       |@synthesize indicatorView = _indicatorView;
   78|       |@synthesize animation = _animation;
   79|       |
   80|       |@dynamic visible, contentView;
   81|       |
   82|       |#pragma mark - Keyboard
   83|       |
   84|       |static CGRect keyboardFrame = (CGRect){{0.0f, 0.0f}, {0.0f, 0.0f}};
   85|       |
   86|      0|+ (void)keyboardFrameWillChange:(NSNotification *)notification {
   87|      0|    keyboardFrame = [notification.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];
   88|      0|    if (CGRectIsEmpty(keyboardFrame)) {
   89|      0|        keyboardFrame = [notification.userInfo[UIKeyboardFrameBeginUserInfoKey] CGRectValue];
   90|      0|    }
   91|      0|}
   92|       |
   93|      0|+ (void)keyboardFrameDidChange:(NSNotification *)notification {
   94|      0|    keyboardFrame = [notification.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];
   95|      0|}
   96|       |
   97|      0|+ (void)keyboardDidHide {
   98|      0|    keyboardFrame = CGRectZero;
   99|      0|}
  100|       |
  101|      0|+ (CGRect)currentKeyboardFrame {
  102|      0|    return keyboardFrame;
  103|      0|}
  104|       |
  105|      1|+ (void)load {
  106|      1|    [super load];
  107|      1|    
  108|      1|    @autoreleasepool {
  109|      1|        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardFrameWillChange:) name:UIKeyboardWillChangeFrameNotification object:nil];
  110|      1|        
  111|      1|        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardFrameDidChange:) name:UIKeyboardDidChangeFrameNotification object:nil];
  112|      1|        
  113|      1|        [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide) name:UIKeyboardDidHideNotification object:nil];
  114|      1|    }
  115|      1|}
  116|       |
  117|       |#pragma mark - Initializers
  118|       |
  119|      0|- (instancetype)init {
  120|      0|    return [self initWithStyle:JGProgressHUDStyleExtraLight];
  121|      0|}
  122|       |
  123|      0|- (instancetype)initWithFrame:(CGRect __unused)frame {
  124|      0|    return [self initWithStyle:JGProgressHUDStyleExtraLight];
  125|      0|}
  126|       |
  127|      1|- (instancetype)initWithStyle:(JGProgressHUDStyle)style {
  128|      1|    self = [super initWithFrame:CGRectZero];
  129|      1|    
  130|      1|    if (self) {
  131|      1|        _style = style;
  132|      1|        _voiceOverEnabled = YES;
  133|      1|        _observeTraitCollectionChange = NO;
  134|      1|        
  135|      1|        self.hidden = YES;
  136|      1|        self.backgroundColor = [UIColor clearColor];
  137|      1|        
  138|      1|        self.contentInsets = UIEdgeInsetsMake(20.0f, 20.0f, 20.0f, 20.0f);
  139|      1|        self.marginInsets = UIEdgeInsetsMake(20.0f, 20.0f, 20.0f, 20.0f);
  140|      1|        
  141|      1|        self.layoutChangeAnimationDuration = 0.3;
  142|      1|        
  143|      1|        [self addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapped:)]];
  144|      1|        
  145|      1|        _indicatorView = [[JGProgressHUDIndeterminateIndicatorView alloc] initWithHUDStyle:self.style];
  146|      1|        
  147|      1|        _HUDView = [[UIView alloc] init];
  148|      1|        _HUDView.backgroundColor = [UIColor clearColor];
  149|      1|        
  150|      1|        _hostForActualHUDView = [[UIView alloc] init];
  151|      1|        _hostForActualHUDView.backgroundColor = [UIColor clearColor];
  152|      1|        _hostForActualHUDView.clipsToBounds = YES;
  153|      1|        
  154|      1|        [_HUDView addSubview:_hostForActualHUDView];
  155|      1|        [self addSubview:_HUDView];
  156|      1|        
  157|      1|        self.cornerRadius = 10.0f;
  158|      1|    }
  159|      1|    
  160|      1|    return self;
  161|      1|}
  162|       |
  163|      0|+ (instancetype)progressHUDWithStyle:(JGProgressHUDStyle)style {
  164|      0|    return [(JGProgressHUD *)[self alloc] initWithStyle:style];
  165|      0|}
  166|       |
  167|       |#pragma mark - Layout
  168|       |
  169|      0|- (void)setHUDViewFrameCenterWithSize:(CGSize)size {
  170|      0|    CGRect frame = CGRectZero;
  171|      0|    
  172|      0|    frame.size = size;
  173|      0|    
  174|      0|    CGRect viewBounds = self.bounds;
  175|      0|    
  176|      0|    CGPoint center = CGPointMake(viewBounds.origin.x+viewBounds.size.width/2.0f, viewBounds.origin.y+viewBounds.size.height/2.0f);
  177|      0|    
  178|      0|    switch (self.position) {
  179|      0|        case JGProgressHUDPositionTopLeft:
  180|      0|            frame.origin.x = self.marginInsets.left;
  181|      0|            frame.origin.y = self.marginInsets.top;
  182|      0|            break;
  183|      0|            
  184|      0|        case JGProgressHUDPositionTopCenter:
  185|      0|            frame.origin.x = center.x-frame.size.width/2.0f;
  186|      0|            frame.origin.y = self.marginInsets.top;
  187|      0|            break;
  188|      0|            
  189|      0|        case JGProgressHUDPositionTopRight:
  190|      0|            frame.origin.x = viewBounds.size.width-self.marginInsets.right-frame.size.width;
  191|      0|            frame.origin.y = self.marginInsets.top;
  192|      0|            break;
  193|      0|            
  194|      0|        case JGProgressHUDPositionCenterLeft:
  195|      0|            frame.origin.x = self.marginInsets.left;
  196|      0|            frame.origin.y = center.y-frame.size.height/2.0f;
  197|      0|            break;
  198|      0|            
  199|      0|        case JGProgressHUDPositionCenter:
  200|      0|            frame.origin.x = center.x-frame.size.width/2.0f;
  201|      0|            frame.origin.y = center.y-frame.size.height/2.0f;
  202|      0|            break;
  203|      0|            
  204|      0|        case JGProgressHUDPositionCenterRight:
  205|      0|            frame.origin.x = viewBounds.size.width-self.marginInsets.right-frame.size.width;
  206|      0|            frame.origin.y = center.y-frame.size.height/2.0f;
  207|      0|            break;
  208|      0|            
  209|      0|        case JGProgressHUDPositionBottomLeft:
  210|      0|            frame.origin.x = self.marginInsets.left;
  211|      0|            frame.origin.y = viewBounds.size.height-self.marginInsets.bottom-frame.size.height;
  212|      0|            break;
  213|      0|            
  214|      0|        case JGProgressHUDPositionBottomCenter:
  215|      0|            frame.origin.x = center.x-frame.size.width/2.0f;
  216|      0|            frame.origin.y = viewBounds.size.height-self.marginInsets.bottom-frame.size.height;
  217|      0|            break;
  218|      0|            
  219|      0|        case JGProgressHUDPositionBottomRight:
  220|      0|            frame.origin.x = viewBounds.size.width-self.marginInsets.right-frame.size.width;
  221|      0|            frame.origin.y = viewBounds.size.height-self.marginInsets.bottom-frame.size.height;
  222|      0|            break;
  223|      0|    }
  224|      0|    
  225|      0|    _HUDView.frame = JGProgressHUD_CGRectIntegral(frame);
  226|      0|    _hostForActualHUDView.frame = _HUDView.bounds;
  227|      0|    self.actualHUDView.frame = _hostForActualHUDView.bounds;
  228|      0|}
  229|       |
  230|      2|- (void)updateHUDAnimated:(BOOL)animated animateIndicatorViewFrame:(BOOL)animateIndicator {
  231|      2|    if (_transitioning) {
  232|      0|        _updateAfterAppear = YES;
  233|      0|        return;
  234|      0|    }
  235|      2|    
  236|      2|    if (!self.superview) {
  237|      2|        return;
  238|      2|    }
  239|      2|    
  240|      0|    CGRect indicatorFrame = self.indicatorView.frame;
  241|      0|    indicatorFrame.origin.y = self.contentInsets.top;
  242|      0|    
  243|      0|    CGFloat maxContentWidth = self.frame.size.width-self.marginInsets.left-self.marginInsets.right-self.contentInsets.left-self.contentInsets.right;
  244|      0|    CGFloat maxContentHeight = self.frame.size.height-self.marginInsets.top-self.marginInsets.bottom-self.contentInsets.top-self.contentInsets.bottom;
  245|      0|    
  246|      0|    CGSize maxContentSize = (CGSize){maxContentWidth, maxContentHeight};
  247|      0|    
  248|      0|    //Label size
  249|      0|    CGRect labelFrame = CGRectZero;
  250|      0|    CGRect detailFrame = CGRectZero;
  251|      0|    
  252|      0|    if (_textLabel) {
  253|      0|        if (iOS7) {
  254|      0|            NSDictionary *attributes = @{NSFontAttributeName : self.textLabel.font};
  255|      0|            labelFrame.size = [self.textLabel.text boundingRectWithSize:maxContentSize options:NSStringDrawingUsesLineFragmentOrigin attributes:attributes context:nil].size;
  256|      0|        }
  257|      0|        else {
  258|      0|#pragma clang diagnostic push
  259|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  260|      0|            labelFrame.size = [self.textLabel.text sizeWithFont:self.textLabel.font constrainedToSize:maxContentSize lineBreakMode:self.textLabel.lineBreakMode];
  261|      0|#pragma clang diagnostic pop
  262|      0|        }
  263|      0|        
  264|      0|        labelFrame.origin.y = CGRectGetMaxY(indicatorFrame);
  265|      0|        
  266|      0|        if (!CGRectIsEmpty(labelFrame) && !CGRectIsEmpty(indicatorFrame)) {
  267|      0|            labelFrame.origin.y += 10.0f;
  268|      0|        }
  269|      0|    }
  270|      0|    
  271|      0|    if (_detailTextLabel) {
  272|      0|        if (iOS7) {
  273|      0|            NSDictionary *attributes = @{NSFontAttributeName : self.detailTextLabel.font};
  274|      0|            detailFrame.size = [self.detailTextLabel.text boundingRectWithSize:maxContentSize options:NSStringDrawingUsesLineFragmentOrigin attributes:attributes context:nil].size;
  275|      0|        }
  276|      0|        else {
  277|      0|#pragma clang diagnostic push
  278|      0|#pragma clang diagnostic ignored "-Wdeprecated-declarations"
  279|      0|            detailFrame.size = [self.detailTextLabel.text sizeWithFont:self.detailTextLabel.font constrainedToSize:maxContentSize lineBreakMode:self.detailTextLabel.lineBreakMode];
  280|      0|#pragma clang diagnostic pop
  281|      0|        }
  282|      0|        
  283|      0|        detailFrame.origin.y = CGRectGetMaxY(labelFrame)+5.0f;
  284|      0|        
  285|      0|        if (!CGRectIsEmpty(detailFrame) && !CGRectIsEmpty(indicatorFrame) && CGRectIsEmpty(labelFrame)) {
  286|      0|            detailFrame.origin.y += 5.0f;
  287|      0|        }
  288|      0|    }
  289|      0|    
  290|      0|    //HUD size
  291|      0|    CGSize size = CGSizeZero;
  292|      0|    
  293|      0|    CGFloat width = MIN(self.contentInsets.left+MAX(indicatorFrame.size.width, MAX(labelFrame.size.width, detailFrame.size.width))+self.contentInsets.right, self.frame.size.width-self.marginInsets.left-self.marginInsets.right);
  294|      0|    
  295|      0|    CGFloat height = MAX(CGRectGetMaxY(labelFrame), MAX(CGRectGetMaxY(detailFrame), CGRectGetMaxY(indicatorFrame)))+self.contentInsets.bottom;
  296|      0|    
  297|      0|    if (self.square) {
  298|      0|        CGFloat uniSize = MAX(width, height);
  299|      0|        
  300|      0|        size.width = uniSize;
  301|      0|        size.height = uniSize;
  302|      0|        
  303|      0|        CGFloat heightDelta = (uniSize-height)/2.0f;
  304|      0|        
  305|      0|        labelFrame.origin.y += heightDelta;
  306|      0|        detailFrame.origin.y += heightDelta;
  307|      0|        indicatorFrame.origin.y += heightDelta;
  308|      0|    }
  309|      0|    else {
  310|      0|        size.width = width;
  311|      0|        size.height = height;
  312|      0|    }
  313|      0|    
  314|      0|    CGPoint center = CGPointMake(size.width/2.0f, size.height/2.0f);
  315|      0|    
  316|      0|    indicatorFrame.origin.x = center.x-indicatorFrame.size.width/2.0f;
  317|      0|    labelFrame.origin.x = center.x-labelFrame.size.width/2.0f;
  318|      0|    detailFrame.origin.x = center.x-detailFrame.size.width/2.0f;
  319|      0|    
  320|      0|    void (^updates)(void) = ^{
  321|      0|        [self setHUDViewFrameCenterWithSize:size];
  322|      0|        
  323|      0|        if (animateIndicator) {
  324|      0|            self.indicatorView.frame = indicatorFrame;
  325|      0|        }
  326|      0|        
  327|      0|        _textLabel.frame = JGProgressHUD_CGRectIntegral(labelFrame);
  328|      0|        _detailTextLabel.frame = JGProgressHUD_CGRectIntegral(detailFrame);
  329|      0|    };
  330|      0|    
  331|      0|    if (!animateIndicator) {
  332|      0|        self.indicatorView.frame = JGProgressHUD_CGRectIntegral(indicatorFrame);
  333|      0|    }
  334|      0|    
  335|      0|    if (self.layoutChangeAnimationDuration > 0.0f && animated && !_transitioning) {
  336|      0|        [UIView animateWithDuration:self.layoutChangeAnimationDuration delay:0.0 options:UIViewAnimationOptionAllowAnimatedContent | UIViewAnimationOptionCurveEaseInOut animations:updates completion:nil];
  337|      0|    }
  338|      0|    else {
  339|      0|        updates();
  340|      0|    }
  341|      0|}
  342|       |
  343|      0|- (CGRect)fullFrameInView:(UIView *)view {
  344|      0|    CGRect _keyboardFrame = [view convertRect:[[self class] currentKeyboardFrame] fromView:nil];
  345|      0|    CGRect frame = view.bounds;
  346|      0|    
  347|      0|    if (!CGRectIsEmpty(_keyboardFrame) && CGRectIntersectsRect(frame, _keyboardFrame)) {
  348|      0|        frame.size.height = MIN(frame.size.height, CGRectGetMinY(_keyboardFrame));
  349|      0|    }
  350|      0|    
  351|      0|    return frame;
  352|      0|}
  353|       |
  354|      1|- (void)applyCornerRadius {
  355|      1|    _HUDView.layer.cornerRadius = self.cornerRadius;
  356|      1|    _hostForActualHUDView.layer.cornerRadius = self.cornerRadius;
  357|      1|}
  358|       |
  359|      0|- (void)traitCollectionDidChange:(__unused UITraitCollection *)previousTraitCollection {
  360|      0|    [super traitCollectionDidChange:previousTraitCollection];
  361|      0|    
  362|      0|    if (_presentingFull && _observeTraitCollectionChange) {
  363|      0|        [self updateFrame:YES];
  364|      0|    }
  365|      0|}
  366|       |
  367|      0|- (void)updateFrame:(BOOL)animated {
  368|      0|    if (self.targetView && !CGRectEqualToRect(self.bounds, self.targetView.bounds)) {
  369|      0|        [UIView animateWithDuration:(animated ? (iPad ? 0.4 : 0.3) : 0.0) delay:0.0 options:UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveEaseInOut animations:^{
  370|      0|            self.frame = [self fullFrameInView:self.targetView];
  371|      0|            [self updateHUDAnimated:NO animateIndicatorViewFrame:YES];
  372|      0|        } completion:nil];
  373|      0|    }
  374|      0|}
  375|       |
  376|       |#pragma mark - Showing
  377|       |
  378|      0|- (void)cleanUpAfterPresentation {
  379|      0|    self.hidden = NO;
  380|      0|    
  381|      0|    _transitioning = NO;
  382|      0|    _displayTimestamp = CFAbsoluteTimeGetCurrent(); //Correct timestamp to the current time for animated presentations
  383|      0|    
  384|      0|    if (_indicatorViewAfterTransitioning) {
  385|      0|        self.indicatorView = _indicatorViewAfterTransitioning;
  386|      0|        _indicatorViewAfterTransitioning = nil;
  387|      0|        _updateAfterAppear = NO; //Setting indicatorView always updateHUDAnimated:animateIndicatorViewFrame:
  388|      0|    }
  389|      0|    else if (_updateAfterAppear) {
  390|      0|        [self updateHUDAnimated:YES animateIndicatorViewFrame:YES];
  391|      0|        _updateAfterAppear = NO;
  392|      0|    }
  393|      0|    
  394|      0|    if ([self.delegate respondsToSelector:@selector(progressHUD:didPresentInView:)]){
  395|      0|        [self.delegate progressHUD:self didPresentInView:self.targetView];
  396|      0|    }
  397|      0|    
  398|      0|    if (_dismissAfterTransitionFinished) {
  399|      0|        [self dismissAnimated:_dismissAfterTransitionFinishedWithAnimation];
  400|      0|        _dismissAfterTransitionFinished = NO;
  401|      0|        _dismissAfterTransitionFinishedWithAnimation = NO;
  402|      0|    }
  403|      0|    
  404|      0|    if (self.voiceOverEnabled && UIAccessibilityIsVoiceOverRunning()) {
  405|      0|        UIAccessibilityPostNotification(UIAccessibilityLayoutChangedNotification, self);
  406|      0|    }
  407|      0|}
  408|       |
  409|      0|- (void)showInView:(UIView *)view {
  410|      0|    [self showInView:view animated:YES];
  411|      0|}
  412|       |
  413|      0|- (void)showInView:(UIView *)view animated:(BOOL)animated {
  414|      0|    CGRect frame = [self fullFrameInView:view];
  415|      0|    
  416|      0|    _presentingFull = YES;
  417|      0|    
  418|      0|    // !!!: Use UIApplicationDidChangeStatusBarFrameNotification since UIDeviceOrientationDidChangeNotification still gives the old bounds in orientationChanged selector for self.targetView on iPad unless it is called after a delay.
  419|      0|    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientationChanged) name:UIApplicationDidChangeStatusBarFrameNotification object:nil];
  420|      0|    
  421|      0|    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appDidBecomeActive) name:UIApplicationDidBecomeActiveNotification object:nil];
  422|      0|    
  423|      0|    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardFrameChanged:) name:UIKeyboardWillChangeFrameNotification object:nil];
  424|      0|    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardFrameChanged:) name:UIKeyboardDidChangeFrameNotification object:nil];
  425|      0|    
  426|      0|    [self showInRect:frame inView:view animated:animated];
  427|      0|}
  428|       |
  429|      0|- (void)showInRect:(CGRect)rect inView:(UIView *)view {
  430|      0|    [self showInRect:rect inView:view animated:YES];
  431|      0|}
  432|       |
  433|      0|- (void)showInRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated {
  434|      0|    if (_transitioning) {
  435|      0|        return;
  436|      0|    }
  437|      0|    else if (self.targetView != nil) {
  438|      0|#if DEBUG
  439|      0|        NSLog(@"[Warning] The HUD is already visible! Ignoring.");
  440|      0|#endif
  441|      0|        return;
  442|      0|    }
  443|      0|    
  444|      0|    _targetView = view;
  445|      0|    
  446|      0|    self.frame = rect;
  447|      0|    [view addSubview:self];
  448|      0|    
  449|      0|    [self updateHUDAnimated:NO animateIndicatorViewFrame:YES];
  450|      0|    
  451|      0|    _transitioning = YES;
  452|      0|    _observeTraitCollectionChange = YES;
  453|      0|    
  454|      0|    _displayTimestamp = CFAbsoluteTimeGetCurrent();
  455|      0|    
  456|      0|    if ([self.delegate respondsToSelector:@selector(progressHUD:willPresentInView:)]) {
  457|      0|        [self.delegate progressHUD:self willPresentInView:view];
  458|      0|    }
  459|      0|    
  460|      0|    if (animated && self.animation) {
  461|      0|        [self.animation show];
  462|      0|    }
  463|      0|    else {
  464|      0|        [self cleanUpAfterPresentation];
  465|      0|    }
  466|      0|}
  467|       |
  468|       |#pragma mark - Dismissing
  469|       |
  470|      0|- (void)cleanUpAfterDismissal {
  471|      0|    self.hidden = YES;
  472|      0|    [self removeFromSuperview];
  473|      0|    
  474|      0|    [self removeObservers];
  475|      0|    
  476|      0|    _presentingFull = NO;
  477|      0|    _transitioning = NO;
  478|      0|    _dismissAfterTransitionFinished = NO;
  479|      0|    _dismissAfterTransitionFinishedWithAnimation = NO;
  480|      0|    _observeTraitCollectionChange = NO;
  481|      0|    
  482|      0|    if ([self.delegate respondsToSelector:@selector(progressHUD:didDismissFromView:)]) {
  483|      0|        [self.delegate progressHUD:self didDismissFromView:self.targetView];
  484|      0|    }
  485|      0|    
  486|      0|    _targetView = nil;
  487|      0|}
  488|       |
  489|      0|- (void)dismiss {
  490|      0|    [self dismissAnimated:YES];
  491|      0|}
  492|       |
  493|      0|- (void)dismissAnimated:(BOOL)animated {
  494|      0|    if (_transitioning) {
  495|      0|        _dismissAfterTransitionFinished = YES;
  496|      0|        _dismissAfterTransitionFinishedWithAnimation = animated;
  497|      0|        return;
  498|      0|    }
  499|      0|    
  500|      0|    if (self.targetView == nil) {
  501|      0|        return;
  502|      0|    }
  503|      0|    
  504|      0|    if (self.minimumDisplayTime > 0.0 && _displayTimestamp > 0.0) {
  505|      0|        CFAbsoluteTime displayedTime = CFAbsoluteTimeGetCurrent()-_displayTimestamp;
  506|      0|        
  507|      0|        if (displayedTime < self.minimumDisplayTime) {
  508|      0|            NSTimeInterval delta = self.minimumDisplayTime-displayedTime;
  509|      0|            
  510|      0|            [self dismissAfterDelay:delta animated:animated];
  511|      0|            
  512|      0|            return;
  513|      0|        }
  514|      0|    }
  515|      0|    
  516|      0|    _transitioning = YES;
  517|      0|    
  518|      0|    if ([self.delegate respondsToSelector:@selector(progressHUD:willDismissFromView:)]) {
  519|      0|        [self.delegate progressHUD:self willDismissFromView:self.targetView];
  520|      0|    }
  521|      0|    
  522|      0|    if (animated && self.animation) {
  523|      0|        [self.animation hide];
  524|      0|    }
  525|      0|    else {
  526|      0|        [self cleanUpAfterDismissal];
  527|      0|    }
  528|      0|}
  529|       |
  530|      0|- (void)dismissAfterDelay:(NSTimeInterval)delay {
  531|      0|    [self dismissAfterDelay:delay animated:YES];
  532|      0|}
  533|       |
  534|      0|- (void)dismissAfterDelay:(NSTimeInterval)delay animated:(BOOL)animated {
  535|      0|    __weak __typeof(self) weakSelf = self;
  536|      0|    
  537|      0|    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delay * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
  538|      0|        if (weakSelf) {
  539|      0|            __strong __typeof(weakSelf) strongSelf = weakSelf;
  540|      0|            if (strongSelf.visible) {
  541|      0|                [strongSelf dismissAnimated:animated];
  542|      0|            }
  543|      0|        }
  544|      0|    });
  545|      0|}
  546|       |
  547|       |#pragma mark - Callbacks
  548|       |
  549|      0|- (void)tapped:(UITapGestureRecognizer *)t {
  550|      0|    if (CGRectContainsPoint(self.contentView.bounds, [t locationInView:self.contentView])) {
  551|      0|        if (self.tapOnHUDViewBlock != nil) {
  552|      0|            self.tapOnHUDViewBlock(self);
  553|      0|        }
  554|      0|    }
  555|      0|    else if (self.tapOutsideBlock != nil) {
  556|      0|        self.tapOutsideBlock(self);
  557|      0|    }
  558|      0|}
  559|       |
  560|      0|NS_INLINE UIViewAnimationOptions UIViewAnimationOptionsFromUIViewAnimationCurve(UIViewAnimationCurve curve) {
  561|      0|    UIViewAnimationOptions testOptions = UIViewAnimationCurveLinear << 16;
  562|      0|    
  563|      0|    if (testOptions != UIViewAnimationOptionCurveLinear) {
  564|      0|        NSLog(@"Unexpected implementation of UIViewAnimationOptionCurveLinear");
  565|      0|    }
  566|      0|    
  567|      0|    return (UIViewAnimationOptions)(curve << 16);
  568|      0|}
  569|       |
  570|      0|- (void)keyboardFrameChanged:(NSNotification *)notification {
  571|      0|    CGRect frame = [self fullFrameInView:self.targetView];
  572|      0|    
  573|      0|    if (CGRectEqualToRect(self.frame, frame)) {
  574|      0|        return;
  575|      0|    }
  576|      0|    
  577|      0|    NSTimeInterval duration = [notification.userInfo[UIKeyboardAnimationDurationUserInfoKey] doubleValue];
  578|      0|    
  579|      0|    UIViewAnimationCurve curve = (UIViewAnimationCurve)[notification.userInfo[UIKeyboardAnimationCurveUserInfoKey] unsignedIntegerValue];
  580|      0|    
  581|      0|    [UIView animateWithDuration:duration delay:0.0 options:UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionsFromUIViewAnimationCurve(curve) animations:^{
  582|      0|        self.frame = frame;
  583|      0|        [self updateHUDAnimated:NO animateIndicatorViewFrame:YES];
  584|      0|    } completion:nil];
  585|      0|}
  586|       |
  587|      0|- (void)orientationChanged {
  588|      0|    [self updateFrame:YES];
  589|      0|}
  590|       |
  591|      0|- (void)appDidBecomeActive {
  592|      0|     [self updateFrame:YES];
  593|      0|}
  594|       |
  595|      0|- (void)updateMotionOnHUDView {
  596|      0|    if (iOS7) {
  597|      0|        BOOL reduceMotionEnabled = (iOS8 && UIAccessibilityIsReduceMotionEnabled());
  598|      0|        
  599|      0|        BOOL wantsParallax = ((self.parallaxMode == JGProgressHUDParallaxModeDevice && !reduceMotionEnabled) || self.parallaxMode == JGProgressHUDParallaxModeAlwaysOn);
  600|      0|        BOOL hasParallax = (_HUDView.motionEffects.count > 0);
  601|      0|        
  602|      0|        if (wantsParallax == hasParallax) {
  603|      0|            return;
  604|      0|        }
  605|      0|        
  606|      0|        if (!wantsParallax) {
  607|      0|            _HUDView.motionEffects = @[];
  608|      0|        }
  609|      0|        else {
  610|      0|            UIInterpolatingMotionEffect *x = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.x" type:UIInterpolatingMotionEffectTypeTiltAlongHorizontalAxis];
  611|      0|            
  612|      0|            CGFloat maxMovement = 20.0f;
  613|      0|            
  614|      0|            x.minimumRelativeValue = @(-maxMovement);
  615|      0|            x.maximumRelativeValue = @(maxMovement);
  616|      0|            
  617|      0|            UIInterpolatingMotionEffect *y = [[UIInterpolatingMotionEffect alloc] initWithKeyPath:@"center.y" type:UIInterpolatingMotionEffectTypeTiltAlongVerticalAxis];
  618|      0|            
  619|      0|            y.minimumRelativeValue = @(-maxMovement);
  620|      0|            y.maximumRelativeValue = @(maxMovement);
  621|      0|            
  622|      0|            _HUDView.motionEffects = @[x, y];
  623|      0|        }
  624|      0|    }
  625|      0|}
  626|       |
  627|      0|- (void)animationDidFinish:(BOOL)presenting {
  628|      0|    if (presenting) {
  629|      0|        [self cleanUpAfterPresentation];
  630|      0|    }
  631|      0|    else {
  632|      0|        [self cleanUpAfterDismissal];
  633|      0|    }
  634|      0|}
  635|       |
  636|       |#pragma mark - Getters
  637|       |
  638|      0|- (BOOL)isVisible {
  639|      0|    return (self.superview != nil);
  640|      0|}
  641|       |
  642|      0|- (UIView *)actualHUDView {
  643|      0|    if (!_actualHUDView) {
  644|      0|        if (iOS8) {
  645|      0|            [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updateMotionOnHUDView) name:UIAccessibilityReduceMotionStatusDidChangeNotification object:nil];
  646|      0|            
  647|      0|            UIBlurEffectStyle effect = 0;
  648|      0|            
  649|      0|            if (self.style == JGProgressHUDStyleDark) {
  650|      0|                effect = UIBlurEffectStyleDark;
  651|      0|            }
  652|      0|            else if (self.style == JGProgressHUDStyleLight) {
  653|      0|                effect = UIBlurEffectStyleLight;
  654|      0|            }
  655|      0|            else {
  656|      0|                effect = UIBlurEffectStyleExtraLight;
  657|      0|            }
  658|      0|            
  659|      0|            UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:effect];
  660|      0|            
  661|      0|            _actualHUDView = [[UIVisualEffectView alloc] initWithEffect:blurEffect];
  662|      0|        }
  663|      0|        else {
  664|      0|            _actualHUDView = [[UIView alloc] init];
  665|      0|            
  666|      0|            if (self.style == JGProgressHUDStyleDark) {
  667|      0|                _actualHUDView.backgroundColor = [UIColor colorWithWhite:0.0f alpha:0.8f];
  668|      0|            }
  669|      0|            else if (self.style == JGProgressHUDStyleLight) {
  670|      0|                _actualHUDView.backgroundColor = [UIColor colorWithWhite:1.0f alpha:0.75f];
  671|      0|            }
  672|      0|            else {
  673|      0|                _actualHUDView.backgroundColor = [UIColor colorWithWhite:1.0f alpha:0.95f];
  674|      0|            }
  675|      0|        }
  676|      0|        
  677|      0|        [self updateMotionOnHUDView];
  678|      0|        
  679|      0|        [_hostForActualHUDView addSubview:_actualHUDView];
  680|      0|        
  681|      0|        if (self.indicatorView) {
  682|      0|            [self.contentView addSubview:self.indicatorView];
  683|      0|        }
  684|      0|        
  685|      0|        [self.contentView addGestureRecognizer:[[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(tapped:)]];
  686|      0|    }
  687|      0|    
  688|      0|    return _actualHUDView;
  689|      0|}
  690|       |
  691|      0|- (UIView *)contentView {
  692|      0|    if (iOS8) {
  693|      0|        return ((UIVisualEffectView *)self.actualHUDView).contentView;
  694|      0|    }
  695|      0|    else {
  696|      0|        return self.actualHUDView;
  697|      0|    }
  698|      0|}
  699|       |
  700|      0|- (UILabel *)textLabel {
  701|      0|    if (!_textLabel) {
  702|      0|        _textLabel = [[UILabel alloc] init];
  703|      0|        _textLabel.backgroundColor = [UIColor clearColor];
  704|      0|        _textLabel.textColor = (self.style == JGProgressHUDStyleDark ? [UIColor whiteColor] : [UIColor blackColor]);
  705|      0|        _textLabel.textAlignment = NSTextAlignmentCenter;
  706|      0|        _textLabel.font = [UIFont boldSystemFontOfSize:15.0f];
  707|      0|        _textLabel.numberOfLines = 0;
  708|      0|        [_textLabel addObserver:self forKeyPath:@"text" options:(NSKeyValueObservingOptions)kNilOptions context:NULL];
  709|      0|        [_textLabel addObserver:self forKeyPath:@"font" options:(NSKeyValueObservingOptions)kNilOptions context:NULL];
  710|      0|        _textLabel.isAccessibilityElement = YES;
  711|      0|        
  712|      0|        [self.contentView addSubview:_textLabel];
  713|      0|    }
  714|      0|    
  715|      0|    return _textLabel;
  716|      0|}
  717|       |
  718|      0|- (UILabel *)detailTextLabel {
  719|      0|    if (!_detailTextLabel) {
  720|      0|        _detailTextLabel = [[UILabel alloc] init];
  721|      0|        _detailTextLabel.backgroundColor = [UIColor clearColor];
  722|      0|        _detailTextLabel.textColor = (self.style == JGProgressHUDStyleDark ? [UIColor whiteColor] : [UIColor blackColor]);
  723|      0|        _detailTextLabel.textAlignment = NSTextAlignmentCenter;
  724|      0|        _detailTextLabel.font = [UIFont systemFontOfSize:13.0f];
  725|      0|        _detailTextLabel.numberOfLines = 0;
  726|      0|        [_detailTextLabel addObserver:self forKeyPath:@"text" options:(NSKeyValueObservingOptions)kNilOptions context:NULL];
  727|      0|        [_detailTextLabel addObserver:self forKeyPath:@"font" options:(NSKeyValueObservingOptions)kNilOptions context:NULL];
  728|      0|        _detailTextLabel.isAccessibilityElement = YES;
  729|      0|        
  730|      0|        [self.contentView addSubview:_detailTextLabel];
  731|      0|    }
  732|      0|    
  733|      0|    return _detailTextLabel;
  734|      0|}
  735|       |
  736|      0|- (JGProgressHUDAnimation *)animation {
  737|      0|    if (!_animation) {
  738|      0|        self.animation = [JGProgressHUDFadeAnimation animation];
  739|      0|    }
  740|      0|    
  741|      0|    return _animation;
  742|      0|}
  743|       |
  744|       |#pragma mark - Setters
  745|       |
  746|      1|- (void)setCornerRadius:(CGFloat)cornerRadius {
  747|      1|    if (fequal(self.cornerRadius, cornerRadius)) {
  748|      0|        return;
  749|      0|    }
  750|      1|    
  751|      1|    _cornerRadius = cornerRadius;
  752|      1|    
  753|      1|    [self applyCornerRadius];
  754|      1|}
  755|       |
  756|      0|- (void)setAnimation:(JGProgressHUDAnimation *)animation {
  757|      0|    if (_animation == animation) {
  758|      0|        return;
  759|      0|    }
  760|      0|    
  761|      0|    _animation.progressHUD = nil;
  762|      0|    
  763|      0|    _animation = animation;
  764|      0|    
  765|      0|    _animation.progressHUD = self;
  766|      0|}
  767|       |
  768|      0|- (void)setParallaxMode:(JGProgressHUDParallaxMode)parallaxMode {
  769|      0|    if (self.parallaxMode == parallaxMode) {
  770|      0|        return;
  771|      0|    }
  772|      0|    
  773|      0|    _parallaxMode = parallaxMode;
  774|      0|    
  775|      0|    [self updateMotionOnHUDView];
  776|      0|}
  777|       |
  778|      0|- (void)setPosition:(JGProgressHUDPosition)position {
  779|      0|    if (self.position == position) {
  780|      0|        return;
  781|      0|    }
  782|      0|    
  783|      0|    _position = position;
  784|      0|    [self updateHUDAnimated:YES animateIndicatorViewFrame:YES];
  785|      0|}
  786|       |
  787|      0|- (void)setSquare:(BOOL)square {
  788|      0|    if (self.square == square) {
  789|      0|        return;
  790|      0|    }
  791|      0|    
  792|      0|    _square = square;
  793|      0|    
  794|      0|    [self updateHUDAnimated:YES animateIndicatorViewFrame:YES];
  795|      0|}
  796|       |
  797|      0|- (void)setIndicatorView:(JGProgressHUDIndicatorView *)indicatorView {
  798|      0|    if (self.indicatorView == indicatorView) {
  799|      0|        return;
  800|      0|    }
  801|      0|    
  802|      0|    if (_transitioning) {
  803|      0|        _indicatorViewAfterTransitioning = indicatorView;
  804|      0|        return;
  805|      0|    }
  806|      0|    
  807|      0|    [_indicatorView removeFromSuperview];
  808|      0|    _indicatorView = indicatorView;
  809|      0|    
  810|      0|    if (self.indicatorView) {
  811|      0|        [self.contentView addSubview:self.indicatorView];
  812|      0|    }
  813|      0|    
  814|      0|    [self updateHUDAnimated:YES animateIndicatorViewFrame:NO];
  815|      0|}
  816|       |
  817|      1|- (void)setMarginInsets:(UIEdgeInsets)marginInsets {
  818|      1|    if (UIEdgeInsetsEqualToEdgeInsets(self.marginInsets, marginInsets)) {
  819|      0|        return;
  820|      0|    }
  821|      1|    
  822|      1|    _marginInsets = marginInsets;
  823|      1|    
  824|      1|    [self updateHUDAnimated:YES animateIndicatorViewFrame:YES];
  825|      1|}
  826|       |
  827|      1|- (void)setContentInsets:(UIEdgeInsets)contentInsets {
  828|      1|    if (UIEdgeInsetsEqualToEdgeInsets(self.contentInsets, contentInsets)) {
  829|      0|        return;
  830|      0|    }
  831|      1|    
  832|      1|    _contentInsets = contentInsets;
  833|      1|    
  834|      1|    [self updateHUDAnimated:YES animateIndicatorViewFrame:YES];
  835|      1|}
  836|       |
  837|      0|- (void)setProgress:(float)progress {
  838|      0|    [self setProgress:progress animated:NO];
  839|      0|}
  840|       |
  841|      0|- (void)setProgress:(float)progress animated:(BOOL)animated {
  842|      0|    if (fequal(self.progress, progress)) {
  843|      0|        return;
  844|      0|    }
  845|      0|    
  846|      0|    _progress = progress;
  847|      0|    
  848|      0|    [self.indicatorView setProgress:progress animated:animated];
  849|      0|}
  850|       |
  851|       |#pragma mark - Overrides
  852|       |
  853|      0|- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
  854|      0|    if (self.interactionType == JGProgressHUDInteractionTypeBlockNoTouches) {
  855|      0|        return nil;
  856|      0|    }
  857|      0|    else {
  858|      0|        UIView *view = [super hitTest:point withEvent:event];
  859|      0|        
  860|      0|        if (self.interactionType == JGProgressHUDInteractionTypeBlockAllTouches) {
  861|      0|            return view;
  862|      0|        }
  863|      0|        else if (self.interactionType == JGProgressHUDInteractionTypeBlockTouchesOnHUDView && view != self) {
  864|      0|            return view;
  865|      0|        }
  866|      0|        
  867|      0|        return nil;
  868|      0|    }
  869|      0|}
  870|       |
  871|      0|- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
  872|      0|    if (object == _textLabel || object == _detailTextLabel) {
  873|      0|        [self updateHUDAnimated:YES animateIndicatorViewFrame:YES];
  874|      0|    }
  875|      0|    else {
  876|      0|        [super observeValueForKeyPath:keyPath ofObject:object change:change context:context];
  877|      0|    }
  878|      0|}
  879|       |
  880|      0|- (void)dealloc {
  881|      0|    [self removeObservers];
  882|      0|    
  883|      0|    [_textLabel removeObserver:self forKeyPath:@"text"];
  884|      0|    [_textLabel removeObserver:self forKeyPath:@"font"];
  885|      0|    
  886|      0|    [_detailTextLabel removeObserver:self forKeyPath:@"text"];
  887|      0|    [_detailTextLabel removeObserver:self forKeyPath:@"font"];
  888|      0|}
  889|       |
  890|      0|- (void)removeObservers {
  891|      0|    if (iOS8) {
  892|      0|        [[NSNotificationCenter defaultCenter] removeObserver:self name:UIAccessibilityReduceMotionStatusDidChangeNotification object:nil];
  893|      0|    }
  894|      0|    
  895|      0|    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidBecomeActiveNotification object:nil];
  896|      0|    
  897|      0|    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIApplicationDidChangeStatusBarFrameNotification object:nil];
  898|      0|    
  899|      0|    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillChangeFrameNotification object:nil];
  900|      0|    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidChangeFrameNotification object:nil];
  901|      0|}
  902|       |
  903|       |@end
  904|       |
  905|       |
  906|       |
  907|       |
  908|       |@implementation JGProgressHUD (HUDManagement)
  909|       |
  910|      0|+ (NSArray *)allProgressHUDsInView:(UIView *)view {
  911|      0|    NSMutableArray *HUDs = [NSMutableArray array];
  912|      0|    
  913|      0|    for (UIView *v in view.subviews) {
  914|      0|        if ([v isKindOfClass:[JGProgressHUD class]]) {
  915|      0|            [HUDs addObject:v];
  916|      0|        }
  917|      0|    }
  918|      0|    
  919|      0|    return HUDs.copy;
  920|      0|}
  921|       |
  922|      0|+ (NSMutableArray *)_allProgressHUDsInViewHierarchy:(UIView *)view {
  923|      0|    NSMutableArray *HUDs = [NSMutableArray array];
  924|      0|    
  925|      0|    for (UIView *v in view.subviews) {
  926|      0|        if ([v isKindOfClass:[JGProgressHUD class]]) {
  927|      0|            [HUDs addObject:v];
  928|      0|        }
  929|      0|        else {
  930|      0|            [HUDs addObjectsFromArray:[self _allProgressHUDsInViewHierarchy:v]];
  931|      0|        }
  932|      0|    }
  933|      0|    
  934|      0|    return HUDs;
  935|      0|}
  936|       |
  937|      0|+ (NSArray *)allProgressHUDsInViewHierarchy:(UIView *)view {
  938|      0|    return [self _allProgressHUDsInViewHierarchy:view].copy;
  939|      0|}
  940|       |
  941|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDAnimation.m:
    1|       |//
    2|       |//  JGProgressHUDAnimation.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 20.7.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//  
    8|       |
    9|       |#import "JGProgressHUDAnimation.h"
   10|       |#import "JGProgressHUD.h"
   11|       |
   12|       |@interface JGProgressHUD (Private)
   13|       |
   14|       |- (void)animationDidFinish:(BOOL)presenting;
   15|       |
   16|       |@end
   17|       |
   18|       |@interface JGProgressHUDAnimation () {
   19|       |    BOOL _presenting;
   20|       |}
   21|       |
   22|       |@property (nonatomic, weak) JGProgressHUD *progressHUD;
   23|       |
   24|       |@end
   25|       |
   26|       |@implementation JGProgressHUDAnimation
   27|       |
   28|       |#pragma mark - Initializers
   29|       |
   30|      0|+ (instancetype)animation {
   31|      0|    return [[self alloc] init];
   32|      0|}
   33|       |
   34|       |#pragma mark - Public methods
   35|       |
   36|      0|- (void)show {
   37|      0|    _presenting = YES;
   38|      0|}
   39|       |
   40|      0|- (void)hide {
   41|      0|    _presenting = NO;
   42|      0|}
   43|       |
   44|      0|- (void)animationFinished {
   45|      0|    [self.progressHUD animationDidFinish:_presenting];
   46|      0|}
   47|       |
   48|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDErrorIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDErrorIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 19.08.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUDErrorIndicatorView.h"
   10|       |#import "JGProgressHUD.h"
   11|       |
   12|       |@implementation JGProgressHUDErrorIndicatorView
   13|       |
   14|      0|- (instancetype)initWithContentView:(UIView *__unused)contentView {
   15|      0|    NSBundle *resourceBundle = [NSBundle bundleWithPath:[[NSBundle bundleForClass:[JGProgressHUD class]] pathForResource:@"JGProgressHUD Resources" ofType:@"bundle"]];
   16|      0|    
   17|      0|    NSString *imgPath = [resourceBundle pathForResource:@"jg_hud_error" ofType:@"png"];
   18|      0|    
   19|      0|    self = [super initWithImage:[UIImage imageWithContentsOfFile:imgPath]];
   20|      0|    
   21|      0|    return self;
   22|      0|}
   23|       |
   24|      0|- (instancetype)init {
   25|      0|    return [self initWithContentView:nil];
   26|      0|}
   27|       |
   28|      0|- (void)updateAccessibility {
   29|      0|    self.accessibilityLabel = NSLocalizedString(@"Error",);
   30|      0|}
   31|       |
   32|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDFadeAnimation.m:
    1|       |//
    2|       |//  JGProgressHUDFadeAnimation.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 20.7.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//  
    8|       |
    9|       |#import "JGProgressHUDFadeAnimation.h"
   10|       |#import "JGProgressHUD.h"
   11|       |
   12|       |@implementation JGProgressHUDFadeAnimation
   13|       |
   14|       |#pragma mark - Initializers
   15|       |
   16|      0|- (instancetype)init {
   17|      0|    self = [super init];
   18|      0|    if (self) {
   19|      0|        self.duration = 0.4;
   20|      0|        self.animationOptions = UIViewAnimationOptionCurveEaseInOut;
   21|      0|    }
   22|      0|    return self;
   23|      0|}
   24|       |
   25|      0|- (void)setAnimationOptions:(UIViewAnimationOptions)animationOptions {
   26|      0|    _animationOptions = (animationOptions | UIViewAnimationOptionBeginFromCurrentState);
   27|      0|}
   28|       |
   29|       |#pragma mark - Showing
   30|       |
   31|      0|- (void)show {
   32|      0|    [super show];
   33|      0|    
   34|      0|    self.progressHUD.alpha = 0.0f;
   35|      0|    
   36|      0|    self.progressHUD.hidden = NO;
   37|      0|    
   38|      0|    [UIView animateWithDuration:self.duration delay:0.0 options:self.animationOptions animations:^{
   39|      0|        self.progressHUD.alpha = 1.0f;
   40|      0|    } completion:^(BOOL __unused finished) {
   41|      0|        [self animationFinished];
   42|      0|    }];
   43|      0|}
   44|       |
   45|       |#pragma mark - Hiding
   46|       |
   47|      0|- (void)hide {
   48|      0|    [super hide];
   49|      0|    
   50|      0|    [UIView animateWithDuration:self.duration delay:0.0 options:self.animationOptions animations:^{
   51|      0|        self.progressHUD.alpha = 0.0f;
   52|      0|    } completion:^(BOOL __unused finished) {
   53|      0|        [self animationFinished];
   54|      0|    }];
   55|      0|}
   56|       |
   57|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDFadeZoomAnimation.m:
    1|       |//
    2|       |//  JGProgressHUDFadeZoomAnimation.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 20.7.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUDFadeZoomAnimation.h"
   10|       |#import "JGProgressHUD.h"
   11|       |
   12|       |@implementation JGProgressHUDFadeZoomAnimation
   13|       |
   14|       |#pragma mark - Initializers
   15|       |
   16|      0|- (instancetype)init {
   17|      0|    self = [super init];
   18|      0|    if (self) {
   19|      0|        self.shrinkAnimationDuaration = 0.2;
   20|      0|        self.expandAnimationDuaration = 0.1;
   21|      0|        self.expandScale = CGSizeMake(1.1f, 1.1f);
   22|      0|    }
   23|      0|    return self;
   24|      0|}
   25|       |
   26|       |#pragma mark - Showing
   27|       |
   28|      0|- (void)show {
   29|      0|    [super show];
   30|      0|    
   31|      0|    self.progressHUD.alpha = 0.0f;
   32|      0|    self.progressHUD.HUDView.transform = CGAffineTransformMakeScale(0.1f, 0.1f);
   33|      0|    
   34|      0|    NSTimeInterval totalDuration = self.expandAnimationDuaration+self.shrinkAnimationDuaration;
   35|      0|    
   36|      0|    self.progressHUD.hidden = NO;
   37|      0|    
   38|      0|    [UIView animateWithDuration:totalDuration delay:0.0 options:(UIViewAnimationOptions)(UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveEaseInOut) animations:^{
   39|      0|        self.progressHUD.alpha = 1.0f;
   40|      0|    } completion:nil];
   41|      0|    
   42|      0|    [UIView animateWithDuration:self.shrinkAnimationDuaration delay:0.0 options:(UIViewAnimationOptions)(UIViewAnimationOptionCurveEaseIn | UIViewAnimationOptionBeginFromCurrentState) animations:^{
   43|      0|        self.progressHUD.HUDView.transform = CGAffineTransformMakeScale(self.expandScale.width, self.expandScale.height);
   44|      0|    } completion:^(BOOL __unused _finished) {
   45|      0|        [UIView animateWithDuration:self.expandAnimationDuaration delay:0.0 options:(UIViewAnimationOptions)(UIViewAnimationOptionCurveEaseOut | UIViewAnimationOptionBeginFromCurrentState) animations:^{
   46|      0|            self.progressHUD.HUDView.transform = CGAffineTransformIdentity;
   47|      0|        } completion:^(BOOL __unused __finished) {
   48|      0|            [self animationFinished];
   49|      0|        }];
   50|      0|    }];
   51|      0|}
   52|       |
   53|       |#pragma mark - Hiding
   54|       |
   55|      0|- (void)hide {
   56|      0|    [super hide];
   57|      0|    
   58|      0|    NSTimeInterval totalDuration = self.expandAnimationDuaration+self.shrinkAnimationDuaration;
   59|      0|    
   60|      0|    [UIView animateWithDuration:totalDuration delay:0.0 options:(UIViewAnimationOptions)(UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveEaseInOut) animations:^{
   61|      0|        self.progressHUD.alpha = 0.0f;
   62|      0|    } completion:nil];
   63|      0|    
   64|      0|    [UIView animateWithDuration:self.expandAnimationDuaration delay:0.0 options:(UIViewAnimationOptions)(UIViewAnimationOptionCurveEaseIn | UIViewAnimationOptionBeginFromCurrentState) animations:^{
   65|      0|        self.progressHUD.HUDView.transform = CGAffineTransformMakeScale(self.expandScale.width, self.expandScale.height);
   66|      0|    } completion:^(BOOL __unused _finished) {
   67|      0|        [UIView animateWithDuration:self.shrinkAnimationDuaration delay:0.0 options:(UIViewAnimationOptions)(UIViewAnimationOptionCurveEaseOut | UIViewAnimationOptionBeginFromCurrentState) animations:^{
   68|      0|            self.progressHUD.HUDView.transform = CGAffineTransformMakeScale(0.1f, 0.1f);
   69|      0|        } completion:^(BOOL __unused __finished) {
   70|      0|            self.progressHUD.HUDView.transform = CGAffineTransformIdentity;
   71|      0|            
   72|      0|            [self animationFinished];
   73|      0|        }];
   74|      0|    }];
   75|      0|}
   76|       |
   77|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDImageIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDImageIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 05.08.15.
    6|       |//  Copyright (c) 2015 Jonas Gessner. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUDImageIndicatorView.h"
   10|       |
   11|       |@implementation JGProgressHUDImageIndicatorView
   12|       |
   13|      0|- (instancetype)initWithImage:(UIImage *)image {
   14|      0|    UIImageView *imageView = [[UIImageView alloc] initWithImage:image];
   15|      0|    
   16|      0|    self = [super initWithContentView:imageView];
   17|      0|    
   18|      0|    return self;
   19|      0|}
   20|       |
   21|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDIndeterminateIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDIndeterminateIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 19.07.14.
    6|       |//  Copyright (c) 2014 Hardtack. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUDIndeterminateIndicatorView.h"
   10|       |
   11|       |@implementation JGProgressHUDIndeterminateIndicatorView
   12|       |
   13|      1|- (instancetype)initWithHUDStyle:(JGProgressHUDStyle)style {
   14|      1|    UIActivityIndicatorView *activityIndicatorView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];
   15|      1|    [activityIndicatorView startAnimating];
   16|      1|    self = [super initWithContentView:activityIndicatorView];
   17|      1|    
   18|      1|    if (self) {
   19|      1|        if (style != JGProgressHUDStyleDark) {
   20|      0|            self.color = [UIColor blackColor];
   21|      0|        }
   22|      1|    }
   23|      1|    
   24|      1|    return self;
   25|      1|}
   26|       |
   27|      0|- (instancetype)init {
   28|      0|    return [self initWithHUDStyle:0];
   29|      0|}
   30|       |
   31|      0|- (void)setColor:(UIColor *)color {
   32|      0|    [(UIActivityIndicatorView *)self.contentView setColor:color];
   33|      0|}
   34|       |
   35|      1|- (void)updateAccessibility {
   36|      1|    self.accessibilityLabel = NSLocalizedString(@"Indeterminate progress",);
   37|      1|}
   38|       |
   39|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 20.7.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//  
    8|       |
    9|       |#import "JGProgressHUDIndicatorView.h"
   10|       |#import "JGProgressHUD.h"
   11|       |
   12|       |@interface JGProgressHUDIndicatorView () {
   13|       |    BOOL _accessibilityUpdateScheduled;
   14|       |}
   15|       |
   16|       |+ (void)runBlock:(void (^)(void))block;
   17|       |
   18|       |@end
   19|       |
   20|      1|NS_INLINE void runOnNextRunLoop(void (^block)(void)) {
   21|      1|    [[NSRunLoop currentRunLoop] performSelector:@selector(runBlock:) target:[JGProgressHUDIndicatorView class] argument:(id)block order:0 modes:@[NSRunLoopCommonModes]];
   22|      1|}
   23|       |
   24|       |@implementation JGProgressHUDIndicatorView
   25|       |
   26|       |#pragma mark - Initializers
   27|       |
   28|      0|- (instancetype)initWithFrame:(CGRect __unused)frame {
   29|      0|    return [self init];
   30|      0|}
   31|       |
   32|      0|- (instancetype)init {
   33|      0|    return [self initWithContentView:nil];
   34|      0|}
   35|       |
   36|      1|- (instancetype)initWithContentView:(UIView *)contentView {
   37|      1|    self = [super initWithFrame:(contentView ? contentView.frame : CGRectMake(0.0f, 0.0f, 50.0f, 50.0f))];
   38|      1|    if (self) {
   39|      1|        self.opaque = NO;
   40|      1|        self.backgroundColor = [UIColor clearColor];
   41|      1|        
   42|      1|        self.isAccessibilityElement = YES;
   43|      1|        [self setNeedsAccessibilityUpdate];
   44|      1|        
   45|      1|        if (contentView) {
   46|      1|            _contentView = contentView;
   47|      1|            
   48|      1|            [self addSubview:self.contentView];
   49|      1|        }
   50|      1|    }
   51|      1|    return self;
   52|      1|}
   53|       |
   54|       |#pragma mark - Accessibility
   55|       |
   56|      1|+ (void)runBlock:(void (^)(void))block {
   57|      1|    if (block != nil) {
   58|      1|        block();
   59|      1|    }
   60|      1|}
   61|       |
   62|      1|- (void)setNeedsAccessibilityUpdate {
   63|      1|    if (!_accessibilityUpdateScheduled) {
   64|      1|        _accessibilityUpdateScheduled = YES;
   65|      1|        
   66|      1|        runOnNextRunLoop(^{
   67|      1|            [self updateAccessibilityIfNeeded];
   68|      1|        });
   69|      1|    }
   70|      1|}
   71|       |
   72|      1|- (void)updateAccessibilityIfNeeded {
   73|      1|    if (_accessibilityUpdateScheduled) {
   74|      1|        [self updateAccessibility];
   75|      1|        _accessibilityUpdateScheduled = NO;
   76|      1|    }
   77|      1|}
   78|       |
   79|      0|- (void)updateAccessibility {
   80|      0|    self.accessibilityLabel = [NSLocalizedString(@"Loading",) stringByAppendingFormat:@" %.f %%", self.progress];
   81|      0|}
   82|       |
   83|       |#pragma mark - Getters & Setters
   84|       |
   85|      0|- (void)setProgress:(float)progress {
   86|      0|    [self setProgress:progress animated:NO];
   87|      0|}
   88|       |
   89|      0|- (void)setProgress:(float)progress animated:(__unused BOOL)animated {
   90|      0|    if (fequal(self.progress, progress)) {
   91|      0|        return;
   92|      0|    }
   93|      0|    
   94|      0|    _progress = progress;
   95|      0|    
   96|      0|    [self setNeedsAccessibilityUpdate];
   97|      0|}
   98|       |
   99|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDPieIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDPieIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 19.07.14.
    6|       |//  Copyright (c) 2014 Hardtack. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUDPieIndicatorView.h"
   10|       |
   11|       |@interface JGProgressHUDPieIndicatorLayer : CALayer
   12|       |
   13|       |@property (nonatomic, assign) float progress;
   14|       |
   15|       |@property (nonatomic, weak) UIColor *color;
   16|       |
   17|       |@property (nonatomic, weak) UIColor *fillColor;
   18|       |
   19|       |@end
   20|       |
   21|       |@implementation JGProgressHUDPieIndicatorLayer
   22|       |
   23|       |@dynamic progress, color, fillColor;
   24|       |
   25|      0|+ (BOOL)needsDisplayForKey:(NSString *)key {
   26|      0|    return ([key isEqualToString:@"progress"] || [key isEqualToString:@"color"] || [key isEqualToString:@"fillColor"] || [super needsDisplayForKey:key]);
   27|      0|}
   28|       |
   29|      0|- (id <CAAction>)actionForKey:(NSString *)key {
   30|      0|    if ([key isEqualToString:@"progress"]) {
   31|      0|        CABasicAnimation *progressAnimation = [CABasicAnimation animation];
   32|      0|        progressAnimation.fromValue = [self.presentationLayer valueForKey:key];
   33|      0|        
   34|      0|        progressAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
   35|      0|        
   36|      0|        return progressAnimation;
   37|      0|    }
   38|      0|    
   39|      0|    return [super actionForKey:key];
   40|      0|}
   41|       |
   42|      0|- (void)drawInContext:(CGContextRef)ctx {
   43|      0|    UIGraphicsPushContext(ctx);
   44|      0|    
   45|      0|    CGRect rect = self.bounds;
   46|      0|    
   47|      0|    CGPoint center = CGPointMake(rect.origin.x + (CGFloat)floor(rect.size.height/2.0f), rect.origin.y + (CGFloat)floor(rect.size.height/2.0f));
   48|      0|    CGFloat lineWidth = 2.0f;
   49|      0|    CGFloat radius = (CGFloat)floor(MIN(rect.size.width, rect.size.height)/2.0f)-lineWidth;
   50|      0|    
   51|      0|    //Border && Fill
   52|      0|    UIBezierPath *borderPath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0.0f endAngle:2.0f*(CGFloat)M_PI clockwise:NO];
   53|      0|    
   54|      0|    [borderPath setLineWidth:lineWidth];
   55|      0|    
   56|      0|    if (self.fillColor) {
   57|      0|        [self.fillColor setFill];
   58|      0|        
   59|      0|        [borderPath fill];
   60|      0|    }
   61|      0|    
   62|      0|    [self.color set];
   63|      0|    
   64|      0|    [borderPath stroke];
   65|      0|    
   66|      0|    
   67|      0|    //Progress
   68|      0|    if (self.progress > 0.0) {
   69|      0|        UIBezierPath *processPath = [UIBezierPath bezierPath];
   70|      0|        
   71|      0|        [processPath setLineWidth:radius];
   72|      0|        
   73|      0|        CGFloat startAngle = -((CGFloat)M_PI/2.0f);
   74|      0|        CGFloat endAngle = startAngle + 2.0f * (CGFloat)M_PI * self.progress;
   75|      0|        
   76|      0|        [processPath addArcWithCenter:center radius:radius/2.0f startAngle:startAngle endAngle:endAngle clockwise:YES];
   77|      0|        
   78|      0|        [processPath stroke];
   79|      0|        
   80|      0|        UIGraphicsPopContext();
   81|      0|    }
   82|      0|}
   83|       |
   84|       |@end
   85|       |
   86|       |
   87|       |@implementation JGProgressHUDPieIndicatorView
   88|       |
   89|       |#pragma mark - Initializers
   90|       |
   91|      0|- (instancetype)initWithHUDStyle:(JGProgressHUDStyle)style {
   92|      0|    self = [super init];
   93|      0|    
   94|      0|    if (self) {
   95|      0|        self.layer.contentsScale = [UIScreen mainScreen].scale;
   96|      0|        [self.layer setNeedsDisplay];
   97|      0|        
   98|      0|        if (style == JGProgressHUDStyleDark) {
   99|      0|            self.color = [UIColor whiteColor];
  100|      0|            self.fillColor = [UIColor colorWithWhite:0.2f alpha:1.0f];
  101|      0|        }
  102|      0|        else {
  103|      0|            self.color = [UIColor blackColor];
  104|      0|            if (style == JGProgressHUDStyleLight) {
  105|      0|                self.fillColor = [UIColor colorWithWhite:0.85f alpha:1.0f];
  106|      0|            }
  107|      0|            else {
  108|      0|                self.fillColor = [UIColor colorWithWhite:0.9f alpha:1.0f];
  109|      0|            }
  110|      0|        }
  111|      0|    }
  112|      0|    
  113|      0|    return self;
  114|      0|}
  115|       |
  116|      0|- (instancetype)initWithContentView:(UIView *)contentView {
  117|      0|    self = [super initWithContentView:contentView];
  118|      0|    
  119|      0|    if (self) {
  120|      0|        self.layer.contentsScale = [UIScreen mainScreen].scale;
  121|      0|        [self.layer setNeedsDisplay];
  122|      0|        
  123|      0|        self.color = [UIColor whiteColor];
  124|      0|    }
  125|      0|    
  126|      0|    return self;
  127|      0|}
  128|       |
  129|       |#pragma mark - Getters & Setters
  130|       |
  131|      0|- (void)setColor:(UIColor *)tintColor {
  132|      0|    if ([tintColor isEqual:self.color]) {
  133|      0|        return;
  134|      0|    }
  135|      0|    
  136|      0|    _color = tintColor;
  137|      0|    
  138|      0|    [(JGProgressHUDPieIndicatorLayer *)self.layer setColor:self.color];
  139|      0|}
  140|       |
  141|      0|- (void)setFillColor:(UIColor *)fillColor {
  142|      0|    if ([fillColor isEqual:self.fillColor]) {
  143|      0|        return;
  144|      0|    }
  145|      0|    
  146|      0|    _fillColor = fillColor;
  147|      0|    
  148|      0|    [(JGProgressHUDPieIndicatorLayer *)self.layer setFillColor:self.fillColor];
  149|      0|}
  150|       |
  151|      0|- (void)setProgress:(float)progress animated:(BOOL)animated {
  152|      0|    if (fequal(self.progress, progress)) {
  153|      0|        return;
  154|      0|    }
  155|      0|    
  156|      0|    [super setProgress:progress animated:animated];
  157|      0|    
  158|      0|    [CATransaction begin];
  159|      0|    [CATransaction setAnimationDuration:(animated ? 0.3 : 0.0)];
  160|      0|    
  161|      0|    [(JGProgressHUDPieIndicatorLayer *)self.layer setProgress:progress];
  162|      0|    
  163|      0|    [CATransaction commit];
  164|      0|}
  165|       |
  166|       |#pragma mark - Overrides
  167|       |
  168|      0|+ (Class)layerClass {
  169|      0|    return [JGProgressHUDPieIndicatorLayer class];
  170|      0|}
  171|       |
  172|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDRingIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDRingIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 20.7.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//  
    8|       |
    9|       |#import "JGProgressHUDRingIndicatorView.h"
   10|       |
   11|       |
   12|       |@interface JGProgressHUDRingIndicatorLayer : CALayer
   13|       |
   14|       |@property (nonatomic, assign) float progress;
   15|       |
   16|       |@property (nonatomic, weak) UIColor *ringColor;
   17|       |@property (nonatomic, weak) UIColor *ringBackgroundColor;
   18|       |
   19|       |@property (nonatomic, assign) BOOL roundProgressLine;
   20|       |
   21|       |@property (nonatomic, assign) CGFloat ringWidth;
   22|       |
   23|       |@end
   24|       |
   25|       |@implementation JGProgressHUDRingIndicatorLayer
   26|       |
   27|       |@dynamic progress, ringBackgroundColor, ringColor, ringWidth, roundProgressLine;
   28|       |
   29|      0|+ (BOOL)needsDisplayForKey:(NSString *)key {
   30|      0|    return ([key isEqualToString:@"progress"] || [key isEqualToString:@"ringColor"] || [key isEqualToString:@"ringBackgroundColor"] || [key isEqualToString:@"roundProgressLine"] || [key isEqualToString:@"ringWidth"] || [super needsDisplayForKey:key]);
   31|      0|}
   32|       |
   33|      0|- (id <CAAction>)actionForKey:(NSString *)key {
   34|      0|    if ([key isEqualToString:@"progress"]) {
   35|      0|        CABasicAnimation *progressAnimation = [CABasicAnimation animation];
   36|      0|        progressAnimation.fromValue = [self.presentationLayer valueForKey:key];
   37|      0|        
   38|      0|        progressAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];
   39|      0|        
   40|      0|        return progressAnimation;
   41|      0|    }
   42|      0|    
   43|      0|    return [super actionForKey:key];
   44|      0|}
   45|       |
   46|      0|- (void)drawInContext:(CGContextRef)ctx {
   47|      0|    UIGraphicsPushContext(ctx);
   48|      0|    
   49|      0|    CGRect rect = self.bounds;
   50|      0|    
   51|      0|    CGPoint center = CGPointMake(rect.origin.x + (CGFloat)floor(rect.size.height/2.0f), rect.origin.y + (CGFloat)floor(rect.size.height/2.0f));
   52|      0|    CGFloat lineWidth = self.ringWidth;
   53|      0|    CGFloat radius = (CGFloat)floor(MIN(rect.size.width, rect.size.height)/2.0f) - lineWidth;
   54|      0|    
   55|      0|    //Background
   56|      0|    [self.ringBackgroundColor setStroke];
   57|      0|    
   58|      0|    UIBezierPath *borderPath = [UIBezierPath bezierPathWithArcCenter:center radius:radius startAngle:0.0f endAngle:2.0f*(CGFloat)M_PI clockwise:NO];
   59|      0|    
   60|      0|    [borderPath setLineWidth:lineWidth];
   61|      0|    [borderPath stroke];
   62|      0|    
   63|      0|    //Progress
   64|      0|    [self.ringColor setStroke];
   65|      0|    
   66|      0|    if (self.progress > 0.0f) {
   67|      0|        UIBezierPath *processPath = [UIBezierPath bezierPath];
   68|      0|        
   69|      0|        [processPath setLineWidth:lineWidth];
   70|      0|        [borderPath setLineCapStyle:(self.roundProgressLine ? kCGLineCapRound : kCGLineCapSquare)];
   71|      0|        
   72|      0|        CGFloat startAngle = -((CGFloat)M_PI / 2.0f);
   73|      0|        CGFloat endAngle = startAngle + 2.0f * (CGFloat)M_PI * self.progress;
   74|      0|        
   75|      0|        [processPath addArcWithCenter:center radius:radius startAngle:startAngle endAngle:endAngle clockwise:YES];
   76|      0|        
   77|      0|        [processPath stroke];
   78|      0|    }
   79|      0|}
   80|       |
   81|       |@end
   82|       |
   83|       |
   84|       |@implementation JGProgressHUDRingIndicatorView
   85|       |
   86|       |#pragma mark - Initializers
   87|       |
   88|      0|- (instancetype)initWithHUDStyle:(JGProgressHUDStyle)style {
   89|      0|    self = [super init];
   90|      0|    
   91|      0|    if (self) {
   92|      0|        self.layer.contentsScale = [UIScreen mainScreen].scale;
   93|      0|        [self.layer setNeedsDisplay];
   94|      0|        
   95|      0|        if (style == JGProgressHUDStyleDark) {
   96|      0|            self.ringColor = [UIColor whiteColor];
   97|      0|            self.ringBackgroundColor = [UIColor blackColor];
   98|      0|        }
   99|      0|        else {
  100|      0|            self.ringColor = [UIColor blackColor];
  101|      0|            if (style == JGProgressHUDStyleLight) {
  102|      0|                self.ringBackgroundColor = [UIColor colorWithWhite:0.85f alpha:1.0f];
  103|      0|            }
  104|      0|            else {
  105|      0|                self.ringBackgroundColor = [UIColor colorWithWhite:0.9f alpha:1.0f];
  106|      0|            }
  107|      0|        }
  108|      0|    }
  109|      0|    
  110|      0|    return self;
  111|      0|}
  112|       |
  113|      0|- (instancetype)initWithContentView:(UIView *)contentView {
  114|      0|    self = [super initWithContentView:contentView];
  115|      0|    
  116|      0|    if (self) {
  117|      0|        self.layer.contentsScale = [UIScreen mainScreen].scale;
  118|      0|        [self.layer setNeedsDisplay];
  119|      0|        
  120|      0|        self.ringColor = [UIColor whiteColor];
  121|      0|        self.ringBackgroundColor = [UIColor blackColor];
  122|      0|        self.ringWidth = 3.0f;
  123|      0|    }
  124|      0|    
  125|      0|    return self;
  126|      0|}
  127|       |
  128|       |#pragma mark - Getters & Setters
  129|       |
  130|      0|- (void)setRoundProgressLine:(BOOL)roundProgressLine {
  131|      0|    if (roundProgressLine == self.roundProgressLine) {
  132|      0|        return;
  133|      0|    }
  134|      0|    
  135|      0|    _roundProgressLine = roundProgressLine;
  136|      0|    
  137|      0|    [(JGProgressHUDRingIndicatorLayer *)self.layer setRoundProgressLine:self.roundProgressLine];
  138|      0|}
  139|       |
  140|      0|- (void)setRingColor:(UIColor *)tintColor {
  141|      0|    if ([tintColor isEqual:self.ringColor]) {
  142|      0|        return;
  143|      0|    }
  144|      0|    
  145|      0|    _ringColor = tintColor;
  146|      0|    
  147|      0|    [(JGProgressHUDRingIndicatorLayer *)self.layer setRingColor:self.ringColor];
  148|      0|}
  149|       |
  150|      0|- (void)setRingBackgroundColor:(UIColor *)backgroundTintColor {
  151|      0|    if ([backgroundTintColor isEqual:self.ringBackgroundColor]) {
  152|      0|        return;
  153|      0|    }
  154|      0|    
  155|      0|    _ringBackgroundColor = backgroundTintColor;
  156|      0|    
  157|      0|    [(JGProgressHUDRingIndicatorLayer *)self.layer setRingBackgroundColor:self.ringBackgroundColor];
  158|      0|}
  159|       |
  160|      0|- (void)setRingWidth:(CGFloat)ringWidth {
  161|      0|    if (fequal(ringWidth, self.ringWidth)) {
  162|      0|        return;
  163|      0|    }
  164|      0|    
  165|      0|    _ringWidth = ringWidth;
  166|      0|    
  167|      0|    [(JGProgressHUDRingIndicatorLayer *)self.layer setRingWidth:self.ringWidth];
  168|      0|}
  169|       |
  170|      0|- (void)setProgress:(float)progress animated:(BOOL)animated {
  171|      0|    if (fequal(self.progress, progress)) {
  172|      0|        return;
  173|      0|    }
  174|      0|    
  175|      0|    [super setProgress:progress animated:animated];
  176|      0|    
  177|      0|    [CATransaction begin];
  178|      0|    [CATransaction setAnimationDuration:(animated ? 0.3 : 0.0)];
  179|      0|    
  180|      0|    [(JGProgressHUDRingIndicatorLayer *)self.layer setProgress:self.progress];
  181|      0|    
  182|      0|    [CATransaction commit];
  183|      0|}
  184|       |
  185|       |#pragma mark - Overrides
  186|       |
  187|      0|+ (Class)layerClass {
  188|      0|    return [JGProgressHUDRingIndicatorLayer class];
  189|      0|}
  190|       |
  191|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/JGProgressHUD/JGProgressHUD/JGProgressHUD/JGProgressHUDSuccessIndicatorView.m:
    1|       |//
    2|       |//  JGProgressHUDSuccessIndicatorView.m
    3|       |//  JGProgressHUD
    4|       |//
    5|       |//  Created by Jonas Gessner on 19.08.14.
    6|       |//  Copyright (c) 2014 Jonas Gessner. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "JGProgressHUDSuccessIndicatorView.h"
   10|       |#import "JGProgressHUD.h"
   11|       |
   12|       |@implementation JGProgressHUDSuccessIndicatorView
   13|       |
   14|      0|- (instancetype)initWithContentView:(UIView *__unused)contentView {
   15|      0|    NSBundle *resourceBundle = [NSBundle bundleWithPath:[[NSBundle bundleForClass:[JGProgressHUD class]] pathForResource:@"JGProgressHUD Resources" ofType:@"bundle"]];
   16|      0|    
   17|      0|    NSString *imgPath = [resourceBundle pathForResource:@"jg_hud_success" ofType:@"png"];
   18|      0|    
   19|      0|    self = [super initWithImage:[UIImage imageWithContentsOfFile:imgPath]];
   20|      0|    
   21|      0|    return self;
   22|      0|}
   23|       |
   24|      0|- (instancetype)init {
   25|      0|    return [self initWithContentView:nil];
   26|      0|}
   27|       |
   28|      0|- (void)updateAccessibility {
   29|      0|    self.accessibilityLabel = NSLocalizedString(@"Success",);
   30|      0|}
   31|       |
   32|       |@end

