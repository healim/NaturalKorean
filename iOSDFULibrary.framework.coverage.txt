/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/DFUPeripheralSelector.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |/// The default selector. Selects the first device with Legacy or Secure DFU Service UUID in the advertising packet.
   26|       |@objc open class DFUPeripheralSelector : NSObject, DFUPeripheralSelectorDelegate {
   27|       |
   28|      0|    open func select(_ peripheral: CBPeripheral, advertisementData: [String : AnyObject], RSSI: NSNumber) -> Bool {
   29|      0|        return true
   30|      0|    }
   31|       |    
   32|      0|    open func filterBy(hint dfuServiceUUID: CBUUID) -> [CBUUID]? {
   33|      0|        return [dfuServiceUUID]
   34|      0|    }
   35|       |}
   36|       |

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/DFUSelector/DFUServiceSelector.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal protocol DFUStarterPeripheralDelegate : BasePeripheralDelegate {
   26|       |    /**
   27|       |     Callback called when a DFU service has been found on a remote device.
   28|       |     - returns: The executor type based on the found DFU Service: SecureDFUExecutor or LegacyDFUExecutor
   29|       |     */
   30|       |    func peripheralDidSelectedExecutor(_ ExecutorType: DFUExecutorAPI.Type)
   31|       |}
   32|       |
   33|       |/**
   34|       | This class has a responsibility to connect to a given peripheral and determin which DFU implementation should be used
   35|       | based on the services found on the device.
   36|       | */
   37|       |internal class DFUServiceSelector : BaseDFUExecutor, DFUStarterPeripheralDelegate {
   38|       |    typealias DFUPeripheralType = DFUStarterPeripheral
   39|       |    
   40|       |    internal let initiator:  DFUServiceInitiator
   41|       |    internal let controller: DFUServiceController
   42|       |    internal let peripheral: DFUStarterPeripheral
   43|       |    internal var error: (error: DFUError, message: String)?
   44|       |    
   45|      0|    init(initiator: DFUServiceInitiator, controller: DFUServiceController) {
   46|      0|        self.initiator  = initiator
   47|      0|        self.controller = controller
   48|      0|        self.peripheral = DFUStarterPeripheral(initiator)
   49|      0|        
   50|      0|        self.peripheral.delegate = self
   51|      0|    }
   52|       |    
   53|      0|    func start() {
   54|      0|        DispatchQueue.main.async(execute: {
   55|      0|            self.delegate?.dfuStateDidChange(to: .connecting)
   56|      0|        })
   57|      0|        peripheral.start()
   58|      0|    }
   59|       |    
   60|      0|    func peripheralDidSelectedExecutor(_ ExecutorType: DFUExecutorAPI.Type) {
   61|      0|        // Release the cyclic reference
   62|      0|        peripheral.destroy()
   63|      0|        
   64|      0|        let executor = ExecutorType.init(initiator)
   65|      0|        controller.executor = executor
   66|      0|        executor.start()
   67|      0|    }
   68|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/DFUSelector/DFUStarterPeripheral.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal class DFUStarterPeripheral : BaseDFUPeripheral<DFUServiceSelector> {
   26|       |    
   27|       |    /**
   28|       |     Method called when a DFU service has been found.
   29|       |     */
   30|      0|    override func peripheralDidDiscoverDfuService(_ service: CBService) {
   31|      0|        if SecureDFUService.matches(service) {
   32|      0|            logger.v("Starting Secure DFU...")
   33|      0|            delegate?.peripheralDidSelectedExecutor(SecureDFUExecutor.self)
   34|      0|        } else if LegacyDFUService.matches(service) {
   35|      0|            logger.v("Starting Legacy DFU...")
   36|      0|            delegate?.peripheralDidSelectedExecutor(LegacyDFUExecutor.self)
   37|      0|        } else if SecureDFUService.matches(experimental: service) {
   38|      0|            logger.v("Starting Secure DFU...")
   39|      0|            delegate?.peripheralDidSelectedExecutor(SecureDFUExecutor.self)
   40|      0|        } else {
   41|      0|            // This will never go in here
   42|      0|            delegate?.error(.deviceNotSupported, didOccurWithMessage: "Device not supported")
   43|      0|        }
   44|      0|    }    
   45|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/DFUServiceController.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |@objc public class DFUServiceController : NSObject {
   26|       |
   27|       |    internal var executor: BaseExecutorAPI?
   28|       |    
   29|       |    private var servicePaused  = false
   30|       |    private var serviceAborted = false
   31|       |    
   32|      0|    internal override init() {
   33|      0|        // empty internal constructor
   34|      0|    }
   35|       |    
   36|       |    /**
   37|       |     Call this method to pause uploading during the transmition process. The transmition can be resumed
   38|       |     only when connection remains. If service has already started sending firmware data it will pause after receiving
   39|       |     next Packet Receipt Notification. Otherwise it will continue to send Op Codes and pause before sending the first bytes
   40|       |     of the firmware. With Packet Receipt Notifications disabled it is the only moment when upload may be paused.
   41|       |     */
   42|      0|    public func pause() {
   43|      0|        guard let executor = executor, !servicePaused, !serviceAborted else { return }
   44|      0|        if executor.pause() {
   45|      0|            servicePaused = true
   46|      0|        }
   47|      0|    }
   48|       |    
   49|       |    /**
   50|       |     Call this method to resume the paused transffer, otherwise does nothing.
   51|       |     */
   52|      0|    public func resume() {
   53|      0|        guard let executor = executor, servicePaused, !serviceAborted else { return }
   54|      0|        if executor.resume() {
   55|      0|            servicePaused = false
   56|      0|        }
   57|      0|    }
   58|       |    
   59|       |    /**
   60|       |     Aborts the upload. The phone will disconnect from peripheral. The peripheral will try to
   61|       |     recover the last firmware. Might, restart in the Bootloader mode if the application has been
   62|       |     removed.
   63|       |     
   64|       |     Abort (Reset) command will be sent instead of a next Op Code, or after receiving a
   65|       |     Packet Receipt Notification. It PRM procedure is disabled it will continue until the whole
   66|       |     firmware is sent and then Reset will be sent instead of Verify Firmware op code.
   67|       |     
   68|       |     - returns: true if DFU has been aborted.
   69|       |     */
   70|      0|    public func abort() -> Bool {
   71|      0|        guard let executor = executor, !serviceAborted else { return serviceAborted }
   72|      0|        serviceAborted = true
   73|      0|        servicePaused = false
   74|      0|        return executor.abort()
   75|      0|    }
   76|       |    
   77|       |    /**
   78|       |     Starts again aborted DFU operation.
   79|       |     */
   80|      0|    public func restart() {
   81|      0|        guard let executor = executor, serviceAborted else { return }
   82|      0|        serviceAborted = false
   83|      0|        servicePaused = false
   84|      0|        executor.start()
   85|      0|    }
   86|       |    
   87|       |    /**
   88|       |     Returns true if DFU operation has been paused.
   89|       |     */
   90|      0|    public var paused: Bool {
   91|      0|        return servicePaused
   92|      0|    }
   93|       |    
   94|       |    /**
   95|       |     Returns true if DFU operation has been aborted.
   96|       |     */
   97|      0|    public var aborted: Bool {
   98|      0|        return serviceAborted
   99|      0|    }
  100|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/DFUServiceDelegate.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |@objc public enum DFUError : Int {
   24|       |    // Legacy DFU errors
   25|       |    case remoteLegacyDFUSuccess               = 1
   26|       |    case remoteLegacyDFUInvalidState          = 2
   27|       |    case remoteLegacyDFUNotSupported          = 3
   28|       |    case remoteLegacyDFUDataExceedsLimit      = 4
   29|       |    case remoteLegacyDFUCrcError              = 5
   30|       |    case remoteLegacyDFUOperationFailed       = 6
   31|       |    
   32|       |    // Secure DFU errors (received value + 10 as they overlap legacy errors)
   33|       |    case remoteSecureDFUSuccess               = 11 // 10 + 1
   34|       |    case remoteSecureDFUOpCodeNotSupported    = 12 // 10 + 2
   35|       |    case remoteSecureDFUInvalidParameter      = 13 // 10 + 3
   36|       |    case remoteSecureDFUInsufficientResources = 14 // 10 + 4
   37|       |    case remoteSecureDFUInvalidObject         = 15 // 10 + 5
   38|       |    case remoteSecureDFUSignatureMismatch     = 16 // 10 + 6
   39|       |    case remoteSecureDFUUnsupportedType       = 17 // 10 + 7
   40|       |    case remoteSecureDFUOperationNotpermitted = 18 // 10 + 8
   41|       |    case remoteSecureDFUOperationFailed       = 20 // 10 + 10
   42|       |    case remoteSecureDFUExtendedError         = 21 // 10 + 11
   43|       |    
   44|       |    // Experimental Buttonless DFU errors (received value + 9000 as they overlap legacy and secure DFU errors)
   45|       |    case remoteExperimentalBootlonlessDFUSuccess               = 9001 // 9000 + 1
   46|       |    case remoteExperimentalBootlonlessDFUOpCodeNotSupported    = 9002 // 9000 + 2
   47|       |    case remoteExperimentalBootlonlessDFUOperationFailed       = 9004 // 9000 + 4
   48|       |    
   49|       |    // Buttonless DFU errors (received value + 9000 as they overlap legacy and secure DFU errors)
   50|       |    case remoteBootlonlessDFUSuccess            = 31 // 30 + 1
   51|       |    case remoteBootlonlessDFUOpCodeNotSupported = 32 // 30 + 2
   52|       |    case remoteBootlonlessDFUOperationFailed    = 34 // 30 + 4
   53|       |    
   54|       |    /// Providing the DFUFirmware is required.
   55|       |    case fileNotSpecified                     = 101
   56|       |    /// Given firmware file is not supported.
   57|       |    case fileInvalid                          = 102
   58|       |    /// Since SDK 7.0.0 the DFU Bootloader requires the extended Init Packet. For more details, see:
   59|       |    /// http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v11.0.0/bledfu_example_init.html?cp=4_0_0_4_2_1_1_3
   60|       |    case extendedInitPacketRequired           = 103
   61|       |    /// Before SDK 7.0.0 the init packet could have contained only 2-byte CRC value, and was optional.
   62|       |    /// Providing an extended one instead would cause CRC error during validation (the bootloader assumes that the 2 first bytes
   63|       |    /// of the init packet are the firmware CRC).
   64|       |    case initPacketRequired                   = 104
   65|       |    
   66|       |    case failedToConnect                      = 201
   67|       |    case deviceDisconnected                   = 202
   68|       |    case bluetoothDisabled                    = 203
   69|       |    
   70|       |    case serviceDiscoveryFailed               = 301
   71|       |    case deviceNotSupported                   = 302
   72|       |    case readingVersionFailed                 = 303
   73|       |    case enablingControlPointFailed           = 304
   74|       |    case writingCharacteristicFailed          = 305
   75|       |    case receivingNotificationFailed          = 306
   76|       |    case unsupportedResponse                  = 307
   77|       |    /// Error raised during upload when the number of bytes sent is not equal to number of bytes confirmed in Packet Receipt Notification.
   78|       |    case bytesLost                            = 308
   79|       |    /// Error raised when the CRC reported by the remote device does not match. Service has done 3 tries to send the data.
   80|       |    case crcError                             = 309
   81|       |}
   82|       |
   83|       |/**
   84|       | The state of the DFU Service.
   85|       | 
   86|       | - connecting:      Service is connecting to the DFU target
   87|       | - starting:        DFU Service is initializing DFU operation
   88|       | - enablingDfuMode: Service is switching the device to DFU mode
   89|       | - uploading:       Service is uploading the firmware
   90|       | - validating:      The DFU target is validating the firmware
   91|       | - disconnecting:   The iDevice is disconnecting or waiting for disconnection
   92|       | - completed:       DFU operation is completed and successful
   93|       | - aborted:         DFU Operation was aborted
   94|       | */
   95|       |
   96|       |@objc public enum DFUState : Int {
   97|       |    case connecting
   98|       |    case starting
   99|       |    case enablingDfuMode
  100|       |    case uploading
  101|       |    case validating
  102|       |    case disconnecting
  103|       |    case completed
  104|       |    case aborted
  105|       |    
  106|      0|    public func description() -> String {
  107|      0|        switch self {
  108|      0|        case .connecting:      return "Connecting"
  109|      0|        case .starting:        return "Starting"
  110|      0|        case .enablingDfuMode: return "Enabling DFU Mode"
  111|      0|        case .uploading:       return "Uploading"
  112|      0|        case .validating:      return "Validating"  // this state occurs only in Legacy DFU
  113|      0|        case .disconnecting:   return "Disconnecting"
  114|      0|        case .completed:       return "Completed"
  115|      0|        case .aborted:         return "Aborted"
  116|      0|        }
  117|      0|    }
  118|       |}
  119|       |
  120|       |/**
  121|       | *  The progress delegates may be used to notify user about progress updates.
  122|       | *  The only method of the delegate is only called when the service is in the Uploading state.
  123|       | */
  124|       |@objc public protocol DFUProgressDelegate {
  125|       |    /**
  126|       |     Callback called in the `State.Uploading` state. Gives detailed information about the progress
  127|       |     and speed of transmission. This method is always called at least two times (for 0% and 100%)
  128|       |     if upload has started and did not fail.
  129|       |     
  130|       |     This method is called in the main thread and is safe to update any UI.
  131|       |     
  132|       |     - parameter part: number of part that is currently being transmitted. Parts start from 1
  133|       |     and may have value either 1 or 2. Part 2 is used only when there were Soft Device and/or
  134|       |     Bootloader AND an Application in the Distribution Packet and the DFU target does not
  135|       |     support sending all files in a single connection. First the SD and/or BL will be sent, then
  136|       |     the service will disconnect, reconnect again to the (new) bootloader and send the Application.
  137|       |     - parameter totalParts: total number of parts that are to be send (this is always equal to 1 or 2).
  138|       |     - parameter progress: the current progress of uploading the current part in percentage (values 0-100).
  139|       |     Each value will be called at most once - in case of a large file a value e.g. 3% will be called only once,
  140|       |     despite that it will take more than one packet to reach 4%. In case of a small firmware file
  141|       |     some values may be ommited. For example, if firmware file would be only 20 bytes you would get
  142|       |     a callback 0% (called always) and then 100% when done.
  143|       |     - parameter currentSpeedBytesPerSecond: the current speed in bytes per second
  144|       |     - parameter avgSpeedBytesPerSecond: the average speed in bytes per second
  145|       |     */
  146|       |    func dfuProgressDidChange(for part: Int, outOf totalParts: Int, to progress: Int,
  147|       |        currentSpeedBytesPerSecond: Double, avgSpeedBytesPerSecond: Double)
  148|       |}
  149|       |
  150|       |/**
  151|       | *  The service delegate reports about state changes and errors.
  152|       | */
  153|       |@objc public protocol DFUServiceDelegate {
  154|       |    /**
  155|       |     Callback called when state of the DFU Service has changed.
  156|       |     
  157|       |     This method is called in the main thread and is safe to update any UI.
  158|       |     
  159|       |     - parameter state: the new state fo the service
  160|       |     */
  161|       |    func dfuStateDidChange(to state: DFUState)
  162|       |    
  163|       |    /**
  164|       |     Called after an error occurred.
  165|       |     The device will be disconnected and DFU operation has been aborted.
  166|       |     
  167|       |     This method is called in the main thread and is safe to update any UI.
  168|       |     
  169|       |     - parameter error:   the error code
  170|       |     - parameter message: error description
  171|       |     */
  172|       |    func dfuError(_ error: DFUError, didOccurWithMessage message: String)
  173|       |
  174|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/DFUServiceInitiator.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |/**
   26|       | The DFUServiceInitiator object should be used to send a firmware update to a remote BLE target compatible
   27|       | with the Nordic Semiconductor's DFU (Device Firmware Update).
   28|       | A `delegate`, `progressDelegate` and `logger` may be specified in order to receive status information.
   29|       | */
   30|       |@objc public class DFUServiceInitiator : NSObject {
   31|       |    
   32|       |    //MARK: - Internal variables
   33|       |    
   34|       |    internal let centralManager : CBCentralManager
   35|       |    internal let target         : CBPeripheral
   36|       |    internal var file           : DFUFirmware?
   37|       |    
   38|       |    //MARK: - Public variables
   39|       |    
   40|       |    /**
   41|       |     The service delegate is an object that will be notified about state changes of the DFU Service.
   42|       |     Setting it is optional but recommended.
   43|       |     */
   44|       |    public weak var delegate: DFUServiceDelegate?
   45|       |    
   46|       |    /**
   47|       |     An optional progress delegate will be called only during upload. It notifies about current upload
   48|       |     percentage and speed.
   49|       |     */
   50|       |    public weak var progressDelegate: DFUProgressDelegate?
   51|       |    
   52|       |    /**
   53|       |     The logger is an object that should print given messages to the user. It is optional.
   54|       |     */
   55|       |    public weak var logger: LoggerDelegate?
   56|       |    
   57|       |    /**
   58|       |     The selector object is used when the device needs to disconnect and start advertising with a different address
   59|       |     to avodi caching problems, for example after switching to the Bootloader mode, or during sending a firmware
   60|       |     containing a Softdevice (or Softdevice and Bootloader) and the Application. 
   61|       |     After flashing the first part (containing the Softdevice), the device restarts in the
   62|       |     DFU Bootloader mode and may (since SDK 8.0.0) start advertising with an address incremented by 1.
   63|       |     The peripheral specified in the `init` may no longer be used as there is no device advertising with its address.
   64|       |     The DFU Service will scan for a new device and connect to the first device returned by the selector.
   65|       |     
   66|       |     The default selecter returns the first device with the required DFU Service UUID in the advertising packet
   67|       |     (Secure or Legacy DFU Service UUID).
   68|       |     
   69|       |     Ignore this property if not updating Softdevice and Application from one ZIP file or your 
   70|       |     */
   71|       |    public var peripheralSelector: DFUPeripheralSelectorDelegate
   72|       |
   73|       |    /**
   74|       |     The number of packets of firmware data to be received by the DFU target before sending
   75|       |     a new Packet Receipt Notification.
   76|       |     If this value is 0, the packet receipt notification will be disabled by the DFU target.
   77|       |     Default value is 12. Higher values (~20+), or disabling it, may speed up the upload process,
   78|       |     but also cause a buffer overflow and hang the Bluetooth adapter.
   79|       |     Maximum verified values were 29 for iPhone 6 Plus or 22 for iPhone 7, both iOS 10.1.
   80|       |     */
   81|       |    public var packetReceiptNotificationParameter: UInt16 = 12
   82|       |    
   83|       |    /**
   84|       |     **Legacy DFU only.**
   85|       |     
   86|       |     Setting this property to true will prevent from jumping to the DFU Bootloader
   87|       |     mode in case there is no DFU Version characteristic. Use it if the DFU operation can be handled by your
   88|       |     device running in the application mode. If the DFU Version characteristic exists, the
   89|       |     information whether to begin DFU operation, or jump to bootloader, is taken from the
   90|       |     characteristic's value. The value returned equal to 0x0100 (read as: minor=1, major=0, or version 0.1)
   91|       |     means that the device is in the application mode and buttonless jump to DFU Bootloader is supported.
   92|       |     
   93|       |     Currently, the following values of the DFU Version characteristic are supported:
   94|       |     
   95|       |     **No DFU Version characteristic** - one of the first implementations of DFU Service. The device
   96|       |     may support only Application update (version from SDK 4.3.0), may support Soft Device, Bootloader
   97|       |     and Application update but without buttonless jump to bootloader (SDK 6.0.0) or with
   98|       |     buttonless jump (SDK 6.1.0).
   99|       |     
  100|       |     The DFU Library determines whether the device is in application mode or in DFU Bootloader mode
  101|       |     by counting number of services: if no DFU Service found - device is in app mode and does not support
  102|       |     buttonless jump, if the DFU Service is the only service found (except General Access and General Attribute
  103|       |     services) - it assumes it is in DFU Bootloader mode and may start DFU immediately, if there is
  104|       |     at least one service except DFU Service - the device is in application mode and supports buttonless
  105|       |     jump. In the lase case, you want to perform DFU operation without jumping - call the setForceDfu(force:Bool)
  106|       |     method with parameter equal to true.
  107|       |     
  108|       |     **0.1** - Device is in a mode that supports buttonless jump to the DFU Bootloader
  109|       |     
  110|       |     **0.5** - Device can handle DFU operation. Extended Init packet is required. Bond information is lost
  111|       |     in the bootloader mode and after updating an app. Released in SDK 7.0.0.
  112|       |     
  113|       |     **0.6** - Bond information is kept in bootloader mode and may be kept after updating application
  114|       |     (DFU Bootloader must be configured to preserve the bond information).
  115|       |     
  116|       |     **0.7** - The SHA-256 firmware hash is used in the Extended Init Packet instead of CRC-16.
  117|       |     This feature is transparent for the DFU Service.
  118|       |     
  119|       |     **0.8** - The Extended Init Packet is signed using the private key. The bootloader, using the public key,
  120|       |     is able to verify the content. Released in SDK 9.0.0 as experimental feature.
  121|       |     Caution! The firmware type (Application, Bootloader, SoftDevice or SoftDevice+Bootloader) is not
  122|       |     encrypted as it is not a part of the Extended Init Packet. A change in the protocol will be required
  123|       |     to fix this issue.
  124|       |     
  125|       |     By default the DFU Library will try to switch the device to the DFU Bootloader mode if it finds
  126|       |     more services then one (DFU Service). It assumes it is already in the bootloader mode
  127|       |     if the only service found is the DFU Service. Setting the forceDfu to true (YES) will prevent from
  128|       |     jumping in these both cases.
  129|       |     */
  130|       |    public var forceDfu = false
  131|       |    
  132|       |    /**
  133|       |     Set this flag to true to enable experimental buttonless feature in Secure DFU. When the 
  134|       |     experimental Buttonless DFU Service is found on a device, the service will use it to
  135|       |     switch the device to the bootloader mode, connect to it in that mode and proceed with DFU.
  136|       |     
  137|       |     **Please, read the information below before setting it to true.**
  138|       |     
  139|       |     In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
  140|       |     It is NOT recommended to use it: it was not properly tested, had implementation bugs 
  141|       |     (e.g. https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/) and
  142|       |     does not required encryption and therefore may lead to DOS attack (anyone can use it to switch the device
  143|       |     to bootloader mode). However, as there is no other way to trigger bootloader mode on devices
  144|       |     without a button, this DFU Library supports this service, but the feature must be explicitly enabled here.
  145|       |     Be aware, that setting this flag to false will no protect your devices from this kind of attacks, as
  146|       |     an attacker may use another app for that purpose. To be sure your device is secure remove this
  147|       |     experimental service from your device.
  148|       |     
  149|       |     Spec:
  150|       |     
  151|       |     Buttonless DFU Service UUID: 8E400001-F315-4F60-9FB8-838830DAEA50
  152|       |     
  153|       |     Buttonless DFU characteristic UUID: 8E400001-F315-4F60-9FB8-838830DAEA50 (the same)
  154|       |     
  155|       |     Enter Bootloader Op Code: 0x01
  156|       |     
  157|       |     Correct return value: 0x20-01-01 , where:
  158|       |       0x20 - Response Op Code
  159|       |       0x01 - Request Code
  160|       |       0x01 - Success
  161|       |     The device should disconnect and restart in DFU mode after sending the notification.
  162|       |     
  163|       |     In SDK 13 this issue will be fixed by a proper implementation (bonding required,
  164|       |     passing bond information to the bootloader, encryption, well tested). It is recommended to use this 
  165|       |     new service when SDK 13 (or later) is out. TODO: fix the docs when SDK 13 is out.
  166|       |     */
  167|       |    public var enableUnsafeExperimentalButtonlessServiceInSecureDfu = false
  168|       |    
  169|       |    //MARK: - Public API
  170|       |    
  171|       |    /**
  172|       |     Creates the DFUServiceInitializer that will allow to send an update to the given peripheral.
  173|       |     The peripheral should be disconnected prior to calling start() method.
  174|       |     The DFU service will automatically connect to the device, check if it has required DFU
  175|       |     service (return a delegate callback if does not have such), jump to the DFU Bootloader mode
  176|       |     if necessary and perform the DFU. Proper delegate methods will be called during the process.
  177|       |     
  178|       |     - parameter centralManager: manager that will be used to connect to the peripheral
  179|       |     - parameter target: the DFU target peripheral
  180|       |     
  181|       |     - returns: the initiator instance
  182|       |     
  183|       |     - seeAlso: peripheralSelector property - a selector used when scanning for a device in DFU Bootloader mode
  184|       |     in case you want to update a Softdevice and Application from a single ZIP Distribution Packet.
  185|       |     */
  186|      0|    public init(centralManager: CBCentralManager, target: CBPeripheral) {
  187|      0|        self.centralManager = centralManager
  188|      0|        // Just to be sure that manager is not scanning
  189|      0|        self.centralManager.stopScan()
  190|      0|        self.target = target
  191|      0|        // Default peripheral selector will choose the service UUID as a filter
  192|      0|        self.peripheralSelector = DFUPeripheralSelector()
  193|      0|        super.init()
  194|      0|    }
  195|       |    
  196|       |    /**
  197|       |     Sets the file with the firmware. The file must be specified before calling `start()` method,
  198|       |     and must not be nil.
  199|       |     
  200|       |     - parameter file: The firmware wrapper object
  201|       |     
  202|       |     - returns: the initiator instance to allow chain use
  203|       |     */
  204|      0|    public func with(firmware file: DFUFirmware) -> DFUServiceInitiator {
  205|      0|        self.file = file
  206|      0|        return self
  207|      0|    }
  208|       |    
  209|       |    /**
  210|       |     Starts sending the specified firmware to the DFU target.
  211|       |     When started, the service will automatically connect to the target, switch to DFU Bootloader mode
  212|       |     (if necessary), and send all the content of the specified firmware file in one or two connections.
  213|       |     Two connections will be used if a ZIP file contains a Soft Device and/or Bootloader and an Application.
  214|       |     First the Soft Device and/or Bootloader will be transferred, then the service will disconnect, reconnect to
  215|       |     the (new) Bootloader again and send the Application (unless the target supports receiving all files in a single
  216|       |     connection).
  217|       |     
  218|       |     The current version of the DFU Bootloader, due to memory limitations, may receive together only a Softdevice and Bootloader.
  219|       |     
  220|       |     - returns: A DFUServiceController object that can be used to control the DFU operation.
  221|       |     */
  222|      0|    public func start() -> DFUServiceController? {
  223|      0|        // The firmware file must be specified before calling `start()`
  224|      0|        if file == nil {
  225|      0|            delegate?.dfuError(.fileNotSpecified, didOccurWithMessage: "Firmare not specified")
  226|      0|            return nil
  227|      0|        }
  228|      0|
  229|      0|        let controller = DFUServiceController()
  230|      0|        let selector   = DFUServiceSelector(initiator: self, controller: controller)
  231|      0|        controller.executor = selector
  232|      0|        selector.start()
  233|      0|        
  234|      0|        return controller
  235|      0|    }
  236|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/Firmware/DFUFirmware.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |/**
   24|       |The type of the BIN or HEX file.
   25|       |
   26|       |- Softdevice:           Firmware file will be sent as a new Softdevice
   27|       |- Bootloader:           Firmware file will be sent as a new Bootloader
   28|       |- Application:          Firmware file will be sent as a new application
   29|       |*/
   30|       |@objc public enum DFUFirmwareType : UInt8 {
   31|       |    case softdevice = 1
   32|       |    case bootloader = 2
   33|       |    case application = 4
   34|       |    // Merged option values (due to objc - Swift compatibility).
   35|       |    case softdeviceBootloader = 3
   36|       |    case softdeviceBootloaderApplication = 7
   37|       |}
   38|       |
   39|       |/// The DFUFirmware object wraps the firmware file.
   40|       |@objc public class DFUFirmware : NSObject, DFUStream {
   41|       |    internal let stream: DFUStream?
   42|       |    
   43|       |    /// The name of the firmware file.
   44|       |    public let fileName: String!
   45|       |    /// The URL to the firmware file.
   46|       |    public let fileUrl: URL!
   47|       |    
   48|       |    /// Information whether the firmware was successfully initialized.
   49|      0|    public var valid: Bool {
   50|      0|        return stream != nil
   51|      0|    }
   52|       |    
   53|       |    /// The size of each component of the firmware.
   54|      0|    public var size: DFUFirmwareSize {
   55|      0|        return stream!.size
   56|      0|    }
   57|       |    
   58|       |    /// Number of connectinos required to transfer the firmware. This does not include the connection needed to switch to the DFU mode.
   59|      0|    public var parts: Int {
   60|      0|        if stream == nil {
   61|      0|            return 0
   62|      0|        }
   63|      0|        return stream!.parts
   64|      0|    }
   65|       |    
   66|      0|    internal var currentPartSize: DFUFirmwareSize {
   67|      0|        return stream!.currentPartSize
   68|      0|    }
   69|       |    
   70|      0|    internal var currentPartType: UInt8 {
   71|      0|        return stream!.currentPartType
   72|      0|    }
   73|       |    
   74|      0|    internal var currentPart: Int {
   75|      0|        return stream!.currentPart
   76|      0|    }
   77|       |    
   78|       |    /**
   79|       |     Creates the DFU Firmware object from a Distribution packet (ZIP). Such file must contain a manifest.json file
   80|       |     with firmware metadata and at least one firmware binaries. Read more about the Distribution packet on
   81|       |     the DFU documentation.
   82|       |     
   83|       |     - parameter urlToZipFile: URL to the Distribution packet (ZIP)
   84|       |     
   85|       |     - returns: the DFU firmware object or null in case of an error
   86|       |     */
   87|      0|    convenience public init?(urlToZipFile: URL) {
   88|      0|        self.init(urlToZipFile: urlToZipFile, type: DFUFirmwareType.softdeviceBootloaderApplication)
   89|      0|    }
   90|       |    
   91|       |    /**
   92|       |     Creates the DFU Firmware object from a Distribution packet (ZIP). Such file must contain a manifest.json file
   93|       |     with firmware metadata and at least one firmware binaries. Read more about the Distribution packet on
   94|       |     the DFU documentation.
   95|       |     
   96|       |     - parameter urlToZipFile: URL to the Distribution packet (ZIP)
   97|       |     - parameter type:         the type of the firmware to use
   98|       |     
   99|       |     - returns: the DFU firmware object or null in case of an error
  100|       |     */
  101|      0|    public init?(urlToZipFile: URL, type: DFUFirmwareType) {
  102|      0|        fileUrl = urlToZipFile
  103|      0|        fileName = urlToZipFile.lastPathComponent
  104|      0|        
  105|      0|        // Quickly check if it's a ZIP file
  106|      0|        let ext = urlToZipFile.pathExtension
  107|      0|        if ext.caseInsensitiveCompare("zip") != .orderedSame {
  108|      0|            NSLog("\(self.fileName) is not a ZIP file")
  109|      0|            stream = nil
  110|      0|            super.init()
  111|      0|            return nil
  112|      0|        }
  113|      0|        
  114|      0|        do {
  115|      0|            stream = try DFUStreamZip(urlToZipFile: urlToZipFile, type: type.rawValue)
  116|      0|        } catch let error as NSError {
  117|      0|            NSLog("Error while creating ZIP stream: \(error.localizedDescription)")
  118|      0|            stream = nil
  119|      0|            super.init()
  120|      0|            return nil
  121|      0|        }
  122|      0|        super.init()
  123|      0|    }
  124|       |    
  125|       |    /**
  126|       |     Creates the DFU Firmware object from a BIN or HEX file. Setting the DAT file with an Init packet is optional,
  127|       |     but may be required by the bootloader.
  128|       |     
  129|       |     - parameter urlToBinOrHexFile: URL to a BIN or HEX file with the firmware
  130|       |     - parameter urlToDatFile: optional URL to a DAT file with the Init packet
  131|       |     - parameter type:         The type of the firmware
  132|       |     
  133|       |     - returns: the DFU firmware object or null in case of an error
  134|       |     */
  135|      0|    public init?(urlToBinOrHexFile: URL, urlToDatFile: URL?, type: DFUFirmwareType) {
  136|      0|        self.fileUrl = urlToBinOrHexFile
  137|      0|        self.fileName = urlToBinOrHexFile.lastPathComponent
  138|      0|        
  139|      0|        // Quickly check if it's a BIN file
  140|      0|        let ext = urlToBinOrHexFile.pathExtension
  141|      0|        let bin = ext.caseInsensitiveCompare("bin") == .orderedSame
  142|      0|        let hex = ext.caseInsensitiveCompare("hex") == .orderedSame
  143|      0|        if !bin && !hex {
  144|      0|            NSLog("\(self.fileName) is not a BIN or HEX file")
  145|      0|            stream = nil
  146|      0|            super.init()
  147|      0|            return nil
  148|      0|        }
  149|      0|        
  150|      0|        if let datUrl = urlToDatFile {
  151|      0|            let datExt = datUrl.pathExtension
  152|      0|            if datExt.caseInsensitiveCompare("dat") != .orderedSame {
  153|      0|                NSLog("\(self.fileName) is not a DAT file")
  154|      0|                stream = nil
  155|      0|                super.init()
  156|      0|                return nil
  157|      0|            }
  158|      0|        }
  159|      0|        
  160|      0|        if bin {
  161|      0|            stream = DFUStreamBin(urlToBinFile: urlToBinOrHexFile, urlToDatFile: urlToDatFile, type: type)
  162|      0|        } else {
  163|      0|            stream = DFUStreamHex(urlToHexFile: urlToBinOrHexFile, urlToDatFile: urlToDatFile, type: type)
  164|      0|        }
  165|      0|        super.init()
  166|      0|    }
  167|       |    
  168|      0|    internal var data: Data {
  169|      0|        return stream!.data as Data
  170|      0|    }
  171|       |    
  172|      0|    internal var initPacket: Data? {
  173|      0|        return stream!.initPacket as Data?
  174|      0|    }
  175|       |    
  176|      0|    internal func hasNextPart() -> Bool {
  177|      0|        return stream!.hasNextPart()
  178|      0|    }
  179|       |    
  180|      0|    internal func switchToNextPart() {
  181|      0|        stream!.switchToNextPart()
  182|      0|    }
  183|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/GenericDFU/DFUExecutor.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal protocol BaseExecutorAPI : class, DFUController {
   26|       |    /**
   27|       |     Starts the DFU operation.
   28|       |     */
   29|       |    func start()
   30|       |}
   31|       |
   32|       |internal protocol BaseDFUExecutor : BaseExecutorAPI, BasePeripheralDelegate {
   33|       |    associatedtype DFUPeripheralType : BaseDFUPeripheralAPI
   34|       |    /// Target peripheral object
   35|       |    var peripheral: DFUPeripheralType { get }
   36|       |    /// The DFU Service Initiator instance that was used to start the service.
   37|       |    var initiator: DFUServiceInitiator { get }
   38|       |    /// If an error occurred it is set as this variable. It will be reported to the user when the device gets disconnected.
   39|       |    var error: (error: DFUError, message: String)? { set get }
   40|       |}
   41|       |
   42|       |extension BaseDFUExecutor {
   43|       |    /// The service delegate will be informed about status changes and errors.
   44|      0|    internal var delegate: DFUServiceDelegate? {
   45|      0|        // The delegate may change during DFU operation (by setting a new one in the initiator). Let's always use the current one.
   46|      0|        return initiator.delegate
   47|      0|    }
   48|       |    
   49|       |    /// The progress delegate will be informed about current upload progress.
   50|      0|    internal var progressDelegate: DFUProgressDelegate? {
   51|      0|        // The delegate may change during DFU operation (by setting a new one in the initiator). Let's always use the current one.
   52|      0|        return initiator.progressDelegate
   53|      0|    }
   54|       |    
   55|       |    // MARK: - DFU Controller API
   56|       |    
   57|      0|    func pause() -> Bool {
   58|      0|        return peripheral.pause()
   59|      0|    }
   60|       |    
   61|      0|    func resume() -> Bool {
   62|      0|        return peripheral.resume()
   63|      0|    }
   64|       |    
   65|      0|    func abort() -> Bool {
   66|      0|        return peripheral.abort()
   67|      0|    }
   68|       |    
   69|       |    // MARK: - BasePeripheralDelegate API
   70|       |    
   71|      0|    func peripheralDidFailToConnect() {
   72|      0|        DispatchQueue.main.async(execute: {
   73|      0|            self.delegate?.dfuError(.failedToConnect, didOccurWithMessage: "Device failed to connect")
   74|      0|        })
   75|      0|        // Release the cyclic reference
   76|      0|        peripheral.destroy()
   77|      0|    }
   78|       |    
   79|      0|    func peripheralDidDisconnect() {
   80|      0|        // The device is now disconnected. Check if there was an error that needs to be reported now
   81|      0|        DispatchQueue.main.async(execute: {
   82|      0|            if let error = self.error {
   83|      0|                self.delegate?.dfuError(error.error, didOccurWithMessage: error.message)
   84|      0|            } else {
   85|      0|                self.delegate?.dfuError(.deviceDisconnected, didOccurWithMessage: "Device disconnected unexpectedly")
   86|      0|            }
   87|      0|        })
   88|      0|        // Release the cyclic reference
   89|      0|        peripheral.destroy()
   90|      0|    }
   91|       |    
   92|      0|    func peripheralDidDisconnect(withError error: Error) {
   93|      0|        DispatchQueue.main.async(execute: {
   94|      0|            self.delegate?.dfuError(.deviceDisconnected, didOccurWithMessage: "\(error.localizedDescription) (code: \((error as NSError).code))")
   95|      0|        })
   96|      0|        // Release the cyclic reference
   97|      0|        peripheral.destroy()
   98|      0|    }
   99|       |    
  100|      0|    func peripheralDidDisconnectAfterAborting() {
  101|      0|        DispatchQueue.main.async(execute: {
  102|      0|            self.delegate?.dfuStateDidChange(to: .aborted)
  103|      0|        })
  104|      0|        // Release the cyclic reference
  105|      0|        peripheral.destroy()
  106|      0|    }
  107|       |    
  108|      0|    func error(_ error: DFUError, didOccurWithMessage message: String) {
  109|      0|        // Save the error. It will be reported when the device disconnects
  110|      0|        if self.error == nil {
  111|      0|            self.error = (error, message)
  112|      0|            peripheral.resetDevice()
  113|      0|        }
  114|      0|    }
  115|       |    
  116|       |    // MARK: - Helper functions
  117|       |    
  118|      0|    func logWith(_ level: LogLevel, message: String) {
  119|      0|        initiator.logger?.logWith(level, message: message)
  120|      0|    }
  121|       |}
  122|       |
  123|       |// MARK: -
  124|       |
  125|       |internal protocol DFUExecutorAPI : BaseExecutorAPI {
  126|       |    /// Required constructor
  127|       |    init(_ initiator: DFUServiceInitiator)
  128|       |}
  129|       |
  130|       |internal protocol DFUExecutor : DFUExecutorAPI, BaseDFUExecutor, DFUPeripheralDelegate {
  131|       |    associatedtype DFUPeripheralType : DFUPeripheralAPI
  132|       |    /// The firmware to be sent over-the-air
  133|       |    var firmware: DFUFirmware { get }
  134|       |}
  135|       |
  136|       |extension DFUExecutor {
  137|       |    
  138|       |    // MARK: - BasePeripheralDelegate API
  139|       |    
  140|      0|    func peripheralDidDisconnectAfterFirmwarePartSent() {
  141|      0|        // Check if there is another part of the firmware that has to be sent
  142|      0|        if firmware.hasNextPart() {
  143|      0|            firmware.switchToNextPart()
  144|      0|            DispatchQueue.main.async(execute: {
  145|      0|                self.delegate?.dfuStateDidChange(to: .connecting)
  146|      0|            })
  147|      0|            peripheral.switchToNewPeripheralAndConnect()
  148|      0|            return
  149|      0|        }
  150|      0|        // If not, we are done here. Congratulations!
  151|      0|        DispatchQueue.main.async(execute: {
  152|      0|            // If no, the DFU operation is complete
  153|      0|            self.delegate?.dfuStateDidChange(to: .completed)
  154|      0|        })
  155|      0|            
  156|      0|        // Release the cyclic reference
  157|      0|        peripheral.destroy()
  158|      0|    }
  159|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/GenericDFU/DFUPeripheral.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal protocol BaseDFUPeripheralAPI : class, DFUController {
   26|       |    /**
   27|       |     This method starts DFU process for given peripheral. If the peripheral is not connected it will call the connect() method,
   28|       |     if it is connected, but services were not discovered before, it will try to discover services instead.
   29|       |     If services were already discovered the DFU process will be started.
   30|       |     */
   31|       |    func start()
   32|       |    
   33|       |    /**
   34|       |     Disconnects the target device.
   35|       |     */
   36|       |    func disconnect()
   37|       |    
   38|       |    /**
   39|       |     This method breaks the cyclic reference and both DFUExecutor and DFUPeripheral may be released.
   40|       |     */
   41|       |    func destroy()
   42|       |    
   43|       |    /**
   44|       |     This method should reset the device, preferably switching it to application mode.
   45|       |     */
   46|       |    func resetDevice()
   47|       |}
   48|       |
   49|       |internal class BaseDFUPeripheral<TD : BasePeripheralDelegate> : NSObject, BaseDFUPeripheralAPI, CBPeripheralDelegate, CBCentralManagerDelegate {
   50|       |    /// Bluetooth Central Manager used to scan for the peripheral.
   51|       |    internal let centralManager: CBCentralManager
   52|       |    /// The DFU Target peripheral.
   53|       |    internal var peripheral: CBPeripheral?
   54|       |    /// The peripheral delegate.
   55|       |    internal var delegate: TD?
   56|       |    /// The optional logger delegate.
   57|       |    internal let logger: LoggerHelper
   58|       |    /// A list of services required to be found on the peripheral. May return nil - then all services will be discovered.
   59|      0|    internal var requiredServices: [CBUUID]? {
   60|      0|        // We have to find all services, not only those releated to DFU. This is required in case the target device
   61|      0|        // was created using SDK 6.0 or 6.1, where there was no DFU Version characteristic. In that case, this DFU library determines
   62|      0|        // whether to jump to bootloader, or proceed with DFU based on number of services found. We have to find all of them.
   63|      0|        // It is not necessary for newer firmwares (SDK 7+) or for Secure DFU where the code below could work.
   64|      0|        return nil
   65|      0|        
   66|      0|        /*
   67|      0|        // If the experimental feature was enabled
   68|      0|        if experimentalButtonlessServiceInSecureDfuEnabled {
   69|      0|            return [LegacyDFUService.UUID, SecureDFUService.UUID, SecureDFUService.ExperimentalButtonlessDfuUUID]
   70|      0|        }
   71|      0|        // By default only standard Secure and Legacy DFU services will be discovered
   72|      0|        return [LegacyDFUService.UUID, SecureDFUService.UUID]
   73|      0|        */
   74|      0|    }
   75|       |    /// A flag indicating whether the eperimental Buttonless DFU Service in Secure DFU is supported
   76|       |    internal let experimentalButtonlessServiceInSecureDfuEnabled: Bool
   77|       |    /// Default error callback
   78|      0|    internal var defaultErrorCallback: ErrorCallback {
   79|      0|        return { (error, message) in self.delegate?.error(error, didOccurWithMessage: message) }
   80|      0|    }
   81|       |    
   82|       |    /// A flag set when upload has been aborted.
   83|       |    fileprivate var aborted: Bool = false
   84|       |    
   85|      0|    init(_ initiator: DFUServiceInitiator) {
   86|      0|        self.centralManager = initiator.centralManager
   87|      0|        self.logger = LoggerHelper(initiator.logger)
   88|      0|        self.experimentalButtonlessServiceInSecureDfuEnabled = initiator.enableUnsafeExperimentalButtonlessServiceInSecureDfu
   89|      0|        super.init()
   90|      0|        // Set the initial peripheral. It may be changed later (flashing App fw after first flashing SD/BL)
   91|      0|        self.peripheral = initiator.target
   92|      0|    }
   93|       |    
   94|       |    // MARK: - Base DFU Peripheral API
   95|       |    
   96|      0|    func start() {
   97|      0|        aborted = false
   98|      0|        centralManager.delegate = self
   99|      0|        
  100|      0|        if peripheral!.state != .connected {
  101|      0|            connect()
  102|      0|        } else {
  103|      0|            let name = peripheral!.name ?? "Unknown device"
  104|      0|            logger.i("Connected to \(name)")
  105|      0|            
  106|      0|            let dfuService = findDfuService(in: peripheral!.services)
  107|      0|            if dfuService == nil {
  108|      0|                // DFU service has not been found, but it doesn't matter it's not there.
  109|      0|                // Perhaps the user's application didn't discover it. Let's discover DFU services.
  110|      0|                discoverServices()
  111|      0|            } else {
  112|      0|                // A DFU service was found, congratulations!
  113|      0|                logger.i("Services discovered")
  114|      0|                peripheralDidDiscoverDfuService(dfuService!)
  115|      0|            }
  116|      0|        }
  117|      0|    }
  118|       |    
  119|      0|    func disconnect() {
  120|      0|        if peripheral!.state == .connected {
  121|      0|            logger.v("Disconnecting...")
  122|      0|        } else {
  123|      0|            logger.v("Cancelling connection...")
  124|      0|        }
  125|      0|        logger.d("centralManager.cancelPeripheralConnection(peripheral)")
  126|      0|        centralManager.cancelPeripheralConnection(peripheral!)
  127|      0|    }
  128|       |    
  129|      0|    func destroy() {
  130|      0|        centralManager.delegate = nil
  131|      0|        peripheral?.delegate = nil
  132|      0|        delegate = nil
  133|      0|    }
  134|       |    
  135|       |    // MARK: - DFU Controller API
  136|       |    
  137|      0|    func pause() -> Bool {
  138|      0|        // BaseDFUPeripheral does not support pausing or resuming
  139|      0|        return false
  140|      0|    }
  141|       |    
  142|      0|    func resume() -> Bool {
  143|      0|        // BaseDFUPeripheral does not support pausing or resuming
  144|      0|        return false
  145|      0|    }
  146|       |    
  147|      0|    func abort() -> Bool {
  148|      0|        aborted = true
  149|      0|        if peripheral?.state == .connecting {
  150|      0|            disconnect()
  151|      0|        }
  152|      0|        return true
  153|      0|    }
  154|       |    
  155|       |    // MARK: - Central Manager methods
  156|       |    
  157|      0|    func centralManagerDidUpdateState(_ central: CBCentralManager) {
  158|      0|        var stateAsString: String
  159|      0|        
  160|      0|        switch (central.state) {
  161|      0|        case .poweredOn:
  162|      0|            stateAsString = "Powered ON"
  163|      0|        case .poweredOff:
  164|      0|            stateAsString = "Powered OFF"
  165|      0|        case .resetting:
  166|      0|            stateAsString = "Resetting"
  167|      0|        case .unauthorized:
  168|      0|            stateAsString = "Unauthorized"
  169|      0|        case .unsupported:
  170|      0|            stateAsString = "Unsupported"
  171|      0|        case .unknown:
  172|      0|            stateAsString = "Unknown"
  173|      0|        }
  174|      0|        logger.d("[Callback] Central Manager did update state to: \(stateAsString)")
  175|      0|        if central.state != .poweredOn {
  176|      0|            // The device has been already disconnected if it was connected
  177|      0|            delegate?.error(.bluetoothDisabled, didOccurWithMessage: "Bluetooth adapter powered off")
  178|      0|        }
  179|      0|    }
  180|       |    
  181|      0|    func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
  182|      0|        cleanUp()
  183|      0|        
  184|      0|        logger.d("[Callback] Central Manager did connect peripheral")
  185|      0|        let name = peripheral.name ?? "Unknown device"
  186|      0|        logger.i("Connected to \(name)")
  187|      0|        
  188|      0|        guard !aborted else {
  189|      0|            resetDevice()
  190|      0|            return
  191|      0|        }
  192|      0|        
  193|      0|        discoverServices()
  194|      0|    }
  195|       |    
  196|      0|    func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
  197|      0|        cleanUp()
  198|      0|        
  199|      0|        if let error = error {
  200|      0|            logger.d("[Callback] Central Manager did fail to connect peripheral")
  201|      0|            logger.e(error)
  202|      0|        } else {
  203|      0|            logger.d("[Callback] Central Manager did fail to connect peripheral without error")
  204|      0|        }
  205|      0|        logger.e("Device failed to connect")
  206|      0|        delegate?.peripheralDidFailToConnect()
  207|      0|    }
  208|       |    
  209|      0|    func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
  210|      0|        cleanUp()
  211|      0|        
  212|      0|        // We may expect an error with 
  213|      0|        // code = 7: "The specified device has disconnected from us." (graceful disconnect), or
  214|      0|        // code = 6: "The connection has timed out unexpectedly." (in case it disconnected before sending the ACK).
  215|      0|        if let error = error {
  216|      0|            let cbError = error as! CBError
  217|      0|            if cbError.code == CBError.connectionTimeout || cbError.code == CBError.peripheralDisconnected {
  218|      0|                logger.d("[Callback] Central Manager did disconnect peripheral")
  219|      0|                logger.i("Disconnected by the remote device")
  220|      0|                
  221|      0|                peripheralDidDisconnect()
  222|      0|            } else {
  223|      0|                logger.e("[Callback] Central Manager did disconnect peripheral with error: \(error.localizedDescription)")
  224|      0|                logger.i("Disconnected")
  225|      0|                
  226|      0|                logger.e(error)
  227|      0|                delegate?.peripheralDidDisconnect(withError: error)
  228|      0|            }
  229|      0|        } else {
  230|      0|            logger.d("[Callback] Central Manager did disconnect peripheral")
  231|      0|            logger.i("Disconnected")
  232|      0|            
  233|      0|            peripheralDidDisconnect()
  234|      0|        }
  235|      0|    }
  236|       |    
  237|      0|    func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
  238|      0|        // This empty method has to be here, otherwise the BaseCommonDFUPeripheral does not get this callback
  239|      0|        
  240|      0|        // Don't use central manager while DFU is in progress!
  241|      0|        print("DFU in progress, don't use this CentralManager instance!")
  242|      0|        central.stopScan()
  243|      0|    }
  244|       |    
  245|       |    // MARK: - Peripheral Delegate methods
  246|       |    
  247|      0|    func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {
  248|      0|        guard error == nil else {
  249|      0|            logger.e("Services discovery failed")
  250|      0|            logger.e(error!)
  251|      0|            delegate?.error(.serviceDiscoveryFailed, didOccurWithMessage: "Services discovery failed")
  252|      0|            return
  253|      0|        }
  254|      0|        
  255|      0|        logger.i("Services discovered")
  256|      0|        
  257|      0|        guard !aborted else {
  258|      0|            resetDevice()
  259|      0|            return
  260|      0|        }
  261|      0|        
  262|      0|        // Search for DFU service
  263|      0|        guard let dfuService = findDfuService(in: peripheral.services) else {
  264|      0|            logger.e("DFU Service not found")
  265|      0|            // The device does not support DFU, nor buttonless jump
  266|      0|            delegate?.error(.deviceNotSupported, didOccurWithMessage: "DFU Service not found")
  267|      0|            return
  268|      0|        }
  269|      0|        // A DFU service was found, congratulations!
  270|      0|        peripheralDidDiscoverDfuService(dfuService)
  271|      0|    }
  272|       |    
  273|       |    // MARK: - Methods to be overriden in the final implementation
  274|       |    
  275|       |    /**
  276|       |     Method called when a DFU service has been found.
  277|       |     */
  278|      0|    func peripheralDidDiscoverDfuService(_ service: CBService) {
  279|      0|        fatalError("This method must be overriden")
  280|      0|    }
  281|       |    
  282|       |    /**
  283|       |     Method called when the device got disconnected.
  284|       |     */
  285|      0|    func peripheralDidDisconnect() {
  286|      0|        guard !aborted else {
  287|      0|            // The device has resetted. Notify user
  288|      0|            logger.w("Upload aborted")
  289|      0|            delegate?.peripheralDidDisconnectAfterAborting()
  290|      0|            return
  291|      0|        }
  292|      0|        
  293|      0|        // Notify the delegate about the disconnection.
  294|      0|        // Most probably an error occurred and will be reported to the user.
  295|      0|        delegate?.peripheralDidDisconnect()
  296|      0|    }
  297|       |    
  298|       |    /**
  299|       |     This method should reset the device, preferably switching it to application mode.
  300|       |     */
  301|      0|    func resetDevice() {
  302|      0|        if peripheral != nil && peripheral!.state != .disconnected {
  303|      0|            disconnect()
  304|      0|        } else {
  305|      0|            peripheralDidDisconnect()
  306|      0|        }
  307|      0|    }
  308|       |    
  309|       |    // MARK: - Private methods
  310|       |    
  311|       |    /**
  312|       |     Looks for a DFU Service in given list of services.
  313|       |     - returns: a DFUService type if a DFU service has been found, or nil if services are nil or the list
  314|       |     does not contain any supported DFU Service.
  315|       |     */
  316|      0|    private func findDfuService(in services:[CBService]?) -> CBService? {
  317|      0|        if let services = services {
  318|      0|            for service in services {
  319|      0|                // Skip the experimental Buttonless DFU Service if this feature wasn't enabled
  320|      0|                if experimentalButtonlessServiceInSecureDfuEnabled && SecureDFUService.matches(experimental: service) {
  321|      0|                    // The experimental Buttonless DFU Service for Secure DFU has been found
  322|      0|                    return service
  323|      0|                }
  324|      0|                if SecureDFUService.matches(service) {
  325|      0|                    // Secure DFU Service has been found
  326|      0|                    return service
  327|      0|                }
  328|      0|                if LegacyDFUService.matches(service) {
  329|      0|                    // Legacy DFU Service has been found
  330|      0|                    return service
  331|      0|                }
  332|      0|            }
  333|      0|        }
  334|      0|        return nil
  335|      0|    }
  336|       |    
  337|       |    /**
  338|       |     Starts the service discovery.
  339|       |     */
  340|      0|    private func discoverServices() {
  341|      0|        let services = requiredServices
  342|      0|        // Discover DFU service on the device to determine the DFU implementation.
  343|      0|        logger.v("Discovering services...")
  344|      0|        if services != nil {
  345|      0|            logger.d("peripheral.discoverServices(\(services!))")
  346|      0|        } else {
  347|      0|            logger.d("peripheral.discoverServices(nil)")
  348|      0|        }
  349|      0|        peripheral!.delegate = self
  350|      0|        peripheral!.discoverServices(services)
  351|      0|    }
  352|       |    
  353|       |    /**
  354|       |     Connects to the peripheral and performs service discovery.
  355|       |     */
  356|      0|    fileprivate func connect() {
  357|      0|        let name = peripheral!.name ?? "Unknown device"
  358|      0|        logger.v("Connecting to \(name)...")
  359|      0|        logger.d("centralManager.connect(peripheral, options: nil)")
  360|      0|        centralManager.connect(peripheral!, options: nil)
  361|      0|    }
  362|       |    
  363|      0|    fileprivate func cleanUp() {
  364|      0|        // do nothing
  365|      0|    }
  366|       |}
  367|       |
  368|       |internal protocol DFUPeripheralAPI : BaseDFUPeripheralAPI {
  369|       |    /**
  370|       |     Checks whether the target device is in application mode and must be switched to the DFU mode.
  371|       |     
  372|       |     - parameter forceDfu: should the service assume the device is in DFU Bootloader mode when
  373|       |     DFU Version characteristic does not exist and at least one other service has been found on the device.
  374|       |     
  375|       |     - returns: true if device needs buttonless jump to DFU Bootloader mode
  376|       |     */
  377|       |    func isInApplicationMode(_ forceDfu: Bool) -> Bool
  378|       |    
  379|       |    /**
  380|       |     Scans for a next device to connect to. When device is found and selected, it connects to it.
  381|       |     
  382|       |     After updating the Softdevice the device may start advertising with an address incremented by 1.
  383|       |     A BLE scan needs to be done to find this new peripheral (it's the same device, but as it
  384|       |     advertises with a new address, from iOS point of view it completly different device).
  385|       |     */
  386|       |    func switchToNewPeripheralAndConnect()
  387|       |    
  388|       |    /**
  389|       |     Returns whether the Init Packet is required by the target DFU device.
  390|       |     
  391|       |     - returns: true if init packet is required, false if not. Init packet is required
  392|       |     since DFU Bootloader version 0.5 (SDK 7.0.0).
  393|       |     */
  394|       |    func isInitPacketRequired() -> Bool
  395|       |    
  396|       |    /// A flag set when a command to jump to DFU Bootloader has been sent.
  397|       |    var jumpingToBootloader: Bool { get set }
  398|       |    /// A flag set when a command to activate the new firmware and reset the device has been sent.
  399|       |    var activating: Bool { get set }
  400|       |    /// A flag set when the library should try again connecting to the device (it may be then in a correct state).
  401|       |    var shouldReconnect: Bool { get set }
  402|       |}
  403|       |
  404|       |internal protocol DFUPeripheral : DFUPeripheralAPI {
  405|       |    associatedtype DFUServiceType : DFUService
  406|       |    
  407|       |    /// Selector used to find the advertising peripheral in DFU Bootloader mode.
  408|       |    var peripheralSelector: DFUPeripheralSelectorDelegate { get }
  409|       |    
  410|       |    /// The DFU Service instance. Not nil when found on the peripheral.
  411|       |    var dfuService: DFUServiceType? { get set }
  412|       |}
  413|       |
  414|       |internal class BaseCommonDFUPeripheral<TD : DFUPeripheralDelegate, TS : DFUService> : BaseDFUPeripheral<TD>, DFUPeripheral {
  415|       |    /// The peripheral selector instance specified in the initiator
  416|       |    internal let peripheralSelector: DFUPeripheralSelectorDelegate
  417|       |    
  418|       |    internal typealias DFUServiceType = TS
  419|       |    internal var dfuService: DFUServiceType?
  420|       |    
  421|       |    /// This flag must be set to true if switching to bootloader mode is expected after executing the next operation.
  422|       |    /// The operation is expecter to reset the device. After the disconnect event is received the service will 
  423|       |    /// try to connect back to the device, or scan for a new device matching specified selector, depending on
  424|       |    /// `newAddressExpected` flag value.
  425|       |    internal var jumpingToBootloader : Bool = false
  426|       |    /// This flag must be set to true when the firmware upload is complete and device will restart and run the new fw
  427|       |    /// after executing the next operation.
  428|       |    internal var activating          : Bool = false
  429|       |    /// This flag has the same behavior as `jumpingToBootloader`, but it's used when Invalid state error was received and
  430|       |    /// a reset command will be executed. The service will reconnect to the same device.
  431|       |    internal var shouldReconnect     : Bool = false
  432|       |    /// This flag must be set to true if the device will advertise with a new device address after it resets.
  433|       |    /// The service will scan and use specified peripheral selector in order to connect to the new peripheral.
  434|       |    internal var newAddressExpected  : Bool = false
  435|       |    
  436|      0|    override init(_ initiator: DFUServiceInitiator) {
  437|      0|        self.peripheralSelector = initiator.peripheralSelector
  438|      0|        super.init(initiator)
  439|      0|    }
  440|       |    
  441|       |    // MARK: - Base DFU Peripheral API
  442|       |    
  443|      0|    override func peripheralDidDiscoverDfuService(_ service: CBService) {
  444|      0|        dfuService = DFUServiceType(service, logger)
  445|      0|        dfuService!.targetPeripheral = self
  446|      0|        dfuService!.discoverCharacteristics(
  447|      0|            onSuccess: { self.delegate?.peripheralDidBecomeReady() },
  448|      0|            onError: defaultErrorCallback
  449|      0|        )
  450|      0|    }
  451|       |    
  452|      0|    override func peripheralDidDisconnect() {
  453|      0|        guard !aborted else {
  454|      0|            // The device has resetted. Notify user
  455|      0|            logger.w("Upload aborted")
  456|      0|            delegate?.peripheralDidDisconnectAfterAborting()
  457|      0|            return
  458|      0|        }
  459|      0|        
  460|      0|        if shouldReconnect {
  461|      0|            shouldReconnect = false
  462|      0|            // We need to reconnect to the device
  463|      0|            connect()
  464|      0|        } else if jumpingToBootloader {
  465|      0|            jumpingToBootloader = false
  466|      0|            if newAddressExpected {
  467|      0|                newAddressExpected = false
  468|      0|                // Scan for a new device and connect to it
  469|      0|                switchToNewPeripheralAndConnect()
  470|      0|            } else {
  471|      0|                // Connect again, hoping for DFU mode this time
  472|      0|                connect()
  473|      0|            }
  474|      0|        } else if activating {
  475|      0|            activating = false
  476|      0|            // This part of firmware has been successfully
  477|      0|            delegate?.peripheralDidDisconnectAfterFirmwarePartSent()
  478|      0|        } else {
  479|      0|            super.peripheralDidDisconnect()
  480|      0|        }
  481|      0|    }
  482|       |    
  483|      0|    override func destroy() {
  484|      0|        super.destroy()
  485|      0|        cleanUp()
  486|      0|    }
  487|       |    
  488|       |    // MARK: - DFU Peripheral API
  489|       |    
  490|      0|    func isInApplicationMode(_ forceDfu: Bool) -> Bool {
  491|      0|        // This method should be overridden if the final implementation supports buttonless jump
  492|      0|        return false
  493|      0|    }
  494|       |    
  495|      0|    func isInitPacketRequired() -> Bool {
  496|      0|        // This method should be overridden if the final implementation requires Init Packet in the DFUFirmware
  497|      0|        return false
  498|      0|    }
  499|       |    
  500|      0|    func switchToNewPeripheralAndConnect() {
  501|      0|        // Release the previous peripheral
  502|      0|        peripheral!.delegate = nil
  503|      0|        peripheral = nil
  504|      0|        cleanUp()
  505|      0|        
  506|      0|        guard !aborted else {
  507|      0|            resetDevice()
  508|      0|            return
  509|      0|        }
  510|      0|        
  511|      0|        logger.v("Scanning for the DFU Bootloader...")
  512|      0|        centralManager.scanForPeripherals(withServices: peripheralSelector.filterBy(hint: DFUServiceType.UUID))
  513|      0|    }
  514|       |    
  515|       |    // MARK: - Peripheral Delegate methods
  516|       |    
  517|      0|    override func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
  518|      0|        // Is this a device we are looking for?
  519|      0|        if peripheralSelector.select(peripheral, advertisementData: advertisementData as [String : AnyObject], RSSI: RSSI) {
  520|      0|            // Hurray!
  521|      0|            central.stopScan()
  522|      0|            
  523|      0|            if let name = peripheral.name {
  524|      0|                logger.i("DFU Bootloader found with name \(name)")
  525|      0|            } else {
  526|      0|                logger.i("DFU Bootloader found")
  527|      0|            }
  528|      0|            
  529|      0|            self.peripheral = peripheral
  530|      0|            connect()
  531|      0|        }
  532|      0|    }
  533|       |    
  534|       |    // MARK: - DFU Controller API
  535|       |    
  536|      0|    override func pause() -> Bool {
  537|      0|        guard let dfuService = dfuService, !aborted else { return false }
  538|      0|        return dfuService.pause()
  539|      0|    }
  540|       |    
  541|      0|    override func resume() -> Bool {
  542|      0|        guard let dfuService = dfuService, !aborted else { return false }
  543|      0|        return dfuService.resume() == false // resume() returns the 'paused' value
  544|      0|    }
  545|       |    
  546|      0|    override func abort() -> Bool {
  547|      0|        aborted = true
  548|      0|        
  549|      0|        guard let dfuService = dfuService else {
  550|      0|            // DFU service has not yet been found.
  551|      0|            
  552|      0|            // Peripheral is nil when the switchToNewPeripheralAndConnect(_ selector:DFUPeripheralSelector) method was called
  553|      0|            // and the second peripheral has not been found yet.
  554|      0|            // Delegate is nil when peripheral was destroyed.
  555|      0|            if let delegate = delegate, peripheral == nil {
  556|      0|                logger.w("Upload aborted. Part 1 flashed sucessfully")
  557|      0|                centralManager.stopScan()
  558|      0|                delegate.peripheralDidDisconnectAfterAborting()
  559|      0|            }
  560|      0|            return true
  561|      0|        }
  562|      0|        
  563|      0|        logger.w("Aborting upload...")
  564|      0|        return dfuService.abort()
  565|      0|    }
  566|       |    
  567|       |    // MARK: - Private methods
  568|       |    
  569|      0|    fileprivate override func cleanUp() {
  570|      0|        dfuService?.destroy()
  571|      0|        dfuService = nil
  572|      0|    }
  573|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/Characteristics/DFUControlPoint.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal enum DFUOpCode : UInt8 {
   26|       |    case startDfu                           = 1
   27|       |    case initDfuParameters                  = 2
   28|       |    case receiveFirmwareImage               = 3
   29|       |    case validateFirmware                   = 4
   30|       |    case activateAndReset                   = 5
   31|       |    case reset                              = 6
   32|       |    case reportReceivedImageSize            = 7 // unused in this library
   33|       |    case packetReceiptNotificationRequest   = 8
   34|       |    case responseCode                       = 16
   35|       |    case packetReceiptNotification          = 17
   36|       |    
   37|      0|    var code: UInt8 {
   38|      0|        return rawValue
   39|      0|    }
   40|       |}
   41|       |
   42|       |internal enum InitDfuParametersRequest : UInt8 {
   43|       |    case receiveInitPacket  = 0
   44|       |    case initPacketComplete = 1
   45|       |    
   46|      0|    var code: UInt8 {
   47|      0|        return rawValue
   48|      0|    }
   49|       |}
   50|       |
   51|       |internal enum Request {
   52|       |    case jumpToBootloader
   53|       |    case startDfu(type: UInt8)
   54|       |    case startDfu_v1
   55|       |    case initDfuParameters(req: InitDfuParametersRequest)
   56|       |    case initDfuParameters_v1
   57|       |    case receiveFirmwareImage
   58|       |    case validateFirmware
   59|       |    case activateAndReset
   60|       |    case reset
   61|       |    case packetReceiptNotificationRequest(number: UInt16)
   62|       |    
   63|      0|    var data : Data {
   64|      0|        switch self {
   65|      0|        case .jumpToBootloader:
   66|      0|            return Data(bytes: [DFUOpCode.startDfu.code, FIRMWARE_TYPE_APPLICATION])
   67|      0|        case .startDfu(let type):
   68|      0|            return Data(bytes: [DFUOpCode.startDfu.code, type])
   69|      0|        case .startDfu_v1:
   70|      0|            return Data(bytes: [DFUOpCode.startDfu.code])
   71|      0|        case .initDfuParameters(let req):
   72|      0|            return Data(bytes: [DFUOpCode.initDfuParameters.code, req.code])
   73|      0|        case .initDfuParameters_v1:
   74|      0|            return Data(bytes: [DFUOpCode.initDfuParameters.code])
   75|      0|        case .receiveFirmwareImage:
   76|      0|            return Data(bytes: [DFUOpCode.receiveFirmwareImage.code])
   77|      0|        case .validateFirmware:
   78|      0|            return Data(bytes: [DFUOpCode.validateFirmware.code])
   79|      0|        case .activateAndReset:
   80|      0|            return Data(bytes: [DFUOpCode.activateAndReset.code])
   81|      0|        case .reset:
   82|      0|            return Data(bytes: [DFUOpCode.reset.code])
   83|      0|        case .packetReceiptNotificationRequest(let number):
   84|      0|            var data = Data(bytes: [DFUOpCode.packetReceiptNotificationRequest.code])
   85|      0|            data += number.littleEndian
   86|      0|            return data
   87|      0|        }
   88|      0|    }
   89|       |    
   90|      0|    var description : String {
   91|      0|        switch self {
   92|      0|        case .jumpToBootloader:     return "Jump to bootloader (Op Code = 1, Upload Mode = 4)"
   93|      0|        case .startDfu(let type):   return "Start DFU (Op Code = 1, Upload Mode = \(type))"
   94|      0|        case .startDfu_v1:          return "Start DFU (Op Code = 1)"
   95|      0|        case .initDfuParameters(_): return "Initialize DFU Parameters"
   96|      0|        case .initDfuParameters_v1: return "Initialize DFU Parameters"
   97|      0|        case .receiveFirmwareImage: return "Receive Firmware Image (Op Code = 3)"
   98|      0|        case .validateFirmware:     return "Validate Firmware (Op Code = 4)"
   99|      0|        case .activateAndReset:     return "Activate and Reset (Op Code = 5)"
  100|      0|        case .reset:                return "Reset (Op Code = 6)"
  101|      0|        case .packetReceiptNotificationRequest(let number):
  102|      0|                                    return "Packet Receipt Notif Req (Op Code = 8, Value = \(number))"
  103|      0|        }
  104|      0|    }
  105|       |}
  106|       |
  107|       |internal enum DFUResultCode : UInt8 {
  108|       |    case success              = 1
  109|       |    case invalidState         = 2
  110|       |    case notSupported         = 3
  111|       |    case dataSizeExceedsLimit = 4
  112|       |    case crcError             = 5
  113|       |    case operationFailed      = 6
  114|       |    
  115|      0|    var description: String {
  116|      0|        switch self {
  117|      0|        case .success:              return "Success"
  118|      0|        case .invalidState:         return "Device is in invalid state"
  119|      0|        case .notSupported:         return "Operation not supported"
  120|      0|        case .dataSizeExceedsLimit: return "Data size exceeds limit"
  121|      0|        case .crcError:             return "CRC Error"
  122|      0|        case .operationFailed:      return "Operation failed"
  123|      0|        }
  124|      0|    }
  125|       |    
  126|      0|    var code: UInt8 {
  127|      0|        return rawValue
  128|      0|    }
  129|       |}
  130|       |
  131|       |internal struct Response {
  132|       |    let opCode        : DFUOpCode?
  133|       |    let requestOpCode : DFUOpCode?
  134|       |    let status        : DFUResultCode?
  135|       |    
  136|      0|    init?(_ data: Data) {
  137|      0|        let opCode        : UInt8 = data[0]
  138|      0|        let requestOpCode : UInt8 = data[1]
  139|      0|        let status        : UInt8 = data[2]
  140|      0|        
  141|      0|        self.opCode        = DFUOpCode(rawValue: opCode)
  142|      0|        self.requestOpCode = DFUOpCode(rawValue: requestOpCode)
  143|      0|        self.status        = DFUResultCode(rawValue: status)
  144|      0|        
  145|      0|        if self.opCode != .responseCode || self.requestOpCode == nil || self.status == nil {
  146|      0|            return nil
  147|      0|        }
  148|      0|    }
  149|       |    
  150|      0|    var description: String {
  151|      0|        return "Response (Op Code = \(requestOpCode!.rawValue), Status = \(status!.rawValue))"
  152|      0|    }
  153|       |}
  154|       |
  155|       |internal struct PacketReceiptNotification {
  156|       |    let opCode        : DFUOpCode?
  157|       |    let bytesReceived : UInt32
  158|       |    
  159|      0|    init?(_ data: Data) {
  160|      0|        let opCode: UInt8 = data[0]
  161|      0|        
  162|      0|        self.opCode = DFUOpCode(rawValue: opCode)
  163|      0|        
  164|      0|        if self.opCode != .packetReceiptNotification {
  165|      0|            return nil
  166|      0|        }
  167|      0|        
  168|      0|        // According to https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library/issues/54
  169|      0|        // in SDK 5.2.0.39364 the bytesReveived value in a PRN packet is 16-bit long, instad of 32-bit.
  170|      0|        // However, the packet is still 5 bytes long and the two last bytes are 0x00-00.
  171|      0|        // This has to be taken under consideration when comparing number of bytes sent and received as
  172|      0|        // the latter counter may rewind if fw size is > 0xFFFF bytes (LegacyDFUService:L372).
  173|      0|        let bytesReceived: UInt32 = data.subdata(in: 1 ..< 4).withUnsafeBytes { $0.pointee }
  174|      0|        self.bytesReceived = bytesReceived
  175|      0|    }
  176|       |}
  177|       |
  178|       |@objc internal class DFUControlPoint : NSObject, CBPeripheralDelegate {
  179|       |    static let UUID = CBUUID(string: "00001531-1212-EFDE-1523-785FEABCD123")
  180|       |    
  181|      0|    static func matches(_ characteristic: CBCharacteristic) -> Bool {
  182|      0|        return characteristic.uuid.isEqual(UUID)
  183|      0|    }
  184|       |    
  185|       |    private var characteristic: CBCharacteristic
  186|       |    private var logger: LoggerHelper
  187|       |    
  188|       |    private var success: Callback?
  189|       |    private var proceed: ProgressCallback?
  190|       |    private var report:  ErrorCallback?
  191|       |    private var request: Request?
  192|       |    private var uploadStartTime: CFAbsoluteTime?
  193|       |    private var resetSent = false
  194|       |    
  195|      0|    internal var valid: Bool {
  196|      0|        return characteristic.properties.isSuperset(of: [.write, .notify])
  197|      0|    }
  198|       |    
  199|       |    // MARK: - Initialization
  200|       |    
  201|      0|    init(_ characteristic: CBCharacteristic, _ logger: LoggerHelper) {
  202|      0|        self.characteristic = characteristic
  203|      0|        self.logger = logger
  204|      0|    }
  205|       |    
  206|       |    // MARK: - Characteristic API methods
  207|       |    
  208|       |    /**
  209|       |    Enables notifications for the DFU Control Point characteristics. Reports success or an error 
  210|       |    using callbacks.
  211|       |    
  212|       |    - parameter success: method called when notifications were successfully enabled
  213|       |    - parameter report:  method called in case of an error
  214|       |    */
  215|      0|    func enableNotifications(onSuccess success: Callback?, onError report: ErrorCallback?) {
  216|      0|        // Save callbacks
  217|      0|        self.success = success
  218|      0|        self.report  = report
  219|      0|        
  220|      0|        // Get the peripheral object
  221|      0|        let peripheral = characteristic.service.peripheral
  222|      0|        
  223|      0|        // Set the peripheral delegate to self
  224|      0|        peripheral.delegate = self
  225|      0|        
  226|      0|        logger.v("Enabling notifications for \(characteristic.uuid.uuidString)...")
  227|      0|        logger.d("peripheral.setNotifyValue(true, for: \(characteristic.uuid.uuidString))")
  228|      0|        peripheral.setNotifyValue(true, for: characteristic)
  229|      0|    }
  230|       |    
  231|       |    /**
  232|       |     Sends given request to the DFU Control Point characteristic. Reports success or an error
  233|       |     using callbacks.
  234|       |     
  235|       |     - parameter request: request to be sent
  236|       |     - parameter success: method called when peripheral reported with status success
  237|       |     - parameter report:  method called in case of an error
  238|       |     */
  239|      0|    func send(_ request: Request, onSuccess success: Callback?, onError report: ErrorCallback?) {
  240|      0|        // Save callbacks and parameter
  241|      0|        self.success   = success
  242|      0|        self.report    = report
  243|      0|        self.request   = request
  244|      0|        self.resetSent = false
  245|      0|        
  246|      0|        // Get the peripheral object
  247|      0|        let peripheral = characteristic.service.peripheral
  248|      0|        
  249|      0|        // Set the peripheral delegate to self
  250|      0|        peripheral.delegate = self
  251|      0|        
  252|      0|        switch request {
  253|      0|        case .initDfuParameters(let req):
  254|      0|            if req == InitDfuParametersRequest.receiveInitPacket {
  255|      0|                logger.a("Writing \(request.description)...")
  256|      0|            }
  257|      0|        case .initDfuParameters_v1:
  258|      0|            logger.a("Writing \(request.description)...")
  259|      0|        case .jumpToBootloader, .activateAndReset, .reset:
  260|      0|            // Those three requests may not be confirmed by the remote DFU target. The device may be restarted before sending the ACK.
  261|      0|            // This would cause an error in peripheral:didWriteValueForCharacteristic:error, which can be ignored in this case.
  262|      0|            resetSent = true
  263|      0|        default:
  264|      0|            break
  265|      0|        }
  266|      0|        logger.v("Writing to characteristic \(characteristic.uuid.uuidString)...")
  267|      0|        logger.d("peripheral.writeValue(0x\(request.data.hexString), for: \(characteristic.uuid.uuidString), type: .withResponse)")
  268|      0|        peripheral.writeValue(request.data, for: characteristic, type: .withResponse)
  269|      0|    }
  270|       |    
  271|       |    /**
  272|       |     Sets the callbacks used later on when a Packet Receipt Notification is received, a device reported an error or the whole firmware has been sent
  273|       |     and the notification with success status was received. Sending the firmware is done using DFU Packet characteristic.
  274|       |     
  275|       |     - parameter success: method called when peripheral reported with status success
  276|       |     - parameter proceed: method called the a PRN has been received and sending following data can be resumed
  277|       |     - parameter report:  method called in case of an error
  278|       |     */
  279|      0|    func waitUntilUploadComplete(onSuccess success: Callback?, onPacketReceiptNofitication proceed: ProgressCallback?, onError report: ErrorCallback?) {
  280|      0|        // Save callbacks. The proceed callback will be called periodically whenever a packet receipt notification is received. It resumes uploading.
  281|      0|        self.success = success
  282|      0|        self.proceed = proceed
  283|      0|        self.report  = report
  284|      0|        self.uploadStartTime = CFAbsoluteTimeGetCurrent()
  285|      0|        
  286|      0|        // Get the peripheral object
  287|      0|        let peripheral = characteristic.service.peripheral
  288|      0|        
  289|      0|        // Set the peripheral delegate to self
  290|      0|        peripheral.delegate = self
  291|      0|        
  292|      0|        logger.a("Uploading firmware...")
  293|      0|        logger.v("Sending firmware to DFU Packet characteristic...")
  294|      0|    }
  295|       |    
  296|       |    // MARK: - Peripheral Delegate callbacks
  297|       |    
  298|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
  299|      0|        if error != nil {
  300|      0|            logger.e("Enabling notifications failed")
  301|      0|            logger.e(error!)
  302|      0|            report?(.enablingControlPointFailed, "Enabling notifications failed")
  303|      0|        } else {
  304|      0|            logger.v("Notifications enabled for \(characteristic.uuid.uuidString)")
  305|      0|            logger.a("DFU Control Point notifications enabled")
  306|      0|            success?()
  307|      0|        }
  308|      0|    }
  309|       |    
  310|      0|    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
  311|      0|        // This method, according to the iOS documentation, should be called only after writing with response to a characteristic.
  312|      0|        // However, on iOS 10 this method is called even after writing without response, which is a bug.
  313|      0|        // The DFU Control Point characteristic always writes with response, in oppose to the DFU Packet, which uses write without response.
  314|      0|        guard characteristic.uuid.isEqual(DFUControlPoint.UUID) else {
  315|      0|            return
  316|      0|        }
  317|      0|        
  318|      0|        if error != nil {
  319|      0|            if !resetSent {
  320|      0|                logger.e("Writing to characteristic failed")
  321|      0|                logger.e(error!)
  322|      0|                report?(.writingCharacteristicFailed, "Writing to characteristic failed")
  323|      0|            } else {
  324|      0|                // When a 'JumpToBootloader', 'Activate and Reset' or 'Reset' command is sent the device may reset before sending the acknowledgement.
  325|      0|                // This is not a blocker, as the device did disconnect and reset successfully.
  326|      0|                logger.a("\(request!.description) request sent")
  327|      0|                logger.w("Device disconnected before sending ACK")
  328|      0|                logger.w(error!)
  329|      0|                success?()
  330|      0|            }
  331|      0|        } else {
  332|      0|            logger.i("Data written to \(characteristic.uuid.uuidString)")
  333|      0|            
  334|      0|            switch request! {
  335|      0|            case .startDfu(_), .startDfu_v1,  .validateFirmware:
  336|      0|                logger.a("\(request!.description) request sent")
  337|      0|                // do not call success until we get a notification
  338|      0|            case .jumpToBootloader, .activateAndReset, .reset, .packetReceiptNotificationRequest(_):
  339|      0|                logger.a("\(request!.description) request sent")
  340|      0|                // there will be no notification send after these requests, call success() immetiatelly
  341|      0|                // (for .ReceiveFirmwareImage the notification will be sent after firmware upload is complete)
  342|      0|                success?()
  343|      0|            case .initDfuParameters(_), .initDfuParameters_v1:
  344|      0|                // Log was created before sending the Op Code
  345|      0|                
  346|      0|                // do not call success until we get a notification
  347|      0|                break
  348|      0|            case .receiveFirmwareImage:
  349|      0|                if proceed == nil {
  350|      0|                    success?()
  351|      0|                }
  352|      0|            }
  353|      0|        }
  354|      0|    }
  355|       |    
  356|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
  357|      0|        // Ignore updates received for other characteristics
  358|      0|        guard characteristic.uuid.isEqual(DFUControlPoint.UUID) else {
  359|      0|            return
  360|      0|        }
  361|      0|        
  362|      0|        if error != nil {
  363|      0|            // This characteristic is never read, the error may only pop up when notification is received
  364|      0|            logger.e("Receiving notification failed")
  365|      0|            logger.e(error!)
  366|      0|            report?(.receivingNotificationFailed, "Receiving notification failed")
  367|      0|        } else {
  368|      0|            // During the upload we may get either a Packet Receipt Notification, or a Response with status code
  369|      0|            if proceed != nil {
  370|      0|                if let prn = PacketReceiptNotification(characteristic.value!) {
  371|      0|                    proceed!(prn.bytesReceived)
  372|      0|                    return
  373|      0|                }
  374|      0|            }
  375|      0|            // Otherwise...
  376|      0|            logger.i("Notification received from \(characteristic.uuid.uuidString), value (0x): \(characteristic.value!.hexString)")
  377|      0|            
  378|      0|            // Parse response received
  379|      0|            let response = Response(characteristic.value!)
  380|      0|            if let response = response {
  381|      0|                logger.a("\(response.description) received")
  382|      0|                
  383|      0|                if response.status == .success {
  384|      0|                    switch response.requestOpCode! {
  385|      0|                    case .initDfuParameters:
  386|      0|                        logger.a("Initialize DFU Parameters completed")
  387|      0|                    case .receiveFirmwareImage:
  388|      0|                        let interval = CFAbsoluteTimeGetCurrent() - uploadStartTime! as CFTimeInterval
  389|      0|                        logger.a("Upload completed in \(interval.format(".2")) seconds")
  390|      0|                    default:
  391|      0|                        break
  392|      0|                    }
  393|      0|                    success?()
  394|      0|                } else {
  395|      0|                    logger.e("Error \(response.status!.code): \(response.status!.description)")
  396|      0|                    report?(DFUError(rawValue: Int(response.status!.rawValue))!, response.status!.description)
  397|      0|                }
  398|      0|            } else {
  399|      0|                logger.e("Unknown response received: 0x\(characteristic.value!.hexString)")
  400|      0|                report?(.unsupportedResponse, "Unsupported response received: 0x\(characteristic.value!.hexString)")
  401|      0|            }
  402|      0|        }
  403|      0|    }
  404|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/Characteristics/DFUPacket.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal class DFUPacket {
   26|       |    static fileprivate let UUID = CBUUID(string: "00001532-1212-EFDE-1523-785FEABCD123")
   27|       |    
   28|      0|    static func matches(_ characteristic: CBCharacteristic) -> Bool {
   29|      0|        return characteristic.uuid.isEqual(UUID)
   30|      0|    }
   31|       |    
   32|       |    private let PacketSize: UInt32 = 20
   33|       |    
   34|       |    private var characteristic: CBCharacteristic
   35|       |    private var logger: LoggerHelper
   36|       |    
   37|       |    /// Number of bytes of firmware already sent.
   38|       |    private(set) var bytesSent: UInt32 = 0
   39|       |    /// Number of bytes sent at the last progress notification. This value is used to calculate the current speed.
   40|       |    private var bytesSentSinceProgessNotification: UInt32 = 0
   41|       |    
   42|       |    /// Current progress in percents (0-99).
   43|       |    private var progress:  UInt8 = 0
   44|       |    private var startTime: CFAbsoluteTime?
   45|       |    private var lastTime:  CFAbsoluteTime?
   46|       |    
   47|      0|    internal var valid: Bool {
   48|      0|        return characteristic.properties.contains(.writeWithoutResponse)
   49|      0|    }
   50|       |    
   51|      0|    init(_ characteristic: CBCharacteristic, _ logger: LoggerHelper) {
   52|      0|        self.characteristic = characteristic
   53|      0|        self.logger = logger
   54|      0|    }
   55|       |    
   56|       |    // MARK: - Characteristic API methods
   57|       |    
   58|       |    /**
   59|       |    Sends the firmware sizes in format [softdevice size, bootloader size, application size], where each size is a UInt32 number.
   60|       |    
   61|       |    - parameter size: sizes of firmware in the current part
   62|       |    */
   63|      0|    func sendFirmwareSize(_ size: DFUFirmwareSize) {
   64|      0|        // Get the peripheral object
   65|      0|        let peripheral = characteristic.service.peripheral
   66|      0|        
   67|      0|        var data     = Data(capacity: 12)
   68|      0|        data += size.softdevice.littleEndian
   69|      0|        data += size.bootloader.littleEndian
   70|      0|        data += size.application.littleEndian
   71|      0|        
   72|      0|        logger.v("Writing image sizes (\(size.softdevice)b, \(size.bootloader)b, \(size.application)b) to characteristic \(DFUPacket.UUID.uuidString)...")
   73|      0|        logger.d("peripheral.writeValue(0x\(data.hexString), for: \(DFUPacket.UUID.uuidString), type: .withoutResponse)")
   74|      0|        peripheral.writeValue(data, for: characteristic, type: .withoutResponse)
   75|      0|    }
   76|       |
   77|       |    /**
   78|       |     Sends the application firmware size in format [application size] (UInt32).
   79|       |     
   80|       |     - parameter size: sizes of firmware in the current part. Only the application size may ne grater than 0.
   81|       |     */
   82|      0|    func sendFirmwareSize_v1(_ size: DFUFirmwareSize) {
   83|      0|        // Get the peripheral object
   84|      0|        let peripheral = characteristic.service.peripheral
   85|      0|        
   86|      0|        var data     = Data(capacity: 4)
   87|      0|        data += size.application.littleEndian
   88|      0|        
   89|      0|        logger.v("Writing image size (\(size.application)b) to characteristic \(DFUPacket.UUID.uuidString)...")
   90|      0|        logger.d("peripheral.writeValue(0x\(data.hexString), for: \(DFUPacket.UUID.uuidString), type: .withoutResponse)")
   91|      0|        peripheral.writeValue(data, for: characteristic, type: .withoutResponse)
   92|      0|    }
   93|       |    
   94|       |    /**
   95|       |     Sends the whole content of the data object.
   96|       |     
   97|       |     - parameter data: the data to be sent
   98|       |     */
   99|      0|    func sendInitPacket(_ data: Data) {
  100|      0|        // Get the peripheral object
  101|      0|        let peripheral = characteristic.service.peripheral
  102|      0|        
  103|      0|        // Data may be sent in up-to-20-bytes packets
  104|      0|        var offset: UInt32 = 0
  105|      0|        var bytesToSend = UInt32(data.count)
  106|      0|        
  107|      0|        repeat {
  108|      0|            let packetLength = min(bytesToSend, PacketSize)
  109|      0|            let packet = data.subdata(in: Int(offset) ..< Int(offset + packetLength))
  110|      0|            logger.v("Writing to characteristic \(DFUPacket.UUID.uuidString)...")
  111|      0|            logger.d("peripheral.writeValue(0x\(packet.hexString), for: \(DFUPacket.UUID.uuidString), type: .withoutResponse)")
  112|      0|            peripheral.writeValue(packet, for: characteristic, type: .withoutResponse)
  113|      0|            
  114|      0|            offset += packetLength
  115|      0|            bytesToSend -= packetLength
  116|      0|        } while bytesToSend > 0
  117|      0|    }
  118|       |    
  119|       |    /**
  120|       |     Sends next number of packets from given firmware data and reports a progress.
  121|       |     This method does not notify progress delegate twice about the same percentage.
  122|       |     
  123|       |     - parameter number:           number of packets to be sent before a Packet Receipt Notification is expected.
  124|       |     Set to 0 to disable Packet Receipt Notification procedure (not recommended)
  125|       |     - parameter aFirmware:         the firmware to be sent
  126|       |     - parameter aProgressDelegate: an optional progress delegate
  127|       |     */
  128|      0|    func sendNext(_ number: UInt16, packetsOf aFirmware: DFUFirmware, andReportProgressTo aProgressDelegate: DFUProgressDelegate?) {
  129|      0|        // Get the peripheral object
  130|      0|        let peripheral = characteristic.service.peripheral
  131|      0|        
  132|      0|        // Some super complicated computations...
  133|      0|        let bytesTotal   = UInt32(aFirmware.data.count)
  134|      0|        let totalPackets = (bytesTotal + PacketSize - 1) / PacketSize
  135|      0|        let packetsSent  = (bytesSent + PacketSize - 1) / PacketSize
  136|      0|        let packetsLeft  = totalPackets - packetsSent
  137|      0|        
  138|      0|        // Calculate how many packets should be sent before EOF or next receipt notification
  139|      0|        var packetsToSendNow = min(UInt32(number), packetsLeft)
  140|      0|        if number == 0 {
  141|      0|            // When Packet Receipt Notification procedure is disabled, the service will send all data here
  142|      0|            packetsToSendNow = totalPackets
  143|      0|        }
  144|      0|        
  145|      0|        // Initialize timers
  146|      0|        if startTime == nil {
  147|      0|            startTime = CFAbsoluteTimeGetCurrent()
  148|      0|            lastTime = startTime
  149|      0|            
  150|      0|            // Notify progress delegate that upload has started (0%)
  151|      0|            DispatchQueue.main.async(execute: {
  152|      0|                aProgressDelegate?.dfuProgressDidChange(
  153|      0|                    for:   aFirmware.currentPart,
  154|      0|                    outOf: aFirmware.parts,
  155|      0|                    to:    0,
  156|      0|                    currentSpeedBytesPerSecond: 0.0,
  157|      0|                    avgSpeedBytesPerSecond:     0.0)
  158|      0|            })
  159|      0|        }
  160|      0|        
  161|      0|        while packetsToSendNow > 0 {
  162|      0|            let bytesLeft    = bytesTotal - bytesSent
  163|      0|            let packetLength = min(bytesLeft, PacketSize)
  164|      0|            let packet       = aFirmware.data.subdata(in: Int(bytesSent) ..< Int(bytesSent + packetLength))
  165|      0|            peripheral.writeValue(packet, for: characteristic, type: .withoutResponse)
  166|      0|            
  167|      0|            bytesSent += packetLength
  168|      0|            packetsToSendNow -= 1
  169|      0|            
  170|      0|            // Calculate progress
  171|      0|            let currentProgress = UInt8(bytesSent * 100 / bytesTotal) // in percantage (0-100)
  172|      0|            
  173|      0|            // Notify progress listener
  174|      0|            if currentProgress > progress {
  175|      0|                // Calculate current transfer speed in bytes per second
  176|      0|                let now = CFAbsoluteTimeGetCurrent()
  177|      0|                let currentSpeed = Double(bytesSent - bytesSentSinceProgessNotification) / (now - lastTime!)
  178|      0|                let avgSpeed = Double(bytesSent) / (now - startTime!)
  179|      0|                lastTime = now
  180|      0|                bytesSentSinceProgessNotification = bytesSent
  181|      0|                
  182|      0|                DispatchQueue.main.async(execute: {
  183|      0|                    aProgressDelegate?.dfuProgressDidChange(
  184|      0|                        for:   aFirmware.currentPart,
  185|      0|                        outOf: aFirmware.parts,
  186|      0|                        to:    Int(currentProgress),
  187|      0|                        currentSpeedBytesPerSecond: currentSpeed,
  188|      0|                        avgSpeedBytesPerSecond:     avgSpeed)
  189|      0|                })
  190|      0|                progress = currentProgress
  191|      0|            }
  192|      0|        }
  193|      0|    }
  194|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/Characteristics/DFUVersion.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal typealias VersionCallback = (_ major: UInt8, _ minor: UInt8) -> Void
   26|       |
   27|       |@objc internal class DFUVersion : NSObject, CBPeripheralDelegate {
   28|       |    static let UUID = CBUUID(string: "00001534-1212-EFDE-1523-785FEABCD123")
   29|       |    
   30|      0|    static func matches(_ characteristic: CBCharacteristic) -> Bool {
   31|      0|        return characteristic.uuid.isEqual(UUID)
   32|      0|    }
   33|       |    
   34|       |    private var characteristic: CBCharacteristic
   35|       |    private var logger: LoggerHelper
   36|       |    
   37|       |    private var success: VersionCallback?
   38|       |    private var report: ErrorCallback?
   39|       |    
   40|      0|    internal var valid: Bool {
   41|      0|        return characteristic.properties.contains(.read)
   42|      0|    }
   43|       |    
   44|       |    // MARK: - Initialization
   45|       |    
   46|      0|    init(_ characteristic: CBCharacteristic, _ logger: LoggerHelper) {
   47|      0|        self.characteristic = characteristic
   48|      0|        self.logger = logger
   49|      0|    }
   50|       |    
   51|       |    // MARK: - Characteristic API methods
   52|       |    
   53|       |    /**
   54|       |    Reads the value of the DFU Version characteristic.
   55|       |    The value, or an error, will be reported as a callback.
   56|       |    
   57|       |    - parameter callback: method called when version is read and is supported
   58|       |    - parameter error:    method called on error of if version is not supported
   59|       |    */
   60|      0|    func readVersion(onSuccess success: VersionCallback?, onError report: ErrorCallback?) {
   61|      0|        // Save callbacks
   62|      0|        self.success = success
   63|      0|        self.report = report
   64|      0|        
   65|      0|        // Get the peripheral object
   66|      0|        let peripheral = characteristic.service.peripheral
   67|      0|        
   68|      0|        // Set the peripheral delegate to self
   69|      0|        peripheral.delegate = self
   70|      0|        
   71|      0|        logger.v("Reading DFU Version number...")
   72|      0|        logger.d("peripheral.readValue(\(characteristic.uuid.uuidString))")
   73|      0|        peripheral.readValue(for: characteristic)
   74|      0|    }
   75|       |    
   76|       |    // MARK: - Peripheral Delegate callbacks
   77|       |    
   78|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
   79|      0|        // Ignore updates received for other characteristics
   80|      0|        guard characteristic.uuid.isEqual(DFUVersion.UUID) else {
   81|      0|            return
   82|      0|        }
   83|      0|        
   84|      0|        if error != nil {
   85|      0|            logger.e("Reading DFU Version characteristic failed")
   86|      0|            logger.e(error!)
   87|      0|            report?(.readingVersionFailed, "Reading DFU Version characteristic failed")
   88|      0|        } else {
   89|      0|            let data = characteristic.value
   90|      0|            logger.i("Read Response received from \(characteristic.uuid.uuidString), value\(data != nil && data!.count > 0 ? " (0x): " + data!.hexString : ": 0 bytes")")
   91|      0|            
   92|      0|            // Validate data length
   93|      0|            if data == nil || data!.count != 2 {
   94|      0|                logger.w("Invalid value: 2 bytes expected")
   95|      0|                report?(.readingVersionFailed, "Unsupported DFU Version: \(data != nil && data!.count > 0 ? "0x" + data!.hexString : "no value")")
   96|      0|                return
   97|      0|            }
   98|      0|            
   99|      0|            // Read major and minor
  100|      0|            let minor: UInt8 = data![0]
  101|      0|            let major: UInt8 = data![1]
  102|      0|            
  103|      0|            logger.a("Version number read: \(major).\(minor)")
  104|      0|            success?(major, minor)
  105|      0|        }
  106|      0|    }
  107|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/DFU/LegacyDFUExecutor.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |internal class LegacyDFUExecutor : DFUExecutor, LegacyDFUPeripheralDelegate {
   24|       |    typealias DFUPeripheralType = LegacyDFUPeripheral
   25|       |    
   26|       |    internal let initiator  : DFUServiceInitiator
   27|       |    internal let peripheral : LegacyDFUPeripheral
   28|       |    internal var firmware   : DFUFirmware
   29|       |    internal var error      : (error: DFUError, message: String)?
   30|       |    
   31|       |    /// Retry counter for peripheral invalid state issue
   32|       |    private let MaxRetryCount = 1
   33|       |    private var invalidStateRetryCount: Int
   34|       |    
   35|       |    // MARK: - Initialization
   36|       |    
   37|      0|    required init(_ initiator: DFUServiceInitiator) {
   38|      0|        self.initiator  = initiator
   39|      0|        self.peripheral = LegacyDFUPeripheral(initiator)
   40|      0|        self.firmware   = initiator.file!
   41|      0|        
   42|      0|        self.invalidStateRetryCount = MaxRetryCount
   43|      0|    }
   44|       |    
   45|      0|    func start() {
   46|      0|        error = nil
   47|      0|        peripheral.delegate = self
   48|      0|        peripheral.start()
   49|      0|    }
   50|       |    
   51|       |    // MARK: - DFU Peripheral Delegate methods
   52|       |    
   53|      0|    func peripheralDidBecomeReady() {
   54|      0|        if firmware.initPacket == nil && peripheral.isInitPacketRequired() {
   55|      0|            error(.extendedInitPacketRequired, didOccurWithMessage: "The init packet is required by the target device")
   56|      0|            return
   57|      0|        }
   58|      0|        DispatchQueue.main.async(execute: {
   59|      0|            self.delegate?.dfuStateDidChange(to: .starting)
   60|      0|        })
   61|      0|        peripheral.enableControlPoint()
   62|      0|    }
   63|       |    
   64|      0|    func peripheralDidEnableControlPoint() {
   65|      0|        // Check whether the target is in application or bootloader mode
   66|      0|        if peripheral.isInApplicationMode(initiator.forceDfu) {
   67|      0|            DispatchQueue.main.async(execute: {
   68|      0|                self.delegate?.dfuStateDidChange(to: .enablingDfuMode)
   69|      0|            })
   70|      0|            peripheral.jumpToBootloader()
   71|      0|        } else {
   72|      0|            // The device is ready to proceed with DFU
   73|      0|            peripheral.sendStartDfu(withFirmwareType: firmware.currentPartType, andSize: firmware.currentPartSize)
   74|      0|        }
   75|      0|    }
   76|       |    
   77|      0|    func peripheralDidFailToStartDfuWithType() {
   78|      0|        // The DFU target has an old implementation of DFU Bootloader, that allows only the application
   79|      0|        // to be updated.
   80|      0|        
   81|      0|        if firmware.currentPartType == FIRMWARE_TYPE_APPLICATION {
   82|      0|            // Try using the old DFU Start command, without type
   83|      0|            peripheral.sendStartDfu(withFirmwareSize: firmware.currentPartSize)
   84|      0|        } else {
   85|      0|            // Operation can not be continued
   86|      0|            error(.remoteLegacyDFUNotSupported, didOccurWithMessage: "Updating Softdevice or Bootloader is not supported")
   87|      0|        }
   88|      0|    }
   89|       |
   90|      0|    func peripheralDidStartDfu() {
   91|      0|        // Check if the init packet is present for this part
   92|      0|        if let initPacket = firmware.initPacket {
   93|      0|            peripheral.sendInitPacket(initPacket)
   94|      0|            return
   95|      0|        }
   96|      0|        
   97|      0|        sendFirmware()
   98|      0|    }
   99|       |    
  100|      0|    func peripheralDidReceiveInitPacket() {
  101|      0|        sendFirmware()
  102|      0|    }
  103|       |    
  104|      0|    func peripheralDidReceiveFirmware() {
  105|      0|        DispatchQueue.main.async(execute: {
  106|      0|            self.delegate?.dfuStateDidChange(to: .validating)
  107|      0|        })
  108|      0|        peripheral.validateFirmware()
  109|      0|    }
  110|       |    
  111|      0|    func peripheralDidVerifyFirmware() {
  112|      0|        DispatchQueue.main.async(execute: {
  113|      0|            self.delegate?.dfuStateDidChange(to: .disconnecting)
  114|      0|        })
  115|      0|        peripheral.activateAndReset()
  116|      0|    }
  117|       |    
  118|      0|    func peripheralDidReportInvalidState() {
  119|      0|        if invalidStateRetryCount > 0 {
  120|      0|            logWith(.warning, message: "Retrying...")
  121|      0|            invalidStateRetryCount -= 1
  122|      0|            peripheral.start()
  123|      0|        } else {
  124|      0|            error(.remoteLegacyDFUInvalidState, didOccurWithMessage: "Peripheral is in an invalid state, please try to reset and start over again.")
  125|      0|        }
  126|      0|    }
  127|       |    
  128|       |    // MARK: - Private methods
  129|       |    
  130|       |    /**
  131|       |     Sends the current part of the firmware to the target DFU device.
  132|       |     */
  133|      0|    private func sendFirmware() {
  134|      0|        DispatchQueue.main.async(execute: {
  135|      0|            self.delegate?.dfuStateDidChange(to: .uploading)
  136|      0|        })
  137|      0|        // First the service will send the number of packets of firmware data to be received
  138|      0|        // by the DFU target before sending a new Packet Receipt Notification.
  139|      0|        // After receiving status Success it will send the firmware.
  140|      0|        peripheral.sendFirmware(firmware, withPacketReceiptNotificationNumber: initiator.packetReceiptNotificationParameter, andReportProgressTo: progressDelegate)
  141|      0|    }
  142|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/DFU/LegacyDFUServiceInitiator.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |@objc public class LegacyDFUServiceInitiator : DFUServiceInitiator {
   26|       |    
   27|      0|    public override func start() -> DFUServiceController? {
   28|      0|        // The firmware file must be specified before calling `start()`
   29|      0|        if file == nil {
   30|      0|            delegate?.dfuError(.fileNotSpecified, didOccurWithMessage: "Firmware not specified")
   31|      0|            return nil
   32|      0|        }
   33|      0|        
   34|      0|        let executor   = LegacyDFUExecutor(self)
   35|      0|        let controller = DFUServiceController()
   36|      0|        controller.executor = executor
   37|      0|        executor.start()
   38|      0|        return controller
   39|      0|    }
   40|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/Peripherals/LegacyDFUPeripheral.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE, DATA, OR PROFITS OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal class LegacyDFUPeripheral : BaseCommonDFUPeripheral<LegacyDFUExecutor, LegacyDFUService> {
   26|       |    
   27|       |    // MARK: - Peripheral API
   28|       |    
   29|      0|    override var requiredServices: [CBUUID]? {
   30|      0|        return [LegacyDFUService.UUID]
   31|      0|    }
   32|       |    
   33|      0|    override func isInitPacketRequired() -> Bool {
   34|      0|        // Init packet has started being required the same time when the DFU Version
   35|      0|        // characteristic was introduced (SDK 7.0.0). It version exists, and we are not
   36|      0|        // in Application mode, then the Init Packet is required.
   37|      0|        
   38|      0|        if let version = dfuService!.version {
   39|      0|            // In the application mode we don't know whether init packet is required
   40|      0|            // as the app is indepenrent from the DFU Bootloader.
   41|      0|            let isInApplicationMode = version.major == 0 && version.minor == 1
   42|      0|            return !isInApplicationMode
   43|      0|        }
   44|      0|        return false
   45|      0|    }
   46|       |    
   47|       |    // MARK: - Implementation
   48|       |    
   49|       |    /**
   50|       |     Enables notifications on DFU Control Point characteristic.
   51|       |     */
   52|      0|    func enableControlPoint() {
   53|      0|        dfuService!.enableControlPoint(
   54|      0|            onSuccess: { self.delegate?.peripheralDidEnableControlPoint() },
   55|      0|            onError: defaultErrorCallback
   56|      0|        )
   57|      0|    }
   58|       |    
   59|      0|    override func isInApplicationMode(_ forceDfu: Bool) -> Bool {
   60|      0|        let applicationMode = dfuService!.isInApplicationMode() ?? !forceDfu
   61|      0|        
   62|      0|        if applicationMode {
   63|      0|            logger.w("Application with buttonless update found")
   64|      0|        }
   65|      0|        
   66|      0|        return applicationMode
   67|      0|    }
   68|       |    
   69|       |    /**
   70|       |     Switches target device to the DFU Bootloader mode.
   71|       |     */
   72|      0|    func jumpToBootloader() {
   73|      0|        jumpingToBootloader = true
   74|      0|        dfuService!.jumpToBootloaderMode(
   75|      0|            // onSuccess the device gets disconnected and centralManager(_:didDisconnectPeripheral:error) will be called
   76|      0|            onError: { (error, message) in
   77|      0|                self.jumpingToBootloader = false
   78|      0|                self.delegate?.error(error, didOccurWithMessage: message)
   79|      0|            }
   80|      0|        )
   81|      0|    }
   82|       |    
   83|       |    /**
   84|       |     Sends the DFU Start command with the specified firmware type to the DFU Control Point characteristic
   85|       |     followed by firmware sizes (in bytes) to the DFU Packet characteristic. Then it waits for a response
   86|       |     notification from the device. In case of a Success, it calls `delegate.peripheralDidStartDfu()`.
   87|       |     If the response has an error code NotSupported it means, that the target device does not support 
   88|       |     updating Softdevice or Bootloader and the old Start DFU command needs to be used. The old command
   89|       |     (without a type) allowed to send only an application firmware.
   90|       |     
   91|       |     - parameter type: the firmware type bitfield. See FIRMWARE_TYPE_* constants
   92|       |     - parameter size: the size of all parts of the firmware
   93|       |     */
   94|      0|    func sendStartDfu(withFirmwareType type: UInt8, andSize size: DFUFirmwareSize) {
   95|      0|        dfuService!.sendDfuStart(withFirmwareType: type, andSize: size,
   96|      0|            onSuccess: { self.delegate?.peripheralDidStartDfu() },
   97|      0|            onError: { error, message in
   98|      0|                if error == .remoteLegacyDFUNotSupported {
   99|      0|                    self.logger.w("DFU target does not support DFU v.2")
  100|      0|                    self.delegate?.peripheralDidFailToStartDfuWithType()
  101|      0|                } else {
  102|      0|                    self.delegate?.error(error, didOccurWithMessage: message)
  103|      0|                }
  104|      0|            }
  105|      0|        )
  106|      0|    }
  107|       |    
  108|       |    /**
  109|       |     Sends the old Start DFU command, where there was no type byte. The old format allowed to send
  110|       |     the application update only. Try this method if `sendStartDfuWithFirmwareType(_:andSize:)` 
  111|       |     returned NotSupported and the firmware contains only the application.
  112|       |     
  113|       |     - parameter size: the size of all parts of the firmware, where size of softdevice and bootloader are 0
  114|       |     */
  115|      0|    func sendStartDfu(withFirmwareSize size: DFUFirmwareSize) {
  116|      0|        logger.v("Switching to DFU v.1")
  117|      0|        dfuService!.sendStartDfu(withFirmwareSize: size,
  118|      0|            onSuccess: { self.delegate?.peripheralDidStartDfu() },
  119|      0|            onError: defaultErrorCallback
  120|      0|        )
  121|      0|    }
  122|       |
  123|       |    /**
  124|       |     Sends the Init Packet with firmware metadata. When complete, the `delegate.peripheralDidReceiveInitPacket()`
  125|       |     callback is called.
  126|       |     
  127|       |     - parameter data: Init Packet data
  128|       |     */
  129|      0|    func sendInitPacket(_ data: Data) {
  130|      0|        dfuService!.sendInitPacket(data,
  131|      0|            onSuccess: { self.delegate?.peripheralDidReceiveInitPacket() },
  132|      0|            onError: defaultErrorCallback
  133|      0|        )
  134|      0|    }
  135|       |    
  136|       |    /**
  137|       |     Sends the firmware to the DFU target device. Before that, it will send the desired number of
  138|       |     packets to be received before sending a new Packet Receipt Notification.
  139|       |     When the whole firmware is transferred the `delegate.peripheralDidReceiveFirmware()` callback is invoked.
  140|       |     
  141|       |     - parameter aFirmware: the firmware
  142|       |     - parameter aPRNValue: number of packets of firmware data to be received by the DFU target
  143|       |     before sending a new Packet Receipt Notification. Set 0 to disable PRNs (not recommended)
  144|       |     - parameter progressDelegate: the deleagate that will be informed about progress changes
  145|       |     */
  146|      0|    func sendFirmware(_ aFirmware: DFUFirmware, withPacketReceiptNotificationNumber aPRNValue: UInt16, andReportProgressTo progressDelegate: DFUProgressDelegate?) {
  147|      0|        dfuService!.sendPacketReceiptNotificationRequest(aPRNValue,
  148|      0|            onSuccess: {
  149|      0|                // Now the service is ready to send the firmware
  150|      0|                self.dfuService!.sendFirmware(aFirmware, andReportProgressTo: progressDelegate,
  151|      0|                    onSuccess: { self.delegate?.peripheralDidReceiveFirmware() },
  152|      0|                    onError: self.defaultErrorCallback
  153|      0|                )
  154|      0|            },
  155|      0|            onError: defaultErrorCallback
  156|      0|        )
  157|      0|    }
  158|       |    
  159|       |    /**
  160|       |     Sends the Validate Firmware request to DFU Control Point characteristic.
  161|       |     On success, the `delegate.peripheralDidVerifyFirmware()` method will be called.
  162|       |     */
  163|      0|    func validateFirmware() {
  164|      0|        dfuService!.sendValidateFirmwareRequest(
  165|      0|            onSuccess: { self.delegate?.peripheralDidVerifyFirmware() },
  166|      0|            onError: defaultErrorCallback
  167|      0|        )
  168|      0|    }
  169|       |    
  170|       |    /**
  171|       |     Sends the Activate and Reset command to the DFU Control Point characteristic.
  172|       |     */
  173|      0|    func activateAndReset() {
  174|      0|        activating = true
  175|      0|        dfuService!.sendActivateAndResetRequest(
  176|      0|            // onSuccess the device gets disconnected and centralManager(_:didDisconnectPeripheral:error) will be called
  177|      0|            onError: defaultErrorCallback
  178|      0|        )
  179|      0|    }
  180|       |    
  181|      0|    override func resetDevice() {
  182|      0|        guard let dfuService = dfuService, dfuService.supportsReset() else {
  183|      0|            super.resetDevice()
  184|      0|            return
  185|      0|        }
  186|      0|        dfuService.sendReset(onError: defaultErrorCallback)
  187|      0|    }
  188|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/LegacyDFU/Services/LegacyDFUService.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |@objc internal class LegacyDFUService : NSObject, CBPeripheralDelegate, DFUService {
   26|       |    static let UUID = CBUUID(string: "00001530-1212-EFDE-1523-785FEABCD123")
   27|       |    
   28|      0|    static func matches(_ service: CBService) -> Bool {
   29|      0|        return service.uuid.isEqual(UUID)
   30|      0|    }
   31|       |    
   32|       |    /// The target DFU Peripheral
   33|       |    internal var targetPeripheral: DFUPeripheralAPI?
   34|       |    /// The logger helper.
   35|       |    private var logger: LoggerHelper
   36|       |    /// The service object from CoreBluetooth used to initialize the DFUService instance.
   37|       |    private let service                       : CBService
   38|       |    private var dfuPacketCharacteristic       : DFUPacket?
   39|       |    private var dfuControlPointCharacteristic : DFUControlPoint?
   40|       |    private var dfuVersionCharacteristic      : DFUVersion?
   41|       |    /// This method returns true if DFU Control Point characteristc has been discovered.
   42|       |    /// A device without this characteristic is not supported and even can't be resetted by sending a Reset command.
   43|      0|    internal func supportsReset() -> Bool {
   44|      0|        return dfuControlPointCharacteristic != nil
   45|      0|    }
   46|       |    
   47|       |    /// The version read from the DFU Version charactertistic. Nil, if such does not exist.
   48|       |    private(set) var version: (major: UInt8, minor: UInt8)?
   49|       |    private var paused  = false
   50|       |    private var aborted = false
   51|       |    
   52|       |    /// A temporary callback used to report end of an operation.
   53|       |    private var success: Callback?
   54|       |    /// A temporary callback used to report an operation error.
   55|       |    private var report:  ErrorCallback?
   56|       |    /// A temporaty callback used to report progress status.
   57|       |    private var progressDelegate: DFUProgressDelegate?
   58|       |    
   59|       |    // -- Properties stored when upload started in order to resume it --
   60|       |    private var firmware: DFUFirmware?
   61|       |    private var packetReceiptNotificationNumber: UInt16 = 0
   62|       |    // -- End --
   63|       |    
   64|       |    // MARK: - Initialization
   65|       |    
   66|      0|    required init(_ service: CBService, _ logger: LoggerHelper) {
   67|      0|        self.service = service
   68|      0|        self.logger = logger
   69|      0|        super.init()
   70|      0|        self.logger.v("Legacy DFU Service found")
   71|      0|    }
   72|       |    
   73|      0|    func destroy() {
   74|      0|        dfuPacketCharacteristic = nil
   75|      0|        dfuControlPointCharacteristic = nil
   76|      0|        dfuVersionCharacteristic = nil
   77|      0|        targetPeripheral = nil
   78|      0|        version = nil
   79|      0|    }
   80|       |    
   81|       |    // MARK: - Controler API methods
   82|       |    
   83|      0|    func pause() -> Bool {
   84|      0|        if !aborted {
   85|      0|            paused = true
   86|      0|        }
   87|      0|        return paused
   88|      0|    }
   89|       |    
   90|      0|    func resume() -> Bool {
   91|      0|        if !aborted && paused && firmware != nil {
   92|      0|            paused = false
   93|      0|            // onSuccess and onError callbacks are still kept by dfuControlPointCharacteristic
   94|      0|            dfuPacketCharacteristic!.sendNext(packetReceiptNotificationNumber, packetsOf: firmware!, andReportProgressTo: progressDelegate)
   95|      0|            return paused
   96|      0|        }
   97|      0|        paused = false
   98|      0|        return paused
   99|      0|    }
  100|       |    
  101|      0|    func abort() -> Bool {
  102|      0|        aborted = true
  103|      0|        // When upload has been started and paused, we have to send the Reset command here as the device will
  104|      0|        // not get a Packet Receipt Notification. If it hasn't been paused, the Reset command will be sent after receiving it, on line 380.
  105|      0|        if paused && firmware != nil {
  106|      0|            let _report = report!
  107|      0|            firmware = nil
  108|      0|            success  = nil
  109|      0|            report   = nil
  110|      0|            progressDelegate = nil
  111|      0|            // Upload has been aborted. Reset the target device. It will disconnect automatically
  112|      0|            sendReset(onError: _report)
  113|      0|        }
  114|      0|        paused = false
  115|      0|        return aborted
  116|      0|    }
  117|       |    
  118|       |    // MARK: - Service API methods
  119|       |    
  120|       |    /**
  121|       |     Discovers characteristics in the DFU Service. Result it reported using callbacks.
  122|       |     
  123|       |     - parameter success: method called when required DFU characteristics were discovered
  124|       |     - parameter report:  method called when an error occurred
  125|       |     */
  126|      0|    func discoverCharacteristics(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  127|      0|        // Save callbacks
  128|      0|        self.success = success
  129|      0|        self.report  = report
  130|      0|        
  131|      0|        // Get the peripheral object
  132|      0|        let peripheral = service.peripheral
  133|      0|        
  134|      0|        // Set the peripheral delegate to self
  135|      0|        peripheral.delegate = self
  136|      0|        
  137|      0|        // Discover DFU characteristics
  138|      0|        logger.v("Discovering characteristics in DFU Service...")
  139|      0|        logger.d("peripheral.discoverCharacteristics(nil, for: \(LegacyDFUService.UUID.uuidString))")
  140|      0|        peripheral.discoverCharacteristics(nil, for: service)
  141|      0|    }
  142|       |    
  143|       |    /**
  144|       |     This method tries to estimate whether the DFU target device is in Application mode which supports
  145|       |     the buttonless jump to the DFU Bootloader.
  146|       |     
  147|       |     - returns: true, if it is for sure in the Application more, false, if definitely is not, nil if uknown
  148|       |     */
  149|      0|    func isInApplicationMode() -> Bool? {
  150|      0|        // If DFU Version characteritsic returned a correct value...
  151|      0|        if let version = version {
  152|      0|            // The app with buttonless update always returns value 0x0100 (major: 0, minor: 1). Otherwise it's in DFU mode.
  153|      0|            // See the documentation for DFUServiceInitiator.forceDfu(:Bool) for details about supported versions.
  154|      0|            return version.major == 0 && version.minor == 1
  155|      0|        }
  156|      0|        
  157|      0|        // The mbed implementation of DFU does not have DFU Packet characteristic in application mode
  158|      0|        if dfuPacketCharacteristic == nil {
  159|      0|            return true
  160|      0|        }
  161|      0|        
  162|      0|        // At last, count services. When only one service found - the DFU Service - we must be in the DFU mode already
  163|      0|        // (otherwise the device would be useless...)
  164|      0|        // Note: On iOS the Generic Access and Generic Attribute services (nor HID Service)
  165|      0|        //       are not returned during service discovery.
  166|      0|        let services = service.peripheral.services!
  167|      0|        if services.count == 1 {
  168|      0|            return false
  169|      0|        }
  170|      0|        // If there are more services than just DFU Service, the state is uncertain
  171|      0|        return nil
  172|      0|    }
  173|       |    
  174|       |    /**
  175|       |     Enables notifications for DFU Control Point characteristic. Result it reported using callbacks.
  176|       |     
  177|       |     - parameter success: method called when notifications were enabled without a problem
  178|       |     - parameter report:  method called when an error occurred
  179|       |     */
  180|      0|    func enableControlPoint(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  181|      0|        if !aborted {
  182|      0|            dfuControlPointCharacteristic!.enableNotifications(onSuccess: success, onError: report)
  183|      0|        } else {
  184|      0|            sendReset(onError: report)
  185|      0|        }
  186|      0|    }
  187|       |    
  188|       |    /**
  189|       |     Triggers a switch to DFU Bootloader mode on the remote target by sending DFU Start command.
  190|       |     
  191|       |     - parameter report:  method called when an error occurred
  192|       |     */
  193|      0|    func jumpToBootloaderMode(onError report:@escaping ErrorCallback) {
  194|      0|        if !aborted {
  195|      0|            dfuControlPointCharacteristic!.send(Request.jumpToBootloader, onSuccess: nil, onError: report)
  196|      0|        } else {
  197|      0|            sendReset(onError: report)
  198|      0|        }
  199|      0|    }
  200|       |    
  201|       |    /**
  202|       |     This methods sends the Start DFU command with the firmware type to the DFU Control Point characterristic,
  203|       |     followed by the sizes of each firware component <softdevice, bootloader, application> (each as UInt32, Little Endian).
  204|       |     
  205|       |     - parameter type:    the type of the current firmware part
  206|       |     - parameter size:    the sizes of firmware components in the current part
  207|       |     - parameter success: a callback called when a response with status Success is received
  208|       |     - parameter report:  a callback called when a response with an error status is received
  209|       |     */
  210|      0|    func sendDfuStart(withFirmwareType type: UInt8, andSize size: DFUFirmwareSize, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  211|      0|        guard !aborted else {
  212|      0|            sendReset(onError: report)
  213|      0|            return
  214|      0|        }
  215|      0|        
  216|      0|        // It has been found that a bootloader from SDK 6.1 or older requires some time before the firmware can be sent in the following situation:
  217|      0|        // 1. DFU starts normally (the delay not required)
  218|      0|        // 2. DFU process interrupts by a link loss (Faraday cage used for testing)
  219|      0|        // 3. The iPhone reconnects and receives state = 2 (Invalid state) after sending app size - bootloader would like the old upload to be resumed,
  220|      0|        //    but new Start DFU sent instead (this is expected)
  221|      0|        // 4. The central sends Op Code = 06 (Reset) to reset the state
  222|      0|        // 5. The central reconnects and starts DFU again. Without the 1 sec delay below it would receive a response with status = 6 (Operation failed)
  223|      0|        //    after sending some firmware packets. Delay 1 sec seems to work while 600 ms was too short. The time seems to be required to prepare flash(?).
  224|      0|        let sendStartDfu = {
  225|      0|            // 1. Sends the Start DFU command with the firmware type to DFU Control Point characteristic
  226|      0|            // 2. Sends firmware sizes to DFU Packet characteristic
  227|      0|            // 3. Receives response notification and calls onSuccess or onError
  228|      0|            self.dfuControlPointCharacteristic!.send(Request.startDfu(type: type), onSuccess: success) { (error, aMessage) in
  229|      0|                if error == .remoteLegacyDFUInvalidState {
  230|      0|                    self.targetPeripheral!.shouldReconnect = true
  231|      0|                    self.sendReset(onError: report)
  232|      0|                    return
  233|      0|                }
  234|      0|                report(error, aMessage)
  235|      0|            }
  236|      0|            self.dfuPacketCharacteristic!.sendFirmwareSize(size)
  237|      0|        }
  238|      0|        if version != nil {
  239|      0|            // The legacy DFU bootloader from SDK 7.0+ does not require delay.
  240|      0|            sendStartDfu()
  241|      0|        } else {
  242|      0|            // DFU Version characteristic did not exist in SDK 6.1 or before. Delay is required as stated above.
  243|      0|            logger.d("wait(1000)")
  244|      0|            DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(1000), execute: sendStartDfu)
  245|      0|        }
  246|      0|    }
  247|       |    
  248|       |    /**
  249|       |     This methods sends the old Start DFU command (without the firmware type) to the DFU Control Point characterristic,
  250|       |     followed by the application size <application> (UInt32, Little Endian).
  251|       |     
  252|       |     - parameter size:    the sizes of firmware components in the current part
  253|       |     - parameter success: a callback called when a response with status Success is received
  254|       |     - parameter report:  a callback called when a response with an error status is received
  255|       |     */
  256|      0|    func sendStartDfu(withFirmwareSize size: DFUFirmwareSize, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  257|      0|        guard !aborted else {
  258|      0|            sendReset(onError: report)
  259|      0|            return
  260|      0|        }
  261|      0|        
  262|      0|        // See comment in sendDfuStart(withFirmwareType:andSize:onSuccess:onError) above
  263|      0|        logger.d("wait(1000)")
  264|      0|        DispatchQueue.main.asyncAfter(deadline: .now() + .milliseconds(1000)) {
  265|      0|            // 1. Sends the Start DFU command with the firmware type to the DFU Control Point characteristic
  266|      0|            // 2. Sends firmware sizes to the DFU Packet characteristic
  267|      0|            // 3. Receives response notification and calls onSuccess or onError
  268|      0|            self.dfuControlPointCharacteristic!.send(Request.startDfu_v1, onSuccess: success)  { (error, aMessage) in
  269|      0|                if error == .remoteLegacyDFUInvalidState {
  270|      0|                    self.targetPeripheral!.shouldReconnect = true
  271|      0|                    self.sendReset(onError: report)
  272|      0|                    return
  273|      0|                }
  274|      0|                report(error, aMessage)
  275|      0|            }
  276|      0|            self.dfuPacketCharacteristic!.sendFirmwareSize_v1(size)
  277|      0|        }
  278|      0|    }
  279|       |    
  280|       |    /**
  281|       |     This method sends the Init Packet with additional firmware metadata to the target DFU device.
  282|       |     The Init Packet is required since Bootloader v0.5 (SDK 7.0.0), when it has been extended with 
  283|       |     firmware verification data, like IDs of supported softdevices, device type and revision, or application version.
  284|       |     The extended Init Packet may also contain a hash of the firmware (since DFU from SDK 9.0.0).
  285|       |     Before Init Packet became required it could have contained only 2-byte CRC of the firmware.
  286|       |     
  287|       |     - parameter data:    the Init Packet data
  288|       |     - parameter success: a callback called when a response with status Success is received
  289|       |     - parameter report:  a callback called when a response with an error status is received
  290|       |     */
  291|      0|    func sendInitPacket(_ data: Data, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  292|      0|        guard !aborted else {
  293|      0|            sendReset(onError: report)
  294|      0|            return
  295|      0|        }
  296|      0|        
  297|      0|        // The procedure of sending the Init Packet has changed the same time the DFU Version characterstic was introduced.
  298|      0|        // Before it was not required, and could contain only CRC of the firmware (2 bytes).
  299|      0|        // Since DFU Bootloader version 0.5 (SDK 7.0.0) it is required and has been extended. Must be at least 14 bytes:
  300|      0|        // Device Type (2), Device Revision (2), Application Version (4), SD array length (2), at least one SD or 0xFEFF (2), CRC or hash (2+)
  301|      0|        // For more details, see:
  302|      0|        // http://infocenter.nordicsemi.com/topic/com.nordic.infocenter.sdk5.v11.0.0/bledfu_example_init.html?cp=4_0_0_4_2_1_1_3
  303|      0|        // (or another version of this page, matching your DFU version)
  304|      0|        
  305|      0|        if version != nil {
  306|      0|            if data.count < 14 {
  307|      0|                // Init packet validation would have failed. We can safely abort here.
  308|      0|                report(.extendedInitPacketRequired, "Extended init packet required. Old one found instead.")
  309|      0|                return
  310|      0|            }
  311|      0|            // Since DFU v0.5, the Extended Init Packet may contain more than 20 bytes.
  312|      0|            // Therefore, there are 2 commands to the DFU Control Point required: one before we start sending init packet,
  313|      0|            // and another one the whole init packet is sent. After sending the second packet a notification will be received
  314|      0|            dfuControlPointCharacteristic!.send(Request.initDfuParameters(req: InitDfuParametersRequest.receiveInitPacket), onSuccess: nil, onError: report)
  315|      0|            dfuPacketCharacteristic!.sendInitPacket(data)
  316|      0|            dfuControlPointCharacteristic!.send(Request.initDfuParameters(req: InitDfuParametersRequest.initPacketComplete), onSuccess: success,
  317|      0|                onError: {
  318|      0|                    error, message in
  319|      0|                    if error == .remoteLegacyDFUOperationFailed {
  320|      0|                        // Init packet validation failed. The device type, revision, app version or Softdevice version 
  321|      0|                        // does not match values specified in the Init packet.
  322|      0|                        report(error, "Operation failed. Ensure the firmware targets that device type and version.")
  323|      0|                    } else {
  324|      0|                        report(error, message)
  325|      0|                    }
  326|      0|            })
  327|      0|        } else {
  328|      0|            // Before that, the Init Packet could have contained only the 2-bytes CRC and was transfered in a single packet.
  329|      0|            // There was a single command sent to the DFU Control Point (Op Code = 2), followed by the Init Packet transfer
  330|      0|            // to the DFU Packet characteristic. After receiving this packet the DFU target was sending a notification with status.
  331|      0|            if data.count == 2 {
  332|      0|                dfuControlPointCharacteristic!.send(Request.initDfuParameters_v1, onSuccess: success, onError: report)
  333|      0|                dfuPacketCharacteristic!.sendInitPacket(data)
  334|      0|            } else {
  335|      0|                // After sending the Extended Init Packet, the DFU would fail on CRC validation eventually. 
  336|      0|                
  337|      0|                // NOTE!
  338|      0|                // We can do 2 thing: abort, with an error:
  339|      0|                report(.initPacketRequired, "Init packet with 2-byte CRC supported. Extended init packet found.")
  340|      0|                // ..or ignore it and do not send any init packet (not safe!):
  341|      0|                // success()
  342|      0|            }
  343|      0|        }
  344|      0|    }
  345|       |    
  346|       |    /**
  347|       |     Sends Packet Receipt Notification Request command with given value.
  348|       |     The DFU target will send Packet Receipt Notifications every time it receives given number of packets
  349|       |     to synchronize the iDevice with the bootloader. The higher number is set, the faster the transmission
  350|       |     may be, but too high values may also cause a buffer overflow error (the app may write
  351|       |     packets to the outgoing queue then much faster then they are actually delivered). The
  352|       |     Packet Receipt Notification procedure has been introduced to empty the outgoing buffer.
  353|       |     Setting number to 0 will disable PRNs.
  354|       |     
  355|       |     - parameter aPRNValue: number of packets of firmware data to be received by the DFU target before
  356|       |     sending a new Packet Receipt Notification.
  357|       |     - parameter success:   a callback called when a response with status Success is received
  358|       |     - parameter report:    a callback called when a response with an error status is received
  359|       |     */
  360|      0|    func sendPacketReceiptNotificationRequest(_ aPRNValue: UInt16, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  361|      0|        if !aborted {
  362|      0|            packetReceiptNotificationNumber = aPRNValue
  363|      0|            dfuControlPointCharacteristic!.send(Request.packetReceiptNotificationRequest(number: aPRNValue), onSuccess: success, onError: report)
  364|      0|        } else {
  365|      0|            sendReset(onError: report)
  366|      0|        }
  367|      0|    }
  368|       |    
  369|       |    /**
  370|       |     Sends the firmware data to the DFU target device.
  371|       |     
  372|       |     - parameter aFirmware: the firmware to be sent
  373|       |     - parameter aPRNValue: number of packets of firmware data to be received by the DFU target before
  374|       |     sending a new Packet Receipt Notification
  375|       |     - parameter progressDelegate: a progress delagate that will be informed about transfer progress
  376|       |     - parameter success:   a callback called when a response with status Success is received
  377|       |     - parameter report:    a callback called when a response with an error status is received
  378|       |     */
  379|       |    func sendFirmware(_ aFirmware: DFUFirmware, andReportProgressTo progressDelegate: DFUProgressDelegate?,
  380|      0|                      onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  381|      0|        guard !aborted else {
  382|      0|            sendReset(onError: report)
  383|      0|            return
  384|      0|        }
  385|      0|        
  386|      0|        // Store parameters in case the upload was paused and resumed
  387|      0|        self.firmware         = aFirmware
  388|      0|        self.report           = report
  389|      0|        self.progressDelegate = progressDelegate
  390|      0|        
  391|      0|        // 1. Sends the Receive Firmware Image command to the DFU Control Point characteristic
  392|      0|        // 2. Sends firmware to the DFU Packet characteristic. If number > 0 it will receive Packet Receit Notifications
  393|      0|        //    every number packets.
  394|      0|        // 3. Receives response notification and calls onSuccess or onError
  395|      0|        dfuControlPointCharacteristic!.send(Request.receiveFirmwareImage,
  396|      0|            onSuccess: {
  397|      0|                // Register callbacks for Packet Receipt Notifications/Responses
  398|      0|                self.dfuControlPointCharacteristic!.waitUntilUploadComplete(
  399|      0|                    onSuccess: {
  400|      0|                        // Upload is completed, release the temporary parameters
  401|      0|                        self.firmware = nil
  402|      0|                        self.report   = nil
  403|      0|                        self.progressDelegate = nil
  404|      0|                        success()
  405|      0|                    },
  406|      0|                    onPacketReceiptNofitication: {
  407|      0|                        bytesReceived in
  408|      0|                        // Each time a PRN is received, send next bunch of packets
  409|      0|                        if !self.paused && !self.aborted {
  410|      0|                            let bytesSent = self.dfuPacketCharacteristic!.bytesSent
  411|      0|                            // Due to https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library/issues/54 only 16 least significant bits are verified
  412|      0|                            if (bytesSent & 0xFFFF) == (bytesReceived & 0xFFFF) {
  413|      0|                                self.dfuPacketCharacteristic!.sendNext(self.packetReceiptNotificationNumber, packetsOf: aFirmware, andReportProgressTo: progressDelegate)
  414|      0|                            } else {
  415|      0|                                // Target device deported invalid number of bytes received
  416|      0|                                report(.bytesLost, "\(bytesSent) bytes were sent while \(bytesReceived) bytes were reported as received")
  417|      0|                            }
  418|      0|                        } else if self.aborted {
  419|      0|                            // Upload has been aborted. Reset the target device. It will disconnect automatically
  420|      0|                            self.firmware = nil
  421|      0|                            self.report   = nil
  422|      0|                            self.progressDelegate = nil
  423|      0|                            self.sendReset(onError: report)
  424|      0|                        }
  425|      0|                    },
  426|      0|                    onError: {
  427|      0|                        error, message in
  428|      0|                        // Upload failed, release the temporary parameters
  429|      0|                        self.firmware = nil
  430|      0|                        self.report   = nil
  431|      0|                        self.progressDelegate = nil
  432|      0|                        report(error, message)
  433|      0|                    }
  434|      0|                )
  435|      0|                // ...and start sending firmware
  436|      0|                if !self.paused && !self.aborted {
  437|      0|                    self.dfuPacketCharacteristic!.sendNext(self.packetReceiptNotificationNumber, packetsOf: aFirmware, andReportProgressTo: progressDelegate)
  438|      0|                } else if self.aborted {
  439|      0|                    // Upload has been aborted. Reset the target device. It will disconnect automatically
  440|      0|                    self.firmware = nil
  441|      0|                    self.report   = nil
  442|      0|                    self.progressDelegate = nil
  443|      0|                    self.sendReset(onError: report)
  444|      0|                }
  445|      0|            },
  446|      0|            onError: report)
  447|      0|    }
  448|       |    
  449|       |    /**
  450|       |     Sends the Validate Firmware request to DFU Control Point characteristic.
  451|       |     
  452|       |     - parameter success: a callback called when a response with status Success is received
  453|       |     - parameter report:  a callback called when a response with an error status is received
  454|       |     */
  455|      0|    func sendValidateFirmwareRequest(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  456|      0|        if !aborted {
  457|      0|            dfuControlPointCharacteristic!.send(Request.validateFirmware, onSuccess: success, onError: report)
  458|      0|        } else {
  459|      0|            sendReset(onError: report)
  460|      0|        }
  461|      0|    }
  462|       |    
  463|       |    /**
  464|       |     Sends a command that will activate the new firmware and reset the DFU target device.
  465|       |     Soon after calling this method the device should disconnect.
  466|       |     
  467|       |     - parameter report: a callback called when writing characteristic failed
  468|       |     */
  469|      0|    func sendActivateAndResetRequest(onError report: @escaping ErrorCallback) {
  470|      0|        if !aborted {
  471|      0|            dfuControlPointCharacteristic!.send(Request.activateAndReset, onSuccess: nil, onError: report)
  472|      0|        } else {
  473|      0|            sendReset(onError: report)
  474|      0|        }
  475|      0|    }
  476|       |    
  477|       |    /**
  478|       |     Sends a Reset command to the target DFU device. The device will disconnect automatically and restore the
  479|       |     previous application (if DFU dual bank was used and application wasn't removed to make space for a new
  480|       |     softdevice) or bootloader.
  481|       |     
  482|       |     - parameter report: a callback called when writing characteristic failed
  483|       |     */
  484|      0|    func sendReset(onError report: @escaping ErrorCallback) {
  485|      0|        dfuControlPointCharacteristic!.send(Request.reset, onSuccess: nil, onError: report)
  486|      0|    }
  487|       |    
  488|       |    // MARK: - Private service API methods
  489|       |    
  490|       |    /**
  491|       |    Reads the DFU Version characteristic value. The characteristic must not be nil.
  492|       |    
  493|       |    - parameter success: the callback called when supported version number has been received
  494|       |    - parameter report:  the error callback which is called in case of an error, or when obtained data are not supported
  495|       |    */
  496|      0|    private func readDfuVersion(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  497|      0|        dfuVersionCharacteristic!.readVersion(
  498|      0|            onSuccess: {
  499|      0|                major, minor in
  500|      0|                self.version = (major, minor)
  501|      0|                success()
  502|      0|            },
  503|      0|            onError:report
  504|      0|        )
  505|      0|    }
  506|       |    
  507|       |    // MARK: - Peripheral Delegate callbacks
  508|       |    
  509|      0|    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
  510|      0|        // Create local references to callback to release the global ones
  511|      0|        let _success = self.success
  512|      0|        let _report = self.report
  513|      0|        self.success = nil
  514|      0|        self.report = nil
  515|      0|        
  516|      0|        if error != nil {
  517|      0|            logger.e("Characteristics discovery failed")
  518|      0|            logger.e(error!)
  519|      0|            _report?(.serviceDiscoveryFailed, "Characteristics discovery failed")
  520|      0|        } else {
  521|      0|            logger.i("DFU characteristics discovered")
  522|      0|            
  523|      0|            // Find DFU characteristics
  524|      0|            for characteristic in service.characteristics! {
  525|      0|                if (DFUPacket.matches(characteristic)) {
  526|      0|                    dfuPacketCharacteristic = DFUPacket(characteristic, logger)
  527|      0|                } else if (DFUControlPoint.matches(characteristic)) {
  528|      0|                    dfuControlPointCharacteristic = DFUControlPoint(characteristic, logger)
  529|      0|                } else if (DFUVersion.matches(characteristic)) {
  530|      0|                    dfuVersionCharacteristic = DFUVersion(characteristic, logger)
  531|      0|                }
  532|      0|            }
  533|      0|            
  534|      0|            // Some validation
  535|      0|            if dfuControlPointCharacteristic == nil {
  536|      0|                logger.e("DFU Control Point characteristics not found")
  537|      0|                // DFU Control Point characteristic is required
  538|      0|                _report?(.deviceNotSupported, "DFU Control Point characteristic not found")
  539|      0|                return
  540|      0|            }
  541|      0|            if !dfuControlPointCharacteristic!.valid {
  542|      0|                logger.e("DFU Control Point characteristics must have Write and Notify properties")
  543|      0|                // DFU Control Point characteristic must have Write and Notify properties
  544|      0|                _report?(.deviceNotSupported, "DFU Control Point characteristic does not have the Write and Notify properties")
  545|      0|                return
  546|      0|            }
  547|      0|            
  548|      0|            // Note: DFU Packet characteristic is not required in the App mode.
  549|      0|            //       The mbed implementation of DFU Service doesn't have such.
  550|      0|            
  551|      0|            // Read DFU Version characteristic if such exists
  552|      0|            if self.dfuVersionCharacteristic != nil {
  553|      0|                if dfuVersionCharacteristic!.valid {
  554|      0|                    readDfuVersion(onSuccess: _success!, onError: _report!)
  555|      0|                } else {
  556|      0|                    version = nil
  557|      0|                    _report?(.readingVersionFailed, "DFU Version found, but does not have the Read property")
  558|      0|                }
  559|      0|            } else {
  560|      0|                // Else... proceed
  561|      0|                version = nil
  562|      0|                _success?()
  563|      0|            }
  564|      0|        }
  565|      0|    }
  566|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/Characteristics/ButtonlessDFU.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal enum ButtonlessDFUOpCode : UInt8 {
   26|       |    case enterBootloader = 0x01
   27|       |    case responseCode    = 0x20
   28|       |    
   29|      0|    var code: UInt8 {
   30|      0|        return rawValue
   31|      0|    }
   32|       |}
   33|       |
   34|       |
   35|       |internal enum ButtonlessDFUResultCode : UInt8 {
   36|       |    case success            = 0x01
   37|       |    case opCodeNotSupported = 0x02
   38|       |    case operationFailed    = 0x04
   39|       |    
   40|      0|    var description: String {
   41|      0|        switch self {
   42|      0|        case .success:            return "Success"
   43|      0|        case .opCodeNotSupported: return "Operation not supported"
   44|      0|        case .operationFailed:    return "Operation failed"
   45|      0|        }
   46|      0|    }
   47|       |    
   48|      0|    var code: UInt8 {
   49|      0|        return rawValue
   50|      0|    }
   51|       |}
   52|       |
   53|       |internal enum ButtonlessDFURequest {
   54|       |    case enterBootloader
   55|       |    
   56|      0|    var data : Data {
   57|      0|        switch self {
   58|      0|        case .enterBootloader:
   59|      0|            return Data(bytes: [ButtonlessDFUOpCode.enterBootloader.code])
   60|      0|        }
   61|      0|    }
   62|       |}
   63|       |
   64|       |internal struct ButtonlessDFUResponse {
   65|       |    let opCode        : ButtonlessDFUOpCode?
   66|       |    let requestOpCode : ButtonlessDFUOpCode?
   67|       |    let status        : ButtonlessDFUResultCode?
   68|       |
   69|      0|    init?(_ data: Data) {
   70|      0|        // The correct response is always 3 bytes long: Response Op Code, Request Op Code and Status
   71|      0|        let opCode        : UInt8 = data[0]
   72|      0|        let requestOpCode : UInt8 = data[1]
   73|      0|        let status        : UInt8 = data[2]
   74|      0|        
   75|      0|        self.opCode        = ButtonlessDFUOpCode(rawValue: opCode)
   76|      0|        self.requestOpCode = ButtonlessDFUOpCode(rawValue: requestOpCode)
   77|      0|        self.status        = ButtonlessDFUResultCode(rawValue: status)
   78|      0|        
   79|      0|        if self.opCode != .responseCode || self.requestOpCode == nil || self.status == nil {
   80|      0|            return nil
   81|      0|        }
   82|      0|    }
   83|       |        
   84|      0|    var description: String {
   85|      0|        return "Response (Op Code = \(requestOpCode!.rawValue), Status = \(status!.rawValue))"
   86|      0|    }
   87|       |}
   88|       |
   89|       |internal class ButtonlessDFU : NSObject, CBPeripheralDelegate {
   90|       |    static let EXPERIMENTAL_UUID         = CBUUID(string: "8E400001-F315-4F60-9FB8-838830DAEA50") // the same UUID as the service
   91|       |    static let WITHOUT_BOND_SHARING_UUID = CBUUID(string: "8EC90003-F315-4F60-9FB8-838830DAEA50")
   92|       |    static let WITH_BOND_SHARING_UUID    = CBUUID(string: "8EC90004-F315-4F60-9FB8-838830DAEA50")
   93|       |    
   94|      0|    static func matches(_ characteristic: CBCharacteristic) -> Bool {
   95|      0|        return characteristic.uuid.isEqual(WITHOUT_BOND_SHARING_UUID) ||
   96|      0|            characteristic.uuid.isEqual(WITH_BOND_SHARING_UUID) ||
   97|      0|            characteristic.uuid.isEqual(EXPERIMENTAL_UUID)
   98|      0|    }
   99|       |    
  100|       |    private var characteristic: CBCharacteristic
  101|       |    private var logger: LoggerHelper
  102|       |    
  103|       |    private var success: Callback?
  104|       |    private var report:  ErrorCallback?
  105|       |    
  106|      0|    internal var valid: Bool {
  107|      0|        return (characteristic.properties.isSuperset(of: [.write, .notify]) && characteristic.uuid.isEqual(ButtonlessDFU.EXPERIMENTAL_UUID)) ||
  108|      0|                characteristic.properties.isSuperset(of: [.write, .indicate])
  109|      0|    }
  110|       |    
  111|      0|    internal var newAddressExpected: Bool {
  112|      0|        return characteristic.uuid.isEqual(ButtonlessDFU.EXPERIMENTAL_UUID) || characteristic.uuid.isEqual(ButtonlessDFU.WITHOUT_BOND_SHARING_UUID)
  113|      0|    }
  114|       |    
  115|       |    // MARK: - Initialization
  116|      0|    init(_ characteristic: CBCharacteristic, _ logger: LoggerHelper) {
  117|      0|        self.characteristic = characteristic
  118|      0|        self.logger = logger
  119|      0|    }
  120|       |    
  121|       |    // MARK: - Characteristic API methods
  122|       |    
  123|       |    /**
  124|       |     Enables notifications or indications for the DFU Control Point characteristics, depending on the characteristic property.
  125|       |     Reports success or an error using callbacks.
  126|       |     
  127|       |     - parameter success: method called when notifications were successfully enabled
  128|       |     - parameter report:  method called in case of an error
  129|       |     */
  130|      0|    func enable(onSuccess success: Callback?, onError report: ErrorCallback?) {
  131|      0|        // Save callbacks
  132|      0|        self.success = success
  133|      0|        self.report  = report
  134|      0|        
  135|      0|        // Get the peripheral object
  136|      0|        let peripheral = characteristic.service.peripheral
  137|      0|        
  138|      0|        // Set the peripheral delegate to self
  139|      0|        peripheral.delegate = self
  140|      0|        
  141|      0|        if characteristic.properties.contains(.indicate) {
  142|      0|            logger.v("Enabling indications for \(characteristic.uuid.uuidString)...")
  143|      0|        } else {
  144|      0|            logger.v("Enabling notifications for \(characteristic.uuid.uuidString)...")
  145|      0|        }
  146|      0|        logger.d("peripheral.setNotifyValue(true, for: \(characteristic.uuid.uuidString))")
  147|      0|        peripheral.setNotifyValue(true, for: characteristic)
  148|      0|    }
  149|       |    
  150|       |    /**
  151|       |     Sends given request to the Buttonless DFU characteristic. Reports success or an error
  152|       |     using callbacks.
  153|       |     
  154|       |     - parameter request: request to be sent
  155|       |     - parameter success: method called when peripheral reported with status success
  156|       |     - parameter report:  method called in case of an error
  157|       |     */
  158|      0|    func send(_ request: ButtonlessDFURequest, onSuccess success: Callback?, onError report: ErrorCallback?) {
  159|      0|        // Save callbacks and parameter
  160|      0|        self.success = success
  161|      0|        self.report  = report
  162|      0|        
  163|      0|        // Get the peripheral object
  164|      0|        let peripheral = characteristic.service.peripheral
  165|      0|        
  166|      0|        // Set the peripheral delegate to self
  167|      0|        peripheral.delegate = self
  168|      0|        
  169|      0|        logger.v("Writing to characteristic \(characteristic.uuid.uuidString)...")
  170|      0|        logger.d("peripheral.writeValue(0x\(request.data.hexString), for: \(characteristic.uuid.uuidString), type: .withResponse)")
  171|      0|        peripheral.writeValue(request.data, for: characteristic, type: .withResponse)
  172|      0|    }
  173|       |    
  174|       |    // MARK: - Peripheral Delegate callbacks
  175|       |    
  176|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
  177|      0|        if error != nil {
  178|      0|            if characteristic.properties.contains(.indicate) {
  179|      0|                logger.e("Enabling indications failed")
  180|      0|                logger.e(error!)
  181|      0|                report?(.enablingControlPointFailed, "Enabling indications failed")
  182|      0|            } else {
  183|      0|                logger.e("Enabling notifications failed")
  184|      0|                logger.e(error!)
  185|      0|                report?(.enablingControlPointFailed, "Enabling notifications failed")
  186|      0|            }
  187|      0|        } else {
  188|      0|            if characteristic.properties.contains(.indicate) {
  189|      0|                logger.v("Indications enabled for \(characteristic.uuid.uuidString)")
  190|      0|                logger.a("Buttonless DFU indications enabled")
  191|      0|            } else {
  192|      0|                logger.v("Notifications enabled for \(characteristic.uuid.uuidString)")
  193|      0|                logger.a("Buttonless DFU notifications enabled")
  194|      0|            }
  195|      0|            success?()
  196|      0|        }
  197|      0|    }
  198|       |    
  199|      0|    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
  200|      0|        if error != nil {
  201|      0|            logger.e("Writing to characteristic failed")
  202|      0|            logger.e(error!)
  203|      0|            report?(.writingCharacteristicFailed, "Writing to characteristic failed")
  204|      0|        } else {
  205|      0|            logger.i("Data written to \(characteristic.uuid.uuidString)")
  206|      0|        }
  207|      0|    }
  208|       |    
  209|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
  210|      0|        // Ignore updates received for other characteristics
  211|      0|        guard ButtonlessDFU.matches(characteristic) else {
  212|      0|            return
  213|      0|        }
  214|      0|        
  215|      0|        if error != nil {
  216|      0|            // This characteristic is never read, the error may only pop up when notification/indication is received
  217|      0|            logger.e("Receiving response failed")
  218|      0|            logger.e(error!)
  219|      0|            report?(.receivingNotificationFailed, "Receiving response failed")
  220|      0|        } else {
  221|      0|            if characteristic.properties.contains(.indicate) {
  222|      0|                logger.i("Indication received from \(characteristic.uuid.uuidString), value (0x):\(characteristic.value!.hexString)")
  223|      0|            } else {
  224|      0|                logger.i("Notification received from \(characteristic.uuid.uuidString), value (0x):\(characteristic.value!.hexString)")
  225|      0|            }
  226|      0|            
  227|      0|            // Parse response received
  228|      0|            let dfuResponse = ButtonlessDFUResponse(characteristic.value!)
  229|      0|            if let dfuResponse = dfuResponse {
  230|      0|                if dfuResponse.status == .success {
  231|      0|                    logger.a("\(dfuResponse.description) received")
  232|      0|                    success?()
  233|      0|                } else {
  234|      0|                    logger.e("Error \(dfuResponse.status!.code): \(dfuResponse.status!.description)")
  235|      0|                    // The returned errod code is incremented by 30 or 9000 to match Buttonless DFU or Experimental Buttonless DFU remote codes
  236|      0|                    // See DFUServiceDelegate.swift -> DFUError
  237|      0|                    let offset = characteristic.uuid.isEqual(ButtonlessDFU.EXPERIMENTAL_UUID) ? 9000 : 30
  238|      0|                    report?(DFUError(rawValue: Int(dfuResponse.status!.code) + offset)!, dfuResponse.status!.description)
  239|      0|                }
  240|      0|            } else {
  241|      0|                logger.e("Unknown response received: 0x\(characteristic.value!.hexString)")
  242|      0|                report?(.unsupportedResponse, "Unsupported response received: 0x\(characteristic.value!.hexString)")
  243|      0|            }
  244|      0|        }
  245|      0|    }
  246|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/Characteristics/SecureDFUControlPoint.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal enum SecureDFUOpCode : UInt8 {
   26|       |    case createObject         = 0x01
   27|       |    case setPRNValue          = 0x02
   28|       |    case calculateChecksum    = 0x03
   29|       |    case execute              = 0x04
   30|       |    case readObjectInfo       = 0x06
   31|       |    case responseCode         = 0x60
   32|       |
   33|      0|    var code: UInt8 {
   34|      0|        return rawValue
   35|      0|    }
   36|       |}
   37|       |
   38|       |internal enum SecureDFUExtendedErrorCode : UInt8 {
   39|       |    case noError              = 0x00
   40|       |    case wrongCommandFormat   = 0x02
   41|       |    case unknownCommand       = 0x03
   42|       |    case initCommandInvalid   = 0x04
   43|       |    case fwVersionFailure     = 0x05
   44|       |    case hwVersionFailure     = 0x06
   45|       |    case sdVersionFailure     = 0x07
   46|       |    case signatureMissing     = 0x08
   47|       |    case wrongHashType        = 0x09
   48|       |    case hashFailed           = 0x0A
   49|       |    case wrongSignatureType   = 0x0B
   50|       |    case verificationFailed   = 0x0C
   51|       |    case insufficientSpace    = 0x0D
   52|       |    
   53|      0|    var code: UInt8 {
   54|      0|        return rawValue
   55|      0|    }
   56|       |    
   57|      0|    var description: String {
   58|      0|        switch self {
   59|      0|        case .noError:              return "No error"
   60|      0|        case .wrongCommandFormat:   return "Wrong command format"
   61|      0|        case .unknownCommand:       return "Unknown command"
   62|      0|        case .initCommandInvalid:   return "Init command was invalid"
   63|      0|        case .fwVersionFailure:     return "FW version check failed"
   64|      0|        case .hwVersionFailure:     return "HW version check failed"
   65|      0|        case .sdVersionFailure:     return "SD version check failed"
   66|      0|        case .signatureMissing:     return "Signature missing"
   67|      0|        case .wrongHashType:        return "Invalid hash type"
   68|      0|        case .hashFailed:           return "Hashing failed"
   69|      0|        case .wrongSignatureType:   return "Invalid signature type"
   70|      0|        case .verificationFailed:   return "Verification failed"
   71|      0|        case .insufficientSpace:    return "Insufficient space for upgrade"
   72|      0|        }
   73|      0|    }
   74|       |    
   75|       |}
   76|       |
   77|       |internal enum SecureDFUProcedureType : UInt8 {
   78|       |    case command = 0x01
   79|       |    case data    = 0x02
   80|       |    
   81|      0|    var description: String{
   82|      0|        switch self{
   83|      0|            case .command:  return "Command"
   84|      0|            case .data:     return "Data"
   85|      0|        }
   86|      0|    }
   87|       |}
   88|       |
   89|       |internal enum SecureDFURequest {
   90|       |    case createCommandObject(withSize : UInt32)
   91|       |    case createDataObject(withSize : UInt32)
   92|       |    case readCommandObjectInfo
   93|       |    case readDataObjectInfo
   94|       |    case setPacketReceiptNotification(value : UInt16)
   95|       |    case calculateChecksumCommand
   96|       |    case executeCommand
   97|       |
   98|      0|    var data : Data {
   99|      0|        switch self {
  100|      0|        case .createDataObject(let aSize):
  101|      0|            var data = Data(bytes: [SecureDFUOpCode.createObject.code, SecureDFUProcedureType.data.rawValue])
  102|      0|            data += aSize.littleEndian
  103|      0|            return data
  104|      0|        case .createCommandObject(let aSize):
  105|      0|            var data = Data(bytes: [SecureDFUOpCode.createObject.code, SecureDFUProcedureType.command.rawValue])
  106|      0|            data += aSize.littleEndian
  107|      0|            return data
  108|      0|        case .readCommandObjectInfo:
  109|      0|            return Data(bytes: [SecureDFUOpCode.readObjectInfo.code, SecureDFUProcedureType.command.rawValue])
  110|      0|        case .readDataObjectInfo:
  111|      0|            return Data(bytes: [SecureDFUOpCode.readObjectInfo.code, SecureDFUProcedureType.data.rawValue])
  112|      0|        case .setPacketReceiptNotification(let aSize):
  113|      0|            var data = Data(bytes: [SecureDFUOpCode.setPRNValue.code])
  114|      0|            data += aSize.littleEndian
  115|      0|            return data
  116|      0|        case .calculateChecksumCommand:
  117|      0|            return Data(bytes: [SecureDFUOpCode.calculateChecksum.code])
  118|      0|        case .executeCommand:
  119|      0|            return Data(bytes: [SecureDFUOpCode.execute.code])
  120|      0|        }
  121|      0|    }
  122|       |
  123|      0|    var description : String {
  124|      0|        switch self {
  125|      0|        case .createCommandObject(let size): return "Create Command Object (Op Code = 1, Type = 1, Size: \(size)b)"
  126|      0|        case .createDataObject(let size):    return "Create Data Object (Op Code = 1, Type = 2, Size: \(size)b)"
  127|      0|        case .readCommandObjectInfo:         return "Read Command Object Info (Op Code = 6, Type = 1)"
  128|      0|        case .readDataObjectInfo:            return "Read Data Object Info (Op Code = 6, Type = 2)"
  129|      0|        case .setPacketReceiptNotification(let number):
  130|      0|                                             return "Packet Receipt Notif Req (Op Code = 2, Value = \(number))"
  131|      0|        case .calculateChecksumCommand:      return "Calculate Checksum (Op Code = 3)"
  132|      0|        case .executeCommand:                return "Execute Object (Op Code = 4)"
  133|      0|        }
  134|      0|    }
  135|       |}
  136|       |
  137|       |internal enum SecureDFUResultCode : UInt8 {
  138|       |    case invalidCode           = 0x0
  139|       |    case success               = 0x01
  140|       |    case opCodeNotSupported    = 0x02
  141|       |    case invalidParameter      = 0x03
  142|       |    case insufficientResources = 0x04
  143|       |    case invalidObject         = 0x05
  144|       |    case signatureMismatch     = 0x06
  145|       |    case unsupportedType       = 0x07
  146|       |    case operationNotpermitted = 0x08
  147|       |    case operationFailed       = 0x0A
  148|       |    case extendedError         = 0x0B
  149|       |    
  150|      0|    var description: String {
  151|      0|        switch self {
  152|      0|            case .invalidCode:           return "Invalid code"
  153|      0|            case .success:               return "Success"
  154|      0|            case .opCodeNotSupported:    return "Operation not supported"
  155|      0|            case .invalidParameter:      return "Invalid parameter"
  156|      0|            case .insufficientResources: return "Insufficient resources"
  157|      0|            case .invalidObject:         return "Invalid object"
  158|      0|            case .signatureMismatch:     return "Signature mismatch"
  159|      0|            case .operationNotpermitted: return "Operation not permitted"
  160|      0|            case .unsupportedType:       return "Unsupported type"
  161|      0|            case .operationFailed:       return "Operation failed"
  162|      0|            case .extendedError:         return "Extended error"
  163|      0|        }
  164|      0|    }
  165|       |    
  166|      0|    var code: UInt8 {
  167|      0|        return rawValue
  168|      0|    }
  169|       |}
  170|       |
  171|       |internal typealias SecureDFUResponseCallback = (_ response : SecureDFUResponse?) -> Void
  172|       |
  173|       |internal struct SecureDFUResponse {
  174|       |    let opCode        : SecureDFUOpCode?
  175|       |    let requestOpCode : SecureDFUOpCode?
  176|       |    let status        : SecureDFUResultCode?
  177|       |    let maxSize       : UInt32?
  178|       |    let offset        : UInt32?
  179|       |    let crc           : UInt32?
  180|       |    let error         : SecureDFUExtendedErrorCode?
  181|       |    
  182|      0|    init?(_ data: Data) {
  183|      0|        let opCode        : UInt8 = data[0]
  184|      0|        let requestOpCode : UInt8 = data[1]
  185|      0|        let status        : UInt8 = data[2]
  186|      0|        
  187|      0|        self.opCode        = SecureDFUOpCode(rawValue: opCode)
  188|      0|        self.requestOpCode = SecureDFUOpCode(rawValue: requestOpCode)
  189|      0|        self.status        = SecureDFUResultCode(rawValue: status)
  190|      0|        
  191|      0|        // Parse response data in case of a success
  192|      0|        if self.status == .success {
  193|      0|            switch self.requestOpCode {
  194|      0|            case .some(.readObjectInfo):
  195|      0|                // The correct reponse for Read Object Info has additional 12 bytes: Max Object Size, Offset and CRC
  196|      0|                let maxSize : UInt32 = data.subdata(in: 3  ..<  7).withUnsafeBytes { $0.pointee }
  197|      0|                let offset  : UInt32 = data.subdata(in: 7  ..< 11).withUnsafeBytes { $0.pointee }
  198|      0|                let crc     : UInt32 = data.subdata(in: 11 ..< 15).withUnsafeBytes { $0.pointee }
  199|      0|                
  200|      0|                self.maxSize = maxSize
  201|      0|                self.offset  = offset
  202|      0|                self.crc     = crc
  203|      0|                self.error   = nil
  204|      0|            case .some(.calculateChecksum):
  205|      0|                // The correct reponse for Calculate Checksum has additional 8 bytes: Offset and CRC
  206|      0|                let offset : UInt32 = data.subdata(in: 3  ..<  7).withUnsafeBytes { $0.pointee }
  207|      0|                let crc    : UInt32 = data.subdata(in: 7  ..< 11).withUnsafeBytes { $0.pointee }
  208|      0|                
  209|      0|                self.maxSize = 0
  210|      0|                self.offset  = offset
  211|      0|                self.crc     = crc
  212|      0|                self.error   = nil
  213|      0|            default:
  214|      0|                self.maxSize = 0
  215|      0|                self.offset  = 0
  216|      0|                self.crc     = 0
  217|      0|                self.error   = nil
  218|      0|            }
  219|      0|        } else if self.status == .extendedError {
  220|      0|            // If extended error was received, parse the extended error code
  221|      0|            // The correct response for Read Error request has 4 bytes. The 4th byte is the extended error code
  222|      0|            let error : UInt8 = data[3]
  223|      0|            
  224|      0|            self.maxSize = 0
  225|      0|            self.offset  = 0
  226|      0|            self.crc     = 0
  227|      0|            self.error   = SecureDFUExtendedErrorCode(rawValue: error)
  228|      0|        } else {
  229|      0|            self.maxSize = 0
  230|      0|            self.offset  = 0
  231|      0|            self.crc     = 0
  232|      0|            self.error   = nil
  233|      0|        }
  234|      0|    
  235|      0|        if self.opCode != .responseCode || self.requestOpCode == nil || self.status == nil {
  236|      0|            return nil
  237|      0|        }
  238|      0|    }
  239|       |
  240|      0|    var description: String {
  241|      0|        if status == .success {
  242|      0|            switch requestOpCode {
  243|      0|            case .some(.readObjectInfo):
  244|      0|                // Max size for a command object is usually around 256. Let's say 1024, just to be sure. This is only for logging, so may be wrong.
  245|      0|                return String(format: "\(maxSize! > 1024 ? "Data" : "Command") object info (Max size = \(maxSize!), Offset = \(offset!), CRC = %08X)", crc!)
  246|      0|            case .some(.calculateChecksum):
  247|      0|                return String(format: "Checksum (Offset = \(offset!), CRC = %08X)", crc!)
  248|      0|            default:
  249|      0|                // Other responses are either not logged, or logged by service or executor, so this 'default' should never be called
  250|      0|                break
  251|      0|            }
  252|      0|        } else if status == .extendedError {
  253|      0|            if let error = error {
  254|      0|                return "Response (Op Code = \(requestOpCode!.rawValue), Status = \(status!.rawValue), Extended Error \(error.rawValue) = \(error.description))"
  255|      0|            } else {
  256|      0|                return "Response (Op Code = \(requestOpCode!.rawValue), Status = \(status!.rawValue), Unsupported Extended Error value)"
  257|      0|            }
  258|      0|        }
  259|      0|        return "Response (Op Code = \(requestOpCode!.rawValue), Status = \(status!.rawValue))"
  260|      0|    }
  261|       |}
  262|       |
  263|       |internal struct SecureDFUPacketReceiptNotification {
  264|       |    let opCode        : SecureDFUOpCode?
  265|       |    let requestOpCode : SecureDFUOpCode?
  266|       |    let resultCode    : SecureDFUResultCode?
  267|       |    let offset        : UInt32
  268|       |    let crc           : UInt32
  269|       |
  270|      0|    init?(_ data: Data) {
  271|      0|        let opCode        : UInt8 = data[0]
  272|      0|        let requestOpCode : UInt8 = data[1]
  273|      0|        let resultCode    : UInt8 = data[2]
  274|      0|
  275|      0|        self.opCode         = SecureDFUOpCode(rawValue: opCode)
  276|      0|        self.requestOpCode  = SecureDFUOpCode(rawValue: requestOpCode)
  277|      0|        self.resultCode     = SecureDFUResultCode(rawValue: resultCode)
  278|      0|
  279|      0|        if self.opCode != .responseCode {
  280|      0|            return nil
  281|      0|        }
  282|      0|        if self.requestOpCode != .calculateChecksum {
  283|      0|            return nil
  284|      0|        }
  285|      0|        if self.resultCode != .success {
  286|      0|            return nil
  287|      0|        }
  288|      0|        
  289|      0|        let offset : UInt32 = data.subdata(in: 3  ..<  7).withUnsafeBytes { $0.pointee }
  290|      0|        let crc    : UInt32 = data.subdata(in: 7  ..< 11).withUnsafeBytes { $0.pointee }
  291|      0|
  292|      0|        self.offset = offset
  293|      0|        self.crc = crc
  294|      0|    }
  295|       |}
  296|       |
  297|       |internal class SecureDFUControlPoint : NSObject, CBPeripheralDelegate {
  298|       |    static let UUID = CBUUID(string: "8EC90001-F315-4F60-9FB8-838830DAEA50")
  299|       |    
  300|      0|    static func matches(_ characteristic: CBCharacteristic) -> Bool {
  301|      0|        return characteristic.uuid.isEqual(UUID)
  302|      0|    }
  303|       |    
  304|       |    private var characteristic: CBCharacteristic
  305|       |    private var logger: LoggerHelper
  306|       |    
  307|       |    private var success:  Callback?
  308|       |    private var response: SecureDFUResponseCallback?
  309|       |    private var proceed:  ProgressCallback?
  310|       |    private var report:   ErrorCallback?
  311|       |
  312|      0|    internal var valid: Bool {
  313|      0|        return characteristic.properties.isSuperset(of: [.write, .notify])
  314|      0|    }
  315|       |    
  316|       |    // MARK: - Initialization
  317|      0|    init(_ characteristic: CBCharacteristic, _ logger: LoggerHelper) {
  318|      0|        self.characteristic = characteristic
  319|      0|        self.logger = logger
  320|      0|    }
  321|       |
  322|      0|    func peripheralDidReceiveObject() {
  323|      0|        proceed = nil
  324|      0|    }
  325|       |
  326|       |    // MARK: - Characteristic API methods
  327|       |    
  328|       |    /**
  329|       |    Enables notifications for the DFU Control Point characteristics. Reports success or an error 
  330|       |    using callbacks.
  331|       |    
  332|       |    - parameter success: method called when notifications were successfully enabled
  333|       |    - parameter report:  method called in case of an error
  334|       |    */
  335|      0|    func enableNotifications(onSuccess success: Callback?, onError report: ErrorCallback?) {
  336|      0|        // Save callbacks
  337|      0|        self.success = success
  338|      0|        self.report  = report
  339|      0|        
  340|      0|        // Get the peripheral object
  341|      0|        let peripheral = characteristic.service.peripheral
  342|      0|        
  343|      0|        // Set the peripheral delegate to self
  344|      0|        peripheral.delegate = self
  345|      0|        
  346|      0|        logger.v("Enabling notifications for \(characteristic.uuid.uuidString)...")
  347|      0|        logger.d("peripheral.setNotifyValue(true, for: \(characteristic.uuid.uuidString))")
  348|      0|        peripheral.setNotifyValue(true, for: characteristic)
  349|      0|    }
  350|       |    
  351|       |    /**
  352|       |     Sends given request to the DFU Control Point characteristic. Reports success or an error
  353|       |     using callbacks.
  354|       |     
  355|       |     - parameter request: request to be sent
  356|       |     - parameter success: method called when peripheral reported with status success
  357|       |     - parameter report:  method called in case of an error
  358|       |     */
  359|      0|    func send(_ request: SecureDFURequest, onSuccess success: Callback?, onError report: ErrorCallback?) {
  360|      0|        // Save callbacks and parameter
  361|      0|        self.success = success
  362|      0|        self.report  = report
  363|      0|        
  364|      0|        // Get the peripheral object
  365|      0|        let peripheral = characteristic.service.peripheral
  366|      0|        
  367|      0|        // Set the peripheral delegate to self
  368|      0|        peripheral.delegate = self
  369|      0|        
  370|      0|        logger.v("Writing to characteristic \(characteristic.uuid.uuidString)...")
  371|      0|        logger.d("peripheral.writeValue(0x\(request.data.hexString), for: \(characteristic.uuid.uuidString), type: .withResponse)")
  372|      0|        peripheral.writeValue(request.data, for: characteristic, type: .withResponse)
  373|      0|    }
  374|       |    
  375|       |    /**
  376|       |     Sends given request to the DFU Control Point characteristic. Reports received data or an error
  377|       |     using callbacks.
  378|       |     
  379|       |     - parameter request:  request to be sent
  380|       |     - parameter response: method called when peripheral sent a notification with requested data and status success
  381|       |     - parameter report:   method called in case of an error
  382|       |     */
  383|      0|    func send(_ request: SecureDFURequest, onResponse response: SecureDFUResponseCallback?, onError report: ErrorCallback?) {
  384|      0|        // Save callbacks and parameter
  385|      0|        self.response = response
  386|      0|        self.report   = report
  387|      0|        
  388|      0|        // Get the peripheral object
  389|      0|        let peripheral = characteristic.service.peripheral
  390|      0|        
  391|      0|        // Set the peripheral delegate to self
  392|      0|        peripheral.delegate = self
  393|      0|        
  394|      0|        logger.v("Writing to characteristic \(characteristic.uuid.uuidString)...")
  395|      0|        logger.d("peripheral.writeValue(0x\(request.data.hexString), for: \(characteristic.uuid.uuidString), type: .withResponse)")
  396|      0|        peripheral.writeValue(request.data, for: characteristic, type: .withResponse)
  397|      0|    }
  398|       |    
  399|       |    /**
  400|       |     Sets the callbacks used later on when a Packet Receipt Notification is received, a device reported an error or the whole firmware has been sent. 
  401|       |     Sending the firmware is done using DFU Packet characteristic.
  402|       |     
  403|       |     - parameter success: method called when peripheral reported with status success
  404|       |     - parameter proceed: method called the a PRN has been received and sending following data can be resumed
  405|       |     - parameter report:  method called in case of an error
  406|       |     */
  407|      0|    func waitUntilUploadComplete(onSuccess success: Callback?, onPacketReceiptNofitication proceed: ProgressCallback?, onError report: ErrorCallback?) {
  408|      0|        // Save callbacks. The proceed callback will be called periodically whenever a packet receipt notification is received. It resumes uploading.
  409|      0|        self.success = success
  410|      0|        self.proceed = proceed
  411|      0|        self.report  = report
  412|      0|
  413|      0|        // Get the peripheral object
  414|      0|        let peripheral = characteristic.service.peripheral
  415|      0|        
  416|      0|        // Set the peripheral delegate to self
  417|      0|        peripheral.delegate = self
  418|      0|        
  419|      0|        logger.a("Uploading firmware...")
  420|      0|        logger.v("Sending firmware to DFU Packet characteristic...")
  421|      0|    }
  422|       |
  423|       |    // MARK: - Peripheral Delegate callbacks
  424|       |    
  425|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateNotificationStateFor characteristic: CBCharacteristic, error: Error?) {
  426|      0|        if error != nil {
  427|      0|            logger.e("Enabling notifications failed")
  428|      0|            logger.e(error!)
  429|      0|            report?(.enablingControlPointFailed, "Enabling notifications failed")
  430|      0|        } else {
  431|      0|            logger.v("Notifications enabled for \(characteristic.uuid.uuidString)")
  432|      0|            logger.a("Secure DFU Control Point notifications enabled")
  433|      0|            success?()
  434|      0|        }
  435|      0|    }
  436|       |    
  437|      0|    func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?) {
  438|      0|        // This method, according to the iOS documentation, should be called only after writing with response to a characteristic.
  439|      0|        // However, on iOS 10 this method is called even after writing without response, which is a bug.
  440|      0|        // The DFU Control Point characteristic always writes with response, in oppose to the DFU Packet, which uses write without response.
  441|      0|        guard characteristic.uuid.isEqual(SecureDFUControlPoint.UUID) else {
  442|      0|            return
  443|      0|        }
  444|      0|        
  445|      0|        if error != nil {
  446|      0|            logger.e("Writing to characteristic failed")
  447|      0|            logger.e(error!)
  448|      0|            report?(.writingCharacteristicFailed, "Writing to characteristic failed")
  449|      0|        } else {
  450|      0|            logger.i("Data written to \(characteristic.uuid.uuidString)")
  451|      0|        }
  452|      0|    }
  453|       |    
  454|      0|    func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
  455|      0|        // Ignore updates received for other characteristics
  456|      0|        guard characteristic.uuid.isEqual(SecureDFUControlPoint.UUID) else {
  457|      0|            return
  458|      0|        }
  459|      0|        
  460|      0|        if error != nil {
  461|      0|            // This characteristic is never read, the error may only pop up when notification is received
  462|      0|            logger.e("Receiving notification failed")
  463|      0|            logger.e(error!)
  464|      0|            report?(.receivingNotificationFailed, "Receiving notification failed")
  465|      0|        } else {
  466|      0|            // During the upload we may get either a Packet Receipt Notification, or a Response with status code
  467|      0|            if proceed != nil {
  468|      0|                if let prn = SecureDFUPacketReceiptNotification(characteristic.value!) {
  469|      0|                    proceed!(prn.offset) // The CRC is not verified after receiving a PRN, only the offset is
  470|      0|                    return
  471|      0|                }
  472|      0|            }
  473|      0|            //Otherwise...    
  474|      0|            logger.i("Notification received from \(characteristic.uuid.uuidString), value (0x): \(characteristic.value!.hexString)")
  475|      0|
  476|      0|            // Parse response received
  477|      0|            let dfuResponse = SecureDFUResponse(characteristic.value!)
  478|      0|            if let dfuResponse = dfuResponse {
  479|      0|                if dfuResponse.status == .success {
  480|      0|                    switch dfuResponse.requestOpCode! {
  481|      0|                    case .readObjectInfo, .calculateChecksum:
  482|      0|                        logger.a("\(dfuResponse.description) received")
  483|      0|                        response?(dfuResponse)
  484|      0|                    case .createObject, .setPRNValue, .execute:
  485|      0|                        // Don't log, executor or service will do it for us
  486|      0|                        success?()
  487|      0|                    default:
  488|      0|                        logger.a("\(dfuResponse.description) received")
  489|      0|                        success?()
  490|      0|                    }
  491|      0|                } else if dfuResponse.status == .extendedError {
  492|      0|                    // An extended error was received
  493|      0|                    logger.e("Error \(dfuResponse.error!.code): \(dfuResponse.error!.description)")
  494|      0|                    // The returned errod code is incremented by 10 to match Secure DFU remote codes
  495|      0|                    report?(DFUError(rawValue: Int(dfuResponse.status!.code) + 10)!, dfuResponse.error!.description)
  496|      0|                } else {
  497|      0|                    logger.e("Error \(dfuResponse.status!.code): \(dfuResponse.status!.description)")
  498|      0|                    // The returned errod code is incremented by 10 to match Secure DFU remote codes
  499|      0|                    report?(DFUError(rawValue: Int(dfuResponse.status!.code) + 10)!, dfuResponse.status!.description)
  500|      0|                }
  501|      0|            } else {
  502|      0|                logger.e("Unknown response received: 0x\(characteristic.value!.hexString)")
  503|      0|                report?(.unsupportedResponse, "Unsupported response received: 0x\(characteristic.value!.hexString)")
  504|      0|            }
  505|      0|        }
  506|      0|    }
  507|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/Characteristics/SecureDFUPacket.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal class SecureDFUPacket {
   26|       |    static fileprivate let UUID = CBUUID(string: "8EC90002-F315-4F60-9FB8-838830DAEA50")
   27|       |    
   28|      0|    static func matches(_ characteristic: CBCharacteristic) -> Bool {
   29|      0|        return characteristic.uuid.isEqual(UUID)
   30|      0|    }
   31|       |    
   32|       |    private let PacketSize: UInt32 = 20
   33|       |    
   34|       |    private var characteristic: CBCharacteristic
   35|       |    private var logger: LoggerHelper
   36|       |    
   37|       |    /// Number of bytes of firmware already sent.
   38|       |    private(set) var bytesSent: UInt32 = 0
   39|       |    /// Number of bytes sent at the last progress notification. This value is used to calculate the current speed.
   40|       |    private var totalBytesSentSinceProgessNotification: UInt32 = 0
   41|       |    private var totalBytesSentWhenDfuStarted: UInt32 = 0
   42|       |
   43|       |    /// Current progress in percents (0-99).
   44|       |    private var progress:  UInt8 = 0
   45|       |    private var startTime: CFAbsoluteTime?
   46|       |    private var lastTime:  CFAbsoluteTime?
   47|       |
   48|      0|    internal var valid: Bool {
   49|      0|        return characteristic.properties.contains(.writeWithoutResponse)
   50|      0|    }
   51|       |    
   52|      0|    init(_ characteristic: CBCharacteristic, _ logger: LoggerHelper) {
   53|      0|        self.characteristic = characteristic
   54|      0|        self.logger = logger
   55|      0|    }
   56|       |    
   57|       |    // MARK: - Characteristic API methods
   58|       |    
   59|      0|    func sendInitPacket(_ initPacketData : Data){
   60|      0|        // Get the peripheral object
   61|      0|        let peripheral = characteristic.service.peripheral
   62|      0|        
   63|      0|        // Data may be sent in up-to-20-bytes packets
   64|      0|        var offset: UInt32 = 0
   65|      0|        var bytesToSend = UInt32(initPacketData.count)
   66|      0|        
   67|      0|        repeat {
   68|      0|            let packetLength = min(bytesToSend, PacketSize)
   69|      0|            let packet = initPacketData.subdata(in: Int(offset) ..< Int(offset + packetLength))
   70|      0|            
   71|      0|            logger.v("Writing to characteristic \(characteristic.uuid.uuidString)...")
   72|      0|            logger.d("peripheral.writeValue(0x\(packet.hexString), for: \(characteristic.uuid.uuidString), type: .withoutResponse)")
   73|      0|            peripheral.writeValue(packet, for: characteristic, type: .withoutResponse)
   74|      0|            
   75|      0|            offset += packetLength
   76|      0|            bytesToSend -= packetLength
   77|      0|        } while bytesToSend > 0
   78|      0|    }
   79|       |
   80|       |    /**
   81|       |     Sends a given range of data from given firmware over DFU Packet characteristic. If the whole object is
   82|       |     completed the completition callback will be called.
   83|       |     */
   84|       |    func sendNext(_ aPRNValue: UInt16, bytesFrom aRange: Range<Int>, of aFirmware : DFUFirmware,
   85|      0|                  andReportProgressTo aProgressDelegate : DFUProgressDelegate?, andCompletionTo aCompletion: @escaping Callback) {
   86|      0|        let peripheral          = characteristic.service.peripheral
   87|      0|        let objectData          = aFirmware.data.subdata(in: aRange)
   88|      0|        let objectSizeInBytes   = UInt32(objectData.count)
   89|      0|        let objectSizeInPackets = (objectSizeInBytes + PacketSize - 1) / PacketSize
   90|      0|        let packetsSent         = (bytesSent + PacketSize - 1) / PacketSize
   91|      0|        let packetsLeft         = objectSizeInPackets - packetsSent
   92|      0|
   93|      0|        // Calculate how many packets should be sent before EOF or next receipt notification
   94|      0|        var packetsToSendNow = min(UInt32(aPRNValue), packetsLeft)
   95|      0|        
   96|      0|        if aPRNValue == 0 {
   97|      0|            packetsToSendNow = objectSizeInPackets
   98|      0|        }
   99|      0|        
  100|      0|        // This is called when we no longer have data to send (PRN received after the whole object was sent)
  101|      0|        // Fixes issue IDFU-9
  102|      0|        if packetsToSendNow == 0 {
  103|      0|            aCompletion()
  104|      0|            return
  105|      0|        }
  106|      0|
  107|      0|        // Initialize timers
  108|      0|        if startTime == nil {
  109|      0|            startTime = CFAbsoluteTimeGetCurrent()
  110|      0|            lastTime = startTime
  111|      0|            totalBytesSentWhenDfuStarted = UInt32(aRange.lowerBound)
  112|      0|            totalBytesSentSinceProgessNotification = totalBytesSentWhenDfuStarted
  113|      0|            
  114|      0|            // Notify progress delegate that upload has started (0%)
  115|      0|            DispatchQueue.main.async(execute: {
  116|      0|                aProgressDelegate?.dfuProgressDidChange(
  117|      0|                    for:   aFirmware.currentPart,
  118|      0|                    outOf: aFirmware.parts,
  119|      0|                    to:     0,
  120|      0|                    currentSpeedBytesPerSecond: 0.0,
  121|      0|                    avgSpeedBytesPerSecond:     0.0)
  122|      0|            })
  123|      0|        }
  124|      0|        
  125|      0|        let originalPacketsToSendNow = packetsToSendNow
  126|      0|        while packetsToSendNow > 0 {
  127|      0|            let bytesLeft = objectSizeInBytes - bytesSent
  128|      0|            let packetLength = min(bytesLeft, PacketSize)
  129|      0|            let packet = objectData.subdata(in: Int(bytesSent) ..< Int(packetLength + bytesSent))
  130|      0|            peripheral.writeValue(packet, for: characteristic, type: .withoutResponse)
  131|      0|            
  132|      0|            bytesSent += packetLength
  133|      0|            packetsToSendNow -= 1
  134|      0|            
  135|      0|            // Calculate the total progress of the firmware, presented to the delegate
  136|      0|            let totalBytesSent = UInt32(aRange.lowerBound) + bytesSent
  137|      0|            let totalProgress = UInt8(totalBytesSent * 100 / UInt32(aFirmware.data.count))
  138|      0|            
  139|      0|            // Notify progress listener only if current progress has increased since last time
  140|      0|            if totalProgress > progress {
  141|      0|                // Calculate current transfer speed in bytes per second
  142|      0|                let now = CFAbsoluteTimeGetCurrent()
  143|      0|                let currentSpeed = Double(totalBytesSent - totalBytesSentSinceProgessNotification) / (now - lastTime!)
  144|      0|                let avgSpeed = Double(totalBytesSent - totalBytesSentWhenDfuStarted) / (now - startTime!)
  145|      0|                lastTime = now
  146|      0|                totalBytesSentSinceProgessNotification = totalBytesSent
  147|      0|                
  148|      0|                // Notify progress delegate of overall progress
  149|      0|                DispatchQueue.main.async(execute: {
  150|      0|                    aProgressDelegate?.dfuProgressDidChange(
  151|      0|                        for:   aFirmware.currentPart,
  152|      0|                        outOf: aFirmware.parts,
  153|      0|                        to:    Int(totalProgress),
  154|      0|                        currentSpeedBytesPerSecond: currentSpeed,
  155|      0|                        avgSpeedBytesPerSecond:     avgSpeed)
  156|      0|                })
  157|      0|                progress = totalProgress
  158|      0|            }
  159|      0|            
  160|      0|            // Notify handler of current object progress to start sending next one
  161|      0|            if bytesSent == objectSizeInBytes {
  162|      0|                if aPRNValue == 0 || originalPacketsToSendNow < UInt32(aPRNValue) {
  163|      0|                    aCompletion()
  164|      0|                } else {
  165|      0|                    // The whole object has been sent but the DFU target will
  166|      0|                    // send a PRN notification as expected.
  167|      0|                    // The sendData method will be called again
  168|      0|                    // with packetsLeft = 0 (see line 105)
  169|      0|                    
  170|      0|                    // Do nothing
  171|      0|                }
  172|      0|            }
  173|      0|        }
  174|      0|    }
  175|       |
  176|      0|    func resetCounters() {
  177|      0|        bytesSent = 0
  178|      0|    }
  179|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/DFU/SecureDFUExecutor.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |internal class SecureDFUExecutor : DFUExecutor, SecureDFUPeripheralDelegate {
   24|       |    typealias DFUPeripheralType = SecureDFUPeripheral
   25|       |    
   26|       |    internal let initiator  : DFUServiceInitiator
   27|       |    internal let peripheral : SecureDFUPeripheral
   28|       |    internal var firmware   : DFUFirmware
   29|       |    internal var error      : (error: DFUError, message: String)?
   30|       |    
   31|       |    private var firmwareRanges  : [Range<Int>]?
   32|       |    private var currentRangeIdx : Int = 0
   33|       |    
   34|       |    private var maxLen          : UInt32?
   35|       |    private var offset          : UInt32?
   36|       |    private var crc             : UInt32?
   37|       |    
   38|       |    private var initPacketSent  : Bool = false
   39|       |    private var firmwareSent    : Bool = false
   40|       |    private var uploadStartTime : CFAbsoluteTime?
   41|       |    
   42|       |    /// Retry counter in case the peripheral returns invalid CRC
   43|       |    private let MaxRetryCount = 3
   44|       |    private var retryCount: Int
   45|       |    
   46|       |    // MARK: - Initialization
   47|      0|    required init(_ initiator: DFUServiceInitiator) {
   48|      0|        self.initiator  = initiator
   49|      0|        self.firmware   = initiator.file!
   50|      0|        self.peripheral = SecureDFUPeripheral(initiator)
   51|      0|        
   52|      0|        self.retryCount = MaxRetryCount
   53|      0|    }
   54|       |    
   55|      0|    func start() {
   56|      0|        error = nil
   57|      0|        peripheral.delegate = self
   58|      0|        peripheral.start()
   59|      0|    }
   60|       |    
   61|       |    // MARK: - DFU Peripheral Delegate methods
   62|       |    
   63|      0|    func peripheralDidBecomeReady() {
   64|      0|        if firmware.initPacket == nil && peripheral.isInitPacketRequired() {
   65|      0|            error(.extendedInitPacketRequired, didOccurWithMessage: "The init packet is required by the target device")
   66|      0|            return
   67|      0|        }
   68|      0|        resetFirmwareRanges()
   69|      0|        
   70|      0|        DispatchQueue.main.async(execute: {
   71|      0|            self.delegate?.dfuStateDidChange(to: .starting)
   72|      0|        })
   73|      0|        peripheral.enableControlPoint()
   74|      0|    }
   75|       |    
   76|      0|    func peripheralDidEnableControlPoint() {
   77|      0|        // Check whether the target is in application or bootloader mode
   78|      0|        if peripheral.isInApplicationMode(initiator.forceDfu) {
   79|      0|            DispatchQueue.main.async(execute: {
   80|      0|                self.delegate?.dfuStateDidChange(to: .enablingDfuMode)
   81|      0|            })
   82|      0|            peripheral.jumpToBootloader()
   83|      0|        } else {
   84|      0|            // The device is ready to proceed with DFU
   85|      0|            
   86|      0|            // Start by reading command object info to get the maximum write size.
   87|      0|            peripheral.readCommandObjectInfo()
   88|      0|        }
   89|      0|    }
   90|       |    
   91|      0|    func peripheralDidSendCommandObjectInfo(maxLen: UInt32, offset: UInt32, crc: UInt32 ) {
   92|      0|        self.maxLen = maxLen
   93|      0|        self.offset = offset
   94|      0|        self.crc = crc
   95|      0|        
   96|      0|        if offset > 0 {
   97|      0|            let match = verifyCRC(for: firmware.initPacket!, andPacketOffset: offset, matches: crc)
   98|      0|            if match {
   99|      0|                // Resume sending Init Packet
  100|      0|                if offset < UInt32(firmware.initPacket!.count) {
  101|      0|                    logWith(.application, message: "Resuming sending Init packet...")
  102|      0|                    
  103|      0|                    // We need to send rest of the Init packet, but before that let's make sure the PRNs are disabled
  104|      0|                    peripheral.setPRNValue(0)
  105|      0|                } else {
  106|      0|                    logWith(.application, message: "Received CRC match Init packet")
  107|      0|                    peripheral.sendExecuteCommand()
  108|      0|                }
  109|      0|            } else {
  110|      0|                // Start new flash, we either are flashing a different firmware
  111|      0|                // or we are resuming from a BL/SD + App and need to start all over again.
  112|      0|                self.offset = 0
  113|      0|                self.crc = 0
  114|      0|                peripheral.createCommandObject(withLength: UInt32(firmware.initPacket!.count))
  115|      0|            }
  116|      0|        } else {
  117|      0|            peripheral.createCommandObject(withLength: UInt32(firmware.initPacket!.count))
  118|      0|        }
  119|      0|    }
  120|       |    
  121|      0|    func peripheralDidCreateCommandObject() {
  122|      0|        // Disable PRNs for first time while we write Init file
  123|      0|        peripheral.setPRNValue(0)
  124|      0|    }
  125|       |    
  126|      0|    func peripheralDidSetPRNValue() {
  127|      0|        if initPacketSent == false {
  128|      0|            sendInitPacket(fromOffset: offset!)
  129|      0|        } else {
  130|      0|            sendDataObject(currentRangeIdx, from: offset!)
  131|      0|        }
  132|      0|    }
  133|       |    
  134|      0|    func peripheralDidReceiveInitPacket() {
  135|      0|        logWith(.application, message: String(format: "Command object sent (CRC = %08X)", CRC32(data: firmware.initPacket!).crc))
  136|      0|        peripheral.sendCalculateChecksumCommand()
  137|      0|    }
  138|       |    
  139|      0|    func peripheralDidSendChecksum(offset: UInt32, crc: UInt32) {
  140|      0|        self.crc    = crc
  141|      0|        self.offset = offset
  142|      0|        
  143|      0|        if initPacketSent == false {
  144|      0|            if verifyCRC(for: firmware.initPacket!, andPacketOffset: UInt32(firmware.initPacket!.count), matches: crc) {
  145|      0|                crcOk()
  146|      0|                peripheral.sendExecuteCommand()
  147|      0|            } else {
  148|      0|                // The CRC does not match, let's start from the beginning
  149|      0|                retryOrReportCrcError({
  150|      0|                    peripheral.createCommandObject(withLength: UInt32(firmware.initPacket!.count))
  151|      0|                })
  152|      0|            }
  153|      0|        } else {
  154|      0|            // Verify CRC
  155|      0|            if verifyCRC(for: firmware.data, andPacketOffset: offset, matches: crc) {
  156|      0|                crcOk()
  157|      0|                firmwareSent = offset == UInt32(firmware.data.count)
  158|      0|                peripheral.sendExecuteCommand(andActivateIf: firmwareSent)
  159|      0|            } else {
  160|      0|                retryOrReportCrcError({
  161|      0|                    createDataObject(currentRangeIdx)
  162|      0|                })
  163|      0|            }
  164|      0|        }
  165|      0|    }
  166|       |    
  167|      0|    func peripheralDidExecuteObject() {
  168|      0|        if initPacketSent == false {
  169|      0|            logWith(.application, message: "Command object executed")
  170|      0|            initPacketSent = true
  171|      0|            peripheral.readDataObjectInfo()
  172|      0|        } else {
  173|      0|            logWith(.application, message: "Data object executed")
  174|      0|            
  175|      0|            if firmwareSent == false {
  176|      0|                currentRangeIdx += 1
  177|      0|                createDataObject(currentRangeIdx)
  178|      0|            } else {
  179|      0|                // The last data object was sent
  180|      0|                // Now the device will reset itself and onTransferCompleted() method will ba called (from the extension)
  181|      0|                let interval = CFAbsoluteTimeGetCurrent() - uploadStartTime! as CFTimeInterval
  182|      0|                logWith(.application, message: "Upload completed in \(interval.format(".2")) seconds")
  183|      0|                
  184|      0|                DispatchQueue.main.async(execute: {
  185|      0|                    self.delegate?.dfuStateDidChange(to: .disconnecting)
  186|      0|                })
  187|      0|            }
  188|      0|        }
  189|      0|    }
  190|       |    
  191|      0|    func peripheralDidSendDataObjectInfo(maxLen: UInt32, offset: UInt32, crc: UInt32 ) {
  192|      0|        self.maxLen = maxLen
  193|      0|        self.offset = offset
  194|      0|        self.crc    = crc
  195|      0|        
  196|      0|        // This is the initial state, if ranges aren't set, assume this is the first
  197|      0|        // or the only stage in the DFU process. The Init packet was already sent and executed.
  198|      0|        if firmwareRanges == nil {
  199|      0|            // Split firmware into smaller object of at most maxLen bytes, if firmware is bigger than maxLen
  200|      0|            firmwareRanges = calculateFirmwareRanges(Int(maxLen))
  201|      0|            currentRangeIdx = 0
  202|      0|        }
  203|      0|        
  204|      0|        DispatchQueue.main.async(execute: {
  205|      0|            self.delegate?.dfuStateDidChange(to: .uploading)
  206|      0|        })
  207|      0|        
  208|      0|        if offset > 0 {
  209|      0|            // Find the current range index
  210|      0|            currentRangeIdx = 0
  211|      0|            for range in firmwareRanges! {
  212|      0|                if range.contains(Int(offset)) {
  213|      0|                    break
  214|      0|                }
  215|      0|                currentRangeIdx += 1
  216|      0|            }
  217|      0|            
  218|      0|            let match = verifyCRC(for: firmware.data, andPacketOffset: offset, matches: crc)
  219|      0|            if match {
  220|      0|                logWith(.info, message: "\(offset) bytes of data sent before, CRC match")
  221|      0|                // Did we sent the whole firmware?
  222|      0|                if offset == UInt32(firmware.data.count) {
  223|      0|                    firmwareSent = true
  224|      0|                    peripheral.sendExecuteCommand(andActivateIf: firmwareSent)
  225|      0|                } else {
  226|      0|                    logWith(.info, message: "Resuming uploading firmware...")
  227|      0|                    // If the PRNs are enabled the value must be sent to the target
  228|      0|                    if initiator.packetReceiptNotificationParameter > 0 {
  229|      0|                        peripheral.setPRNValue(initiator.packetReceiptNotificationParameter)
  230|      0|                    } else {
  231|      0|                        // Otherwise we can just start by creating the first object. PRNs were set to 0 before, to send the init packet.
  232|      0|                        // Note: setting PRNs to 0 (disabling them) will not work!
  233|      0|                        
  234|      0|                        // Otherwise create current object
  235|      0|                        sendDataObject(currentRangeIdx, from: offset)
  236|      0|                    }
  237|      0|                }
  238|      0|            } else {
  239|      0|                // If offset % maxLen and CRC does not match it means that the whole object needs to be sent again
  240|      0|                if (offset % maxLen) == 0 {
  241|      0|                    // currentRangeIdx won't go below 0 because offset > 0 and offset % maxLen == 0
  242|      0|                    currentRangeIdx -= 1
  243|      0|                }
  244|      0|                retryOrReportCrcError({
  245|      0|                    createDataObject(currentRangeIdx)
  246|      0|                })
  247|      0|            }
  248|      0|        } else {
  249|      0|            // If the PRNs are enabled the value must be sent to the target
  250|      0|            if initiator.packetReceiptNotificationParameter > 0 {
  251|      0|                peripheral.setPRNValue(initiator.packetReceiptNotificationParameter)
  252|      0|            } else {
  253|      0|                // Otherwise we can just start by creating the first object. PRNs were set to 0 before, to send the init packet.
  254|      0|                // Note: setting PRNs to 0 (disabling them) will not work!
  255|      0|                
  256|      0|                // Create the first data object
  257|      0|                createDataObject(currentRangeIdx)
  258|      0|            }
  259|      0|        }
  260|      0|    }
  261|       |    
  262|      0|    func peripheralDidCreateDataObject() {
  263|      0|        logWith(.info, message: "Data object \(currentRangeIdx + 1)/\(firmwareRanges!.count) created")
  264|      0|        sendDataObject(currentRangeIdx)
  265|      0|    }
  266|       |    
  267|      0|    func peripheralDidReceiveObject() {
  268|      0|        peripheral.sendCalculateChecksumCommand()
  269|      0|    }
  270|       |    
  271|       |    // MARK: - Private methods
  272|       |    
  273|      0|    private func retryOrReportCrcError(_ operation:()->()) {
  274|      0|        retryCount -= 1
  275|      0|        if retryCount > 0 {
  276|      0|            logWith(.warning, message: "CRC does not match! Retrying...")
  277|      0|            operation()
  278|      0|        } else {
  279|      0|            logWith(.error, message: "CRC does not match!")
  280|      0|            error(.crcError, didOccurWithMessage: "Sending firmware failed")
  281|      0|        }
  282|      0|    }
  283|       |    
  284|      0|    private func crcOk() {
  285|      0|        retryCount = MaxRetryCount
  286|      0|    }
  287|       |    
  288|       |    /**
  289|       |     Resets firmware ranges and progress flags. This method should be called before sending each part of the firmware.
  290|       |     */
  291|      0|    private func resetFirmwareRanges() {
  292|      0|        currentRangeIdx = 0
  293|      0|        firmwareRanges  = nil
  294|      0|        initPacketSent  = false
  295|      0|        firmwareSent    = false
  296|      0|        uploadStartTime = CFAbsoluteTimeGetCurrent()
  297|      0|    }
  298|       |    
  299|       |    /**
  300|       |     Calculates the firmware ranges.
  301|       |     In Secure DFU the firmware is sent as separate 'objects', where each object is at most 'maxLen' long.
  302|       |     This method creates a list of ranges that will be used to send data to the peripheral, for example:
  303|       |     0 ..< 4096, 4096 ..< 5000 in case the firmware was 5000 bytes long.
  304|       |     */
  305|      0|    private func calculateFirmwareRanges(_ maxLen: Int) -> [Range<Int>] {
  306|      0|        var totalLength = firmware.data.count
  307|      0|        var ranges = [Range<Int>]()
  308|      0|        
  309|      0|        var partIdx = 0
  310|      0|        while (totalLength > 0) {
  311|      0|            var range : Range<Int>
  312|      0|            if totalLength > maxLen {
  313|      0|                totalLength -= maxLen
  314|      0|                range = (partIdx * maxLen) ..< maxLen + (partIdx * maxLen)
  315|      0|            } else {
  316|      0|                range = (partIdx * maxLen) ..< totalLength + (partIdx * maxLen)
  317|      0|                totalLength = 0
  318|      0|            }
  319|      0|            ranges.append(range)
  320|      0|            partIdx += 1
  321|      0|        }
  322|      0|        
  323|      0|        return ranges
  324|      0|    }
  325|       |    
  326|       |    /**
  327|       |     Verifies if the CRC-32 of the data for byte 0 to given offset matches the given CRC value.
  328|       |     - parameter data: firmware or Init packet data
  329|       |     - parameter offset: number of bytes that should be used for CRC calculation
  330|       |     - parameter crc: the CRC obtained from the DFU Target to be matched
  331|       |     - returns: true if CRCs are identical, false otherwise
  332|       |     */
  333|      0|    private func verifyCRC(for data: Data, andPacketOffset offset: UInt32, matches crc: UInt32) -> Bool {
  334|      0|        // Edge case where a different objcet might be flashed with a biger init file
  335|      0|        if offset > UInt32(data.count) {
  336|      0|            return false
  337|      0|        }
  338|      0|        // Get data form 0 up to the offset the peripheral has reproted
  339|      0|        let offsetData : Data = (data.subdata(in: 0 ..< Int(offset)))
  340|      0|        let calculatedCRC = CRC32(data: offsetData).crc
  341|      0|        
  342|      0|        // This returns true if the current data packet's CRC matches the current firmware's packet CRC
  343|      0|        return calculatedCRC == crc
  344|      0|    }
  345|       |    
  346|       |    /**
  347|       |     Sends the Init packet starting from the given offset. This method is synchronous, however it calls 
  348|       |     peripheralDidReceiveInitPacket() callback when done.
  349|       |     */
  350|      0|    private func sendInitPacket(fromOffset offset: UInt32) {
  351|      0|        let initPacketLength = UInt32(firmware.initPacket!.count)
  352|      0|        let data = firmware.initPacket!.subdata(in: Int(offset) ..< Int(initPacketLength - offset))
  353|      0|        
  354|      0|        // Send following bytes of init packet (offset may be 0)
  355|      0|        peripheral.sendInitPacket(data)
  356|      0|    }
  357|       |    
  358|       |    /**
  359|       |     Creates the new data object with length equal to the length of the range with given index.
  360|       |     The ranges were calculated using `calculateFirmwareRanges()`.
  361|       |     */
  362|      0|    private func createDataObject(_ rangeIdx: Int) {
  363|      0|        let currentRange = firmwareRanges![rangeIdx]
  364|      0|        peripheral.createDataObject(withLength: UInt32(currentRange.upperBound - currentRange.lowerBound))
  365|      0|    }
  366|       |    
  367|       |    /**
  368|       |     This method sends the bytes from the range with given index.
  369|       |     If the resumeOffset is set and equal to lower bound of the given range it will create the object instead.
  370|       |     When created, a onObjectCreated() method will be called which will call this method again, now with the offset
  371|       |     parameter equal nil.
  372|       |     - parameter rangeIdx: index of the range to be sent. The ranges were calculated using `calculateFirmwareRanges()`.
  373|       |     - parameter resumeOffset: if set, this method will send only the part of firmware from the range. The offset must
  374|       |     be inside the given range.
  375|       |     */
  376|      0|    private func sendDataObject(_ rangeIdx: Int, from resumeOffset: UInt32? = nil) {
  377|      0|        var aRange = firmwareRanges![rangeIdx]
  378|      0|        
  379|      0|        if let resumeOffset = resumeOffset {
  380|      0|            if UInt32(aRange.lowerBound) == resumeOffset {
  381|      0|                // We reached the end of previous object so a new one must be created
  382|      0|                createDataObject(rangeIdx)
  383|      0|                return
  384|      0|            }
  385|      0|            
  386|      0|            // This is a resuming object, recalculate location and size
  387|      0|            let newLength = aRange.lowerBound + (aRange.upperBound - aRange.lowerBound) - Int(offset!)
  388|      0|            aRange = Int(resumeOffset) ..< newLength + Int(resumeOffset)
  389|      0|        }
  390|      0|        
  391|      0|        peripheral.sendNextObject(from: aRange, of: firmware, andReportProgressTo: progressDelegate)
  392|      0|    }
  393|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/DFU/SecureDFUServiceInitiator.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |@objc public class SecureDFUServiceInitiator : DFUServiceInitiator {
   26|       |    
   27|      0|    public override func start() -> DFUServiceController? {
   28|      0|        // The firmware file must be specified before calling `start()`
   29|      0|        if file == nil {
   30|      0|            delegate?.dfuError(.fileNotSpecified, didOccurWithMessage: "Firmware not specified")
   31|      0|            return nil
   32|      0|        }
   33|      0|        
   34|      0|        let executor = SecureDFUExecutor(self)
   35|      0|        let controller = DFUServiceController()
   36|      0|        controller.executor = executor
   37|      0|        executor.start()
   38|      0|        return controller
   39|      0|    }
   40|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/Peripheral/SecureDFUPeripheral.swift:
    1|       |/*
    2|       | * Copyright (c) 2016, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE, DATA, OR PROFITS OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |internal class SecureDFUPeripheral : BaseCommonDFUPeripheral<SecureDFUExecutor, SecureDFUService> {
   26|       |    
   27|       |    // MARK: - Peripheral API
   28|       |    
   29|      0|    override var requiredServices: [CBUUID]? {
   30|      0|        return [SecureDFUService.UUID]
   31|      0|    }
   32|       |    
   33|      0|    override func isInitPacketRequired() -> Bool {
   34|      0|        // Init packet is obligatory in Secure DFU
   35|      0|        return true
   36|      0|    }
   37|       |    
   38|       |    // MARK: - Implementation
   39|       |    
   40|       |    /**
   41|       |     Enables notifications on DFU Control Point characteristic.
   42|       |     */
   43|      0|    func enableControlPoint() {
   44|      0|        dfuService!.enableControlPoint(
   45|      0|            onSuccess: { self.delegate?.peripheralDidEnableControlPoint() },
   46|      0|            onError: defaultErrorCallback
   47|      0|        )
   48|      0|    }
   49|       |    
   50|      0|    override func isInApplicationMode(_ forceDfu: Bool) -> Bool {
   51|      0|        let applicationMode = dfuService!.isInApplicationMode() ?? !forceDfu
   52|      0|        
   53|      0|        if applicationMode {
   54|      0|            logger.w("Application with buttonless update found")
   55|      0|        }
   56|      0|        
   57|      0|        return applicationMode
   58|      0|    }
   59|       |    
   60|       |    /**
   61|       |     Switches target device to the DFU Bootloader mode using either the 
   62|       |     experimental or final Buttonless DFU feature. The experimental buttonless DFU from SDK 12 must be
   63|       |     enabled explicitly in DFUServiceInitiator.
   64|       |     */
   65|      0|    func jumpToBootloader() {
   66|      0|        jumpingToBootloader = true
   67|      0|        newAddressExpected = dfuService!.newAddressExpected
   68|      0|        dfuService!.jumpToBootloaderMode(
   69|      0|            // onSuccess the device gets disconnected and centralManager(_:didDisconnectPeripheral:error) will be called
   70|      0|            onError: { (error, message) in
   71|      0|                self.jumpingToBootloader = false
   72|      0|                self.delegate?.error(error, didOccurWithMessage: message)
   73|      0|            }
   74|      0|        )
   75|      0|    }
   76|       |    
   77|       |    /**
   78|       |     Reads Data Object Info in order to obtain current status and the maximum object size.
   79|       |     */
   80|      0|    func readDataObjectInfo() {
   81|      0|        dfuService!.readDataObjectInfo(
   82|      0|            onReponse: { (response) in
   83|      0|                self.delegate?.peripheralDidSendDataObjectInfo(maxLen: response!.maxSize!, offset: response!.offset!, crc: response!.crc!)
   84|      0|            },
   85|      0|            onError: defaultErrorCallback
   86|      0|        )
   87|      0|    }
   88|       |    
   89|       |    /**
   90|       |     Reads Command Object Info in order to obtain current status and the maximum object size.
   91|       |     */
   92|      0|    func readCommandObjectInfo() {
   93|      0|        dfuService!.readCommandObjectInfo(
   94|      0|            onReponse: { (response) in
   95|      0|                self.delegate?.peripheralDidSendCommandObjectInfo(maxLen: response!.maxSize!, offset: response!.offset!, crc: response!.crc!)
   96|      0|            },
   97|      0|            onError: defaultErrorCallback
   98|      0|        )
   99|      0|    }
  100|       |    
  101|       |    /**
  102|       |     Creates data object with given length.
  103|       |     
  104|       |     - parameter aLength: exact size of the object
  105|       |     */
  106|      0|    func createDataObject(withLength aLength: UInt32) {
  107|      0|        dfuService!.createDataObject(withLength: aLength,
  108|      0|             onSuccess: { self.delegate?.peripheralDidCreateDataObject() },
  109|      0|             onError: defaultErrorCallback
  110|      0|        )
  111|      0|    }
  112|       |    
  113|       |    /**
  114|       |     Creates command object with given length.
  115|       |     
  116|       |     - parameter aLength: exact size of the object
  117|       |     */
  118|      0|    func createCommandObject(withLength aLength: UInt32) {
  119|      0|        dfuService!.createCommandObject(withLength: aLength,
  120|      0|            onSuccess: { self.delegate?.peripheralDidCreateCommandObject() },
  121|      0|            onError: defaultErrorCallback
  122|      0|        )
  123|      0|    }
  124|       |    
  125|       |    /**
  126|       |     Sends a given range of data from the firmware.
  127|       |     
  128|       |     - parameter aRange:            given range of the firmware will be sent
  129|       |     - parameter aFirmware:         the firmware from with part is to be sent
  130|       |     - parameter aProgressDelegate: an optional progress delegate
  131|       |     */
  132|      0|    func sendNextObject(from aRange: Range<Int>, of aFirmware: DFUFirmware, andReportProgressTo aProgressDelegate: DFUProgressDelegate?) {
  133|      0|        dfuService!.sendNextObject(from: aRange, of: aFirmware, andReportProgressTo: aProgressDelegate,
  134|      0|            onSuccess: { self.delegate?.peripheralDidReceiveObject() },
  135|      0|            onError: defaultErrorCallback
  136|      0|        )
  137|      0|    }
  138|       |    
  139|       |    /**
  140|       |     Sets the Packet Receipt Notification value. 0 disables the PRN procedure. On iOS the value may not be greater than ~20 or equal to 0
  141|       |     if more than ~20 are to be sent or a buffer overflow error may occur.
  142|       |     This library sends the Init packet without PRNs, but that's only because of the Init packet is small enough.
  143|       |     
  144|       |     - parameter aValue:  Packet Receipt Notification value (0 to disable PRNs)
  145|       |     */
  146|      0|    func setPRNValue(_ aValue: UInt16 = 0) {
  147|      0|        dfuService!.setPacketReceiptNotificationValue(aValue,
  148|      0|            onSuccess: { self.delegate?.peripheralDidSetPRNValue() },
  149|      0|            onError: defaultErrorCallback
  150|      0|        )
  151|      0|    }
  152|       |    
  153|       |    /**
  154|       |     Sends Init packet. This method is synchronuous and calls delegate's peripheralDidReceiveInitPacket() method ater the given data are sent.
  155|       |     
  156|       |     - parameter packetData: data to be sent as Init Packet
  157|       |     */
  158|      0|    func sendInitPacket(_ packetData: Data){
  159|      0|        // This method is synchronuous.
  160|      0|        // It sends all bytes of init packet in up-to-20-byte packets.
  161|      0|        // The init packet may not be too long as sending > ~15 packets without PRNs may lead to buffer overflow.
  162|      0|        dfuService!.sendInitPacket(withdata: packetData)
  163|      0|        self.delegate?.peripheralDidReceiveInitPacket()
  164|      0|    }
  165|       |    
  166|       |    /**
  167|       |     Sends Calculate Checksum request.
  168|       |     */
  169|      0|    func sendCalculateChecksumCommand() {
  170|      0|        dfuService!.calculateChecksumCommand(
  171|      0|            onSuccess: { (response) in self.delegate?.peripheralDidSendChecksum(offset: response!.offset!, crc: response!.crc!) },
  172|      0|            onError: defaultErrorCallback
  173|      0|        )
  174|      0|    }
  175|       |    
  176|       |    /**
  177|       |     Sends Execute command.
  178|       |     
  179|       |     - parameter activating: if the parameter is set to true the service will assume that the whole firmware was sent
  180|       |     and the device will disconnect on its own on Execute command. Delegate's onTransferComplete event will be called when
  181|       |     the disconnect event is receviced.
  182|       |     */
  183|      0|    func sendExecuteCommand(andActivateIf activating: Bool = false) {
  184|      0|        self.activating = activating
  185|      0|        dfuService!.executeCommand(
  186|      0|            onSuccess: { self.delegate?.peripheralDidExecuteObject() },
  187|      0|            onError: defaultErrorCallback
  188|      0|        )
  189|      0|    }
  190|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Implementation/SecureDFU/Services/SecureDFUService.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import CoreBluetooth
   24|       |
   25|       |@objc internal class SecureDFUService : NSObject, CBPeripheralDelegate, DFUService {
   26|       |    static internal let UUID = CBUUID(string: "FE59")
   27|       |    
   28|      0|    static func matches(_ service: CBService) -> Bool {
   29|      0|        return service.uuid.isEqual(UUID)
   30|      0|    }
   31|       |    
   32|       |    /// The target DFU Peripheral
   33|       |    internal var targetPeripheral: DFUPeripheralAPI?
   34|       |    /// The logger helper.
   35|       |    private var logger: LoggerHelper
   36|       |    /// The service object from CoreBluetooth used to initialize the SecureDFUService instance.
   37|       |    private let service                       : CBService
   38|       |    private var dfuPacketCharacteristic       : SecureDFUPacket?
   39|       |    private var dfuControlPointCharacteristic : SecureDFUControlPoint?
   40|       |
   41|       |    private var paused  = false
   42|       |    private var aborted = false
   43|       |    
   44|       |    /// A temporary callback used to report end of an operation.
   45|       |    private var success          : Callback?
   46|       |    /// A temporary callback used to report an operation error.
   47|       |    private var report           : ErrorCallback?
   48|       |    /// A temporaty callback used to report progress status.
   49|       |    private var progressDelegate : DFUProgressDelegate?
   50|       |    
   51|       |    // -- Properties stored when upload started in order to resume it --
   52|       |    private var firmware: DFUFirmware?
   53|       |    private var packetReceiptNotificationNumber: UInt16 = 0
   54|       |    private var range: Range<Int>?
   55|       |    // -- End --
   56|       |    
   57|       |    // MARK: - Initialization
   58|       |    
   59|      0|    required init(_ service: CBService, _ logger: LoggerHelper) {
   60|      0|        self.service = service
   61|      0|        self.logger = logger
   62|      0|        super.init()
   63|      0|        self.logger.v("Secure DFU Service found")
   64|      0|    }
   65|       |    
   66|      0|    func destroy() {
   67|      0|        dfuPacketCharacteristic = nil
   68|      0|        dfuControlPointCharacteristic = nil
   69|      0|        targetPeripheral = nil
   70|      0|    }
   71|       |    
   72|       |    // MARK: - Controler API methods
   73|       |    
   74|      0|    func pause() -> Bool {
   75|      0|        if !aborted {
   76|      0|            paused = true
   77|      0|        }
   78|      0|        return paused
   79|      0|    }
   80|       |    
   81|      0|    func resume() -> Bool {
   82|      0|        if !aborted && paused && firmware != nil {
   83|      0|            paused = false
   84|      0|            dfuPacketCharacteristic!.sendNext(packetReceiptNotificationNumber, bytesFrom: range!, of: firmware!,
   85|      0|                                              andReportProgressTo: progressDelegate, andCompletionTo: success!)
   86|      0|            return paused
   87|      0|        }
   88|      0|        paused = false
   89|      0|        return paused
   90|      0|    }
   91|       |    
   92|      0|    func abort() -> Bool {
   93|      0|        aborted = true
   94|      0|        // When upload has been started and paused, we have to send the Reset command here as the device will
   95|      0|        // not get a Packet Receipt Notification. If it hasn't been paused, the Reset command will be sent after receiving it, on line 292.
   96|      0|        if paused && firmware != nil {
   97|      0|            let _report = report!
   98|      0|            firmware = nil
   99|      0|            range    = nil
  100|      0|            success  = nil
  101|      0|            report   = nil
  102|      0|            progressDelegate = nil
  103|      0|            // Upload has been aborted. Reset the target device. It will disconnect automatically
  104|      0|            sendReset(onError: _report)
  105|      0|        }
  106|      0|        paused = false
  107|      0|        return aborted
  108|      0|    }
  109|       |    
  110|       |    // MARK: - Service API methods
  111|       |    
  112|       |    /**
  113|       |     Discovers characteristics in the DFU Service. Result it reported using callbacks.
  114|       |     
  115|       |     - parameter success: method called when required DFU characteristics were discovered
  116|       |     - parameter report:  method called when an error occurred
  117|       |    */
  118|      0|    func discoverCharacteristics(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  119|      0|        // Save callbacks
  120|      0|        self.success = success
  121|      0|        self.report  = report
  122|      0|        
  123|      0|        // Get the peripheral object
  124|      0|        let peripheral = service.peripheral
  125|      0|        
  126|      0|        // Set the peripheral delegate to self
  127|      0|        peripheral.delegate = self
  128|      0|        
  129|      0|        // Discover DFU characteristics
  130|      0|        logger.v("Discovering characteristics in DFU Service...")
  131|      0|        logger.d("peripheral.discoverCharacteristics(nil, for: \(SecureDFUService.UUID.uuidString))")
  132|      0|        peripheral.discoverCharacteristics(nil, for: service)
  133|      0|    }
  134|       |    
  135|       |    /**
  136|       |     Enables notifications for DFU Control Point characteristic. Result it reported using callbacks.
  137|       |     
  138|       |     - parameter success: method called when notifications were enabled without a problem
  139|       |     - parameter report:  method called when an error occurred
  140|       |     */
  141|      0|    func enableControlPoint(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  142|      0|        if !aborted {
  143|      0|            // Support for Buttonless DFU Service
  144|      0|            if buttonlessDfuCharacteristic != nil {
  145|      0|                buttonlessDfuCharacteristic!.enable(onSuccess: success, onError: report)
  146|      0|                return
  147|      0|            }
  148|      0|            // End
  149|      0|            dfuControlPointCharacteristic!.enableNotifications(onSuccess: success, onError: report)
  150|      0|        } else {
  151|      0|            sendReset(onError: report)
  152|      0|        }
  153|      0|    }
  154|       |    
  155|       |    /**
  156|       |     Reads Command Object Info. Result it reported using callbacks.
  157|       |     
  158|       |     - parameter response: method called when the response was received
  159|       |     - parameter report:   method called when an error occurred
  160|       |     */
  161|      0|    func readCommandObjectInfo(onReponse response: @escaping SecureDFUResponseCallback, onError report: @escaping ErrorCallback) {
  162|      0|        if !aborted {
  163|      0|            dfuControlPointCharacteristic!.send(SecureDFURequest.readCommandObjectInfo, onResponse: response, onError: report)
  164|      0|        } else {
  165|      0|            sendReset(onError: report)
  166|      0|        }
  167|      0|    }
  168|       |    
  169|       |    /**
  170|       |     Reads object info Data. Result it reported using callbacks.
  171|       |     
  172|       |     - parameter response: method called when the response was received
  173|       |     - parameter report:   method called when an error occurred
  174|       |     */
  175|      0|    func readDataObjectInfo(onReponse response: @escaping SecureDFUResponseCallback, onError report: @escaping ErrorCallback) {
  176|      0|        if !aborted {
  177|      0|            dfuControlPointCharacteristic!.send(SecureDFURequest.readDataObjectInfo, onResponse: response, onError: report)
  178|      0|        } else {
  179|      0|            sendReset(onError: report)
  180|      0|        }
  181|      0|    }
  182|       |    
  183|       |    /**
  184|       |     Creates object command. Result it reported using callbacks.
  185|       |     
  186|       |     - parameter aLength: exact size of the object
  187|       |     - parameter success: method called when the object has been created
  188|       |     - parameter report:  method called when an error occurred
  189|       |     
  190|       |     */
  191|      0|    func createCommandObject(withLength aLength: UInt32, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  192|      0|        if !aborted {
  193|      0|            dfuControlPointCharacteristic!.send(SecureDFURequest.createCommandObject(withSize: aLength), onSuccess: success, onError:report)
  194|      0|        } else {
  195|      0|            sendReset(onError: report)
  196|      0|        }
  197|      0|    }
  198|       |    
  199|       |    /**
  200|       |     Creates object data. Result it reported using callbacks.
  201|       |     
  202|       |     - parameter aLength: exact size of the object
  203|       |     - parameter success: method called when the object has been created
  204|       |     - parameter report:  method called when an error occurred
  205|       |     */
  206|      0|    func createDataObject(withLength aLength: UInt32, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  207|      0|        if !aborted {
  208|      0|            dfuControlPointCharacteristic!.send(SecureDFURequest.createDataObject(withSize: aLength), onSuccess: success, onError:report)
  209|      0|        } else {
  210|      0|            sendReset(onError: report)
  211|      0|        }
  212|      0|    }
  213|       |    
  214|       |    /**
  215|       |     Sends a Packet Receipt Notification request with given value. Result it reported using callbacks.
  216|       |     
  217|       |     - parameter aValue:  Packet Receipt Notification value (0 to disable PRNs)
  218|       |     - parameter success: method called when the PRN value has been set
  219|       |     - parameter report:  method called when an error occurred
  220|       |     */
  221|      0|    func setPacketReceiptNotificationValue(_ aValue: UInt16 = 0, onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  222|      0|        self.packetReceiptNotificationNumber = aValue
  223|      0|        dfuControlPointCharacteristic?.send(SecureDFURequest.setPacketReceiptNotification(value: aValue),
  224|      0|            onSuccess: {
  225|      0|                if aValue > 0 {
  226|      0|                    self.logger.a("Packet Receipt Notif enabled (Op Code = 2, Value = \(aValue))")
  227|      0|                } else {
  228|      0|                    self.logger.a("Packet Receipt Notif disabled (Op Code = 2, Value = 0)")
  229|      0|                }
  230|      0|                success()
  231|      0|            },
  232|      0|            onError: report
  233|      0|        )
  234|      0|    }
  235|       |    
  236|       |    /**
  237|       |     Sends Calculate checksum request. Result it reported using callbacks.
  238|       |     
  239|       |     - parameter response: method called when the response was received
  240|       |     - parameter report:   method called when an error occurred
  241|       |     */
  242|      0|    func calculateChecksumCommand(onSuccess response: @escaping SecureDFUResponseCallback, onError report: @escaping ErrorCallback) {
  243|      0|        if !aborted {
  244|      0|            dfuControlPointCharacteristic!.send(SecureDFURequest.calculateChecksumCommand, onResponse: response, onError: report)
  245|      0|        } else {
  246|      0|            sendReset(onError: report)
  247|      0|        }
  248|      0|    }
  249|       |    
  250|       |    /**
  251|       |     Sends Execute command request. Result it reported using callbacks.
  252|       |     
  253|       |     - parameter success: method called when the object was executed without an error
  254|       |     - parameter report:  method called when an error occurred
  255|       |     */
  256|      0|    func executeCommand(onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  257|      0|        if !aborted {
  258|      0|            dfuControlPointCharacteristic?.send(SecureDFURequest.executeCommand, onSuccess: success, onError: report)
  259|      0|        } else {
  260|      0|            sendReset(onError: report)
  261|      0|        }
  262|      0|    }
  263|       |    
  264|       |    /**
  265|       |     Disconnects from the device.
  266|       |     
  267|       |     - parameter report: a callback called when writing characteristic failed
  268|       |     */
  269|      0|    private func sendReset(onError report: @escaping ErrorCallback) {
  270|      0|        aborted = true
  271|      0|        // There is no command to reset a Secure DFU device. We can just disconnect
  272|      0|        targetPeripheral!.disconnect()
  273|      0|    }
  274|       |    
  275|       |    //MARK: - Packet commands
  276|       |    
  277|       |    /**
  278|       |     Sends the init packet. This method is synchronous and will terminate when all data were written.
  279|       |     The init data file should not have more than ~16 packets of data as the buffer overflow error may occur.
  280|       |     
  281|       |     - parameter packetData: data to be sent as Init Packet
  282|       |     */
  283|      0|    func sendInitPacket(withdata packetData: Data){
  284|      0|        dfuPacketCharacteristic!.sendInitPacket(packetData)
  285|      0|    }
  286|       |
  287|       |    /**
  288|       |     Sends the next object of firmware. Result it reported using callbacks.
  289|       |     
  290|       |     - parameter aRange:           given range of the firmware will be sent
  291|       |     - parameter aFirmware:        the firmware from with part is to be sent
  292|       |     - parameter progressDelegate: an optional progress delegate
  293|       |     - parameter success:          method called when the object was sent
  294|       |     - parameter report:           method called when an error occurred
  295|       |     */
  296|       |    func sendNextObject(from aRange: Range<Int>, of aFirmware: DFUFirmware, andReportProgressTo progressDelegate: DFUProgressDelegate?,
  297|      0|                        onSuccess success: @escaping Callback, onError report: @escaping ErrorCallback) {
  298|      0|        guard !aborted else {
  299|      0|            sendReset(onError: report)
  300|      0|            return
  301|      0|        }
  302|      0|        
  303|      0|        // Those will be stored here in case of pause/resume
  304|      0|        self.firmware         = aFirmware
  305|      0|        self.range            = aRange
  306|      0|        self.progressDelegate = progressDelegate
  307|      0|        
  308|      0|        self.report = {
  309|      0|            error, message in
  310|      0|            self.firmware = nil
  311|      0|            self.range    = nil
  312|      0|            self.success  = nil
  313|      0|            self.report   = nil
  314|      0|            self.progressDelegate = nil
  315|      0|            report(error, message)
  316|      0|        }
  317|      0|        self.success = {
  318|      0|            self.firmware = nil
  319|      0|            self.range    = nil
  320|      0|            self.success  = nil
  321|      0|            self.report   = nil
  322|      0|            self.progressDelegate = nil
  323|      0|            self.dfuControlPointCharacteristic!.peripheralDidReceiveObject()
  324|      0|            success()
  325|      0|        }
  326|      0|
  327|      0|        dfuControlPointCharacteristic!.waitUntilUploadComplete(onSuccess: self.success!, onPacketReceiptNofitication: { bytesReceived in
  328|      0|                if !self.paused && !self.aborted {
  329|      0|                    let bytesSent = self.dfuPacketCharacteristic!.bytesSent + UInt32(aRange.lowerBound)
  330|      0|                    if bytesSent == bytesReceived {
  331|      0|                        self.dfuPacketCharacteristic!.sendNext(self.packetReceiptNotificationNumber, bytesFrom: aRange, of: aFirmware,
  332|      0|                                                               andReportProgressTo: progressDelegate, andCompletionTo: self.success!)
  333|      0|                    } else {
  334|      0|                        // Target device deported invalid number of bytes received
  335|      0|                        report(.bytesLost, "\(bytesSent) bytes were sent while \(bytesReceived) bytes were reported as received")
  336|      0|                    }
  337|      0|                } else if self.aborted {
  338|      0|                    self.firmware = nil
  339|      0|                    self.range    = nil
  340|      0|                    self.success  = nil
  341|      0|                    self.report   = nil
  342|      0|                    self.progressDelegate = nil
  343|      0|                    self.sendReset(onError: report)
  344|      0|                }
  345|      0|            }, onError: self.report!)
  346|      0|        
  347|      0|        // A new object is started, reset counters before sending the next object
  348|      0|        // It must be done even if the upload was paused, otherwise it would be resumed from a wrong place
  349|      0|        dfuPacketCharacteristic!.resetCounters()
  350|      0|        
  351|      0|        if !paused && !aborted {
  352|      0|            // ...and start sending firmware if
  353|      0|            dfuPacketCharacteristic!.sendNext(packetReceiptNotificationNumber, bytesFrom: aRange, of: aFirmware,
  354|      0|                                                   andReportProgressTo: progressDelegate, andCompletionTo: self.success!)
  355|      0|        } else if aborted {
  356|      0|            self.firmware = nil
  357|      0|            self.range    = nil
  358|      0|            self.success  = nil
  359|      0|            self.report   = nil
  360|      0|            self.progressDelegate = nil
  361|      0|            sendReset(onError: report)
  362|      0|        }
  363|      0|    }
  364|       |    
  365|       |    // MARK: - Peripheral Delegate callbacks
  366|       |
  367|      0|    func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
  368|      0|        // Create local references to callback to release the global ones
  369|      0|        let _success = self.success
  370|      0|        let _report  = self.report
  371|      0|        self.success = nil
  372|      0|        self.report  = nil
  373|      0|        
  374|      0|        if error != nil {
  375|      0|            logger.e("Characteristics discovery failed")
  376|      0|            logger.e(error!)
  377|      0|            _report?(.serviceDiscoveryFailed, "Characteristics discovery failed")
  378|      0|        } else {
  379|      0|            logger.i("DFU characteristics discovered")
  380|      0|            
  381|      0|            // Find DFU characteristics
  382|      0|            for characteristic in service.characteristics! {
  383|      0|                if SecureDFUPacket.matches(characteristic) {
  384|      0|                    dfuPacketCharacteristic = SecureDFUPacket(characteristic, logger)
  385|      0|                } else if SecureDFUControlPoint.matches(characteristic) {
  386|      0|                    dfuControlPointCharacteristic = SecureDFUControlPoint(characteristic, logger)
  387|      0|                }
  388|      0|                // Support for Buttonless DFU Service from SDK 12.x (as experimental).
  389|      0|                // SDK 13 added a new characteristic in Secure DFU Service with buttonless feature without bond sharing (bootloader uses different device address).
  390|      0|                // SDK 14 will add a new characteristic with buttonless service for bonded devices with bond information sharing between app and the bootloader.
  391|      0|                else if ButtonlessDFU.matches(characteristic) {
  392|      0|                    buttonlessDfuCharacteristic = ButtonlessDFU(characteristic, logger)
  393|      0|                    _success?()
  394|      0|                    return
  395|      0|                }
  396|      0|                // End
  397|      0|            }
  398|      0|            
  399|      0|            // Some validation
  400|      0|            if dfuControlPointCharacteristic == nil {
  401|      0|                logger.e("DFU Control Point characteristics not found")
  402|      0|                // DFU Control Point characteristic is required
  403|      0|                _report?(.deviceNotSupported, "DFU Control Point characteristic not found")
  404|      0|                return
  405|      0|            }
  406|      0|            if dfuPacketCharacteristic == nil {
  407|      0|                logger.e("DFU Packet characteristics not found")
  408|      0|                // DFU Packet characteristic is required
  409|      0|                _report?(.deviceNotSupported, "DFU Packet characteristic not found")
  410|      0|                return
  411|      0|            }
  412|      0|            if !dfuControlPointCharacteristic!.valid {
  413|      0|                logger.e("DFU Control Point characteristics must have Write and Notify properties")
  414|      0|                // DFU Control Point characteristic must have Write and Notify properties
  415|      0|                _report?(.deviceNotSupported, "DFU Control Point characteristic does not have the Write and Notify properties")
  416|      0|                return
  417|      0|            }
  418|      0|            
  419|      0|            _success?()
  420|      0|        }
  421|      0|    }
  422|       |    
  423|       |    // MARK: - Support for Buttonless DFU Service
  424|       |    
  425|       |    /// The buttonless jump feature was experimental in SDK 12. It did not support passing bond information to the DFU bootloader,
  426|       |    /// was not safe (possible DOS attack) and had bugs. This is the service UUID used by this service.
  427|       |    static internal let ExperimentalButtonlessDfuUUID = CBUUID(string: "8E400001-F315-4F60-9FB8-838830DAEA50")
  428|       |    
  429|      0|    static func matches(experimental service: CBService) -> Bool {
  430|      0|        return service.uuid.isEqual(ExperimentalButtonlessDfuUUID)
  431|      0|    }
  432|       |    
  433|       |    private var buttonlessDfuCharacteristic: ButtonlessDFU?
  434|       |    
  435|       |    /**
  436|       |     This method tries to estimate whether the DFU target device is in Application mode which supports
  437|       |     the buttonless jump to the DFU Bootloader.
  438|       |     
  439|       |     - returns: true, if it is for sure in the Application more, false, if definitely is not, nil if uknown
  440|       |     */
  441|      0|    func isInApplicationMode() -> Bool? {
  442|      0|        // If the buttonless DFU characteristic is not nil it means that the device is in app mode.
  443|      0|        return buttonlessDfuCharacteristic != nil
  444|      0|    }
  445|       |    
  446|       |    /**
  447|       |     Returns whether the bootloader is expected to advertise with the same address on one incremented by 1.
  448|       |     In the latter case the library needs to scan for a new advertising device and select it by filtering the adv packet,
  449|       |     as device address is not available through iOS API.
  450|       |     */
  451|      0|    var newAddressExpected: Bool {
  452|      0|        // The bootloader will advertise with address +1 if the experimental Buttonless DFU Service from SDK 12.x
  453|      0|        // or Buttonless DFU service from SDK 13 were found.
  454|      0|        // The Buttonless DFU Service from SDK 14 supports bond sharing between app and the bootlaoder, thus the bootloader
  455|      0|        // will use the same address after jump and the connection will be encrypted.
  456|      0|        return buttonlessDfuCharacteristic?.newAddressExpected ?? false
  457|      0|    }
  458|       |    
  459|       |    /**
  460|       |     Triggers a switch to DFU Bootloader mode on the remote target by sending DFU Start command.
  461|       |     
  462|       |     - parameter report: method called when an error occurred
  463|       |     */
  464|      0|    func jumpToBootloaderMode(onError report: @escaping ErrorCallback) {
  465|      0|        if !aborted {
  466|      0|            buttonlessDfuCharacteristic!.send(ButtonlessDFURequest.enterBootloader, onSuccess: nil, onError: report)
  467|      0|        } else {
  468|      0|            sendReset(onError: report)
  469|      0|        }
  470|      0|    }
  471|       |    
  472|       |    // End
  473|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/DFUPackage/Manifest/Manifest.swift:
    1|       |//
    2|       |//  Manifest.swift
    3|       |//  Pods
    4|       |//
    5|       |//  Created by Mostafa Berg on 28/07/16.
    6|       |//
    7|       |//
    8|       |
    9|       |class Manifest: NSObject {
   10|       |    var application: ManifestFirmwareInfo?
   11|       |    var softdevice:  ManifestFirmwareInfo?
   12|       |    var bootloader:  ManifestFirmwareInfo?
   13|       |    var softdeviceBootloader: SoftdeviceBootloaderInfo?
   14|       |    
   15|      0|    var valid: Bool {
   16|      0|        // The manifest.json file may specify only:
   17|      0|        // 1. a softdevice, a bootloader, or both combined (with, or without an app)
   18|      0|        // 2. only the app
   19|      0|        let hasApplication = application != nil
   20|      0|        var count = 0
   21|      0|        
   22|      0|        count += softdevice != nil ? 1 : 0
   23|      0|        count += bootloader != nil ? 1 : 0
   24|      0|        count += softdeviceBootloader != nil ? 1 : 0
   25|      0|        
   26|      0|        return count == 1 || (count == 0 && hasApplication)
   27|      0|    }
   28|       |    
   29|      0|    init(withJsonString aString : String) {
   30|      0|        do {
   31|      0|            let data = aString.data(using: String.Encoding.utf8)
   32|      0|            let aDictionary = try JSONSerialization.jsonObject(with: data!, options: .allowFragments) as! Dictionary<String, AnyObject>
   33|      0|            
   34|      0|            let mainObject = aDictionary["manifest"] as! Dictionary<String, AnyObject>
   35|      0|            if mainObject.keys.contains("application") {
   36|      0|                let dictionary = mainObject["application"] as? Dictionary<String, AnyObject>
   37|      0|                self.application = ManifestFirmwareInfo(withDictionary: dictionary!)
   38|      0|            }
   39|      0|            if mainObject.keys.contains("softdevice_bootloader") {
   40|      0|                let dictionary = mainObject["softdevice_bootloader"] as? Dictionary<String, AnyObject>
   41|      0|                self.softdeviceBootloader = SoftdeviceBootloaderInfo(withDictionary: dictionary!)
   42|      0|            }
   43|      0|            if mainObject.keys.contains("softdevice"){
   44|      0|                let dictionary = mainObject["softdevice"] as? Dictionary<String, AnyObject>
   45|      0|                self.softdevice = ManifestFirmwareInfo(withDictionary: dictionary!)
   46|      0|            }
   47|      0|            if mainObject.keys.contains("bootloader"){
   48|      0|                let dictionary = mainObject["bootloader"] as? Dictionary<String, AnyObject>
   49|      0|                self.bootloader = ManifestFirmwareInfo(withDictionary: dictionary!)
   50|      0|            }
   51|      0|
   52|      0|        } catch {
   53|      0|            print("an error occured while parsing manifest.json \(error)")
   54|      0|        }        
   55|      0|    }
   56|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/DFUPackage/Manifest/ManifestFirmwareInfo.swift:
    1|       |//
    2|       |//  ManifestFirmwareInfo.swift
    3|       |//  Pods
    4|       |//
    5|       |//  Created by Mostafa Berg on 28/07/16.
    6|       |//
    7|       |//
    8|       |
    9|       |class ManifestFirmwareInfo: NSObject {
   10|       |    var binFile: String? = nil
   11|       |    var datFile: String? = nil
   12|       |    
   13|      0|    var valid: Bool {
   14|      0|        return binFile != nil // && datFile != nil The init packet was not required before SDK 7.1
   15|      0|    }
   16|       |    
   17|      0|    init(withDictionary aDictionary : Dictionary<String, AnyObject>) {
   18|      0|        if aDictionary.keys.contains("bin_file") {
   19|      0|            binFile = String(describing: aDictionary["bin_file"]!)
   20|      0|        }
   21|      0|        if aDictionary.keys.contains("dat_file") {
   22|      0|            datFile = String(describing: aDictionary["dat_file"]!)
   23|      0|        }
   24|      0|    }
   25|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/DFUPackage/Manifest/SoftdeviceBootloaderInfo.swift:
    1|       |//
    2|       |//  Manifest.swift
    3|       |//  Pods
    4|       |//
    5|       |//  Created by Mostafa Berg on 28/07/16.
    6|       |//
    7|       |//
    8|       |
    9|       |class SoftdeviceBootloaderInfo: ManifestFirmwareInfo {
   10|       |    var blSize: UInt32 = 0
   11|       |    var sdSize: UInt32 = 0
   12|       |    
   13|      0|    override init(withDictionary aDictionary : Dictionary<String, AnyObject>) {
   14|      0|        super.init(withDictionary: aDictionary)
   15|      0|        if aDictionary.keys.contains("bl_size") {
   16|      0|            blSize = (aDictionary["bl_size"]!).uint32Value
   17|      0|        }
   18|      0|        if aDictionary.keys.contains("sd_size") {
   19|      0|            sdSize = (aDictionary["sd_size"]!).uint32Value
   20|      0|        }
   21|      0|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Data.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |// Source: http://stackoverflow.com/a/35201226/2115352
   24|       |
   25|       |extension Data {
   26|       |
   27|      0|    internal var hexString: String {
   28|      0|        let pointer = self.withUnsafeBytes { (bytes: UnsafePointer<UInt8>) -> UnsafePointer<UInt8> in
   29|      0|            return bytes
   30|      0|        }
   31|      0|        let array = getByteArray(pointer)
   32|      0|        
   33|      0|        return array.reduce("") { (result, byte) -> String in
   34|      0|            result + String(format: "%02x", byte)
   35|      0|        }
   36|      0|    }
   37|       |
   38|      0|    private func getByteArray(_ pointer: UnsafePointer<UInt8>) -> [UInt8] {
   39|      0|        let buffer = UnsafeBufferPointer<UInt8>(start: pointer, count: count)
   40|      0|        return [UInt8](buffer)
   41|      0|    }
   42|       |}
   43|       |
   44|       |// Source: http://stackoverflow.com/a/42241894/2115352
   45|       |
   46|       |public protocol DataConvertible {
   47|       |    static func + (lhs: Data, rhs: Self) -> Data
   48|       |    static func += (lhs: inout Data, rhs: Self)
   49|       |}
   50|       |
   51|       |extension DataConvertible {
   52|      0|    public static func + (lhs: Data, rhs: Self) -> Data {
   53|      0|        var value = rhs
   54|      0|        let data = Data(buffer: UnsafeBufferPointer(start: &value, count: 1))
   55|      0|        return lhs + data
   56|      0|    }
   57|       |    
   58|      0|    public static func += (lhs: inout Data, rhs: Self) {
   59|      0|        lhs = lhs + rhs
   60|      0|    }
   61|       |}
   62|       |
   63|       |extension UInt8  : DataConvertible { }
   64|       |extension UInt16 : DataConvertible { }
   65|       |extension UInt32 : DataConvertible { }
   66|       |
   67|       |extension Int    : DataConvertible { }
   68|       |extension Float  : DataConvertible { }
   69|       |extension Double : DataConvertible { }
   70|       |
   71|       |extension String : DataConvertible {
   72|      0|    public static func + (lhs: Data, rhs: String) -> Data {
   73|      0|        guard let data = rhs.data(using: .utf8) else { return lhs}
   74|      0|        return lhs + data
   75|      0|    }
   76|       |}
   77|       |
   78|       |extension Data : DataConvertible {
   79|      0|    public static func + (lhs: Data, rhs: Data) -> Data {
   80|      0|        var data = Data()
   81|      0|        data.append(lhs)
   82|      0|        data.append(rhs)
   83|      0|        
   84|      0|        return data
   85|      0|    }
   86|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Double.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |// Source: http://stackoverflow.com/a/24055762/2115352
   24|       |
   25|       |extension Double {
   26|       |    
   27|      0|    internal func format(_ f: String) -> String {
   28|      0|        return String(format: "%\(f)f", self)
   29|      0|    }
   30|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/HexToBinConverter/IntelHex2BinConverter.m:
    1|       |/*
    2|       | * Copyright (c) 2015, Nordic Semiconductor
    3|       | * All rights reserved.
    4|       | *
    5|       | * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       | *
    7|       | * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       | *
    9|       | * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       | * documentation and/or other materials provided with the distribution.
   11|       | *
   12|       | * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       | * software without specific prior written permission.
   14|       | *
   15|       | * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       | * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       | * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       | * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       | * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       | * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       | */
   22|       |
   23|       |#import "IntelHex2BinConverter.h"
   24|       |
   25|       |@implementation IntelHex2BinConverter
   26|       |
   27|       |+(const Byte)ascii2char:(const Byte*)ascii
   28|      0|{
   29|      0|    if (*ascii >= 'A')
   30|      0|        return *ascii - 0x37;
   31|      0|    
   32|      0|    if (*ascii >= '0')
   33|      0|        return *ascii - '0';
   34|      0|    return -1;
   35|      0|}
   36|       |
   37|       |+(const Byte)readByte:(const Byte*)pointer
   38|      0|{
   39|      0|    Byte first = [IntelHex2BinConverter ascii2char:pointer];
   40|      0|    Byte second = [IntelHex2BinConverter ascii2char:pointer + 1];
   41|      0|    
   42|      0|    return (first << 4) | second;
   43|      0|}
   44|       |
   45|       |+(const UInt16)readAddress:(const Byte*)pointer
   46|      0|{
   47|      0|    Byte msb = [IntelHex2BinConverter readByte:pointer];
   48|      0|    Byte lsb = [IntelHex2BinConverter readByte:pointer + 2];
   49|      0|    
   50|      0|    return (msb << 8) | lsb;
   51|      0|}
   52|       |
   53|       |+(NSUInteger)calculateBinLength:(NSData*)hex
   54|      0|{
   55|      0|    if (hex == nil || hex.length == 0)
   56|      0|    {
   57|      0|        return 0;
   58|      0|    }
   59|      0|    
   60|      0|    NSUInteger binLength = 0;
   61|      0|    const NSUInteger hexLength = hex.length;
   62|      0|    const Byte* pointer = (const Byte*)hex.bytes;
   63|      0|    UInt32 lastBaseAddress = 0;
   64|      0|    
   65|      0|    do
   66|      0|    {
   67|      0|        const Byte semicollon = *pointer++;
   68|      0|        
   69|      0|        // Validate - each line of the file must have a semicollon as a firs char
   70|      0|        if (semicollon != ':')
   71|      0|        {
   72|      0|            return 0;
   73|      0|        }
   74|      0|        
   75|      0|        const UInt8 reclen = [IntelHex2BinConverter readByte:pointer]; pointer += 2;
   76|      0|        const UInt16 offset = [IntelHex2BinConverter readAddress:pointer]; pointer += 4;
   77|      0|        const UInt8 rectype = [IntelHex2BinConverter readByte:pointer]; pointer += 2;
   78|      0|        
   79|      0|        switch (rectype) {
   80|      0|            case 0x04: {
   81|      0|                // Only consistent hex files are supported. If there is a jump to non-following ULBA address skip the rest of the file
   82|      0|                const UInt32 newULBA = [IntelHex2BinConverter readAddress:pointer];
   83|      0|                if (binLength > 0 && newULBA != (lastBaseAddress >> 16) + 1)
   84|      0|                    return binLength;
   85|      0|                lastBaseAddress = newULBA << 16;
   86|      0|                break;
   87|      0|            }
   88|      0|            case 0x02: {
   89|      0|                // The same with Extended Segment Address. The calculated ULBA must not be greater than the last one + 1
   90|      0|                const UInt32 newSBA = [IntelHex2BinConverter readAddress:pointer] << 4;
   91|      0|                if (binLength > 0 && (newSBA >> 16) != (lastBaseAddress >> 16) + 1)
   92|      0|                    return binLength;
   93|      0|                lastBaseAddress = newSBA;
   94|      0|                break;
   95|      0|            }
   96|      0|            case 0x00:
   97|      0|                // If record type is Data Record (rectype = 0), add it's length (only it the address is >= 0x1000, MBR is skipped)
   98|      0|                if (lastBaseAddress + offset >= 0x1000)
   99|      0|                    binLength += reclen;
  100|      0|            default:
  101|      0|                break;
  102|      0|        }
  103|      0|        
  104|      0|        pointer += (reclen << 1);  // Skip the data when calculating length
  105|      0|        pointer += 2;   // Skip the checksum
  106|      0|        // Skip new line
  107|      0|        if (*pointer == '\r') pointer++;
  108|      0|        if (*pointer == '\n') pointer++;
  109|      0|    } while (pointer != hex.bytes + hexLength);
  110|      0|    
  111|      0|    return binLength;
  112|      0|}
  113|       |
  114|       |+(NSData *)convert:(NSData *)hex
  115|      0|{
  116|      0|    const NSUInteger binLength = [IntelHex2BinConverter calculateBinLength:hex];
  117|      0|    const NSUInteger hexLength = hex.length;
  118|      0|    const Byte* pointer = (const Byte*)hex.bytes;
  119|      0|    NSUInteger bytesCopied = 0;
  120|      0|    UInt32 lastBaseAddress = 0;
  121|      0|    
  122|      0|    Byte* bytes = malloc(sizeof(Byte) * binLength);
  123|      0|    Byte* output = bytes;
  124|      0|    
  125|      0|    do
  126|      0|    {
  127|      0|        const Byte semicollon = *pointer++;
  128|      0|        
  129|      0|        // Validate - each line of the file must have a semicollon as a firs char
  130|      0|        if (semicollon != ':')
  131|      0|        {
  132|      0|            free(bytes);
  133|      0|            return nil;
  134|      0|        }
  135|      0|        
  136|      0|        const UInt8 reclen = [IntelHex2BinConverter readByte:pointer]; pointer += 2;
  137|      0|        const UInt16 offset = [IntelHex2BinConverter readAddress:pointer]; pointer += 4;
  138|      0|        const UInt8 rectype = [IntelHex2BinConverter readByte:pointer]; pointer += 2;
  139|      0|        
  140|      0|        switch (rectype) {
  141|      0|            case 0x04: {
  142|      0|                const UInt32 newULBA = [IntelHex2BinConverter readAddress:pointer]; pointer += 4;
  143|      0|                if (bytesCopied > 0 && newULBA != (lastBaseAddress >> 16) + 1)
  144|      0|                    return [NSData dataWithBytesNoCopy:bytes length:bytesCopied];
  145|      0|                lastBaseAddress = newULBA << 16;
  146|      0|                break;
  147|      0|            }
  148|      0|            case 0x02: {
  149|      0|                const UInt32 newSBA = [IntelHex2BinConverter readAddress:pointer] << 4; pointer += 4;
  150|      0|                if (bytesCopied > 0 && (newSBA >> 16) != (lastBaseAddress >> 16) + 1)
  151|      0|                    return [NSData dataWithBytesNoCopy:bytes length:bytesCopied];
  152|      0|                lastBaseAddress = newSBA;
  153|      0|                break;
  154|      0|            }
  155|      0|            case 0x00:
  156|      0|                // If record type is Data Record (rectype = 0), copy data to output buffer
  157|      0|                // Skip data below 0x1000 address (MBR)
  158|      0|                if (lastBaseAddress + offset >= 0x1000)
  159|      0|                {
  160|      0|                    for (int i = 0; i < reclen; i++)
  161|      0|                    {
  162|      0|                        *output++ = [IntelHex2BinConverter readByte:pointer]; pointer += 2;
  163|      0|                        bytesCopied++;
  164|      0|                    }
  165|      0|                }
  166|      0|                else
  167|      0|                {
  168|      0|                    pointer += (reclen << 1);  // Skip the data
  169|      0|                }
  170|      0|                break;
  171|      0|            default:
  172|      0|                pointer += (reclen << 1);  // Skip the irrelevant data
  173|      0|                break;
  174|      0|        }
  175|      0|        
  176|      0|        pointer += 2;   // Skip the checksum
  177|      0|        // Skip new line
  178|      0|        if (*pointer == '\r') pointer++;
  179|      0|        if (*pointer == '\n') pointer++;
  180|      0|    } while (pointer != hex.bytes + hexLength);
  181|      0|    
  182|      0|    return [NSData dataWithBytesNoCopy:bytes length:bytesCopied];
  183|      0|}
  184|       |
  185|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Logging/LoggerDelegate.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |/**
   24|       |Log level. Logger application may filter log entries based on their level. Levels allow to ignore less important messages.
   25|       |
   26|       |- Debug -       Lowest priority. Usually names of called methods or callbacks received.
   27|       |- Verbose -     Low priority messages what the service is doing.
   28|       |- Info -        Messages about completed tasks.
   29|       |- Application - Messages about application level events, in this case DFU messages in human-readable form.
   30|       |- Warning -     Important messages.
   31|       |- Error -       Highest priority messages with errors.
   32|       |*/
   33|       |@objc public enum LogLevel : Int {
   34|       |    case debug       = 0
   35|       |    case verbose     = 1
   36|       |    case info        = 5
   37|       |    case application = 10
   38|       |    case warning     = 15
   39|       |    case error       = 20
   40|       |    
   41|      0|    public func name() -> String {
   42|      0|        var readableName: String
   43|      0|        switch (self) {
   44|      0|        case .debug:
   45|      0|            readableName = "D"
   46|      0|        case .verbose:
   47|      0|            readableName = "V"
   48|      0|        case .info:
   49|      0|            readableName = "I"
   50|      0|        case .application:
   51|      0|            readableName = "A"
   52|      0|        case .warning:
   53|      0|            readableName = "W"
   54|      0|        case .error:
   55|      0|            readableName = "E"
   56|      0|        }
   57|      0|        return readableName
   58|      0|    }
   59|       |}
   60|       |
   61|       |/**
   62|       | *  The Logger delegate.
   63|       | */
   64|       |@objc public protocol LoggerDelegate : class {
   65|       |    
   66|       |    /**
   67|       |     This method is called whenever a new log entry is to be saved. The logger implementation should save this or present it to the user.
   68|       |     
   69|       |     It is NOT safe to update any UI from this method as multiple threads may log.
   70|       |     
   71|       |     - parameter level:   the log level
   72|       |     - parameter message: the message
   73|       |     */
   74|       |    func logWith(_ level: LogLevel, message: String)
   75|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Logging/LoggerHelper.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |class LoggerHelper {
   24|       |    private var logger: LoggerDelegate?
   25|       |    
   26|      0|    init(_ logger: LoggerDelegate?) {
   27|      0|        self.logger = logger
   28|      0|    }
   29|       |    
   30|      0|    func d(_ message: String) {
   31|      0|        logger?.logWith(.debug, message: message)
   32|      0|    }
   33|       |    
   34|      0|    func v(_ message: String) {
   35|      0|        logger?.logWith(.verbose, message: message)
   36|      0|    }
   37|       |    
   38|      0|    func i(_ message: String) {
   39|      0|        logger?.logWith(.info, message: message)
   40|      0|    }
   41|       |    
   42|      0|    func a(_ message: String) {
   43|      0|        logger?.logWith(.application, message: message)
   44|      0|    }
   45|       |    
   46|      0|    func w(_ message: String) {
   47|      0|        logger?.logWith(.warning, message: message)
   48|      0|    }
   49|       |    
   50|      0|    func e(_ message: String) {
   51|      0|        logger?.logWith(.error, message: message)
   52|      0|    }
   53|       |    
   54|      0|    func w(_ error: Error) {
   55|      0|        logger?.logWith(.warning, message: "Error \((error as NSError).code): \(error.localizedDescription)")
   56|      0|    }
   57|       |    
   58|      0|    func e(_ error: Error) {
   59|      0|        logger?.logWith(.error, message: "Error \((error as NSError).code): \(error.localizedDescription)")
   60|      0|    }
   61|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Streams/DFUStream.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |internal let FIRMWARE_TYPE_SOFTDEVICE  : UInt8 = 0x01
   24|       |internal let FIRMWARE_TYPE_BOOTLOADER  : UInt8 = 0x02
   25|       |internal let FIRMWARE_TYPE_APPLICATION : UInt8 = 0x04
   26|       |
   27|       |@objc open class DFUFirmwareSize : NSObject {
   28|       |    open fileprivate(set) var softdevice  : UInt32 = 0
   29|       |    open fileprivate(set) var bootloader  : UInt32 = 0
   30|       |    open fileprivate(set) var application : UInt32 = 0
   31|       |    
   32|      0|    internal init(softdevice: UInt32, bootloader: UInt32, application: UInt32) {
   33|      0|        self.softdevice = softdevice
   34|      0|        self.bootloader = bootloader
   35|      0|        self.application = application
   36|      0|    }
   37|       |}
   38|       |
   39|       |/**
   40|       | * The stream to read firmware from.
   41|       | */
   42|       |internal protocol DFUStream {
   43|       |    /// Returns the 1-based number of the current part.
   44|       |    var currentPart: Int { get }
   45|       |    /// Number of parts to be sent.
   46|       |    var parts: Int { get }
   47|       |    /// The size of each component of the firmware.
   48|       |    var size: DFUFirmwareSize { get }
   49|       |    /// The size of each component of the firmware from the current part.
   50|       |    var currentPartSize: DFUFirmwareSize { get }
   51|       |    /// The type of the current part. See FIRMWARE_TYPE_* constants.
   52|       |    var currentPartType: UInt8 { get }
   53|       |    
   54|       |    /// The firmware data to be sent to the DFU target.
   55|       |    var data: Data { get }
   56|       |    /// The whole init packet matching the current part. Data may be longer than 20 bytes.
   57|       |    var initPacket: Data? { get }
   58|       |    
   59|       |    /**
   60|       |     Returns true if there is another part to be send.
   61|       |     
   62|       |     - returns: true if there is at least one byte of data not sent in the current packet
   63|       |     */
   64|       |    func hasNextPart() -> Bool
   65|       |    /**
   66|       |     Switches the stream to the second part.
   67|       |     */
   68|       |    func switchToNextPart()
   69|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Streams/DFUStreamBin.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |internal class DFUStreamBin : DFUStream {
   24|       |    private(set) var currentPart = 1
   25|       |    private(set) var parts       = 1
   26|       |    private(set) var currentPartType: UInt8 = 0
   27|       |    
   28|       |    /// Firmware binaries
   29|       |    private var binaries: Data
   30|       |    /// The init packet content
   31|       |    private var initPacketBinaries: Data?
   32|       |    
   33|       |    private var firmwareSize: UInt32 = 0
   34|       |    
   35|      0|    var size: DFUFirmwareSize {
   36|      0|        switch currentPartType {
   37|      0|        case FIRMWARE_TYPE_SOFTDEVICE:
   38|      0|            return DFUFirmwareSize(softdevice: firmwareSize, bootloader: 0, application: 0)
   39|      0|        case FIRMWARE_TYPE_BOOTLOADER:
   40|      0|            return DFUFirmwareSize(softdevice: 0, bootloader: firmwareSize, application: 0)
   41|      0|            // case FIRMWARE_TYPE_APPLICATION:
   42|      0|        default:
   43|      0|            return DFUFirmwareSize(softdevice: 0, bootloader: 0, application: firmwareSize)
   44|      0|        }
   45|      0|    }
   46|       |    
   47|      0|    var currentPartSize: DFUFirmwareSize {
   48|      0|        return size
   49|      0|    }
   50|       |    
   51|      0|    init(urlToBinFile: URL, urlToDatFile: URL?, type: DFUFirmwareType) {
   52|      0|        binaries = try! Data(contentsOf: urlToBinFile)
   53|      0|        firmwareSize = UInt32(binaries.count)
   54|      0|        
   55|      0|        if let dat = urlToDatFile {
   56|      0|            initPacketBinaries = try? Data(contentsOf: dat)
   57|      0|        }
   58|      0|        
   59|      0|        self.currentPartType = type.rawValue
   60|      0|    }
   61|       |    
   62|      0|    var data: Data {
   63|      0|        return binaries
   64|      0|    }
   65|       |    
   66|      0|    var initPacket: Data? {
   67|      0|        return initPacketBinaries
   68|      0|    }
   69|       |    
   70|      0|    func hasNextPart() -> Bool {
   71|      0|        return false
   72|      0|    }
   73|       |    
   74|      0|    func switchToNextPart() {
   75|      0|        // do nothing
   76|      0|    }
   77|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Streams/DFUStreamHex.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |internal class DFUStreamHex : DFUStream {
   24|       |    private(set) var currentPart = 1
   25|       |    private(set) var parts       = 1
   26|       |    private(set) var currentPartType: UInt8 = 0
   27|       |    
   28|       |    /// Firmware binaries
   29|       |    private var binaries: Data
   30|       |    /// The init packet content
   31|       |    private var initPacketBinaries: Data?
   32|       |    
   33|       |    private var firmwareSize: UInt32 = 0
   34|       |    
   35|      0|    var size: DFUFirmwareSize {
   36|      0|        switch currentPartType {
   37|      0|        case FIRMWARE_TYPE_SOFTDEVICE:
   38|      0|            return DFUFirmwareSize(softdevice: firmwareSize, bootloader: 0, application: 0)
   39|      0|        case FIRMWARE_TYPE_BOOTLOADER:
   40|      0|            return DFUFirmwareSize(softdevice: 0, bootloader: firmwareSize, application: 0)
   41|      0|            // case FIRMWARE_TYPE_APPLICATION:
   42|      0|        default:
   43|      0|            return DFUFirmwareSize(softdevice: 0, bootloader: 0, application: firmwareSize)
   44|      0|        }
   45|      0|    }
   46|       |    
   47|      0|    var currentPartSize: DFUFirmwareSize {
   48|      0|        return size
   49|      0|    }
   50|       |    
   51|      0|    init(urlToHexFile: URL, urlToDatFile: URL?, type: DFUFirmwareType) {
   52|      0|        let hexData = try? Data(contentsOf: urlToHexFile)
   53|      0|        binaries = IntelHex2BinConverter.convert(hexData)
   54|      0|        firmwareSize = UInt32(binaries.count)
   55|      0|        
   56|      0|        if let dat = urlToDatFile {
   57|      0|            initPacketBinaries = try? Data(contentsOf: dat)
   58|      0|        }
   59|      0|        
   60|      0|        self.currentPartType = type.rawValue
   61|      0|    }
   62|       |    
   63|      0|    var data: Data {
   64|      0|        return binaries
   65|      0|    }
   66|       |    
   67|      0|    var initPacket: Data? {
   68|      0|        return initPacketBinaries
   69|      0|    }
   70|       |    
   71|      0|    func hasNextPart() -> Bool {
   72|      0|        return false
   73|      0|    }
   74|       |    
   75|      0|    func switchToNextPart() {
   76|      0|        // do nothing
   77|      0|    }
   78|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/Streams/DFUStreamZip.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |// Errors
   24|       |internal enum DFUStreamZipError : Error {
   25|       |    case noManifest
   26|       |    case invalidManifest
   27|       |    case fileNotFound
   28|       |    case typeNotFound
   29|       |    
   30|      0|    var description: String {
   31|      0|        switch self {
   32|      0|        case .noManifest:      return NSLocalizedString("No manifest file found", comment: "")
   33|      0|        case .invalidManifest: return NSLocalizedString("Invalid manifest.json file", comment: "")
   34|      0|        case .fileNotFound:    return NSLocalizedString("File specified in manifest.json not found in ZIP", comment: "")
   35|      0|        case .typeNotFound:    return NSLocalizedString("Specified type not found in manifest.json", comment: "")
   36|      0|        }
   37|      0|    }
   38|       |}
   39|       |
   40|       |internal class DFUStreamZip : DFUStream {
   41|       |    private static let MANIFEST_FILE = "manifest.json"
   42|       |    
   43|       |    private(set) var currentPart = 1
   44|       |    private(set) var parts       = 1
   45|       |    private(set) var currentPartType: UInt8 = 0
   46|       |    
   47|       |    /// The parsed manifest file if such found, nil otherwise.
   48|       |    private var manifest: Manifest?
   49|       |    /// Binaries with softdevice and bootloader.
   50|       |    private var systemBinaries: Data?
   51|       |    /// Binaries with an app.
   52|       |    private var appBinaries: Data?
   53|       |    /// System init packet.
   54|       |    private var systemInitPacket: Data?
   55|       |    /// Application init packet.
   56|       |    private var appInitPacket: Data?
   57|       |    
   58|       |    private var currentBinaries: Data?
   59|       |    private var currentInitPacket: Data?
   60|       |    
   61|       |    private var softdeviceSize  : UInt32 = 0
   62|       |    private var bootloaderSize  : UInt32 = 0
   63|       |    private var applicationSize : UInt32 = 0
   64|       |    
   65|      0|    var size: DFUFirmwareSize {
   66|      0|        return DFUFirmwareSize(softdevice: softdeviceSize, bootloader: bootloaderSize, application: applicationSize)
   67|      0|    }
   68|       |    
   69|      0|    var currentPartSize: DFUFirmwareSize {
   70|      0|        // If the ZIP file will be transferred in one part, return all sizes. Two of them will be 0.
   71|      0|        if parts == 1 {
   72|      0|            return DFUFirmwareSize(softdevice: softdeviceSize, bootloader: bootloaderSize, application: applicationSize)
   73|      0|        }
   74|      0|        // Else, return sizes based on the current part number. First the SD and/or BL are uploaded
   75|      0|        if currentPart == 1 {
   76|      0|            return DFUFirmwareSize(softdevice: softdeviceSize, bootloader: bootloaderSize, application: 0)
   77|      0|        }
   78|      0|        // and then the application.
   79|      0|        return DFUFirmwareSize(softdevice: 0, bootloader: 0, application: applicationSize)
   80|      0|    }
   81|       |    
   82|       |    /**
   83|       |     Initializes the stream with URL to the ZIP file.
   84|       |     
   85|       |     - parameter urlToZipFile: URL to the ZIP file with firmware files and manifest.json file containing metadata.
   86|       |     
   87|       |     - throws: DFUStreamZipError when manifest file was not found or contained an error
   88|       |     
   89|       |     - returns: the stream
   90|       |     */
   91|      0|    convenience init(urlToZipFile: URL) throws {
   92|      0|        let allTypes = FIRMWARE_TYPE_SOFTDEVICE | FIRMWARE_TYPE_BOOTLOADER | FIRMWARE_TYPE_APPLICATION
   93|      0|        try self.init(urlToZipFile: urlToZipFile, type: allTypes)
   94|      0|    }
   95|       |    
   96|       |    /**
   97|       |     Initializes the stream with URL to the ZIP file.
   98|       |     
   99|       |     - parameter urlToZipFile: URL to the ZIP file with firmware files and manifest.json file containing metadata.
  100|       |     - parameter type:         The type of the firmware to use
  101|       |     
  102|       |     - throws: DFUStreamZipError when manifest file was not found or contained an error
  103|       |     
  104|       |     - returns: the stream
  105|       |     */
  106|      0|    init(urlToZipFile: URL, type: UInt8) throws {
  107|      0|        // Try to unzip the file. This may throw an exception
  108|      0|        let contentUrls = try ZipArchive.unzip(urlToZipFile)
  109|      0|        
  110|      0|        // Look for MANIFEST_FILE
  111|      0|        let manifestUrl = ZipArchive.findFile(DFUStreamZip.MANIFEST_FILE, inside: contentUrls)
  112|      0|        
  113|      0|        if let url = manifestUrl {
  114|      0|            // Read manifest content
  115|      0|            let json = try String(contentsOf: url)
  116|      0|            
  117|      0|            // Deserialize json
  118|      0|            manifest = Manifest(withJsonString: json)
  119|      0|
  120|      0|            if manifest!.valid {
  121|      0|
  122|      0|                // After validation we are sure that the manifest file contains at most one
  123|      0|                // of: softdeviceBootloader, softdevice or bootloader
  124|      0|                
  125|      0|                // Look for and assign files specified in the manifest
  126|      0|                let softdeviceBootloaderType = FIRMWARE_TYPE_SOFTDEVICE | FIRMWARE_TYPE_BOOTLOADER
  127|      0|                if type & softdeviceBootloaderType == softdeviceBootloaderType {
  128|      0|                    if let softdeviceBootloader = manifest!.softdeviceBootloader {
  129|      0|                        let (bin, dat) = try getContentOf(softdeviceBootloader, from: contentUrls)
  130|      0|                        systemBinaries = bin
  131|      0|                        systemInitPacket = dat
  132|      0|                        softdeviceSize = softdeviceBootloader.sdSize
  133|      0|                        bootloaderSize = softdeviceBootloader.blSize
  134|      0|                        currentPartType = softdeviceBootloaderType
  135|      0|                    }
  136|      0|                }
  137|      0|                
  138|      0|                let softdeviceType = FIRMWARE_TYPE_SOFTDEVICE
  139|      0|                if type & softdeviceType == softdeviceType {
  140|      0|                    if let softdevice = manifest!.softdevice {
  141|      0|                        if systemBinaries != nil {
  142|      0|                            // It is not allowed to put both softdevice and softdeviceBootloader in the manifest
  143|      0|                            throw DFUStreamZipError.invalidManifest
  144|      0|                        }
  145|      0|                        let (bin, dat) = try getContentOf(softdevice, from: contentUrls)
  146|      0|                        systemBinaries = bin
  147|      0|                        systemInitPacket = dat
  148|      0|                        softdeviceSize = UInt32(bin.count)
  149|      0|                        currentPartType = softdeviceType
  150|      0|                    }
  151|      0|                }
  152|      0|                
  153|      0|                let bootloaderType = FIRMWARE_TYPE_BOOTLOADER
  154|      0|                if type & bootloaderType == bootloaderType {
  155|      0|                    if let bootloader = manifest!.bootloader {
  156|      0|                        if systemBinaries != nil {
  157|      0|                            // It is not allowed to put both bootloader and softdeviceBootloader in the manifest
  158|      0|                            throw DFUStreamZipError.invalidManifest
  159|      0|                        }
  160|      0|                        let (bin, dat) = try getContentOf(bootloader, from: contentUrls)
  161|      0|                        systemBinaries = bin
  162|      0|                        systemInitPacket = dat
  163|      0|                        bootloaderSize = UInt32(bin.count)
  164|      0|                        currentPartType = bootloaderType
  165|      0|                    }
  166|      0|                }
  167|      0|                
  168|      0|                let applicationType = FIRMWARE_TYPE_APPLICATION
  169|      0|                if type & applicationType == applicationType {
  170|      0|                    if let application = manifest!.application {
  171|      0|                        let (bin, dat) = try getContentOf(application, from: contentUrls)
  172|      0|                        appBinaries = bin
  173|      0|                        appInitPacket = dat
  174|      0|                        applicationSize = UInt32(bin.count)
  175|      0|                        if currentPartType == 0 {
  176|      0|                            currentPartType = applicationType
  177|      0|                        } else {
  178|      0|                            // Otherwise the app will be sent as part 2
  179|      0|                            
  180|      0|                            // It is not possible to send SD+BL+App in a single connection, due to a fact that
  181|      0|                            // the softdevice_bootloade_application section is not defined for the manifest.json file.
  182|      0|                            // It would be possible to send both bin (systemBinaries and appBinaries), but there are
  183|      0|                            // two dat files with two Init Packets and non of them matches two combined binaries.
  184|      0|                        }
  185|      0|                    }
  186|      0|                }
  187|      0|                
  188|      0|                if systemBinaries == nil && appBinaries == nil {
  189|      0|                    // The specified type is not included in the manifest.
  190|      0|                    throw DFUStreamZipError.typeNotFound
  191|      0|                }
  192|      0|                else if systemBinaries != nil {
  193|      0|                    currentBinaries = systemBinaries
  194|      0|                    currentInitPacket = systemInitPacket
  195|      0|                } else {
  196|      0|                    currentBinaries = appBinaries
  197|      0|                    currentInitPacket = appInitPacket
  198|      0|                }
  199|      0|                
  200|      0|                // If the ZIP file contains an app and a softdevice or bootloader,
  201|      0|                // the content will be sent in 2 parts.
  202|      0|                if systemBinaries != nil && appBinaries != nil {
  203|      0|                    parts = 2
  204|      0|                }
  205|      0|            } else {
  206|      0|                throw DFUStreamZipError.invalidManifest
  207|      0|            }
  208|      0|        } else { // no manifest file
  209|      0|            // This library does not support the old, deprecated name-based ZIP files
  210|      0|            // Please, use the nrf-util app to create a new Distribution packet
  211|      0|            throw DFUStreamZipError.noManifest
  212|      0|        }
  213|      0|    }
  214|       |    
  215|       |    /**
  216|       |     This method checks if the FirmwareInfo object is valid (has both bin and dat files specified),
  217|       |     adds those files to binUrls and datUrls arrays and returns the length of the bin file in bytes.
  218|       |     
  219|       |     - parameter info:        the metadata obtained from the manifest file
  220|       |     - parameter contentUrls: the list of URLs to the unzipped files
  221|       |     
  222|       |     - throws: DFUStreamZipError when file specified in the metadata was not found in the ZIP
  223|       |     
  224|       |     - returns: content bin and dat files
  225|       |     */
  226|      0|    fileprivate func getContentOf(_ info: ManifestFirmwareInfo, from contentUrls: [URL]) throws -> (Data, Data?) {
  227|      0|        if !info.valid {
  228|      0|            throw DFUStreamZipError.invalidManifest
  229|      0|        }
  230|      0|        
  231|      0|        // Get the URLs to the bin and dat files specified in the FirmwareInfo
  232|      0|        let bin = ZipArchive.findFile(info.binFile!, inside: contentUrls)
  233|      0|        var dat: URL? = nil
  234|      0|        if let datFile = info.datFile {
  235|      0|            dat = ZipArchive.findFile(datFile, inside: contentUrls)
  236|      0|        }
  237|      0|        
  238|      0|        // Check if the files were found in the ZIP
  239|      0|        if bin == nil || (info.datFile != nil && dat == nil) {
  240|      0|            throw DFUStreamZipError.fileNotFound
  241|      0|        }
  242|      0|        
  243|      0|        // Read content of those files
  244|      0|        let binData = try! Data(contentsOf: bin!)
  245|      0|        var datData: Data? = nil
  246|      0|        if let dat = dat {
  247|      0|            datData = try! Data(contentsOf: dat)
  248|      0|        }
  249|      0|        
  250|      0|        return (binData, datData)
  251|      0|    }
  252|       |    
  253|      0|    var data: Data {
  254|      0|        return currentBinaries!
  255|      0|    }
  256|       |    
  257|      0|    var initPacket: Data? {
  258|      0|        return currentInitPacket
  259|      0|    }
  260|       |    
  261|      0|    func hasNextPart() -> Bool {
  262|      0|        return currentPart < parts
  263|      0|    }
  264|       |    
  265|      0|    func switchToNextPart() {
  266|      0|        if currentPart == 1 && parts == 2 {
  267|      0|            currentPart = 2
  268|      0|            currentPartType = FIRMWARE_TYPE_APPLICATION
  269|      0|            currentBinaries = appBinaries
  270|      0|            currentInitPacket = appInitPacket
  271|      0|        }
  272|      0|    }
  273|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/ZipArchive.swift:
    1|       |/*
    2|       |* Copyright (c) 2016, Nordic Semiconductor
    3|       |* All rights reserved.
    4|       |*
    5|       |* Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
    6|       |*
    7|       |* 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    8|       |*
    9|       |* 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
   10|       |* documentation and/or other materials provided with the distribution.
   11|       |*
   12|       |* 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
   13|       |* software without specific prior written permission.
   14|       |*
   15|       |* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   16|       |* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   17|       |* HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   18|       |* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
   19|       |* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
   20|       |* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   21|       |*/
   22|       |
   23|       |import Zip
   24|       |
   25|       |internal class ZipArchive {
   26|       |    
   27|      0|    private init() {
   28|      0|        // Forbid creating instance of this class
   29|      0|        // Use this class only in static way
   30|      0|    }
   31|       |    
   32|       |    /**
   33|       |     Opens the ZIP archive and returs a list of URLs to all unzipped files.
   34|       |     Unzipped files were moved to a temporary destination in Cache Directory.
   35|       |     
   36|       |     - parameter url: URL to a ZIP file
   37|       |     
   38|       |     - throws: an error if unzipping, or obtaining the list of files failed
   39|       |     
   40|       |     - returns: list of URLs to unzipped files in the tmp folder
   41|       |     */
   42|      0|    internal static func unzip(_ url: URL) throws -> [URL] {
   43|      0|        let fileName = url.lastPathComponent
   44|      0|        let destinationPath = try createTemporaryFolderPath(fileName)
   45|      0|        
   46|      0|        // Unzip file to the destination folder
   47|      0|        let destination = URL(fileURLWithPath: destinationPath)
   48|      0|        try Zip.unzipFile(url, destination: destination, overwrite: true, password: nil, progress: nil)
   49|      0|        
   50|      0|        // Get folder content
   51|      0|        let files = try getFilesFromDirectory(destinationPath)
   52|      0|        
   53|      0|        // Convert Strings to NSURLs
   54|      0|        var urls = [URL]()
   55|      0|        for file in files {
   56|      0|            urls.append(URL(fileURLWithPath: destinationPath + file))
   57|      0|        }
   58|      0|        return urls
   59|      0|    }
   60|       |    
   61|       |    /**
   62|       |     A path to a newly created temp directory or nil in case of an error.
   63|       |     
   64|       |     - throws: an error when creating the tmp directory failed
   65|       |     
   66|       |     - returns: a path to the tmp folder
   67|       |     */
   68|      0|    internal static func createTemporaryFolderPath(_ name: String) throws -> String {
   69|      0|        // Build the temp folder path. Content of the ZIP file will be copied into it
   70|      0|        let tempPath = NSTemporaryDirectory() + ".dfu/unzip/" + name + "/"
   71|      0|        
   72|      0|        // Check if folder exists. Remove it if so
   73|      0|        let fileManager = FileManager.default
   74|      0|        if fileManager.fileExists(atPath: tempPath) {
   75|      0|            do {
   76|      0|                try fileManager.removeItem(atPath: tempPath)
   77|      0|            } catch let error as NSError {
   78|      0|                NSLog("Error while removing old temp file: \(error.localizedDescription)")
   79|      0|                throw error
   80|      0|            }
   81|      0|        }
   82|      0|        
   83|      0|        // Create a new temporary folder
   84|      0|        do {
   85|      0|            try fileManager.createDirectory(atPath: tempPath, withIntermediateDirectories: true, attributes: nil)
   86|      0|        } catch let error as NSError {
   87|      0|            NSLog("Error while creating temp file: \(error.localizedDescription)")
   88|      0|            throw error
   89|      0|        }
   90|      0|        
   91|      0|        return tempPath
   92|      0|    }
   93|       |    
   94|       |    /**
   95|       |     Returns a list of paths to all files from a given directory.
   96|       |     
   97|       |     - parameter path: a path to the directory to get files from
   98|       |     
   99|       |     - throws: an error if could not get contents of the directory
  100|       |     
  101|       |     - returns: list of paths to files from the directory at given path
  102|       |     */
  103|      0|    internal static func getFilesFromDirectory(_ path: String) throws -> [String] {
  104|      0|        let fileManager = FileManager.default
  105|      0|        
  106|      0|        do {
  107|      0|            return try fileManager.contentsOfDirectory(atPath: path)
  108|      0|        } catch let error as NSError {
  109|      0|            NSLog("Error while obtaining content of temp folder: \(error.localizedDescription)")
  110|      0|            throw error
  111|      0|        }
  112|      0|    }
  113|       |    
  114|       |    /**
  115|       |     Looks for a file with given name inside an array or file URLs.
  116|       |     
  117|       |     - parameter name: file name
  118|       |     - parameter urls: list of files URLs to search in
  119|       |     
  120|       |     - returns: URL to a file or nil
  121|       |     */
  122|      0|    internal static func findFile(_ name: String, inside urls: [URL]) -> URL? {
  123|      0|        for url in urls {
  124|      0|            if url.lastPathComponent == name {
  125|      0|                return url
  126|      0|            }
  127|      0|        }
  128|      0|        return nil
  129|      0|    }
  130|       |}

/Users/won/IO/Switcher-m-iOS/Pods/iOSDFULibrary/iOSDFULibrary/Classes/Utilities/crc32.swift:
    1|       |//
    2|       |//  crc32.swift
    3|       |//  SuperSFV
    4|       |//
    5|       |//  Created by C.W. Betts on 8/23/15.
    6|       |//
    7|       |//
    8|       |/* crc32.swift -- compute the CRC-32 of a data stream
    9|       | Copyright (C) 1995-1998 Mark Adler
   10|       | Copyright (C) 2015 C.W. "Madd the Sane" Betts
   11|       | This software is provided 'as-is', without any express or implied
   12|       | warranty.  In no event will the authors be held liable for any damages
   13|       | arising from the use of this software.
   14|       | Permission is granted to anyone to use this software for any purpose,
   15|       | including commercial applications, and to alter it and redistribute it
   16|       | freely, subject to the following restrictions:
   17|       | 1. The origin of this software must not be misrepresented; you must not
   18|       | claim that you wrote the original software. If you use this software
   19|       | in a product, an acknowledgment in the product documentation would be
   20|       | appreciated but is not required.
   21|       | 2. Altered source versions must be plainly marked as such, and must not be
   22|       | misrepresented as being the original software.
   23|       | 3. This notice may not be removed or altered from any source distribution.
   24|       | Jean-loup Gailly        Mark Adler
   25|       | jloup@gzip.org          madler@alumni.caltech.edu
   26|       | */
   27|       |
   28|       |import Foundation
   29|       |
   30|       |/**
   31|       | Table of CRC-32's of all single-byte values (made by make_crc_table)
   32|       | */
   33|       |private let crcTable: [UInt32] = [
   34|       |    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
   35|       |    0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
   36|       |    0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
   37|       |    0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
   38|       |    0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
   39|       |    0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
   40|       |    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
   41|       |    0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
   42|       |    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
   43|       |    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
   44|       |    0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
   45|       |    0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
   46|       |    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
   47|       |    0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
   48|       |    0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
   49|       |    0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
   50|       |    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
   51|       |    0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
   52|       |    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
   53|       |    0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
   54|       |    0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
   55|       |    0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
   56|       |    0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
   57|       |    0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
   58|       |    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
   59|       |    0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
   60|       |    0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
   61|       |    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
   62|       |    0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
   63|       |    0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
   64|       |    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
   65|       |    0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
   66|       |    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
   67|       |    0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
   68|       |    0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
   69|       |    0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
   70|       |    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
   71|       |    0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
   72|       |    0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
   73|       |    0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
   74|       |    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
   75|       |    0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
   76|       |    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
   77|       |    0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
   78|       |    0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
   79|       |    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
   80|       |    0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
   81|       |    0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
   82|       |    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
   83|       |    0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
   84|       |    0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
   85|       |    0x2d02ef8d]
   86|       |
   87|      0|func crc32(_ crc: UInt32, data: Data?) -> UInt32 {
   88|      0|    guard let data = data else {
   89|      0|        return crc32(0, buffer: nil, length: 0)
   90|      0|    }
   91|      0|    return crc32(crc, buffer: (data as NSData).bytes.bindMemory(to: UInt8.self, capacity: data.count), length: data.count)
   92|      0|}
   93|       |
   94|       |/**
   95|       | Update a running crc with the bytes buf[0..len-1] and return the updated
   96|       | crc. If buf is `nil`, this function returns the required initial value
   97|       | for the crc. Pre- and post-conditioning (one's complement) is performed
   98|       | within this function so it shouldn't be done by the application.<br>
   99|       | Usage example:
  100|       | Var crc: UInt32 = crc32(0, nil, 0);
  101|       | 
  102|       | while (read_buffer(buffer, length) != EOF) {
  103|       | crc = crc32(crc, buffer: buffer, length: length)
  104|       | }
  105|       | if (crc != original_crc) error();
  106|       | */
  107|      0|func crc32(_ crc: UInt32, buffer: UnsafePointer<UInt8>?, length: Int) -> UInt32 {
  108|      0|    if buffer == nil {
  109|      0|        return 0
  110|      0|    }
  111|      0|    var crc1 = crc ^ 0xffffffff
  112|      0|    var len = length
  113|      0|    var buf = buffer
  114|      0|    func DO1() {
  115|      0|        let toBuf = buf?.pointee
  116|      0|        buf = buf! + 1
  117|      0|        crc1 = crcTable[Int((crc1 ^ UInt32(toBuf!)) & 0xFF)] ^ crc1 >> 8
  118|      0|    }
  119|      0|    func DO2() { DO1(); DO1(); }
  120|      0|    func DO4() { DO2(); DO2(); }
  121|      0|    func DO8() { DO4(); DO4(); }
  122|      0|    
  123|      0|    while len >= 8 {
  124|      0|        DO8()
  125|      0|        len -= 8
  126|      0|    }
  127|      0|    if len != 0 {
  128|      0|        repeat {
  129|      0|            len -= 1
  130|      0|            DO1()
  131|      0|        } while len != 0
  132|      0|    }
  133|      0|    
  134|      0|    return crc1 ^ 0xffffffff;
  135|      0|}
  136|       |
  137|      0|func ==(lhs: CRC32, rhs: CRC32) -> Bool {
  138|      0|    return lhs.initialized == rhs.initialized && lhs.crc == rhs.crc
  139|      0|}
  140|       |
  141|       |final class CRC32: Hashable {
  142|       |    fileprivate var initialized = false
  143|       |    fileprivate(set) var crc: UInt32 = 0
  144|       |    
  145|      0|    var hashValue: Int {
  146|      0|        return Int(crc)
  147|      0|    }
  148|       |    
  149|      0|    init() {}
  150|       |    
  151|      0|    convenience init(data: Data) {
  152|      0|        self.init()
  153|      0|        crc = crc32(crc, data: data)
  154|      0|        initialized = true
  155|      0|    }
  156|       |    
  157|      0|    func run(buffer: UnsafePointer<UInt8>, length: Int) {
  158|      0|        crc = crc32(crc, buffer: buffer, length: length)
  159|      0|        initialized = true
  160|      0|    }
  161|       |    
  162|      0|    func run(data: Data) {
  163|      0|        crc = crc32(crc, data: data)
  164|      0|        initialized = true
  165|      0|    }
  166|       |}

