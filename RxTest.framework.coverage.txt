/Users/won/IO/Switcher-m-iOS/Pods/RxTest/Platform/DataStructures/Bag.swift:
    1|       |//
    2|       |//  Bag.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Swift
   10|       |
   11|       |let arrayDictionaryMaxSize = 30
   12|       |
   13|       |struct BagKey {
   14|       |    /**
   15|       |    Unique identifier for object added to `Bag`.
   16|       |     
   17|       |    It's underlying type is UInt64. If we assume there in an idealized CPU that works at 4GHz,
   18|       |     it would take ~150 years of continuous running time for it to overflow.
   19|       |    */
   20|       |    fileprivate let rawValue: UInt64
   21|       |}
   22|       |
   23|       |/**
   24|       |Data structure that represents a bag of elements typed `T`.
   25|       |
   26|       |Single element can be stored multiple times.
   27|       |
   28|       |Time and space complexity of insertion an deletion is O(n). 
   29|       |
   30|       |It is suitable for storing small number of elements.
   31|       |*/
   32|       |struct Bag<T> : CustomDebugStringConvertible {
   33|       |    /// Type of identifier for inserted elements.
   34|       |    typealias KeyType = BagKey
   35|       |    
   36|       |    typealias Entry = (key: BagKey, value: T)
   37|       | 
   38|       |    fileprivate var _nextKey: BagKey = BagKey(rawValue: 0)
   39|       |
   40|       |    // data
   41|       |
   42|       |    // first fill inline variables
   43|       |    var _key0: BagKey? = nil
   44|       |    var _value0: T? = nil
   45|       |
   46|       |    // then fill "array dictionary"
   47|       |    var _pairs = ContiguousArray<Entry>()
   48|       |
   49|       |    // last is sparse dictionary
   50|       |    var _dictionary: [BagKey : T]? = nil
   51|       |
   52|       |    var _onlyFastPath = true
   53|       |
   54|       |    /// Creates new empty `Bag`.
   55|      0|    init() {
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |    Inserts `value` into bag.
   60|       |    
   61|       |    - parameter element: Element to insert.
   62|       |    - returns: Key that can be used to remove element from bag.
   63|       |    */
   64|      0|    mutating func insert(_ element: T) -> BagKey {
   65|      0|        let key = _nextKey
   66|      0|
   67|      0|        _nextKey = BagKey(rawValue: _nextKey.rawValue &+ 1)
   68|      0|
   69|      0|        if _key0 == nil {
   70|      0|            _key0 = key
   71|      0|            _value0 = element
   72|      0|            return key
   73|      0|        }
   74|      0|
   75|      0|        _onlyFastPath = false
   76|      0|
   77|      0|        if _dictionary != nil {
   78|      0|            _dictionary![key] = element
   79|      0|            return key
   80|      0|        }
   81|      0|
   82|      0|        if _pairs.count < arrayDictionaryMaxSize {
   83|      0|            _pairs.append(key: key, value: element)
   84|      0|            return key
   85|      0|        }
   86|      0|
   87|      0|        if _dictionary == nil {
   88|      0|            _dictionary = [:]
   89|      0|        }
   90|      0|
   91|      0|        _dictionary![key] = element
   92|      0|        
   93|      0|        return key
   94|      0|    }
   95|       |    
   96|       |    /// - returns: Number of elements in bag.
   97|      0|    var count: Int {
   98|      0|        let dictionaryCount: Int = _dictionary?.count ?? 0
   99|      0|        return (_value0 != nil ? 1 : 0) + _pairs.count + dictionaryCount
  100|      0|    }
  101|       |    
  102|       |    /// Removes all elements from bag and clears capacity.
  103|      0|    mutating func removeAll() {
  104|      0|        _key0 = nil
  105|      0|        _value0 = nil
  106|      0|
  107|      0|        _pairs.removeAll(keepingCapacity: false)
  108|      0|        _dictionary?.removeAll(keepingCapacity: false)
  109|      0|    }
  110|       |    
  111|       |    /**
  112|       |    Removes element with a specific `key` from bag.
  113|       |    
  114|       |    - parameter key: Key that identifies element to remove from bag.
  115|       |    - returns: Element that bag contained, or nil in case element was already removed.
  116|       |    */
  117|      0|    mutating func removeKey(_ key: BagKey) -> T? {
  118|      0|        if _key0 == key {
  119|      0|            _key0 = nil
  120|      0|            let value = _value0!
  121|      0|            _value0 = nil
  122|      0|            return value
  123|      0|        }
  124|      0|
  125|      0|        if let existingObject = _dictionary?.removeValue(forKey: key) {
  126|      0|            return existingObject
  127|      0|        }
  128|      0|
  129|      0|        for i in 0 ..< _pairs.count {
  130|      0|            if _pairs[i].key == key {
  131|      0|                let value = _pairs[i].value
  132|      0|                _pairs.remove(at: i)
  133|      0|                return value
  134|      0|            }
  135|      0|        }
  136|      0|
  137|      0|        return nil
  138|      0|    }
  139|       |}
  140|       |
  141|       |extension Bag {
  142|       |    /// A textual representation of `self`, suitable for debugging.
  143|      0|    var debugDescription : String {
  144|      0|        return "\(self.count) elements in Bag"
  145|      0|    }
  146|       |}
  147|       |
  148|       |extension Bag {
  149|       |    /// Enumerates elements inside the bag.
  150|       |    ///
  151|       |    /// - parameter action: Enumeration closure.
  152|      0|    func forEach(_ action: (T) -> Void) {
  153|      0|        if _onlyFastPath {
  154|      0|            if let value0 = _value0 {
  155|      0|                action(value0)
  156|      0|            }
  157|      0|            return
  158|      0|        }
  159|      0|
  160|      0|        let value0 = _value0
  161|      0|        let dictionary = _dictionary
  162|      0|
  163|      0|        if let value0 = value0 {
  164|      0|            action(value0)
  165|      0|        }
  166|      0|
  167|      0|        for i in 0 ..< _pairs.count {
  168|      0|            action(_pairs[i].value)
  169|      0|        }
  170|      0|
  171|      0|        if dictionary?.count ?? 0 > 0 {
  172|      0|            for element in dictionary!.values {
  173|      0|                action(element)
  174|      0|            }
  175|      0|        }
  176|      0|    }
  177|       |}
  178|       |
  179|       |extension BagKey: Hashable {
  180|      0|    var hashValue: Int {
  181|      0|        return rawValue.hashValue
  182|      0|    }
  183|       |}
  184|       |
  185|      0|func ==(lhs: BagKey, rhs: BagKey) -> Bool {
  186|      0|    return lhs.rawValue == rhs.rawValue
  187|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/Platform/DataStructures/InfiniteSequence.swift:
    1|       |//
    2|       |//  InfiniteSequence.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Sequence that repeats `repeatedValue` infinite number of times.
   10|       |struct InfiniteSequence<E> : Sequence {
   11|       |    typealias Element = E
   12|       |    typealias Iterator = AnyIterator<E>
   13|       |    
   14|       |    private let _repeatedValue: E
   15|       |    
   16|      0|    init(repeatedValue: E) {
   17|      0|        _repeatedValue = repeatedValue
   18|      0|    }
   19|       |    
   20|      0|    func makeIterator() -> Iterator {
   21|      0|        let repeatedValue = _repeatedValue
   22|      0|        return AnyIterator {
   23|      0|            return repeatedValue
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/Platform/DataStructures/PriorityQueue.swift:
    1|       |//
    2|       |//  PriorityQueue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct PriorityQueue<Element> {
   10|       |    private let _hasHigherPriority: (Element, Element) -> Bool
   11|       |    private let _isEqual: (Element, Element) -> Bool
   12|       |
   13|       |    fileprivate var _elements = [Element]()
   14|       |
   15|      0|    init(hasHigherPriority: @escaping (Element, Element) -> Bool, isEqual: @escaping (Element, Element) -> Bool) {
   16|      0|        _hasHigherPriority = hasHigherPriority
   17|      0|        _isEqual = isEqual
   18|      0|    }
   19|       |
   20|      0|    mutating func enqueue(_ element: Element) {
   21|      0|        _elements.append(element)
   22|      0|        bubbleToHigherPriority(_elements.count - 1)
   23|      0|    }
   24|       |
   25|      0|    func peek() -> Element? {
   26|      0|        return _elements.first
   27|      0|    }
   28|       |
   29|      0|    var isEmpty: Bool {
   30|      0|        return _elements.count == 0
   31|      0|    }
   32|       |
   33|      0|    mutating func dequeue() -> Element? {
   34|      0|        guard let front = peek() else {
   35|      0|            return nil
   36|      0|        }
   37|      0|
   38|      0|        removeAt(0)
   39|      0|
   40|      0|        return front
   41|      0|    }
   42|       |
   43|      0|    mutating func remove(_ element: Element) {
   44|      0|        for i in 0 ..< _elements.count {
   45|      0|            if _isEqual(_elements[i], element) {
   46|      0|                removeAt(i)
   47|      0|                return
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |
   52|      0|    private mutating func removeAt(_ index: Int) {
   53|      0|        let removingLast = index == _elements.count - 1
   54|      0|        if !removingLast {
   55|      0|            swap(&_elements[index], &_elements[_elements.count - 1])
   56|      0|        }
   57|      0|
   58|      0|        _ = _elements.popLast()
   59|      0|
   60|      0|        if !removingLast {
   61|      0|            bubbleToHigherPriority(index)
   62|      0|            bubbleToLowerPriority(index)
   63|      0|        }
   64|      0|    }
   65|       |
   66|      0|    private mutating func bubbleToHigherPriority(_ initialUnbalancedIndex: Int) {
   67|      0|        precondition(initialUnbalancedIndex >= 0)
   68|      0|        precondition(initialUnbalancedIndex < _elements.count)
   69|      0|
   70|      0|        var unbalancedIndex = initialUnbalancedIndex
   71|      0|
   72|      0|        while unbalancedIndex > 0 {
   73|      0|            let parentIndex = (unbalancedIndex - 1) / 2
   74|      0|            guard _hasHigherPriority(_elements[unbalancedIndex], _elements[parentIndex]) else { break }
   75|      0|            
   76|      0|            swap(&_elements[unbalancedIndex], &_elements[parentIndex])
   77|      0|            unbalancedIndex = parentIndex
   78|      0|        }
   79|      0|    }
   80|       |
   81|      0|    private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {
   82|      0|        precondition(initialUnbalancedIndex >= 0)
   83|      0|        precondition(initialUnbalancedIndex < _elements.count)
   84|      0|
   85|      0|        var unbalancedIndex = initialUnbalancedIndex
   86|      0|        while true {
   87|      0|            let leftChildIndex = unbalancedIndex * 2 + 1
   88|      0|            let rightChildIndex = unbalancedIndex * 2 + 2
   89|      0|
   90|      0|            var highestPriorityIndex = unbalancedIndex
   91|      0|
   92|      0|            if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {
   93|      0|                highestPriorityIndex = leftChildIndex
   94|      0|            }
   95|      0|
   96|      0|            if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {
   97|      0|                highestPriorityIndex = rightChildIndex
   98|      0|            }
   99|      0|
  100|      0|            guard highestPriorityIndex != unbalancedIndex else { break }
  101|      0|
  102|      0|            swap(&_elements[highestPriorityIndex], &_elements[unbalancedIndex])
  103|      0|            unbalancedIndex = highestPriorityIndex
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |extension PriorityQueue : CustomDebugStringConvertible {
  109|      0|    var debugDescription: String {
  110|      0|        return _elements.debugDescription
  111|      0|    }
  112|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/Platform/DataStructures/Queue.swift:
    1|       |//
    2|       |//  Queue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Data structure that represents queue.
   11|       |
   12|       |Complexity of `enqueue`, `dequeue` is O(1) when number of operations is
   13|       |averaged over N operations.
   14|       |
   15|       |Complexity of `peek` is O(1).
   16|       |*/
   17|       |struct Queue<T>: Sequence {
   18|       |    /// Type of generator.
   19|       |    typealias Generator = AnyIterator<T>
   20|       |
   21|       |    private let _resizeFactor = 2
   22|       |    
   23|       |    private var _storage: ContiguousArray<T?>
   24|       |    private var _count = 0
   25|       |    private var _pushNextIndex = 0
   26|       |    private let _initialCapacity: Int
   27|       |
   28|       |    /**
   29|       |    Creates new queue.
   30|       |    
   31|       |    - parameter capacity: Capacity of newly created queue.
   32|       |    */
   33|      0|    init(capacity: Int) {
   34|      0|        _initialCapacity = capacity
   35|      0|
   36|      0|        _storage = ContiguousArray<T?>(repeating: nil, count: capacity)
   37|      0|    }
   38|       |    
   39|      0|    private var dequeueIndex: Int {
   40|      0|        let index = _pushNextIndex - count
   41|      0|        return index < 0 ? index + _storage.count : index
   42|      0|    }
   43|       |    
   44|       |    /// - returns: Is queue empty.
   45|      0|    var isEmpty: Bool {
   46|      0|        return count == 0
   47|      0|    }
   48|       |    
   49|       |    /// - returns: Number of elements inside queue.
   50|      0|    var count: Int {
   51|      0|        return _count
   52|      0|    }
   53|       |    
   54|       |    /// - returns: Element in front of a list of elements to `dequeue`.
   55|      0|    func peek() -> T {
   56|      0|        precondition(count > 0)
   57|      0|        
   58|      0|        return _storage[dequeueIndex]!
   59|      0|    }
   60|       |    
   61|      0|    mutating private func resizeTo(_ size: Int) {
   62|      0|        var newStorage = ContiguousArray<T?>(repeating: nil, count: size)
   63|      0|        
   64|      0|        let count = _count
   65|      0|        
   66|      0|        let dequeueIndex = self.dequeueIndex
   67|      0|        let spaceToEndOfQueue = _storage.count - dequeueIndex
   68|      0|        
   69|      0|        // first batch is from dequeue index to end of array
   70|      0|        let countElementsInFirstBatch = Swift.min(count, spaceToEndOfQueue)
   71|      0|        // second batch is wrapped from start of array to end of queue
   72|      0|        let numberOfElementsInSecondBatch = count - countElementsInFirstBatch
   73|      0|        
   74|      0|        newStorage[0 ..< countElementsInFirstBatch] = _storage[dequeueIndex ..< (dequeueIndex + countElementsInFirstBatch)]
   75|      0|        newStorage[countElementsInFirstBatch ..< (countElementsInFirstBatch + numberOfElementsInSecondBatch)] = _storage[0 ..< numberOfElementsInSecondBatch]
   76|      0|        
   77|      0|        _count = count
   78|      0|        _pushNextIndex = count
   79|      0|        _storage = newStorage
   80|      0|    }
   81|       |    
   82|       |    /// Enqueues `element`.
   83|       |    ///
   84|       |    /// - parameter element: Element to enqueue.
   85|      0|    mutating func enqueue(_ element: T) {
   86|      0|        if count == _storage.count {
   87|      0|            resizeTo(Swift.max(_storage.count, 1) * _resizeFactor)
   88|      0|        }
   89|      0|        
   90|      0|        _storage[_pushNextIndex] = element
   91|      0|        _pushNextIndex += 1
   92|      0|        _count += 1
   93|      0|        
   94|      0|        if _pushNextIndex >= _storage.count {
   95|      0|            _pushNextIndex -= _storage.count
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    private mutating func dequeueElementOnly() -> T {
  100|      0|        precondition(count > 0)
  101|      0|        
  102|      0|        let index = dequeueIndex
  103|      0|
  104|      0|        defer {
  105|      0|            _storage[index] = nil
  106|      0|            _count -= 1
  107|      0|        }
  108|      0|
  109|      0|        return _storage[index]!
  110|      0|    }
  111|       |
  112|       |    /// Dequeues element or throws an exception in case queue is empty.
  113|       |    ///
  114|       |    /// - returns: Dequeued element.
  115|      0|    mutating func dequeue() -> T? {
  116|      0|        if self.count == 0 {
  117|      0|            return nil
  118|      0|        }
  119|      0|
  120|      0|        defer {
  121|      0|            let downsizeLimit = _storage.count / (_resizeFactor * _resizeFactor)
  122|      0|            if _count < downsizeLimit && downsizeLimit >= _initialCapacity {
  123|      0|                resizeTo(_storage.count / _resizeFactor)
  124|      0|            }
  125|      0|        }
  126|      0|
  127|      0|        return dequeueElementOnly()
  128|      0|    }
  129|       |    
  130|       |    /// - returns: Generator of contained elements.
  131|      0|    func makeIterator() -> AnyIterator<T> {
  132|      0|        var i = dequeueIndex
  133|      0|        var count = _count
  134|      0|
  135|      0|        return AnyIterator {
  136|      0|            if count == 0 {
  137|      0|                return nil
  138|      0|            }
  139|      0|
  140|      0|            defer {
  141|      0|                count -= 1
  142|      0|                i += 1
  143|      0|            }
  144|      0|
  145|      0|            if i >= self._storage.count {
  146|      0|                i -= self._storage.count
  147|      0|            }
  148|      0|
  149|      0|            return self._storage[i]
  150|      0|        }
  151|      0|    }
  152|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/Platform/DispatchQueue+Extensions.swift:
    1|       |//
    2|       |//  DispatchQueue+Extensions.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/22/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |extension DispatchQueue {
   12|       |    private static var token: DispatchSpecificKey<()> = {
   13|       |        let key = DispatchSpecificKey<()>()
   14|       |        DispatchQueue.main.setSpecific(key: key, value: ())
   15|       |        return key
   16|       |    }()
   17|       |
   18|      0|    static var isMain: Bool {
   19|      0|        return DispatchQueue.getSpecific(key: token) != nil
   20|      0|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/Platform/Platform.Darwin.swift:
    1|       |//
    2|       |//  Platform.Darwin.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
   10|       |
   11|       |    import Darwin
   12|       |    import class Foundation.Thread
   13|       |    import func Foundation.OSAtomicCompareAndSwap32Barrier
   14|       |    import func Foundation.OSAtomicIncrement32Barrier
   15|       |    import func Foundation.OSAtomicDecrement32Barrier
   16|       |    import protocol Foundation.NSCopying
   17|       |
   18|       |    typealias AtomicInt = Int32
   19|       |
   20|      0|    fileprivate func castToUInt32Pointer(_ pointer: UnsafeMutablePointer<Int32>) -> UnsafeMutablePointer<UInt32> {
   21|      0|        let raw = UnsafeMutableRawPointer(pointer)
   22|      0|        return raw.assumingMemoryBound(to: UInt32.self)
   23|      0|    }
   24|       |
   25|       |    let AtomicCompareAndSwap = OSAtomicCompareAndSwap32Barrier
   26|       |    let AtomicIncrement = OSAtomicIncrement32Barrier
   27|       |    let AtomicDecrement = OSAtomicDecrement32Barrier
   28|      0|    func AtomicOr(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Int32 {
   29|      0|        return OSAtomicOr32OrigBarrier(mask, castToUInt32Pointer(theValue))
   30|      0|    }
   31|      0|    func AtomicFlagSet(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Bool {
   32|      0|        // just used to create a barrier
   33|      0|        OSAtomicXor32OrigBarrier(0, castToUInt32Pointer(theValue))
   34|      0|        return (theValue.pointee & Int32(mask)) != 0
   35|      0|    }
   36|       |
   37|       |    extension Thread {
   38|       |
   39|       |        static func setThreadLocalStorageValue<T: AnyObject>(_ value: T?, forKey key: NSCopying
   40|      0|            ) {
   41|      0|            let currentThread = Thread.current
   42|      0|            let threadDictionary = currentThread.threadDictionary
   43|      0|
   44|      0|            if let newValue = value {
   45|      0|                threadDictionary[key] = newValue
   46|      0|            }
   47|      0|            else {
   48|      0|                threadDictionary[key] = nil
   49|      0|            }
   50|      0|
   51|      0|        }
   52|      0|        static func getThreadLocalStorageValueForKey<T>(_ key: NSCopying) -> T? {
   53|      0|            let currentThread = Thread.current
   54|      0|            let threadDictionary = currentThread.threadDictionary
   55|      0|            
   56|      0|            return threadDictionary[key] as? T
   57|      0|        }
   58|       |    }
   59|       |
   60|       |    extension AtomicInt {
   61|      0|        func valueSnapshot() -> Int32 {
   62|      0|            return self
   63|      0|        }
   64|       |    }
   65|       |    
   66|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/Any+Equatable.swift:
    1|       |//
    2|       |//  Any+Equatable.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// A way to use built in XCTest methods with objects that are partially equatable.
   10|       |///
   11|       |/// If this can be done simpler, PRs are welcome :)
   12|       |struct AnyEquatable<Target>
   13|       |    : Equatable {
   14|       |    typealias Comparer = (Target, Target) -> Bool
   15|       |
   16|       |    let _target: Target
   17|       |    let _comparer: Comparer
   18|       |
   19|      0|    init(target: Target, comparer: @escaping Comparer) {
   20|      0|        _target = target
   21|      0|        _comparer = comparer
   22|      0|    }
   23|       |}
   24|       |
   25|      0|func == <T>(lhs: AnyEquatable<T>, rhs: AnyEquatable<T>) -> Bool {
   26|      0|    return lhs._comparer(lhs._target, rhs._target)
   27|      0|}
   28|       |
   29|       |extension AnyEquatable
   30|       |    : CustomDebugStringConvertible
   31|       |    , CustomStringConvertible  {
   32|      0|    var description: String {
   33|      0|        return "\(_target)"
   34|      0|    }
   35|       |
   36|      0|    var debugDescription: String {
   37|      0|        return "\(_target)"
   38|      0|    }
   39|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/ColdObservable.swift:
    1|       |//
    2|       |//  ColdObservable.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// A representation of cold observable sequence.
   12|       |///
   13|       |/// Recorded events are replayed after subscription once per subscriber.
   14|       |///
   15|       |/// Event times represent relative offset to subscription time.
   16|       |final class ColdObservable<Element>
   17|       |    : TestableObservable<Element> {
   18|       |
   19|      0|    override init(testScheduler: TestScheduler, recordedEvents: [Recorded<Event<Element>>]) {
   20|      0|        super.init(testScheduler: testScheduler, recordedEvents: recordedEvents)
   21|      0|    }
   22|       |
   23|       |    /// Subscribes `observer` to receive events for this sequence.
   24|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   25|      0|        subscriptions.append(Subscription(testScheduler.clock))
   26|      0|        
   27|      0|        let i = self.subscriptions.count - 1
   28|      0|
   29|      0|        for recordedEvent in recordedEvents {
   30|      0|            _ = testScheduler.scheduleRelativeVirtual((), dueTime: recordedEvent.time, action: { (_) in
   31|      0|                observer.on(recordedEvent.value)
   32|      0|                return Disposables.create()
   33|      0|            })
   34|      0|        }
   35|      0|        
   36|      0|        return Disposables.create {
   37|      0|            let existing = self.subscriptions[i]
   38|      0|            self.subscriptions[i] = Subscription(existing.subscribe, self.testScheduler.clock)
   39|      0|        }
   40|      0|    }
   41|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/Event+Equatable.swift:
    1|       |//
    2|       |//  Event+Equatable.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |import class Foundation.NSError
   11|       |
   12|       |/// Compares two events. They are equal if they are both the same member of `Event` enumeration.
   13|       |///
   14|       |/// In case `Error` events are being compared, they are equal in case their `NSError` representations are equal (domain and code)
   15|       |/// and their string representations are equal.
   16|      0|public func == <Element: Equatable>(lhs: Event<Element>, rhs: Event<Element>) -> Bool {
   17|      0|    switch (lhs, rhs) {
   18|      0|    case (.completed, .completed): return true
   19|      0|    case (.error(let e1), .error(let e2)):
   20|      0|        #if os(Linux)
   21|      0|          return  "\(e1)" == "\(e2)"
   22|      0|        #else
   23|      0|          let error1 = e1 as NSError
   24|      0|          let error2 = e2 as NSError
   25|      0|
   26|      0|          return error1.domain == error2.domain
   27|      0|              && error1.code == error2.code
   28|      0|              && "\(e1)" == "\(e2)"
   29|      0|        #endif
   30|      0|    case (.next(let v1), .next(let v2)): return v1 == v2
   31|      0|    default: return false
   32|      0|    }
   33|      0|}
   34|       |
   35|       |/// Compares two events. They are equal if they are both the same member of `Event` enumeration.
   36|       |///
   37|       |/// In case `Error` events are being compared, they are equal in case their `NSError` representations are equal (domain and code)
   38|       |/// and their string representations are equal.
   39|      0|public func == <Element: Equatable>(lhs: SingleEvent<Element>, rhs: SingleEvent<Element>) -> Bool {
   40|      0|    switch (lhs, rhs) {
   41|      0|    case (.error(let e1), .error(let e2)):
   42|      0|        #if os(Linux)
   43|      0|            return  "\(e1)" == "\(e2)"
   44|      0|        #else
   45|      0|            let error1 = e1 as NSError
   46|      0|            let error2 = e2 as NSError
   47|      0|
   48|      0|            return error1.domain == error2.domain
   49|      0|                && error1.code == error2.code
   50|      0|                && "\(e1)" == "\(e2)"
   51|      0|        #endif
   52|      0|    case (.success(let v1), .success(let v2)): return v1 == v2
   53|      0|    default: return false
   54|      0|    }
   55|      0|}
   56|       |
   57|       |/// Compares two events. They are equal if they are both the same member of `Event` enumeration.
   58|       |///
   59|       |/// In case `Error` events are being compared, they are equal in case their `NSError` representations are equal (domain and code)
   60|       |/// and their string representations are equal.
   61|      0|public func == <Element: Equatable>(lhs: MaybeEvent<Element>, rhs: MaybeEvent<Element>) -> Bool {
   62|      0|    switch (lhs, rhs) {
   63|      0|    case (.completed, .completed): return true
   64|      0|    case (.error(let e1), .error(let e2)):
   65|      0|        #if os(Linux)
   66|      0|            return  "\(e1)" == "\(e2)"
   67|      0|        #else
   68|      0|            let error1 = e1 as NSError
   69|      0|            let error2 = e2 as NSError
   70|      0|
   71|      0|            return error1.domain == error2.domain
   72|      0|                && error1.code == error2.code
   73|      0|                && "\(e1)" == "\(e2)"
   74|      0|        #endif
   75|      0|    case (.success(let v1), .success(let v2)): return v1 == v2
   76|      0|    default: return false
   77|      0|    }
   78|      0|}
   79|       |
   80|       |/// Compares two events. They are equal if they are both the same member of `Event` enumeration.
   81|       |///
   82|       |/// In case `Error` events are being compared, they are equal in case their `NSError` representations are equal (domain and code)
   83|       |/// and their string representations are equal.
   84|      0|public func == (lhs: CompletableEvent, rhs: CompletableEvent) -> Bool {
   85|      0|    switch (lhs, rhs) {
   86|      0|    case (.completed, .completed): return true
   87|      0|    case (.error(let e1), .error(let e2)):
   88|      0|        #if os(Linux)
   89|      0|            return  "\(e1)" == "\(e2)"
   90|      0|        #else
   91|      0|            let error1 = e1 as NSError
   92|      0|            let error2 = e2 as NSError
   93|      0|
   94|      0|            return error1.domain == error2.domain
   95|      0|                && error1.code == error2.code
   96|      0|                && "\(e1)" == "\(e2)"
   97|      0|        #endif
   98|      0|    default: return false
   99|      0|    }
  100|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/HotObservable.swift:
    1|       |//
    2|       |//  HotObservable.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// A representation of hot observable sequence.
   12|       |///
   13|       |/// Recorded events are replayed at absolute times no matter is there any subscriber.
   14|       |///
   15|       |/// Event times represent absolute `TestScheduler` time.
   16|       |final class HotObservable<Element>
   17|       |    : TestableObservable<Element> {
   18|       |
   19|       |    typealias Observer = (Event<Element>) -> ()
   20|       |    typealias Observers = Bag<Observer>
   21|       |
   22|       |    /// Current subscribed observers.
   23|       |    private var _observers: Observers
   24|       |
   25|      0|    override init(testScheduler: TestScheduler, recordedEvents: [Recorded<Event<Element>>]) {
   26|      0|        _observers = Observers()
   27|      0|        
   28|      0|        super.init(testScheduler: testScheduler, recordedEvents: recordedEvents)
   29|      0|
   30|      0|        for recordedEvent in recordedEvents {
   31|      0|            testScheduler.scheduleAt(recordedEvent.time) { t in
   32|      0|                self._observers.forEach {
   33|      0|                    $0(recordedEvent.value)
   34|      0|                }
   35|      0|            }
   36|      0|        }
   37|      0|    }
   38|       |
   39|       |    /// Subscribes `observer` to receive events for this sequence.
   40|      0|    override func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   41|      0|        let key = _observers.insert(observer.on)
   42|      0|        subscriptions.append(Subscription(self.testScheduler.clock))
   43|      0|        
   44|      0|        let i = self.subscriptions.count - 1
   45|      0|        
   46|      0|        return Disposables.create {
   47|      0|            let removed = self._observers.removeKey(key)
   48|      0|            assert(removed != nil)
   49|      0|            
   50|      0|            let existing = self.subscriptions[i]
   51|      0|            self.subscriptions[i] = Subscription(existing.subscribe, self.testScheduler.clock)
   52|      0|        }
   53|      0|    }
   54|       |}
   55|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/Recorded.swift:
    1|       |//
    2|       |//  Recorded.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |import Swift
   11|       |
   12|       |/// Record of a value including the virtual time it was produced on.
   13|       |public struct Recorded<Value>
   14|       |    : CustomDebugStringConvertible {
   15|       |
   16|       |    /// Gets the virtual time the value was produced on.
   17|       |    public let time: TestTime
   18|       |
   19|       |    /// Gets the recorded value.
   20|       |    public let value: Value
   21|       |    
   22|      2|    public init(time: TestTime, value: Value) {
   23|      2|        self.time = time
   24|      2|        self.value = value
   25|      2|    }
   26|       |}
   27|       |
   28|       |extension Recorded {
   29|       |    /// A textual representation of `self`, suitable for debugging.
   30|      0|    public var debugDescription: String {
   31|      0|        return "\(value) @ \(time)"
   32|      0|    }
   33|       |}
   34|       |
   35|      0|public func == <T: Equatable>(lhs: Recorded<T>, rhs: Recorded<T>) -> Bool {
   36|      0|    return lhs.time == rhs.time && lhs.value == rhs.value
   37|      0|}
   38|       |
   39|      0|public func == <T: Equatable>(lhs: Recorded<Event<T>>, rhs: Recorded<Event<T>>) -> Bool {
   40|      0|    return lhs.time == rhs.time && lhs.value == rhs.value
   41|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/Schedulers/TestScheduler.swift:
    1|       |//
    2|       |//  TestScheduler.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/8/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// Virtual time scheduler used for testing applications and libraries built using RxSwift.
   12|       |public class TestScheduler : VirtualTimeScheduler<TestSchedulerVirtualTimeConverter> {
   13|       |    /// Default values of scheduler times.
   14|       |    public struct Defaults {
   15|       |        /// Default absolute time when to create tested observable sequence.
   16|       |        public static let created = 100
   17|       |        /// Default absolute time when to subscribe to tested observable sequence.
   18|       |        public static let subscribed = 200
   19|       |        /// Default absolute time when to dispose subscription to tested observable sequence.
   20|       |        public static let disposed = 1000
   21|       |    }
   22|       |
   23|       |    private let _simulateProcessingDelay: Bool
   24|       |
   25|       |    /**
   26|       |     Creates a new test scheduler.
   27|       |     
   28|       |     - parameter initialClock: Initial value for the clock.
   29|       |     - parameter resolution: Real time [NSTimeInterval] = ticks * resolution 
   30|       |     - parameter simulateProcessingDelay: When true, if something is scheduled right `now`, 
   31|       |        it will be scheduled to `now + 1` in virtual time.
   32|       |    */
   33|      7|    public init(initialClock: TestTime, resolution: Double = 1.0, simulateProcessingDelay: Bool = true) {
   34|      7|        _simulateProcessingDelay = simulateProcessingDelay
   35|      7|        super.init(initialClock: initialClock, converter: TestSchedulerVirtualTimeConverter(resolution: resolution))
   36|      7|    }
   37|       |
   38|       |    /**
   39|       |    Creates a hot observable using the specified timestamped events.
   40|       |     
   41|       |    - parameter events: Events to surface through the created sequence at their specified absolute virtual times.
   42|       |    - returns: Hot observable sequence that can be used to assert the timing of subscriptions and events.
   43|       |    */
   44|      0|    public func createHotObservable<Element>(_ events: [Recorded<Event<Element>>]) -> TestableObservable<Element> {
   45|      0|        return HotObservable(testScheduler: self as AnyObject as! TestScheduler, recordedEvents: events)
   46|      0|    }
   47|       |
   48|       |    /**
   49|       |    Creates a cold observable using the specified timestamped events.
   50|       |     
   51|       |     - parameter events: Events to surface through the created sequence at their specified virtual time offsets from the sequence subscription time.
   52|       |     - returns: Cold observable sequence that can be used to assert the timing of subscriptions and events.
   53|       |    */
   54|      0|    public func createColdObservable<Element>(_ events: [Recorded<Event<Element>>]) -> TestableObservable<Element> {
   55|      0|        return ColdObservable(testScheduler: self as AnyObject as! TestScheduler, recordedEvents: events)
   56|      0|    }
   57|       |
   58|       |    /**
   59|       |    Creates an observer that records received events and timestamps those.
   60|       |    
   61|       |     - parameter type: Optional type hint of the observed sequence elements.
   62|       |     - returns: Observer that can be used to assert the timing of events.
   63|       |    */
   64|      1|    public func createObserver<E>(_ type: E.Type) -> TestableObserver<E> {
   65|      1|        return TestableObserver(scheduler: self as AnyObject as! TestScheduler)
   66|      1|    }
   67|       |
   68|       |    /**
   69|       |     Schedules an action to be executed at the specified virtual time.
   70|       |
   71|       |     - parameter time: Absolute virtual time at which to execute the action.
   72|       |     */
   73|      1|    public func scheduleAt(_ time: TestTime, action: @escaping () -> Void) {
   74|      1|        _ = self.scheduleAbsoluteVirtual((), time: time, action: { () -> Disposable in
   75|      1|            action()
   76|      1|            return Disposables.create()
   77|      1|        })
   78|      1|    }
   79|       |
   80|       |    /**
   81|       |    Adjusts time of scheduling before adding item to schedule queue. If scheduled time is `<= clock`, then it is scheduled at `clock + 1`
   82|       |    */
   83|      0|    override public func adjustScheduledTime(_ time: VirtualTime) -> VirtualTime {
   84|      0|        return time <= clock ? clock + (_simulateProcessingDelay ? 1 : 0) : time
   85|      0|    }
   86|       |
   87|       |    /**
   88|       |    Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
   89|       |    
   90|       |    - parameter create: Factory method to create an observable sequence.
   91|       |    - parameter created: Virtual time at which to invoke the factory to create an observable sequence.
   92|       |    - parameter subscribed: Virtual time at which to subscribe to the created observable sequence.
   93|       |    - parameter disposed: Virtual time at which to dispose the subscription.
   94|       |    - returns: Observer with timestamped recordings of events that were received during the virtual time window when the subscription to the source sequence was active.
   95|       |    */
   96|      0|    public func start<Element>(_ created: TestTime, subscribed: TestTime, disposed: TestTime, create: @escaping () -> Observable<Element>) -> TestableObserver<Element> {
   97|      0|        var source : Observable<Element>? = nil
   98|      0|        var subscription : Disposable? = nil
   99|      0|        let observer = createObserver(Element.self)
  100|      0|        
  101|      0|        _ = self.scheduleAbsoluteVirtual((), time: created) {
  102|      0|            source = create()
  103|      0|            return Disposables.create()
  104|      0|        }
  105|      0|        
  106|      0|        _ = self.scheduleAbsoluteVirtual((), time: subscribed) {
  107|      0|            subscription = source!.subscribe(observer)
  108|      0|            return Disposables.create()
  109|      0|        }
  110|      0|        
  111|      0|        _ = self.scheduleAbsoluteVirtual((), time: disposed) {
  112|      0|            subscription!.dispose()
  113|      0|            return Disposables.create()
  114|      0|        }
  115|      0|
  116|      0|        start()
  117|      0|        
  118|      0|        return observer
  119|      0|    }
  120|       |
  121|       |    /**
  122|       |     Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
  123|       |
  124|       |     Observable sequence will be:
  125|       |     * created at virtual time `Defaults.created`           -> 100
  126|       |     * subscribed to at virtual time `Defaults.subscribed`  -> 200
  127|       |
  128|       |     - parameter create: Factory method to create an observable sequence.
  129|       |     - parameter disposed: Virtual time at which to dispose the subscription.
  130|       |     - returns: Observer with timestamped recordings of events that were received during the virtual time window when the subscription to the source sequence was active.
  131|       |     */
  132|      0|    public func start<Element>(_ disposed: TestTime, create: @escaping () -> Observable<Element>) -> TestableObserver<Element> {
  133|      0|        return start(Defaults.created, subscribed: Defaults.subscribed, disposed: disposed, create: create)
  134|      0|    }
  135|       |
  136|       |    /**
  137|       |     Starts the test scheduler and uses the specified virtual times to invoke the factory function, subscribe to the resulting sequence, and dispose the subscription.
  138|       |
  139|       |     Observable sequence will be:
  140|       |     * created at virtual time `Defaults.created`           -> 100
  141|       |     * subscribed to at virtual time `Defaults.subscribed`  -> 200
  142|       |     * subscription will be disposed at `Defaults.disposed` -> 1000
  143|       |
  144|       |     - parameter create: Factory method to create an observable sequence.
  145|       |     - returns: Observer with timestamped recordings of events that were received during the virtual time window when the subscription to the source sequence was active.
  146|       |     */
  147|      0|    public func start<Element>(_ create: @escaping () -> Observable<Element>) -> TestableObserver<Element> {
  148|      0|        return start(Defaults.created, subscribed: Defaults.subscribed, disposed: Defaults.disposed, create: create)
  149|      0|    }
  150|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/Schedulers/TestSchedulerVirtualTimeConverter.swift:
    1|       |//
    2|       |//  TestSchedulerVirtualTimeConverter.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.Date
   10|       |import RxSwift
   11|       |
   12|       |/// Converter from virtual time and time interval measured in `Int`s to `Date` and `NSTimeInterval`.
   13|       |public struct TestSchedulerVirtualTimeConverter : VirtualTimeConverterType {
   14|       |    /// Virtual time unit used that represents ticks of virtual clock.
   15|       |    public typealias VirtualTimeUnit = Int
   16|       |
   17|       |    /// Virtual time unit used to represent differences of virtual times.
   18|       |    public typealias VirtualTimeIntervalUnit = Int
   19|       |
   20|       |    private let _resolution: Double
   21|       |
   22|      7|    init(resolution: Double) {
   23|      7|        _resolution = resolution
   24|      7|    }
   25|       |
   26|       |
   27|       |    /// Converts virtual time to real time.
   28|       |    ///
   29|       |    /// - parameter virtualTime: Virtual time to convert to `Date`.
   30|       |    /// - returns: `Date` corresponding to virtual time.
   31|      0|    public func convertFromVirtualTime(_ virtualTime: VirtualTimeUnit) -> RxTime {
   32|      0|        return Date(timeIntervalSince1970: RxTimeInterval(virtualTime) * _resolution)
   33|      0|    }
   34|       |
   35|       |    /// Converts real time to virtual time.
   36|       |    ///
   37|       |    /// - parameter time: `Date` to convert to virtual time.
   38|       |    /// - returns: Virtual time corresponding to `Date`.
   39|      0|    public func convertToVirtualTime(_ time: RxTime) -> VirtualTimeUnit {
   40|      0|        return VirtualTimeIntervalUnit(time.timeIntervalSince1970 / _resolution + 0.5)
   41|      0|    }
   42|       |
   43|       |    /// Converts from virtual time interval to `NSTimeInterval`.
   44|       |    ///
   45|       |    /// - parameter virtualTimeInterval: Virtual time interval to convert to `NSTimeInterval`.
   46|       |    /// - returns: `NSTimeInterval` corresponding to virtual time interval.
   47|      0|    public func convertFromVirtualTimeInterval(_ virtualTimeInterval: VirtualTimeIntervalUnit) -> RxTimeInterval {
   48|      0|        return RxTimeInterval(virtualTimeInterval) * _resolution
   49|      0|    }
   50|       |
   51|       |    /// Converts from virtual time interval to `NSTimeInterval`.
   52|       |    ///
   53|       |    /// - parameter timeInterval: `NSTimeInterval` to convert to virtual time interval.
   54|       |    /// - returns: Virtual time interval corresponding to time interval.
   55|      0|    public func convertToVirtualTimeInterval(_ timeInterval: RxTimeInterval) -> VirtualTimeIntervalUnit {
   56|      0|        return VirtualTimeIntervalUnit(timeInterval / _resolution + 0.5)
   57|      0|    }
   58|       |
   59|       |    /// Adds virtual time and virtual time interval.
   60|       |    ///
   61|       |    /// - parameter time: Virtual time.
   62|       |    /// - parameter offset: Virtual time interval.
   63|       |    /// - returns: Time corresponding to time offsetted by virtual time interval.
   64|      0|    public func offsetVirtualTime(_ time: VirtualTimeUnit, offset: VirtualTimeIntervalUnit) -> VirtualTimeUnit {
   65|      0|        return time + offset
   66|      0|    }
   67|       |
   68|       |    /// Compares virtual times.
   69|      1|    public func compareVirtualTime(_ lhs: VirtualTimeUnit, _ rhs: VirtualTimeUnit) -> VirtualTimeComparison {
   70|      0|        if lhs < rhs {
   71|      0|            return .lessThan
   72|      1|        }
   73|      1|        else if lhs > rhs {
   74|      1|            return .greaterThan
   75|      0|        }
   76|      0|        else {
   77|      0|            return .equal
   78|      0|        }
   79|      0|    }
   80|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/Subscription.swift:
    1|       |//
    2|       |//  Subscription.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Records information about subscriptions to and unsubscriptions from observable sequences.
   10|       |public struct Subscription
   11|       |    {
   12|       |
   13|       |    /// Subscription virtual time.
   14|       |    public let subscribe : Int
   15|       |    /// Unsubscription virtual time.
   16|       |    public let unsubscribe : Int
   17|       |
   18|       |    /// Creates a new subscription object with the given virtual subscription time.
   19|       |    ///
   20|       |    /// - parameter subscribe: Virtual time at which the subscription occurred.
   21|      0|    public init(_ subscribe: Int) {
   22|      0|        self.subscribe = subscribe
   23|      0|        self.unsubscribe = Int.max
   24|      0|    }
   25|       |
   26|       |    
   27|       |    /// Creates a new subscription object with the given virtual subscription and unsubscription time.
   28|       |    ///
   29|       |    /// - parameter subscribe: Virtual time at which the subscription occurred.
   30|       |    /// - parameter unsubscribe: Virtual time at which the unsubscription occurred.
   31|      0|    public init(_ subscribe: Int, _ unsubscribe: Int) {
   32|      0|        self.subscribe = subscribe
   33|      0|        self.unsubscribe = unsubscribe
   34|      0|    }
   35|       |}
   36|       |
   37|       |extension Subscription
   38|       |    : Hashable
   39|       |    , Equatable {
   40|       |    /// The hash value.
   41|      0|    public var hashValue : Int {
   42|      0|        return subscribe.hashValue ^ unsubscribe.hashValue
   43|      0|    }
   44|       |}
   45|       |
   46|       |extension Subscription
   47|       |    : CustomDebugStringConvertible {
   48|       |    /// A textual representation of `self`, suitable for debugging.
   49|      0|    public var debugDescription : String {
   50|      0|        let infiniteText = "Infinity"
   51|      0|        return "(\(subscribe) : \(unsubscribe != Int.max ? String(unsubscribe) : infiniteText))"
   52|      0|    }
   53|       |}
   54|       |
   55|      0|public func == (lhs: Subscription, rhs: Subscription) -> Bool {
   56|      0|    return lhs.subscribe == rhs.subscribe && lhs.unsubscribe == rhs.unsubscribe
   57|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/TestableObservable.swift:
    1|       |//
    2|       |//  TestableObservable.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// Observable sequence that records subscription lifetimes and timestamped events sent to observers.
   12|       |public class TestableObservable<Element>
   13|       |    : ObservableType {
   14|       |    public typealias E = Element
   15|       |    /// Subscriptions recorded during observable lifetime.
   16|       |    public internal(set) var subscriptions: [Subscription]
   17|       |
   18|       |    /// List of events to replay for all subscribers.
   19|       |    ///
   20|       |    /// Event times represent absolute `TestScheduler` time.
   21|       |    public internal(set) var recordedEvents: [Recorded<Event<Element>>]
   22|       |    
   23|       |    /// Parent test scheduler.
   24|       |    internal let testScheduler: TestScheduler
   25|       |
   26|      0|    init(testScheduler: TestScheduler, recordedEvents: [Recorded<Event<Element>>]) {
   27|      0|        self.testScheduler = testScheduler
   28|      0|        self.recordedEvents = recordedEvents
   29|      0|        self.subscriptions = []
   30|      0|    }
   31|       |
   32|      0|    public func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element {
   33|      0|        fatalError("Abstract method")
   34|      0|    }
   35|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/TestableObserver.swift:
    1|       |//
    2|       |//  TestableObserver.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/// Observer that records events together with virtual time when they were received.
   12|       |public final class TestableObserver<ElementType>
   13|       |    : ObserverType {
   14|       |    public typealias Element = ElementType
   15|       |    
   16|       |    fileprivate let _scheduler: TestScheduler
   17|       |
   18|       |    /// Recorded events.
   19|       |    public fileprivate(set) var events = [Recorded<Event<Element>>]()
   20|       |    
   21|      1|    init(scheduler: TestScheduler) {
   22|      1|        _scheduler = scheduler
   23|      1|    }
   24|       |
   25|       |    /// Notify observer about sequence event.
   26|       |    ///
   27|       |    /// - parameter event: Event that occured.
   28|      2|    public func on(_ event: Event<Element>) {
   29|      2|        events.append(Recorded(time: _scheduler.clock, value: event))
   30|      2|    }
   31|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxTest/RxTest/XCTest+Rx.swift:
    1|       |//
    2|       |//  XCTest+Rx.swift
    3|       |//  RxTest
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import RxSwift
   10|       |
   11|       |/**
   12|       |These methods are conceptually extensions of `XCTestCase` but because referencing them in closures would
   13|       |require specifying `self.*`, they are made global.
   14|       |*/
   15|       |//extension XCTestCase {
   16|       |    /**
   17|       |    Factory method for an `.next` event recorded at a given time with a given value.
   18|       |
   19|       |     - parameter time: Recorded virtual time the `.next` event occurs.
   20|       |     - parameter element: Next sequence element.
   21|       |     - returns: Recorded event in time.
   22|       |    */
   23|      0|    public func next<T>(_ time: TestTime, _ element: T) -> Recorded<Event<T>> {
   24|      0|        return Recorded(time: time, value: .next(element))
   25|      0|    }
   26|       |
   27|       |    /**
   28|       |    Factory method for an `.completed` event recorded at a given time.
   29|       |
   30|       |     - parameter time: Recorded virtual time the `.completed` event occurs.
   31|       |     - parameter type: Sequence elements type.
   32|       |     - returns: Recorded event in time.
   33|       |    */
   34|      0|    public func completed<T>(_ time: TestTime, _ type: T.Type = T.self) -> Recorded<Event<T>> {
   35|      0|        return Recorded(time: time, value: .completed)
   36|      0|    }
   37|       |
   38|       |    /**
   39|       |    Factory method for an `.error` event recorded at a given time with a given error.
   40|       |
   41|       |     - parameter time: Recorded virtual time the `.completed` event occurs.
   42|       |    */
   43|      0|    public func error<T>(_ time: TestTime, _ error: Swift.Error, _ type: T.Type = T.self) -> Recorded<Event<T>> {
   44|      0|        return Recorded(time: time, value: .error(error))
   45|      0|    }
   46|       |//}
   47|       |
   48|       |import XCTest
   49|       |/**
   50|       |Asserts two lists of events are equal.
   51|       |
   52|       |Event is considered equal if:
   53|       |* `Next` events are equal if they have equal corresponding elements.
   54|       |* `Error` events are equal if errors have same domain and code for `NSError` representation and have equal descriptions.
   55|       |* `Completed` events are always equal.
   56|       |
   57|       |- parameter lhs: first set of events.
   58|       |- parameter lhs: second set of events.
   59|       |*/
   60|      0|public func XCTAssertEqual<T: Equatable>(_ lhs: [Event<T>], _ rhs: [Event<T>], file: StaticString = #file, line: UInt = #line) {
   61|      0|    let leftEquatable = lhs.map { AnyEquatable(target: $0, comparer: ==) }
   62|      0|    let rightEquatable = rhs.map { AnyEquatable(target: $0, comparer: ==) }
   63|      0|    #if os(Linux)
   64|      0|      XCTAssertEqual(leftEquatable, rightEquatable)
   65|      0|    #else
   66|      0|      XCTAssertEqual(leftEquatable, rightEquatable, file: file, line: line)
   67|      0|    #endif
   68|      0|    if leftEquatable == rightEquatable {
   69|      0|        return
   70|      0|    }
   71|      0|
   72|      0|    printSequenceDifferences(lhs, rhs, ==)
   73|      0|}
   74|       |
   75|       |/**
   76|       | Asserts two lists of events are equal.
   77|       |
   78|       | Event is considered equal if:
   79|       | * `Next` events are equal if they have equal corresponding elements.
   80|       | * `Error` events are equal if errors have same domain and code for `NSError` representation and have equal descriptions.
   81|       | * `Completed` events are always equal.
   82|       |
   83|       | - parameter lhs: first set of events.
   84|       | - parameter lhs: second set of events.
   85|       | */
   86|      0|public func XCTAssertEqual<T: Equatable>(_ lhs: [SingleEvent<T>], _ rhs: [SingleEvent<T>], file: StaticString = #file, line: UInt = #line) {
   87|      0|    let leftEquatable = lhs.map { AnyEquatable(target: $0, comparer: ==) }
   88|      0|    let rightEquatable = rhs.map { AnyEquatable(target: $0, comparer: ==) }
   89|      0|    #if os(Linux)
   90|      0|        XCTAssertEqual(leftEquatable, rightEquatable)
   91|      0|    #else
   92|      0|        XCTAssertEqual(leftEquatable, rightEquatable, file: file, line: line)
   93|      0|    #endif
   94|      0|    if leftEquatable == rightEquatable {
   95|      0|        return
   96|      0|    }
   97|      0|
   98|      0|    printSequenceDifferences(lhs, rhs, ==)
   99|      0|}
  100|       |
  101|       |/**
  102|       | Asserts two lists of events are equal.
  103|       |
  104|       | Event is considered equal if:
  105|       | * `Next` events are equal if they have equal corresponding elements.
  106|       | * `Error` events are equal if errors have same domain and code for `NSError` representation and have equal descriptions.
  107|       | * `Completed` events are always equal.
  108|       |
  109|       | - parameter lhs: first set of events.
  110|       | - parameter lhs: second set of events.
  111|       | */
  112|      0|public func XCTAssertEqual<T: Equatable>(_ lhs: [MaybeEvent<T>], _ rhs: [MaybeEvent<T>], file: StaticString = #file, line: UInt = #line) {
  113|      0|    let leftEquatable = lhs.map { AnyEquatable(target: $0, comparer: ==) }
  114|      0|    let rightEquatable = rhs.map { AnyEquatable(target: $0, comparer: ==) }
  115|      0|    #if os(Linux)
  116|      0|        XCTAssertEqual(leftEquatable, rightEquatable)
  117|      0|    #else
  118|      0|        XCTAssertEqual(leftEquatable, rightEquatable, file: file, line: line)
  119|      0|    #endif
  120|      0|    if leftEquatable == rightEquatable {
  121|      0|        return
  122|      0|    }
  123|      0|
  124|      0|    printSequenceDifferences(lhs, rhs, ==)
  125|      0|}
  126|       |
  127|       |/**
  128|       | Asserts two lists of events are equal.
  129|       |
  130|       | Event is considered equal if:
  131|       | * `Next` events are equal if they have equal corresponding elements.
  132|       | * `Error` events are equal if errors have same domain and code for `NSError` representation and have equal descriptions.
  133|       | * `Completed` events are always equal.
  134|       |
  135|       | - parameter lhs: first set of events.
  136|       | - parameter lhs: second set of events.
  137|       | */
  138|      0|public func XCTAssertEqual(_ lhs: [CompletableEvent], _ rhs: [CompletableEvent], file: StaticString = #file, line: UInt = #line) {
  139|      0|    let leftEquatable = lhs.map { AnyEquatable(target: $0, comparer: ==) }
  140|      0|    let rightEquatable = rhs.map { AnyEquatable(target: $0, comparer: ==) }
  141|      0|    #if os(Linux)
  142|      0|        XCTAssertEqual(leftEquatable, rightEquatable)
  143|      0|    #else
  144|      0|        XCTAssertEqual(leftEquatable, rightEquatable, file: file, line: line)
  145|      0|    #endif
  146|      0|    if leftEquatable == rightEquatable {
  147|      0|        return
  148|      0|    }
  149|      0|
  150|      0|    printSequenceDifferences(lhs, rhs, ==)
  151|      0|}
  152|       |
  153|       |/**
  154|       |Asserts two lists of Recorded events are equal.
  155|       |
  156|       |Recorded events are equal if times are equal and recoreded events are equal.
  157|       |
  158|       |Event is considered equal if:
  159|       |* `Next` events are equal if they have equal corresponding elements.
  160|       |* `Error` events are equal if errors have same domain and code for `NSError` representation and have equal descriptions.
  161|       |* `Completed` events are always equal.
  162|       |
  163|       |- parameter lhs: first set of events.
  164|       |- parameter lhs: second set of events.
  165|       |*/
  166|      0|public func XCTAssertEqual<T: Equatable>(_ lhs: [Recorded<Event<T>>], _ rhs: [Recorded<Event<T>>], file: StaticString = #file, line: UInt = #line) {
  167|      0|    let leftEquatable = lhs.map { AnyEquatable(target: $0, comparer: ==) }
  168|      0|    let rightEquatable = rhs.map { AnyEquatable(target: $0, comparer: ==) }
  169|      0|    #if os(Linux)
  170|      0|      XCTAssertEqual(leftEquatable, rightEquatable)
  171|      0|    #else
  172|      0|      XCTAssertEqual(leftEquatable, rightEquatable, file: file, line: line)
  173|      0|    #endif
  174|      0|
  175|      0|    if leftEquatable == rightEquatable {
  176|      0|        return
  177|      0|    }
  178|      0|
  179|      0|    printSequenceDifferences(lhs, rhs, ==)
  180|      0|}
  181|       |
  182|      0|func printSequenceDifferences<E>(_ lhs: [E], _ rhs: [E], _ equal: (E, E) -> Bool) {
  183|      0|    print("Differences:")
  184|      0|    for (index, elements) in zip(lhs, rhs).enumerated() {
  185|      0|        let l = elements.0
  186|      0|        let r = elements.1
  187|      0|        if !equal(l, r) {
  188|      0|            print("lhs[\(index)]:\n    \(l)")
  189|      0|            print("rhs[\(index)]:\n    \(r)")
  190|      0|        }
  191|      0|    }
  192|      0|
  193|      0|    let shortest = min(lhs.count, rhs.count)
  194|      0|    for (index, element) in lhs[shortest ..< lhs.count].enumerated() {
  195|      0|        print("lhs[\(index + shortest)]:\n    \(element)")
  196|      0|    }
  197|      0|    for (index, element) in rhs[shortest ..< rhs.count].enumerated() {
  198|      0|        print("rhs[\(index + shortest)]:\n    \(element)")
  199|      0|    }
  200|      0|}

