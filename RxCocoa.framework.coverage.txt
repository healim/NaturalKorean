/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/Platform/DataStructures/Bag.swift:
    1|       |//
    2|       |//  Bag.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Swift
   10|       |
   11|       |let arrayDictionaryMaxSize = 30
   12|       |
   13|       |struct BagKey {
   14|       |    /**
   15|       |    Unique identifier for object added to `Bag`.
   16|       |     
   17|       |    It's underlying type is UInt64. If we assume there in an idealized CPU that works at 4GHz,
   18|       |     it would take ~150 years of continuous running time for it to overflow.
   19|       |    */
   20|       |    fileprivate let rawValue: UInt64
   21|       |}
   22|       |
   23|       |/**
   24|       |Data structure that represents a bag of elements typed `T`.
   25|       |
   26|       |Single element can be stored multiple times.
   27|       |
   28|       |Time and space complexity of insertion an deletion is O(n). 
   29|       |
   30|       |It is suitable for storing small number of elements.
   31|       |*/
   32|       |struct Bag<T> : CustomDebugStringConvertible {
   33|       |    /// Type of identifier for inserted elements.
   34|       |    typealias KeyType = BagKey
   35|       |    
   36|       |    typealias Entry = (key: BagKey, value: T)
   37|       | 
   38|       |    fileprivate var _nextKey: BagKey = BagKey(rawValue: 0)
   39|       |
   40|       |    // data
   41|       |
   42|       |    // first fill inline variables
   43|       |    var _key0: BagKey? = nil
   44|       |    var _value0: T? = nil
   45|       |
   46|       |    // then fill "array dictionary"
   47|       |    var _pairs = ContiguousArray<Entry>()
   48|       |
   49|       |    // last is sparse dictionary
   50|       |    var _dictionary: [BagKey : T]? = nil
   51|       |
   52|       |    var _onlyFastPath = true
   53|       |
   54|       |    /// Creates new empty `Bag`.
   55|      0|    init() {
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |    Inserts `value` into bag.
   60|       |    
   61|       |    - parameter element: Element to insert.
   62|       |    - returns: Key that can be used to remove element from bag.
   63|       |    */
   64|      0|    mutating func insert(_ element: T) -> BagKey {
   65|      0|        let key = _nextKey
   66|      0|
   67|      0|        _nextKey = BagKey(rawValue: _nextKey.rawValue &+ 1)
   68|      0|
   69|      0|        if _key0 == nil {
   70|      0|            _key0 = key
   71|      0|            _value0 = element
   72|      0|            return key
   73|      0|        }
   74|      0|
   75|      0|        _onlyFastPath = false
   76|      0|
   77|      0|        if _dictionary != nil {
   78|      0|            _dictionary![key] = element
   79|      0|            return key
   80|      0|        }
   81|      0|
   82|      0|        if _pairs.count < arrayDictionaryMaxSize {
   83|      0|            _pairs.append(key: key, value: element)
   84|      0|            return key
   85|      0|        }
   86|      0|
   87|      0|        if _dictionary == nil {
   88|      0|            _dictionary = [:]
   89|      0|        }
   90|      0|
   91|      0|        _dictionary![key] = element
   92|      0|        
   93|      0|        return key
   94|      0|    }
   95|       |    
   96|       |    /// - returns: Number of elements in bag.
   97|      0|    var count: Int {
   98|      0|        let dictionaryCount: Int = _dictionary?.count ?? 0
   99|      0|        return (_value0 != nil ? 1 : 0) + _pairs.count + dictionaryCount
  100|      0|    }
  101|       |    
  102|       |    /// Removes all elements from bag and clears capacity.
  103|      0|    mutating func removeAll() {
  104|      0|        _key0 = nil
  105|      0|        _value0 = nil
  106|      0|
  107|      0|        _pairs.removeAll(keepingCapacity: false)
  108|      0|        _dictionary?.removeAll(keepingCapacity: false)
  109|      0|    }
  110|       |    
  111|       |    /**
  112|       |    Removes element with a specific `key` from bag.
  113|       |    
  114|       |    - parameter key: Key that identifies element to remove from bag.
  115|       |    - returns: Element that bag contained, or nil in case element was already removed.
  116|       |    */
  117|      0|    mutating func removeKey(_ key: BagKey) -> T? {
  118|      0|        if _key0 == key {
  119|      0|            _key0 = nil
  120|      0|            let value = _value0!
  121|      0|            _value0 = nil
  122|      0|            return value
  123|      0|        }
  124|      0|
  125|      0|        if let existingObject = _dictionary?.removeValue(forKey: key) {
  126|      0|            return existingObject
  127|      0|        }
  128|      0|
  129|      0|        for i in 0 ..< _pairs.count {
  130|      0|            if _pairs[i].key == key {
  131|      0|                let value = _pairs[i].value
  132|      0|                _pairs.remove(at: i)
  133|      0|                return value
  134|      0|            }
  135|      0|        }
  136|      0|
  137|      0|        return nil
  138|      0|    }
  139|       |}
  140|       |
  141|       |extension Bag {
  142|       |    /// A textual representation of `self`, suitable for debugging.
  143|      0|    var debugDescription : String {
  144|      0|        return "\(self.count) elements in Bag"
  145|      0|    }
  146|       |}
  147|       |
  148|       |extension Bag {
  149|       |    /// Enumerates elements inside the bag.
  150|       |    ///
  151|       |    /// - parameter action: Enumeration closure.
  152|      0|    func forEach(_ action: (T) -> Void) {
  153|      0|        if _onlyFastPath {
  154|      0|            if let value0 = _value0 {
  155|      0|                action(value0)
  156|      0|            }
  157|      0|            return
  158|      0|        }
  159|      0|
  160|      0|        let value0 = _value0
  161|      0|        let dictionary = _dictionary
  162|      0|
  163|      0|        if let value0 = value0 {
  164|      0|            action(value0)
  165|      0|        }
  166|      0|
  167|      0|        for i in 0 ..< _pairs.count {
  168|      0|            action(_pairs[i].value)
  169|      0|        }
  170|      0|
  171|      0|        if dictionary?.count ?? 0 > 0 {
  172|      0|            for element in dictionary!.values {
  173|      0|                action(element)
  174|      0|            }
  175|      0|        }
  176|      0|    }
  177|       |}
  178|       |
  179|       |extension BagKey: Hashable {
  180|      0|    var hashValue: Int {
  181|      0|        return rawValue.hashValue
  182|      0|    }
  183|       |}
  184|       |
  185|      0|func ==(lhs: BagKey, rhs: BagKey) -> Bool {
  186|      0|    return lhs.rawValue == rhs.rawValue
  187|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/Platform/DataStructures/InfiniteSequence.swift:
    1|       |//
    2|       |//  InfiniteSequence.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Sequence that repeats `repeatedValue` infinite number of times.
   10|       |struct InfiniteSequence<E> : Sequence {
   11|       |    typealias Element = E
   12|       |    typealias Iterator = AnyIterator<E>
   13|       |    
   14|       |    private let _repeatedValue: E
   15|       |    
   16|      0|    init(repeatedValue: E) {
   17|      0|        _repeatedValue = repeatedValue
   18|      0|    }
   19|       |    
   20|      0|    func makeIterator() -> Iterator {
   21|      0|        let repeatedValue = _repeatedValue
   22|      0|        return AnyIterator {
   23|      0|            return repeatedValue
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/Platform/DataStructures/PriorityQueue.swift:
    1|       |//
    2|       |//  PriorityQueue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct PriorityQueue<Element> {
   10|       |    private let _hasHigherPriority: (Element, Element) -> Bool
   11|       |    private let _isEqual: (Element, Element) -> Bool
   12|       |
   13|       |    fileprivate var _elements = [Element]()
   14|       |
   15|      0|    init(hasHigherPriority: @escaping (Element, Element) -> Bool, isEqual: @escaping (Element, Element) -> Bool) {
   16|      0|        _hasHigherPriority = hasHigherPriority
   17|      0|        _isEqual = isEqual
   18|      0|    }
   19|       |
   20|      0|    mutating func enqueue(_ element: Element) {
   21|      0|        _elements.append(element)
   22|      0|        bubbleToHigherPriority(_elements.count - 1)
   23|      0|    }
   24|       |
   25|      0|    func peek() -> Element? {
   26|      0|        return _elements.first
   27|      0|    }
   28|       |
   29|      0|    var isEmpty: Bool {
   30|      0|        return _elements.count == 0
   31|      0|    }
   32|       |
   33|      0|    mutating func dequeue() -> Element? {
   34|      0|        guard let front = peek() else {
   35|      0|            return nil
   36|      0|        }
   37|      0|
   38|      0|        removeAt(0)
   39|      0|
   40|      0|        return front
   41|      0|    }
   42|       |
   43|      0|    mutating func remove(_ element: Element) {
   44|      0|        for i in 0 ..< _elements.count {
   45|      0|            if _isEqual(_elements[i], element) {
   46|      0|                removeAt(i)
   47|      0|                return
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |
   52|      0|    private mutating func removeAt(_ index: Int) {
   53|      0|        let removingLast = index == _elements.count - 1
   54|      0|        if !removingLast {
   55|      0|            swap(&_elements[index], &_elements[_elements.count - 1])
   56|      0|        }
   57|      0|
   58|      0|        _ = _elements.popLast()
   59|      0|
   60|      0|        if !removingLast {
   61|      0|            bubbleToHigherPriority(index)
   62|      0|            bubbleToLowerPriority(index)
   63|      0|        }
   64|      0|    }
   65|       |
   66|      0|    private mutating func bubbleToHigherPriority(_ initialUnbalancedIndex: Int) {
   67|      0|        precondition(initialUnbalancedIndex >= 0)
   68|      0|        precondition(initialUnbalancedIndex < _elements.count)
   69|      0|
   70|      0|        var unbalancedIndex = initialUnbalancedIndex
   71|      0|
   72|      0|        while unbalancedIndex > 0 {
   73|      0|            let parentIndex = (unbalancedIndex - 1) / 2
   74|      0|            guard _hasHigherPriority(_elements[unbalancedIndex], _elements[parentIndex]) else { break }
   75|      0|            
   76|      0|            swap(&_elements[unbalancedIndex], &_elements[parentIndex])
   77|      0|            unbalancedIndex = parentIndex
   78|      0|        }
   79|      0|    }
   80|       |
   81|      0|    private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {
   82|      0|        precondition(initialUnbalancedIndex >= 0)
   83|      0|        precondition(initialUnbalancedIndex < _elements.count)
   84|      0|
   85|      0|        var unbalancedIndex = initialUnbalancedIndex
   86|      0|        while true {
   87|      0|            let leftChildIndex = unbalancedIndex * 2 + 1
   88|      0|            let rightChildIndex = unbalancedIndex * 2 + 2
   89|      0|
   90|      0|            var highestPriorityIndex = unbalancedIndex
   91|      0|
   92|      0|            if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {
   93|      0|                highestPriorityIndex = leftChildIndex
   94|      0|            }
   95|      0|
   96|      0|            if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {
   97|      0|                highestPriorityIndex = rightChildIndex
   98|      0|            }
   99|      0|
  100|      0|            guard highestPriorityIndex != unbalancedIndex else { break }
  101|      0|
  102|      0|            swap(&_elements[highestPriorityIndex], &_elements[unbalancedIndex])
  103|      0|            unbalancedIndex = highestPriorityIndex
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |extension PriorityQueue : CustomDebugStringConvertible {
  109|      0|    var debugDescription: String {
  110|      0|        return _elements.debugDescription
  111|      0|    }
  112|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/Platform/DataStructures/Queue.swift:
    1|       |//
    2|       |//  Queue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Data structure that represents queue.
   11|       |
   12|       |Complexity of `enqueue`, `dequeue` is O(1) when number of operations is
   13|       |averaged over N operations.
   14|       |
   15|       |Complexity of `peek` is O(1).
   16|       |*/
   17|       |struct Queue<T>: Sequence {
   18|       |    /// Type of generator.
   19|       |    typealias Generator = AnyIterator<T>
   20|       |
   21|       |    private let _resizeFactor = 2
   22|       |    
   23|       |    private var _storage: ContiguousArray<T?>
   24|       |    private var _count = 0
   25|       |    private var _pushNextIndex = 0
   26|       |    private let _initialCapacity: Int
   27|       |
   28|       |    /**
   29|       |    Creates new queue.
   30|       |    
   31|       |    - parameter capacity: Capacity of newly created queue.
   32|       |    */
   33|      0|    init(capacity: Int) {
   34|      0|        _initialCapacity = capacity
   35|      0|
   36|      0|        _storage = ContiguousArray<T?>(repeating: nil, count: capacity)
   37|      0|    }
   38|       |    
   39|      0|    private var dequeueIndex: Int {
   40|      0|        let index = _pushNextIndex - count
   41|      0|        return index < 0 ? index + _storage.count : index
   42|      0|    }
   43|       |    
   44|       |    /// - returns: Is queue empty.
   45|      0|    var isEmpty: Bool {
   46|      0|        return count == 0
   47|      0|    }
   48|       |    
   49|       |    /// - returns: Number of elements inside queue.
   50|      0|    var count: Int {
   51|      0|        return _count
   52|      0|    }
   53|       |    
   54|       |    /// - returns: Element in front of a list of elements to `dequeue`.
   55|      0|    func peek() -> T {
   56|      0|        precondition(count > 0)
   57|      0|        
   58|      0|        return _storage[dequeueIndex]!
   59|      0|    }
   60|       |    
   61|      0|    mutating private func resizeTo(_ size: Int) {
   62|      0|        var newStorage = ContiguousArray<T?>(repeating: nil, count: size)
   63|      0|        
   64|      0|        let count = _count
   65|      0|        
   66|      0|        let dequeueIndex = self.dequeueIndex
   67|      0|        let spaceToEndOfQueue = _storage.count - dequeueIndex
   68|      0|        
   69|      0|        // first batch is from dequeue index to end of array
   70|      0|        let countElementsInFirstBatch = Swift.min(count, spaceToEndOfQueue)
   71|      0|        // second batch is wrapped from start of array to end of queue
   72|      0|        let numberOfElementsInSecondBatch = count - countElementsInFirstBatch
   73|      0|        
   74|      0|        newStorage[0 ..< countElementsInFirstBatch] = _storage[dequeueIndex ..< (dequeueIndex + countElementsInFirstBatch)]
   75|      0|        newStorage[countElementsInFirstBatch ..< (countElementsInFirstBatch + numberOfElementsInSecondBatch)] = _storage[0 ..< numberOfElementsInSecondBatch]
   76|      0|        
   77|      0|        _count = count
   78|      0|        _pushNextIndex = count
   79|      0|        _storage = newStorage
   80|      0|    }
   81|       |    
   82|       |    /// Enqueues `element`.
   83|       |    ///
   84|       |    /// - parameter element: Element to enqueue.
   85|      0|    mutating func enqueue(_ element: T) {
   86|      0|        if count == _storage.count {
   87|      0|            resizeTo(Swift.max(_storage.count, 1) * _resizeFactor)
   88|      0|        }
   89|      0|        
   90|      0|        _storage[_pushNextIndex] = element
   91|      0|        _pushNextIndex += 1
   92|      0|        _count += 1
   93|      0|        
   94|      0|        if _pushNextIndex >= _storage.count {
   95|      0|            _pushNextIndex -= _storage.count
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    private mutating func dequeueElementOnly() -> T {
  100|      0|        precondition(count > 0)
  101|      0|        
  102|      0|        let index = dequeueIndex
  103|      0|
  104|      0|        defer {
  105|      0|            _storage[index] = nil
  106|      0|            _count -= 1
  107|      0|        }
  108|      0|
  109|      0|        return _storage[index]!
  110|      0|    }
  111|       |
  112|       |    /// Dequeues element or throws an exception in case queue is empty.
  113|       |    ///
  114|       |    /// - returns: Dequeued element.
  115|      0|    mutating func dequeue() -> T? {
  116|      0|        if self.count == 0 {
  117|      0|            return nil
  118|      0|        }
  119|      0|
  120|      0|        defer {
  121|      0|            let downsizeLimit = _storage.count / (_resizeFactor * _resizeFactor)
  122|      0|            if _count < downsizeLimit && downsizeLimit >= _initialCapacity {
  123|      0|                resizeTo(_storage.count / _resizeFactor)
  124|      0|            }
  125|      0|        }
  126|      0|
  127|      0|        return dequeueElementOnly()
  128|      0|    }
  129|       |    
  130|       |    /// - returns: Generator of contained elements.
  131|      0|    func makeIterator() -> AnyIterator<T> {
  132|      0|        var i = dequeueIndex
  133|      0|        var count = _count
  134|      0|
  135|      0|        return AnyIterator {
  136|      0|            if count == 0 {
  137|      0|                return nil
  138|      0|            }
  139|      0|
  140|      0|            defer {
  141|      0|                count -= 1
  142|      0|                i += 1
  143|      0|            }
  144|      0|
  145|      0|            if i >= self._storage.count {
  146|      0|                i -= self._storage.count
  147|      0|            }
  148|      0|
  149|      0|            return self._storage[i]
  150|      0|        }
  151|      0|    }
  152|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/Platform/DispatchQueue+Extensions.swift:
    1|       |//
    2|       |//  DispatchQueue+Extensions.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/22/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |extension DispatchQueue {
   12|       |    private static var token: DispatchSpecificKey<()> = {
   13|       |        let key = DispatchSpecificKey<()>()
   14|       |        DispatchQueue.main.setSpecific(key: key, value: ())
   15|       |        return key
   16|       |    }()
   17|       |
   18|     79|    static var isMain: Bool {
   19|     79|        return DispatchQueue.getSpecific(key: token) != nil
   20|     79|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/Platform/Platform.Darwin.swift:
    1|       |//
    2|       |//  Platform.Darwin.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
   10|       |
   11|       |    import Darwin
   12|       |    import class Foundation.Thread
   13|       |    import func Foundation.OSAtomicCompareAndSwap32Barrier
   14|       |    import func Foundation.OSAtomicIncrement32Barrier
   15|       |    import func Foundation.OSAtomicDecrement32Barrier
   16|       |    import protocol Foundation.NSCopying
   17|       |
   18|       |    typealias AtomicInt = Int32
   19|       |
   20|      0|    fileprivate func castToUInt32Pointer(_ pointer: UnsafeMutablePointer<Int32>) -> UnsafeMutablePointer<UInt32> {
   21|      0|        let raw = UnsafeMutableRawPointer(pointer)
   22|      0|        return raw.assumingMemoryBound(to: UInt32.self)
   23|      0|    }
   24|       |
   25|       |    let AtomicCompareAndSwap = OSAtomicCompareAndSwap32Barrier
   26|       |    let AtomicIncrement = OSAtomicIncrement32Barrier
   27|       |    let AtomicDecrement = OSAtomicDecrement32Barrier
   28|      0|    func AtomicOr(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Int32 {
   29|      0|        return OSAtomicOr32OrigBarrier(mask, castToUInt32Pointer(theValue))
   30|      0|    }
   31|      0|    func AtomicFlagSet(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Bool {
   32|      0|        // just used to create a barrier
   33|      0|        OSAtomicXor32OrigBarrier(0, castToUInt32Pointer(theValue))
   34|      0|        return (theValue.pointee & Int32(mask)) != 0
   35|      0|    }
   36|       |
   37|       |    extension Thread {
   38|       |
   39|       |        static func setThreadLocalStorageValue<T: AnyObject>(_ value: T?, forKey key: NSCopying
   40|      0|            ) {
   41|      0|            let currentThread = Thread.current
   42|      0|            let threadDictionary = currentThread.threadDictionary
   43|      0|
   44|      0|            if let newValue = value {
   45|      0|                threadDictionary[key] = newValue
   46|      0|            }
   47|      0|            else {
   48|      0|                threadDictionary[key] = nil
   49|      0|            }
   50|      0|
   51|      0|        }
   52|      0|        static func getThreadLocalStorageValueForKey<T>(_ key: NSCopying) -> T? {
   53|      0|            let currentThread = Thread.current
   54|      0|            let threadDictionary = currentThread.threadDictionary
   55|      0|            
   56|      0|            return threadDictionary[key] as? T
   57|      0|        }
   58|       |    }
   59|       |
   60|       |    extension AtomicInt {
   61|      0|        func valueSnapshot() -> Int32 {
   62|      0|            return self
   63|      0|        }
   64|       |    }
   65|       |    
   66|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/ControlTarget.swift:
    1|       |//
    2|       |//  ControlTarget.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS) || os(macOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |
   15|       |#if os(iOS) || os(tvOS)
   16|       |    import UIKit
   17|       |
   18|       |    typealias Control = UIKit.UIControl
   19|       |    typealias ControlEvents = UIKit.UIControlEvents
   20|       |#elseif os(macOS)
   21|       |    import Cocoa
   22|       |
   23|       |    typealias Control = Cocoa.NSControl
   24|       |#endif
   25|       |
   26|       |// This should be only used from `MainScheduler`
   27|       |final class ControlTarget: RxTarget {
   28|       |    typealias Callback = (Control) -> Void
   29|       |
   30|       |    let selector: Selector = #selector(ControlTarget.eventHandler(_:))
   31|       |
   32|       |    weak var control: Control?
   33|       |#if os(iOS) || os(tvOS)
   34|       |    let controlEvents: UIControlEvents
   35|       |#endif
   36|       |    var callback: Callback?
   37|       |    #if os(iOS) || os(tvOS)
   38|    366|    init(control: Control, controlEvents: UIControlEvents, callback: @escaping Callback) {
   39|    366|        MainScheduler.ensureExecutingOnScheduler()
   40|    366|
   41|    366|        self.control = control
   42|    366|        self.controlEvents = controlEvents
   43|    366|        self.callback = callback
   44|    366|
   45|    366|        super.init()
   46|    366|
   47|    366|        control.addTarget(self, action: selector, for: controlEvents)
   48|    366|
   49|    366|        let method = self.method(for: selector)
   50|      0|        if method == nil {
   51|      0|            rxFatalError("Can't find method")
   52|    366|        }
   53|    366|    }
   54|       |#elseif os(macOS)
   55|       |    init(control: Control, callback: @escaping Callback) {
   56|       |        MainScheduler.ensureExecutingOnScheduler()
   57|       |
   58|       |        self.control = control
   59|       |        self.callback = callback
   60|       |
   61|       |        super.init()
   62|       |
   63|       |        control.target = self
   64|       |        control.action = selector
   65|       |
   66|       |        let method = self.method(for: selector)
   67|       |        if method == nil {
   68|       |            rxFatalError("Can't find method")
   69|       |        }
   70|       |    }
   71|       |#endif
   72|       |
   73|      6|    func eventHandler(_ sender: Control!) {
   74|      6|        if let callback = self.callback, let control = self.control {
   75|      6|            callback(control)
   76|      6|        }
   77|      6|    }
   78|       |
   79|      1|    override func dispose() {
   80|      1|        super.dispose()
   81|      1|#if os(iOS) || os(tvOS)
   82|      1|        self.control?.removeTarget(self, action: self.selector, for: self.controlEvents)
   83|      1|#elseif os(macOS)
   84|      1|        self.control?.target = nil
   85|      1|        self.control?.action = nil
   86|      1|#endif
   87|      1|        self.callback = nil
   88|      1|    }
   89|       |}
   90|       |
   91|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/DelegateProxy.swift:
    1|       |//
    2|       |//  DelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |    import RxSwift
   13|       |    #if SWIFT_PACKAGE && !os(Linux)
   14|       |        import RxCocoaRuntime
   15|       |    #endif
   16|       |#endif
   17|       |
   18|       |var delegateAssociatedTag: UnsafeRawPointer = UnsafeRawPointer(UnsafeMutablePointer<UInt8>.allocate(capacity: 1))
   19|       |var dataSourceAssociatedTag: UnsafeRawPointer = UnsafeRawPointer(UnsafeMutablePointer<UInt8>.allocate(capacity: 1))
   20|       |
   21|       |/// Base class for `DelegateProxyType` protocol.
   22|       |///
   23|       |/// This implementation is not thread safe and can be used only from one thread (Main thread).
   24|       |open class DelegateProxy : _RXDelegateProxy {
   25|       |
   26|       |    private var sentMessageForSelector = [Selector: MessageDispatcher]()
   27|       |    private var methodInvokedForSelector = [Selector: MessageDispatcher]()
   28|       |
   29|       |    /// Parent object associated with delegate proxy.
   30|       |    weak private(set) var parentObject: AnyObject?
   31|       |    
   32|       |    /// Initializes new instance.
   33|       |    ///
   34|       |    /// - parameter parentObject: Optional parent object that owns `DelegateProxy` as associated object.
   35|     42|    public required init(parentObject: AnyObject) {
   36|     42|        self.parentObject = parentObject
   37|     42|        
   38|     42|        MainScheduler.ensureExecutingOnScheduler()
   39|     42|#if TRACE_RESOURCES
   40|     42|        _ = Resources.incrementTotal()
   41|     42|#endif
   42|     42|        super.init()
   43|     42|    }
   44|       |
   45|       |    /**
   46|       |    Returns observable sequence of invocations of delegate methods. Elements are sent *before method is invoked*.
   47|       |
   48|       |    Only methods that have `void` return value can be observed using this method because
   49|       |     those methods are used as a notification mechanism. It doesn't matter if they are optional
   50|       |     or not. Observing is performed by installing a hidden associated `PublishSubject` that is 
   51|       |     used to dispatch messages to observers.
   52|       |
   53|       |    Delegate methods that have non `void` return value can't be observed directly using this method
   54|       |     because:
   55|       |     * those methods are not intended to be used as a notification mechanism, but as a behavior customization mechanism
   56|       |     * there is no sensible automatic way to determine a default return value
   57|       |
   58|       |    In case observing of delegate methods that have return type is required, it can be done by
   59|       |     manually installing a `PublishSubject` or `BehaviorSubject` and implementing delegate method.
   60|       |     
   61|       |     e.g.
   62|       |     
   63|       |         // delegate proxy part (RxScrollViewDelegateProxy)
   64|       |
   65|       |         let internalSubject = PublishSubject<CGPoint>
   66|       |     
   67|       |         public func requiredDelegateMethod(scrollView: UIScrollView, arg1: CGPoint) -> Bool {
   68|       |             internalSubject.on(.next(arg1))
   69|       |             return self._forwardToDelegate?.requiredDelegateMethod?(scrollView, arg1: arg1) ?? defaultReturnValue
   70|       |         }
   71|       |     
   72|       |         ....
   73|       |
   74|       |         // reactive property implementation in a real class (`UIScrollView`)
   75|       |         public var property: Observable<CGPoint> {
   76|       |             let proxy = RxScrollViewDelegateProxy.proxyForObject(base)
   77|       |             return proxy.internalSubject.asObservable()
   78|       |         }
   79|       |
   80|       |     **In case calling this method prints "Delegate proxy is already implementing `\(selector)`, 
   81|       |     a more performant way of registering might exist.", that means that manual observing method 
   82|       |     is required analog to the example above because delegate method has already been implemented.**
   83|       |
   84|       |    - parameter selector: Selector used to filter observed invocations of delegate methods.
   85|       |    - returns: Observable sequence of arguments passed to `selector` method.
   86|       |    */
   87|      0|    open func sentMessage(_ selector: Selector) -> Observable<[Any]> {
   88|      0|        MainScheduler.ensureExecutingOnScheduler()
   89|      0|        checkSelectorIsObservable(selector)
   90|      0|
   91|      0|        let subject = sentMessageForSelector[selector]
   92|      0|        
   93|      0|        if let subject = subject {
   94|      0|            return subject.asObservable()
   95|      0|        }
   96|      0|        else {
   97|      0|            let subject = MessageDispatcher(delegateProxy: self)
   98|      0|            sentMessageForSelector[selector] = subject
   99|      0|            return subject.asObservable()
  100|      0|        }
  101|      0|    }
  102|       |
  103|       |    /**
  104|       |     Returns observable sequence of invoked delegate methods. Elements are sent *after method is invoked*.
  105|       |
  106|       |    Only methods that have `void` return value can be observed using this method because
  107|       |     those methods are used as a notification mechanism. It doesn't matter if they are optional
  108|       |     or not. Observing is performed by installing a hidden associated `PublishSubject` that is 
  109|       |     used to dispatch messages to observers.
  110|       |
  111|       |    Delegate methods that have non `void` return value can't be observed directly using this method
  112|       |     because:
  113|       |     * those methods are not intended to be used as a notification mechanism, but as a behavior customization mechanism
  114|       |     * there is no sensible automatic way to determine a default return value
  115|       |
  116|       |    In case observing of delegate methods that have return type is required, it can be done by
  117|       |     manually installing a `PublishSubject` or `BehaviorSubject` and implementing delegate method.
  118|       |     
  119|       |     e.g.
  120|       |     
  121|       |         // delegate proxy part (RxScrollViewDelegateProxy)
  122|       |
  123|       |         let internalSubject = PublishSubject<CGPoint>
  124|       |     
  125|       |         public func requiredDelegateMethod(scrollView: UIScrollView, arg1: CGPoint) -> Bool {
  126|       |             internalSubject.on(.next(arg1))
  127|       |             return self._forwardToDelegate?.requiredDelegateMethod?(scrollView, arg1: arg1) ?? defaultReturnValue
  128|       |         }
  129|       |     
  130|       |         ....
  131|       |
  132|       |         // reactive property implementation in a real class (`UIScrollView`)
  133|       |         public var property: Observable<CGPoint> {
  134|       |             let proxy = RxScrollViewDelegateProxy.proxyForObject(base)
  135|       |             return proxy.internalSubject.asObservable()
  136|       |         }
  137|       |
  138|       |     **In case calling this method prints "Delegate proxy is already implementing `\(selector)`, 
  139|       |     a more performant way of registering might exist.", that means that manual observing method 
  140|       |     is required analog to the example above because delegate method has already been implemented.**
  141|       |
  142|       |    - parameter selector: Selector used to filter observed invocations of delegate methods.
  143|       |    - returns: Observable sequence of arguments passed to `selector` method.
  144|       |     */
  145|     38|    open func methodInvoked(_ selector: Selector) -> Observable<[Any]> {
  146|     38|        MainScheduler.ensureExecutingOnScheduler()
  147|     38|        checkSelectorIsObservable(selector)
  148|     38|
  149|     38|        let subject = methodInvokedForSelector[selector]
  150|     38|
  151|      0|        if let subject = subject {
  152|      0|            return subject.asObservable()
  153|     38|        }
  154|     38|        else {
  155|     38|            let subject = MessageDispatcher(delegateProxy: self)
  156|     38|            methodInvokedForSelector[selector] = subject
  157|     38|            return subject.asObservable()
  158|      0|        }
  159|      0|    }
  160|       |
  161|     38|    private func checkSelectorIsObservable(_ selector: Selector) {
  162|     38|        MainScheduler.ensureExecutingOnScheduler()
  163|     38|
  164|      0|        if hasWiredImplementation(for: selector) {
  165|      0|            print("Delegate proxy is already implementing `\(selector)`, a more performant way of registering might exist.")
  166|      0|            return
  167|     38|        }
  168|     38|
  169|     38|        guard (self.forwardToDelegate()?.responds(to: selector) ?? false) || voidDelegateMethodsContain(selector) else {
  170|      0|            rxFatalError("This class doesn't respond to selector \(selector)")
  171|     38|        }
  172|     38|    }
  173|       |
  174|       |    // proxy
  175|       |
  176|      0|    open override func _sentMessage(_ selector: Selector, withArguments arguments: [Any]) {
  177|      0|        sentMessageForSelector[selector]?.on(.next(arguments))
  178|      0|    }
  179|       |
  180|      0|    open override func _methodInvoked(_ selector: Selector, withArguments arguments: [Any]) {
  181|      0|        methodInvokedForSelector[selector]?.on(.next(arguments))
  182|      0|    }
  183|       |
  184|       |    /// Returns tag used to identify associated object.
  185|       |    ///
  186|       |    /// - returns: Associated object tag.
  187|    122|    open class func delegateAssociatedObjectTag() -> UnsafeRawPointer {
  188|    122|        return delegateAssociatedTag
  189|    122|    }
  190|       |    
  191|       |    /// Initializes new instance of delegate proxy.
  192|       |    ///
  193|       |    /// - returns: Initialized instance of `self`.
  194|      0|    open class func createProxyForObject(_ object: AnyObject) -> AnyObject {
  195|      0|        return self.init(parentObject: object)
  196|      0|    }
  197|       |    
  198|       |    /// Returns assigned proxy for object.
  199|       |    ///
  200|       |    /// - parameter object: Object that can have assigned delegate proxy.
  201|       |    /// - returns: Assigned delegate proxy or `nil` if no delegate proxy is assigned.
  202|     96|    open class func assignedProxyFor(_ object: AnyObject) -> AnyObject? {
  203|     96|        let maybeDelegate = objc_getAssociatedObject(object, self.delegateAssociatedObjectTag())
  204|     54|        return castOptionalOrFatalError(maybeDelegate.map { $0 as AnyObject })
  205|     96|    }
  206|       |    
  207|       |    /// Assigns proxy to object.
  208|       |    ///
  209|       |    /// - parameter object: Object that can have assigned delegate proxy.
  210|       |    /// - parameter proxy: Delegate proxy object to assign to `object`.
  211|     42|    open class func assignProxy(_ proxy: AnyObject, toObject object: AnyObject) {
  212|     42|        precondition(proxy.isKind(of: self.classForCoder()))
  213|     42|       
  214|     42|        objc_setAssociatedObject(object, self.delegateAssociatedObjectTag(), proxy, .OBJC_ASSOCIATION_RETAIN)
  215|     42|    }
  216|       |    
  217|       |    /// Sets reference of normal delegate that receives all forwarded messages
  218|       |    /// through `self`.
  219|       |    ///
  220|       |    /// - parameter forwardToDelegate: Reference of delegate that receives all messages through `self`.
  221|       |    /// - parameter retainDelegate: Should `self` retain `forwardToDelegate`.
  222|     50|    open func setForwardToDelegate(_ delegate: AnyObject?, retainDelegate: Bool) {
  223|     50|        #if DEBUG // 4.0 all configurations
  224|     50|            MainScheduler.ensureExecutingOnScheduler()
  225|     50|        #endif
  226|     50|        self._setForward(toDelegate: delegate, retainDelegate: retainDelegate)
  227|     50|        self.reset()
  228|     50|    }
  229|       |   
  230|       |    /// Returns reference of normal delegate that receives all forwarded messages
  231|       |    /// through `self`.
  232|       |    ///
  233|       |    /// - returns: Value of reference if set or nil.
  234|    130|    open func forwardToDelegate() -> AnyObject? {
  235|    130|        return self._forwardToDelegate
  236|    130|    }
  237|       |
  238|  1.15k|    private func hasObservers(selector: Selector) -> Bool {
  239|  1.15k|        return (sentMessageForSelector[selector]?.hasObservers ?? false)
  240|  1.15k|            || (methodInvokedForSelector[selector]?.hasObservers ?? false)
  241|  1.15k|    }
  242|       |    
  243|  6.46k|    override open func responds(to aSelector: Selector!) -> Bool {
  244|  6.46k|        return super.responds(to: aSelector)
  245|  6.36k|            || (self._forwardToDelegate?.responds(to: aSelector) ?? false)
  246|  5.72k|            || (self.voidDelegateMethodsContain(aSelector) && self.hasObservers(selector: aSelector))
  247|  6.46k|    }
  248|       |
  249|     88|    internal func reset() {
  250|      0|        guard let delegateProxySelf = self as? DelegateProxyType else {
  251|      0|            rxFatalErrorInDebug("\(self) doesn't implement delegate proxy type.")
  252|      0|            return
  253|     88|        }
  254|     88|        
  255|     88|        guard let parentObject = self.parentObject else { return }
  256|     88|
  257|     88|        let selfType = type(of: delegateProxySelf)
  258|     88|
  259|     88|        let maybeCurrentDelegate = selfType.currentDelegateFor(parentObject)
  260|     88|
  261|     46|        if maybeCurrentDelegate === self {
  262|     46|            selfType.setCurrentDelegate(nil, toObject: parentObject)
  263|     46|            selfType.setCurrentDelegate(self, toObject: parentObject)
  264|     88|        }
  265|     88|    }
  266|       |
  267|      0|    deinit {
  268|      0|        for v in sentMessageForSelector.values {
  269|      0|            v.on(.completed)
  270|      0|        }
  271|      0|        for v in methodInvokedForSelector.values {
  272|      0|            v.on(.completed)
  273|      0|        }
  274|      0|#if TRACE_RESOURCES
  275|      0|        _ = Resources.decrementTotal()
  276|      0|#endif
  277|      0|    }
  278|       |}
  279|       |
  280|       |fileprivate let mainScheduler = MainScheduler()
  281|       |
  282|       |fileprivate final class MessageDispatcher {
  283|       |    private let dispatcher: PublishSubject<[Any]>
  284|       |    private let result: Observable<[Any]>
  285|       |
  286|     38|    init(delegateProxy _delegateProxy: DelegateProxy) {
  287|     38|        weak var weakDelegateProxy = _delegateProxy
  288|     38|
  289|     38|        let dispatcher = PublishSubject<[Any]>()
  290|     38|        self.dispatcher = dispatcher
  291|     38|
  292|     38|        self.result = dispatcher
  293|     38|            .do(onSubscribed: { weakDelegateProxy?.reset() }, onDispose: { weakDelegateProxy?.reset() })
  294|     38|            .share()
  295|     38|            .subscribeOn(mainScheduler)
  296|     38|    }
  297|       |
  298|      0|    var on: (Event<[Any]>) -> () {
  299|      0|        return self.dispatcher.on
  300|      0|    }
  301|       |
  302|     42|    var hasObservers: Bool {
  303|     42|        return self.dispatcher.hasObservers
  304|     42|    }
  305|       |
  306|     38|    func asObservable() -> Observable<[Any]> {
  307|     38|        return self.result
  308|     38|    }
  309|       |}
  310|       |    
  311|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/DelegateProxyType.swift:
    1|       |//
    2|       |//  DelegateProxyType.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |
   15|       |/**
   16|       |`DelegateProxyType` protocol enables using both normal delegates and Rx observable sequences with
   17|       |views that can have only one delegate/datasource registered.
   18|       |
   19|       |`Proxies` store information about observers, subscriptions and delegates
   20|       |for specific views.
   21|       |
   22|       |Type implementing `DelegateProxyType` should never be initialized directly.
   23|       |
   24|       |To fetch initialized instance of type implementing `DelegateProxyType`, `proxyForObject` method
   25|       |should be used.
   26|       |
   27|       |This is more or less how it works.
   28|       |
   29|       |
   30|       |
   31|       |      +-------------------------------------------+
   32|       |      |                                           |                           
   33|       |      | UIView subclass (UIScrollView)            |                           
   34|       |      |                                           |
   35|       |      +-----------+-------------------------------+                           
   36|       |                  |                                                           
   37|       |                  | Delegate                                                  
   38|       |                  |                                                           
   39|       |                  |                                                           
   40|       |      +-----------v-------------------------------+                           
   41|       |      |                                           |                           
   42|       |      | Delegate proxy : DelegateProxyType        +-----+---->  Observable<T1>
   43|       |      |                , UIScrollViewDelegate     |     |
   44|       |      +-----------+-------------------------------+     +---->  Observable<T2>
   45|       |                  |                                     |                     
   46|       |                  |                                     +---->  Observable<T3>
   47|       |                  |                                     |                     
   48|       |                  | forwards events                     |
   49|       |                  | to custom delegate                  |
   50|       |                  |                                     v                     
   51|       |      +-----------v-------------------------------+                           
   52|       |      |                                           |                           
   53|       |      | Custom delegate (UIScrollViewDelegate)    |                           
   54|       |      |                                           |
   55|       |      +-------------------------------------------+                           
   56|       |
   57|       |
   58|       |Since RxCocoa needs to automagically create those Proxys
   59|       |..and because views that have delegates can be hierarchical
   60|       |
   61|       |UITableView : UIScrollView : UIView
   62|       |
   63|       |.. and corresponding delegates are also hierarchical
   64|       |
   65|       |UITableViewDelegate : UIScrollViewDelegate : NSObject
   66|       |
   67|       |.. and sometimes there can be only one proxy/delegate registered,
   68|       |every view has a corresponding delegate virtual factory method.
   69|       |
   70|       |In case of UITableView / UIScrollView, there is
   71|       |
   72|       |    extension UIScrollView {
   73|       |        public func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
   74|       |            return RxScrollViewDelegateProxy(parentObject: base)
   75|       |        }
   76|       |    ....
   77|       |
   78|       |
   79|       |and override in UITableView
   80|       |
   81|       |    extension UITableView {
   82|       |        public override func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
   83|       |        ....
   84|       |
   85|       |
   86|       |*/
   87|       |public protocol DelegateProxyType : AnyObject {
   88|       |    /// Creates new proxy for target object.
   89|       |    static func createProxyForObject(_ object: AnyObject) -> AnyObject
   90|       |
   91|       |    /// Returns assigned proxy for object.
   92|       |    ///
   93|       |    /// - parameter object: Object that can have assigned delegate proxy.
   94|       |    /// - returns: Assigned delegate proxy or `nil` if no delegate proxy is assigned.
   95|       |    static func assignedProxyFor(_ object: AnyObject) -> AnyObject?
   96|       |    
   97|       |    /// Assigns proxy to object.
   98|       |    ///
   99|       |    /// - parameter object: Object that can have assigned delegate proxy.
  100|       |    /// - parameter proxy: Delegate proxy object to assign to `object`.
  101|       |    static func assignProxy(_ proxy: AnyObject, toObject object: AnyObject)
  102|       |    
  103|       |    /// Returns designated delegate property for object.
  104|       |    ///
  105|       |    /// Objects can have multiple delegate properties.
  106|       |    ///
  107|       |    /// Each delegate property needs to have it's own type implementing `DelegateProxyType`.
  108|       |    ///
  109|       |    /// - parameter object: Object that has delegate property.
  110|       |    /// - returns: Value of delegate property.
  111|       |    static func currentDelegateFor(_ object: AnyObject) -> AnyObject?
  112|       |
  113|       |    /// Sets designated delegate property for object.
  114|       |    ///
  115|       |    /// Objects can have multiple delegate properties.
  116|       |    ///
  117|       |    /// Each delegate property needs to have it's own type implementing `DelegateProxyType`.
  118|       |    ///
  119|       |    /// - parameter toObject: Object that has delegate property.
  120|       |    /// - parameter delegate: Delegate value.
  121|       |    static func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject)
  122|       |    
  123|       |    /// Returns reference of normal delegate that receives all forwarded messages
  124|       |    /// through `self`.
  125|       |    ///
  126|       |    /// - returns: Value of reference if set or nil.
  127|       |    func forwardToDelegate() -> AnyObject?
  128|       |
  129|       |    /// Sets reference of normal delegate that receives all forwarded messages
  130|       |    /// through `self`.
  131|       |    ///
  132|       |    /// - parameter forwardToDelegate: Reference of delegate that receives all messages through `self`.
  133|       |    /// - parameter retainDelegate: Should `self` retain `forwardToDelegate`.
  134|       |    func setForwardToDelegate(_ forwardToDelegate: AnyObject?, retainDelegate: Bool)
  135|       |}
  136|       |
  137|       |extension DelegateProxyType {
  138|       |    /// Returns existing proxy for object or installs new instance of delegate proxy.
  139|       |    ///
  140|       |    /// - parameter object: Target object on which to install delegate proxy.
  141|       |    /// - returns: Installed instance of delegate proxy.
  142|       |    ///
  143|       |    ///
  144|       |    ///     extension Reactive where Base: UISearchBar {
  145|       |    ///
  146|       |    ///         public var delegate: DelegateProxy {
  147|       |    ///            return RxSearchBarDelegateProxy.proxyForObject(base)
  148|       |    ///         }
  149|       |    ///
  150|       |    ///         public var text: ControlProperty<String> {
  151|       |    ///             let source: Observable<String> = self.delegate.observe(#selector(UISearchBarDelegate.searchBar(_:textDidChange:)))
  152|       |    ///             ...
  153|       |    ///         }
  154|       |    ///     }
  155|     54|    public static func proxyForObject(_ object: AnyObject) -> Self {
  156|     54|        MainScheduler.ensureExecutingOnScheduler()
  157|     54|
  158|     54|        let maybeProxy = Self.assignedProxyFor(object) as? Self
  159|     54|
  160|     54|        let proxy: Self
  161|     12|        if let existingProxy = maybeProxy {
  162|     12|            proxy = existingProxy
  163|     54|        }
  164|     42|        else {
  165|     42|            proxy = Self.createProxyForObject(object) as! Self
  166|     42|            Self.assignProxy(proxy, toObject: object)
  167|     42|            assert(Self.assignedProxyFor(object) === proxy)
  168|     54|        }
  169|     54|
  170|     54|        let currentDelegate: AnyObject? = Self.currentDelegateFor(object)
  171|     54|
  172|     42|        if currentDelegate !== proxy {
  173|     42|            proxy.setForwardToDelegate(currentDelegate, retainDelegate: false)
  174|     42|            assert(proxy.forwardToDelegate() === currentDelegate)
  175|     42|            Self.setCurrentDelegate(proxy, toObject: object)
  176|     42|            assert(Self.currentDelegateFor(object) === proxy)
  177|     42|            assert(proxy.forwardToDelegate() === currentDelegate)
  178|     54|        }
  179|     54|
  180|     54|        return proxy
  181|     54|    }
  182|       |
  183|       |    /// Sets forward delegate for `DelegateProxyType` associated with a specific object and return disposable that can be used to unset the forward to delegate.
  184|       |    /// Using this method will also make sure that potential original object cached selectors are cleared and will report any accidental forward delegate mutations.
  185|       |    ///
  186|       |    /// - parameter forwardDelegate: Delegate object to set.
  187|       |    /// - parameter retainDelegate: Retain `forwardDelegate` while it's being set.
  188|       |    /// - parameter onProxyForObject: Object that has `delegate` property.
  189|       |    /// - returns: Disposable object that can be used to clear forward delegate.
  190|      8|    public static func installForwardDelegate(_ forwardDelegate: AnyObject, retainDelegate: Bool, onProxyForObject object: AnyObject) -> Disposable {
  191|      8|        weak var weakForwardDelegate: AnyObject? = forwardDelegate
  192|      8|
  193|      8|        let proxy = Self.proxyForObject(object)
  194|      8|        
  195|      8|        assert(proxy.forwardToDelegate() === nil, "This is a feature to warn you that there is already a delegate (or data source) set somewhere previously. The action you are trying to perform will clear that delegate (data source) and that means that some of your features that depend on that delegate (data source) being set will likely stop working.\n" +
  196|      0|            "If you are ok with this, try to set delegate (data source) to `nil` in front of this operation.\n" +
  197|      0|            " This is the source object value: \(object)\n" +
  198|      0|            " This this the original delegate (data source) value: \(proxy.forwardToDelegate()!)\n" +
  199|      0|            "Hint: Maybe delegate was already set in xib or storyboard and now it's being overwritten in code.\n")
  200|      8|
  201|      8|        proxy.setForwardToDelegate(forwardDelegate, retainDelegate: retainDelegate)
  202|      8|        
  203|      0|        return Disposables.create {
  204|      0|            MainScheduler.ensureExecutingOnScheduler()
  205|      0|            
  206|      0|            let delegate: AnyObject? = weakForwardDelegate
  207|      0|            
  208|      0|            assert(delegate == nil || proxy.forwardToDelegate() === delegate, "Delegate was changed from time it was first set. Current \(String(describing: proxy.forwardToDelegate())), and it should have been \(proxy)")
  209|      0|            
  210|      0|            proxy.setForwardToDelegate(nil, retainDelegate: retainDelegate)
  211|      0|        }
  212|      8|    }
  213|       |}
  214|       |
  215|       |    #if os(iOS) || os(tvOS)
  216|       |        import UIKit
  217|       |
  218|       |        extension ObservableType {
  219|       |            func subscribeProxyDataSource<P: DelegateProxyType>(ofObject object: UIView, dataSource: AnyObject, retainDataSource: Bool, binding: @escaping (P, Event<E>) -> Void)
  220|      4|                -> Disposable {
  221|      4|                let proxy = P.proxyForObject(object)
  222|      4|                let unregisterDelegate = P.installForwardDelegate(dataSource, retainDelegate: retainDataSource, onProxyForObject: object)
  223|      4|                // this is needed to flush any delayed old state (https://github.com/RxSwiftCommunity/RxDataSources/pull/75)
  224|      4|                object.layoutIfNeeded()
  225|      4|
  226|      4|                let subscription = self.asObservable()
  227|      4|                    .observeOn(MainScheduler())
  228|      0|                    .catchError { error in
  229|      0|                        bindingErrorToInterface(error)
  230|      0|                        return Observable.empty()
  231|      0|                    }
  232|      4|                    // source can never end, otherwise it would release the subscriber, and deallocate the data source
  233|      4|                    .concat(Observable.never())
  234|      4|                    .takeUntil(object.rx.deallocated)
  235|     37|                    .subscribe { [weak object] (event: Event<E>) in
  236|     37|
  237|     37|                        if let object = object {
  238|     37|                            assert(proxy === P.currentDelegateFor(object), "Proxy changed from the time it was first set.\nOriginal: \(proxy)\nExisting: \(String(describing: P.currentDelegateFor(object)))")
  239|     37|                        }
  240|     37|                        
  241|     37|                        binding(proxy, event)
  242|     37|                        
  243|     37|                        switch event {
  244|      0|                        case .error(let error):
  245|      0|                            bindingErrorToInterface(error)
  246|      0|                            unregisterDelegate.dispose()
  247|      0|                        case .completed:
  248|      0|                            unregisterDelegate.dispose()
  249|     37|                        default:
  250|     37|                            break
  251|     37|                        }
  252|     37|                    }
  253|      4|                    
  254|      0|                return Disposables.create { [weak object] in
  255|      0|                    subscription.dispose()
  256|      0|                    object?.layoutIfNeeded()
  257|      0|                    unregisterDelegate.dispose()
  258|      0|                }
  259|      4|            }
  260|       |        }
  261|       |
  262|       |    #endif
  263|       |
  264|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/NSLayoutConstraint+Rx.swift:
    1|       |//
    2|       |//  NSLayoutConstraint+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |#if os(macOS)
   12|       |import Cocoa
   13|       |#else
   14|       |import UIKit
   15|       |#endif
   16|       |
   17|       |#if !RX_NO_MODULE
   18|       |import RxSwift
   19|       |#endif
   20|       |
   21|       |#if os(iOS) || os(macOS) || os(tvOS)
   22|       |extension Reactive where Base: NSLayoutConstraint {
   23|       |    /// Bindable sink for `constant` property.
   24|      0|    public var constant: UIBindingObserver<Base, CGFloat> {
   25|      0|        return UIBindingObserver(UIElement: self.base) { constraint, constant in
   26|      0|            constraint.constant = constant
   27|      0|        }
   28|      0|    }
   29|       |    
   30|       |    /// Bindable sink for `active` property.
   31|       |    @available(iOS 8, OSX 10.10, *)
   32|      0|    public var active:  UIBindingObserver<Base, Bool> {
   33|      0|        return UIBindingObserver(UIElement: self.base) { constraint, value in
   34|      0|            constraint.isActive = value
   35|      0|        }
   36|      0|    }
   37|       |}
   38|       |
   39|       |#endif
   40|       |
   41|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/Observable+Bind.swift:
    1|       |//
    2|       |//  Observable+Bind.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |extension ObservableType {
   14|       |    
   15|       |    /**
   16|       |    Creates new subscription and sends elements to observer.
   17|       |    
   18|       |    In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   19|       |    writing more consistent binding code.
   20|       |    
   21|       |    - parameter to: Observer that receives events.
   22|       |    - returns: Disposable object that can be used to unsubscribe the observer.
   23|       |    */
   24|     34|    public func bind<O: ObserverType>(to observer: O) -> Disposable where O.E == E {
   25|     34|        return self.subscribe(observer)
   26|     34|    }
   27|       |
   28|       |    /**
   29|       |     Creates new subscription and sends elements to observer.
   30|       |
   31|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   32|       |     writing more consistent binding code.
   33|       |
   34|       |     - parameter to: Observer that receives events.
   35|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   36|       |     */
   37|      7|    public func bind<O: ObserverType>(to observer: O) -> Disposable where O.E == E? {
   38|      7|        return self.map { $0 }.subscribe(observer)
   39|      7|    }
   40|       |
   41|       |    /**
   42|       |    Creates new subscription and sends elements to variable.
   43|       |
   44|       |    In case error occurs in debug mode, `fatalError` will be raised.
   45|       |    In case error occurs in release mode, `error` will be logged.
   46|       |
   47|       |    - parameter to: Target variable for sequence elements.
   48|       |    - returns: Disposable object that can be used to unsubscribe the observer.
   49|       |    */
   50|      7|    public func bind(to variable: Variable<E>) -> Disposable {
   51|      6|        return subscribe { e in
   52|      6|            switch e {
   53|      6|            case let .next(element):
   54|      6|                variable.value = element
   55|      0|            case let .error(error):
   56|      0|                let error = "Binding error to variable: \(error)"
   57|      0|            #if DEBUG
   58|      0|                rxFatalError(error)
   59|      0|            #else
   60|      0|                print(error)
   61|      0|            #endif
   62|      0|            case .completed:
   63|      0|                break
   64|      6|            }
   65|      6|        }
   66|      7|    }
   67|       |
   68|       |    /**
   69|       |     Creates new subscription and sends elements to variable.
   70|       |
   71|       |     In case error occurs in debug mode, `fatalError` will be raised.
   72|       |     In case error occurs in release mode, `error` will be logged.
   73|       |
   74|       |     - parameter to: Target variable for sequence elements.
   75|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   76|       |     */
   77|      0|    public func bind(to variable: Variable<E?>) -> Disposable {
   78|      0|        return self.map { $0 as E? }.bind(to: variable)
   79|      0|    }
   80|       |    
   81|       |    /**
   82|       |    Subscribes to observable sequence using custom binder function.
   83|       |    
   84|       |    - parameter to: Function used to bind elements from `self`.
   85|       |    - returns: Object representing subscription.
   86|       |    */
   87|      4|    public func bind<R>(to binder: (Self) -> R) -> R {
   88|      4|        return binder(self)
   89|      4|    }
   90|       |
   91|       |    /**
   92|       |    Subscribes to observable sequence using custom binder function and final parameter passed to binder function
   93|       |    after `self` is passed.
   94|       |    
   95|       |        public func bind<R1, R2>(to binder: Self -> R1 -> R2, curriedArgument: R1) -> R2 {
   96|       |            return binder(self)(curriedArgument)
   97|       |        }
   98|       |    
   99|       |    - parameter to: Function used to bind elements from `self`.
  100|       |    - parameter curriedArgument: Final argument passed to `binder` to finish binding process.
  101|       |    - returns: Object representing subscription.
  102|       |    */
  103|      0|    public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2 {
  104|      0|         return binder(self)(curriedArgument)
  105|      0|    }
  106|       |    
  107|       |    
  108|       |    /**
  109|       |    Subscribes an element handler to an observable sequence. 
  110|       |
  111|       |    In case error occurs in debug mode, `fatalError` will be raised.
  112|       |    In case error occurs in release mode, `error` will be logged.
  113|       |    
  114|       |    - parameter onNext: Action to invoke for each element in the observable sequence.
  115|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
  116|       |    */
  117|     16|    public func bind(onNext: @escaping (E) -> Void) -> Disposable {
  118|      0|        return subscribe(onNext: onNext, onError: { error in
  119|      0|            let error = "Binding error: \(error)"
  120|      0|            #if DEBUG
  121|      0|                rxFatalError(error)
  122|      0|            #else
  123|      0|                print(error)
  124|      0|            #endif
  125|      0|        })
  126|     16|    }
  127|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/RxCocoaObjCRuntimeError+Extensions.swift:
    1|       |//
    2|       |//  RxCocoaObjCRuntimeError+Extensions.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/9/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    #if SWIFT_PACKAGE && !DISABLE_SWIZZLING && !os(Linux)
   11|       |        import RxCocoaRuntime
   12|       |    #endif
   13|       |#endif
   14|       |
   15|       |#if !DISABLE_SWIZZLING && !os(Linux)
   16|       |    /// RxCocoa ObjC runtime interception mechanism.
   17|       |    public enum RxCocoaInterceptionMechanism {
   18|       |        /// Unknown message interception mechanism.
   19|       |        case unknown
   20|       |        /// Key value observing interception mechanism.
   21|       |        case kvo
   22|       |    }
   23|       |
   24|       |    /// RxCocoa ObjC runtime modification errors.
   25|       |    public enum RxCocoaObjCRuntimeError
   26|       |        : Swift.Error
   27|       |        , CustomDebugStringConvertible {
   28|       |        /// Unknown error has occurred.
   29|       |        case unknown(target: AnyObject)
   30|       |
   31|       |        /**
   32|       |        If the object is reporting a different class then it's real class, that means that there is probably
   33|       |        already some interception mechanism in place or something weird is happening.
   34|       |
   35|       |        The most common case when this would happen is when using a combination of KVO (`observe`) and `sentMessage`.
   36|       |
   37|       |        This error is easily resolved by just using `sentMessage` observing before `observe`.
   38|       |
   39|       |        The reason why the other way around could create issues is because KVO will unregister it's interceptor
   40|       |        class and restore original class. Unfortunately that will happen no matter was there another interceptor
   41|       |        subclass registered in hierarchy or not.
   42|       |
   43|       |        Failure scenario:
   44|       |        * KVO sets class to be `__KVO__OriginalClass` (subclass of `OriginalClass`)
   45|       |        * `sentMessage` sets object class to be `_RX_namespace___KVO__OriginalClass` (subclass of `__KVO__OriginalClass`)
   46|       |        * then unobserving with KVO will restore class to be `OriginalClass` -> failure point (possibly a bug in KVO)
   47|       |
   48|       |        The reason why changing order of observing works is because any interception method on unregistration 
   49|       |        should return object's original real class (if that doesn't happen then it's really easy to argue that's a bug
   50|       |        in that interception mechanism).
   51|       |
   52|       |        This library won't remove registered interceptor even if there aren't any observers left because
   53|       |        it's highly unlikely it would have any benefit in real world use cases, and it's even more
   54|       |        dangerous.
   55|       |        */
   56|       |        case objectMessagesAlreadyBeingIntercepted(target: AnyObject, interceptionMechanism: RxCocoaInterceptionMechanism)
   57|       |
   58|       |        /// Trying to observe messages for selector that isn't implemented.
   59|       |        case selectorNotImplemented(target: AnyObject)
   60|       |
   61|       |        /// Core Foundation classes are usually toll free bridged. Those classes crash the program in case
   62|       |        /// `object_setClass` is performed on them.
   63|       |        ///
   64|       |        /// There is a possibility to just swizzle methods on original object, but since those won't be usual use
   65|       |        /// cases for this library, then an error will just be reported for now.
   66|       |        case cantInterceptCoreFoundationTollFreeBridgedObjects(target: AnyObject)
   67|       |
   68|       |        /// Two libraries have simultaneously tried to modify ObjC runtime and that was detected. This can only
   69|       |        /// happen in scenarios where multiple interception libraries are used.
   70|       |        ///
   71|       |        /// To synchronize other libraries intercepting messages for an object, use `synchronized` on target object and
   72|       |        /// it's meta-class.
   73|       |        case threadingCollisionWithOtherInterceptionMechanism(target: AnyObject)
   74|       |
   75|       |        /// For some reason saving original method implementation under RX namespace failed.
   76|       |        case savingOriginalForwardingMethodFailed(target: AnyObject)
   77|       |
   78|       |        /// Intercepting a sent message by replacing a method implementation with `_objc_msgForward` failed for some reason.
   79|       |        case replacingMethodWithForwardingImplementation(target: AnyObject)
   80|       |
   81|       |        /// Attempt to intercept one of the performance sensitive methods:
   82|       |        ///    * class
   83|       |        ///    * respondsToSelector:
   84|       |        ///    * methodSignatureForSelector:
   85|       |        ///    * forwardingTargetForSelector:
   86|       |        case observingPerformanceSensitiveMessages(target: AnyObject)
   87|       |
   88|       |        /// Message implementation has unsupported return type (for example large struct). The reason why this is a error
   89|       |        /// is because in some cases intercepting sent messages requires replacing implementation with `_objc_msgForward_stret`
   90|       |        /// instead of `_objc_msgForward`.
   91|       |        ///
   92|       |        /// The unsupported cases should be fairly uncommon.
   93|       |        case observingMessagesWithUnsupportedReturnType(target: AnyObject)
   94|       |    }
   95|       |
   96|       |    extension RxCocoaObjCRuntimeError {
   97|       |        /// A textual representation of `self`, suitable for debugging.
   98|      0|        public var debugDescription: String {
   99|      0|            switch self {
  100|      0|            case let .unknown(target):
  101|      0|                return "Unknown error occurred.\nTarget: `\(target)`"
  102|      0|            case let .objectMessagesAlreadyBeingIntercepted(target, interceptionMechanism):
  103|      0|                let interceptionMechanismDescription = interceptionMechanism == .kvo ? "KVO" : "other interception mechanism"
  104|      0|                return "Collision between RxCocoa interception mechanism and \(interceptionMechanismDescription)."
  105|      0|                    + " To resolve this conflict please use this interception mechanism first.\nTarget: \(target)"
  106|      0|            case let .selectorNotImplemented(target):
  107|      0|                return "Trying to observe messages for selector that isn't implemented.\nTarget: \(target)"
  108|      0|            case let .cantInterceptCoreFoundationTollFreeBridgedObjects(target):
  109|      0|                return "Interception of messages sent to Core Foundation isn't supported.\nTarget: \(target)"
  110|      0|            case let .threadingCollisionWithOtherInterceptionMechanism(target):
  111|      0|                return "Detected a conflict while modifying ObjC runtime.\nTarget: \(target)"
  112|      0|            case let .savingOriginalForwardingMethodFailed(target):
  113|      0|                return "Saving original method implementation failed.\nTarget: \(target)"
  114|      0|            case let .replacingMethodWithForwardingImplementation(target):
  115|      0|                return "Intercepting a sent message by replacing a method implementation with `_objc_msgForward` failed for some reason.\nTarget: \(target)"
  116|      0|            case let .observingPerformanceSensitiveMessages(target):
  117|      0|                return "Attempt to intercept one of the performance sensitive methods. \nTarget: \(target)"
  118|      0|            case let .observingMessagesWithUnsupportedReturnType(target):
  119|      0|                return "Attempt to intercept a method with unsupported return type. \nTarget: \(target)"
  120|      0|            }
  121|      0|        }
  122|       |    }
  123|       |    
  124|       |    // MARK: Conversions `NSError` > `RxCocoaObjCRuntimeError`
  125|       |
  126|       |    extension Error {
  127|      0|        func rxCocoaErrorForTarget(_ target: AnyObject) -> RxCocoaObjCRuntimeError {
  128|      0|            let error = self as NSError
  129|      0|            
  130|      0|            if error.domain == RXObjCRuntimeErrorDomain {
  131|      0|                let errorCode = RXObjCRuntimeError(rawValue: error.code) ?? .unknown
  132|      0|                
  133|      0|                switch errorCode {
  134|      0|                case .unknown:
  135|      0|                    return .unknown(target: target)
  136|      0|                case .objectMessagesAlreadyBeingIntercepted:
  137|      0|                    let isKVO = (error.userInfo[RXObjCRuntimeErrorIsKVOKey] as? NSNumber)?.boolValue ?? false
  138|      0|                    return .objectMessagesAlreadyBeingIntercepted(target: target, interceptionMechanism: isKVO ? .kvo : .unknown)
  139|      0|                case .selectorNotImplemented:
  140|      0|                    return .selectorNotImplemented(target: target)
  141|      0|                case .cantInterceptCoreFoundationTollFreeBridgedObjects:
  142|      0|                    return .cantInterceptCoreFoundationTollFreeBridgedObjects(target: target)
  143|      0|                case .threadingCollisionWithOtherInterceptionMechanism:
  144|      0|                    return .threadingCollisionWithOtherInterceptionMechanism(target: target)
  145|      0|                case .savingOriginalForwardingMethodFailed:
  146|      0|                    return .savingOriginalForwardingMethodFailed(target: target)
  147|      0|                case .replacingMethodWithForwardingImplementation:
  148|      0|                    return .replacingMethodWithForwardingImplementation(target: target)
  149|      0|                case .observingPerformanceSensitiveMessages:
  150|      0|                    return .observingPerformanceSensitiveMessages(target: target)
  151|      0|                case .observingMessagesWithUnsupportedReturnType:
  152|      0|                    return .observingMessagesWithUnsupportedReturnType(target: target)
  153|      0|                }
  154|      0|            }
  155|      0|            
  156|      0|            return RxCocoaObjCRuntimeError.unknown(target: target)
  157|      0|        }
  158|       |    }
  159|       |
  160|       |#endif
  161|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/RxTarget.swift:
    1|       |//
    2|       |//  RxTarget.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSObject
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |
   15|       |class RxTarget : NSObject
   16|       |               , Disposable {
   17|       |    
   18|       |    private var retainSelf: RxTarget?
   19|       |    
   20|    370|    override init() {
   21|    370|        super.init()
   22|    370|        self.retainSelf = self
   23|    370|
   24|    370|#if TRACE_RESOURCES
   25|    370|        _ = Resources.incrementTotal()
   26|    370|#endif
   27|    370|
   28|    370|#if DEBUG
   29|    370|        MainScheduler.ensureExecutingOnScheduler()
   30|    370|#endif
   31|    370|    }
   32|       |    
   33|      1|    func dispose() {
   34|      1|#if DEBUG
   35|      1|        MainScheduler.ensureExecutingOnScheduler()
   36|      1|#endif
   37|      1|        self.retainSelf = nil
   38|      1|    }
   39|       |
   40|       |#if TRACE_RESOURCES
   41|       |    deinit {
   42|       |        _ = Resources.decrementTotal()
   43|       |    }
   44|       |#endif
   45|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Common/TextInput.swift:
    1|       |//
    2|       |//  TextInput.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/12/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |#if os(iOS) || os(tvOS)
   14|       |    import UIKit
   15|       |
   16|       |    /// Represents text input with reactive extensions.
   17|       |    public struct TextInput<Base: UITextInput> {
   18|       |        /// Base text input to extend.
   19|       |        public let base: Base
   20|       |
   21|       |        /// Reactive wrapper for `text` property.
   22|       |        public let text: ControlProperty<String?>
   23|       |
   24|       |        /// Initializes new text input.
   25|       |        ///
   26|       |        /// - parameter base: Base object.
   27|       |        /// - parameter text: Textual control property.
   28|      0|        public init(base: Base, text: ControlProperty<String?>) {
   29|      0|            self.base = base
   30|      0|            self.text = text
   31|      0|        }
   32|       |    }
   33|       |
   34|       |    extension Reactive where Base: UITextField {
   35|       |        /// Reactive text input.
   36|      0|        public var textInput: TextInput<Base> {
   37|      0|            return TextInput(base: base, text: self.text)
   38|      0|        }
   39|       |    }
   40|       |
   41|       |    extension Reactive where Base: UITextView {
   42|       |        /// Reactive text input.
   43|      0|        public var textInput: TextInput<Base> {
   44|      0|            return TextInput(base: base, text: self.text)
   45|      0|        }
   46|       |    }
   47|       |
   48|       |#endif
   49|       |
   50|       |#if os(macOS)
   51|       |    import Cocoa
   52|       |
   53|       |    /// Represents text input with reactive extensions.
   54|       |    public struct TextInput<Base: NSTextInputClient> {
   55|       |        /// Base text input to extend.
   56|       |        public let base: Base
   57|       |
   58|       |        /// Reactive wrapper for `text` property.
   59|       |        public let text: ControlProperty<String?>
   60|       |
   61|       |        /// Initializes new text input.
   62|       |        ///
   63|       |        /// - parameter base: Base object.
   64|       |        /// - parameter text: Textual control property.
   65|       |        public init(base: Base, text: ControlProperty<String?>) {
   66|       |            self.base = base
   67|       |            self.text = text
   68|       |        }
   69|       |    }
   70|       |
   71|       |    extension Reactive where Base: NSTextField, Base: NSTextInputClient {
   72|       |        /// Reactive text input.
   73|       |        public var textInput: TextInput<Base> {
   74|       |            return TextInput(base: base, text: self.text)
   75|       |        }
   76|       |    }
   77|       |
   78|       |#endif
   79|       |
   80|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Deprecated.swift:
    1|       |//
    2|       |//  Deprecated.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/19/17.
    6|       |//  Copyright © 2017 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |extension ObservableType {
   14|       |
   15|       |    /**
   16|       |     Creates new subscription and sends elements to observer.
   17|       |
   18|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   19|       |     writing more consistent binding code.
   20|       |
   21|       |     - parameter observer: Observer that receives events.
   22|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   23|       |     */
   24|       |    @available(*, deprecated, renamed: "bind(to:)")
   25|      0|    public func bindTo<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   26|      0|        return self.subscribe(observer)
   27|      0|    }
   28|       |
   29|       |    /**
   30|       |     Creates new subscription and sends elements to observer.
   31|       |
   32|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better, and enables
   33|       |     writing more consistent binding code.
   34|       |
   35|       |     - parameter observer: Observer that receives events.
   36|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   37|       |     */
   38|       |    @available(*, deprecated, renamed: "bind(to:)")
   39|      0|    public func bindTo<O: ObserverType>(_ observer: O) -> Disposable where O.E == E? {
   40|      0|        return self.map { $0 }.subscribe(observer)
   41|      0|    }
   42|       |
   43|       |    /**
   44|       |     Creates new subscription and sends elements to variable.
   45|       |
   46|       |     In case error occurs in debug mode, `fatalError` will be raised.
   47|       |     In case error occurs in release mode, `error` will be logged.
   48|       |
   49|       |     - parameter variable: Target variable for sequence elements.
   50|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   51|       |     */
   52|       |    @available(*, deprecated, renamed: "bind(to:)")
   53|      0|    public func bindTo(_ variable: Variable<E>) -> Disposable {
   54|      0|        return subscribe { e in
   55|      0|            switch e {
   56|      0|            case let .next(element):
   57|      0|                variable.value = element
   58|      0|            case let .error(error):
   59|      0|                let error = "Binding error to variable: \(error)"
   60|      0|                #if DEBUG
   61|      0|                    rxFatalError(error)
   62|      0|                #else
   63|      0|                    print(error)
   64|      0|                #endif
   65|      0|            case .completed:
   66|      0|                break
   67|      0|            }
   68|      0|        }
   69|      0|    }
   70|       |
   71|       |    /**
   72|       |     Creates new subscription and sends elements to variable.
   73|       |
   74|       |     In case error occurs in debug mode, `fatalError` will be raised.
   75|       |     In case error occurs in release mode, `error` will be logged.
   76|       |
   77|       |     - parameter variable: Target variable for sequence elements.
   78|       |     - returns: Disposable object that can be used to unsubscribe the observer.
   79|       |     */
   80|       |    @available(*, deprecated, renamed: "bind(to:)")
   81|      0|    public func bindTo(_ variable: Variable<E?>) -> Disposable {
   82|      0|        return self.map { $0 as E? }.bindTo(variable)
   83|      0|    }
   84|       |
   85|       |    /**
   86|       |     Subscribes to observable sequence using custom binder function.
   87|       |
   88|       |     - parameter binder: Function used to bind elements from `self`.
   89|       |     - returns: Object representing subscription.
   90|       |     */
   91|       |    @available(*, deprecated, renamed: "bind(to:)")
   92|      0|    public func bindTo<R>(_ binder: (Self) -> R) -> R {
   93|      0|        return binder(self)
   94|      0|    }
   95|       |
   96|       |    /**
   97|       |     Subscribes to observable sequence using custom binder function and final parameter passed to binder function
   98|       |     after `self` is passed.
   99|       |
  100|       |     public func bindTo<R1, R2>(binder: Self -> R1 -> R2, curriedArgument: R1) -> R2 {
  101|       |     return binder(self)(curriedArgument)
  102|       |     }
  103|       |
  104|       |     - parameter binder: Function used to bind elements from `self`.
  105|       |     - parameter curriedArgument: Final argument passed to `binder` to finish binding process.
  106|       |     - returns: Object representing subscription.
  107|       |     */
  108|       |    @available(*, deprecated, renamed: "bind(to:)")
  109|      0|    public func bindTo<R1, R2>(_ binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2 {
  110|      0|        return binder(self)(curriedArgument)
  111|      0|    }
  112|       |
  113|       |
  114|       |    /**
  115|       |     Subscribes an element handler to an observable sequence.
  116|       |
  117|       |     In case error occurs in debug mode, `fatalError` will be raised.
  118|       |     In case error occurs in release mode, `error` will be logged.
  119|       |
  120|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  121|       |     - returns: Subscription object used to unsubscribe from the observable sequence.
  122|       |     */
  123|       |    @available(*, deprecated, renamed: "bind(onNext:)")
  124|      0|    public func bindNext(_ onNext: @escaping (E) -> Void) -> Disposable {
  125|      0|        return subscribe(onNext: onNext, onError: { error in
  126|      0|            let error = "Binding error: \(error)"
  127|      0|            #if DEBUG
  128|      0|                rxFatalError(error)
  129|      0|            #else
  130|      0|                print(error)
  131|      0|            #endif
  132|      0|        })
  133|      0|    }
  134|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/KVORepresentable+CoreGraphics.swift:
    1|       |//
    2|       |//  KVORepresentable+CoreGraphics.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |    import RxSwift
   13|       |#endif
   14|       |    import CoreGraphics
   15|       |
   16|       |    import class Foundation.NSValue
   17|       |
   18|       |#if arch(x86_64) || arch(arm64)
   19|       |let CGRectType = "{CGRect={CGPoint=dd}{CGSize=dd}}"
   20|       |let CGSizeType = "{CGSize=dd}"
   21|       |let CGPointType = "{CGPoint=dd}"
   22|       |#elseif arch(i386) || arch(arm)
   23|       |let CGRectType = "{CGRect={CGPoint=ff}{CGSize=ff}}"
   24|       |let CGSizeType = "{CGSize=ff}"
   25|       |let CGPointType = "{CGPoint=ff}"
   26|       |#endif
   27|       |
   28|       |extension CGRect : KVORepresentable {
   29|       |    public typealias KVOType = NSValue
   30|       |
   31|       |    /// Constructs self from `NSValue`.
   32|      0|    public init?(KVOValue: KVOType) {
   33|      0|        if strcmp(KVOValue.objCType, CGRectType) != 0 {
   34|      0|            return nil
   35|      0|        }
   36|      0|        var typedValue = CGRect(x: 0, y: 0, width: 0, height: 0)
   37|      0|        KVOValue.getValue(&typedValue)
   38|      0|        self = typedValue
   39|      0|    }
   40|       |}
   41|       |
   42|       |extension CGPoint : KVORepresentable {
   43|       |    public typealias KVOType = NSValue
   44|       |
   45|       |    /// Constructs self from `NSValue`.
   46|      0|    public init?(KVOValue: KVOType) {
   47|      0|        if strcmp(KVOValue.objCType, CGPointType) != 0 {
   48|      0|            return nil
   49|      0|        }
   50|      0|        var typedValue = CGPoint(x: 0, y: 0)
   51|      0|        KVOValue.getValue(&typedValue)
   52|      0|        self = typedValue
   53|      0|    }
   54|       |}
   55|       |
   56|       |extension CGSize : KVORepresentable {
   57|       |    public typealias KVOType = NSValue
   58|       |
   59|       |    /// Constructs self from `NSValue`.
   60|      0|    public init?(KVOValue: KVOType) {
   61|      0|        if strcmp(KVOValue.objCType, CGSizeType) != 0 {
   62|      0|            return nil
   63|      0|        }
   64|      0|        var typedValue = CGSize(width: 0, height: 0)
   65|      0|        KVOValue.getValue(&typedValue)
   66|      0|        self = typedValue
   67|      0|    }
   68|       |}
   69|       |
   70|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/KVORepresentable+Swift.swift:
    1|       |//
    2|       |//  KVORepresentable+Swift.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSNumber
   10|       |
   11|       |extension Int : KVORepresentable {
   12|       |    public typealias KVOType = NSNumber
   13|       |
   14|       |    /// Constructs `Self` using KVO value.
   15|      0|    public init?(KVOValue: KVOType) {
   16|      0|        self.init(KVOValue.int32Value)
   17|      0|    }
   18|       |}
   19|       |
   20|       |extension Int32 : KVORepresentable {
   21|       |    public typealias KVOType = NSNumber
   22|       |
   23|       |    /// Constructs `Self` using KVO value.
   24|      0|    public init?(KVOValue: KVOType) {
   25|      0|        self.init(KVOValue.int32Value)
   26|      0|    }
   27|       |}
   28|       |
   29|       |extension Int64 : KVORepresentable {
   30|       |    public typealias KVOType = NSNumber
   31|       |
   32|       |    /// Constructs `Self` using KVO value.
   33|      0|    public init?(KVOValue: KVOType) {
   34|      0|        self.init(KVOValue.int64Value)
   35|      0|    }
   36|       |}
   37|       |
   38|       |extension UInt : KVORepresentable {
   39|       |    public typealias KVOType = NSNumber
   40|       |
   41|       |    /// Constructs `Self` using KVO value.
   42|      0|    public init?(KVOValue: KVOType) {
   43|      0|        self.init(KVOValue.uintValue)
   44|      0|    }
   45|       |}
   46|       |
   47|       |extension UInt32 : KVORepresentable {
   48|       |    public typealias KVOType = NSNumber
   49|       |
   50|       |    /// Constructs `Self` using KVO value.
   51|      0|    public init?(KVOValue: KVOType) {
   52|      0|        self.init(KVOValue.uint32Value)
   53|      0|    }
   54|       |}
   55|       |
   56|       |extension UInt64 : KVORepresentable {
   57|       |    public typealias KVOType = NSNumber
   58|       |
   59|       |    /// Constructs `Self` using KVO value.
   60|      0|    public init?(KVOValue: KVOType) {
   61|      0|        self.init(KVOValue.uint64Value)
   62|      0|    }
   63|       |}
   64|       |
   65|       |extension Bool : KVORepresentable {
   66|       |    public typealias KVOType = NSNumber
   67|       |
   68|       |    /// Constructs `Self` using KVO value.
   69|      0|    public init?(KVOValue: KVOType) {
   70|      0|        self.init(KVOValue.boolValue)
   71|      0|    }
   72|       |}
   73|       |
   74|       |
   75|       |extension RawRepresentable where RawValue: KVORepresentable {
   76|       |    /// Constructs `Self` using optional KVO value.
   77|      0|    init?(KVOValue: RawValue.KVOType?) {
   78|      0|        guard let KVOValue = KVOValue else {
   79|      0|            return nil
   80|      0|        }
   81|      0|
   82|      0|        guard let rawValue = RawValue(KVOValue: KVOValue) else {
   83|      0|            return nil
   84|      0|        }
   85|      0|
   86|      0|        self.init(rawValue: rawValue)
   87|      0|    }
   88|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/KVORepresentable.swift:
    1|       |//
    2|       |//  KVORepresentable.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Type that is KVO representable (KVO mechanism can be used to observe it).
   10|       |public protocol KVORepresentable {
   11|       |    /// Associated KVO type.
   12|       |    associatedtype KVOType
   13|       |
   14|       |    /// Constructs `Self` using KVO value.
   15|       |    init?(KVOValue: KVOType)
   16|       |}
   17|       |
   18|       |extension KVORepresentable {
   19|       |    /// Initializes `KVORepresentable` with optional value.
   20|      0|    init?(KVOValue: KVOType?) {
   21|      0|        guard let KVOValue = KVOValue else {
   22|      0|            return nil
   23|      0|        }
   24|      0|
   25|      0|        self.init(KVOValue: KVOValue)
   26|      0|    }
   27|       |}
   28|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/NSObject+Rx+KVORepresentable.swift:
    1|       |//
    2|       |//  NSObject+Rx+KVORepresentable.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/14/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import Foundation
   12|       |#if !RX_NO_MODULE
   13|       |    import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: NSObject {
   17|       |
   18|       |    /**
   19|       |     Specialization of generic `observe` method.
   20|       |
   21|       |     This is a special overload because to observe values of some type (for example `Int`), first values of KVO type
   22|       |     need to be observed (`NSNumber`), and then converted to result type.
   23|       |
   24|       |     For more information take a look at `observe` method.
   25|       |     */
   26|      0|    public func observe<E: KVORepresentable>(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -> Observable<E?> {
   27|      0|        return observe(E.KVOType.self, keyPath, options: options, retainSelf: retainSelf)
   28|      0|            .map(E.init)
   29|      0|    }
   30|       |}
   31|       |
   32|       |#if !DISABLE_SWIZZLING && !os(Linux)
   33|       |    // KVO
   34|       |    extension Reactive where Base: NSObject {
   35|       |        /**
   36|       |        Specialization of generic `observeWeakly` method.
   37|       |
   38|       |        For more information take a look at `observeWeakly` method.
   39|       |        */
   40|      0|        public func observeWeakly<E: KVORepresentable>(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial]) -> Observable<E?> {
   41|      0|            return observeWeakly(E.KVOType.self, keyPath, options: options)
   42|      0|                .map(E.init)
   43|      0|        }
   44|       |    }
   45|       |#endif
   46|       |
   47|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/NSObject+Rx+RawRepresentable.swift:
    1|       |//
    2|       |//  NSObject+Rx+RawRepresentable.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/9/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import Foundation
   12|       |#if !RX_NO_MODULE
   13|       |    import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: NSObject {
   17|       |    /**
   18|       |     Specialization of generic `observe` method.
   19|       |
   20|       |     This specialization first observes `KVORepresentable` value and then converts it to `RawRepresentable` value.
   21|       |     
   22|       |     It is useful for observing bridged ObjC enum values.
   23|       |
   24|       |     For more information take a look at `observe` method.
   25|       |     */
   26|      0|    public func observe<E: RawRepresentable>(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -> Observable<E?> where E.RawValue: KVORepresentable {
   27|      0|        return observe(E.RawValue.KVOType.self, keyPath, options: options, retainSelf: retainSelf)
   28|      0|            .map(E.init)
   29|      0|    }
   30|       |}
   31|       |
   32|       |#if !DISABLE_SWIZZLING
   33|       |
   34|       |    // observeWeakly + RawRepresentable
   35|       |    extension Reactive where Base: NSObject {
   36|       |
   37|       |        /**
   38|       |         Specialization of generic `observeWeakly` method.
   39|       |
   40|       |         This specialization first observes `KVORepresentable` value and then converts it to `RawRepresentable` value.
   41|       |     
   42|       |         It is useful for observing bridged ObjC enum values.
   43|       |
   44|       |         For more information take a look at `observeWeakly` method.
   45|       |         */
   46|      0|        public func observeWeakly<E: RawRepresentable>(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial]) -> Observable<E?> where E.RawValue: KVORepresentable {
   47|      0|            return observeWeakly(E.RawValue.KVOType.self, keyPath, options: options)
   48|      0|                .map(E.init)
   49|      0|        }
   50|       |    }
   51|       |#endif
   52|       |
   53|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/NSObject+Rx.swift:
    1|       |//
    2|       |//  NSObject+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !os(Linux)
   10|       |
   11|       |import Foundation
   12|       |#if !RX_NO_MODULE
   13|       |    import RxSwift
   14|       |    #if SWIFT_PACKAGE && !DISABLE_SWIZZLING && !os(Linux)
   15|       |        import RxCocoaRuntime
   16|       |    #endif
   17|       |#endif
   18|       |
   19|       |#if !DISABLE_SWIZZLING && !os(Linux)
   20|       |fileprivate var deallocatingSubjectTriggerContext: UInt8 = 0
   21|       |fileprivate var deallocatingSubjectContext: UInt8 = 0
   22|       |#endif
   23|       |fileprivate var deallocatedSubjectTriggerContext: UInt8 = 0
   24|       |fileprivate var deallocatedSubjectContext: UInt8 = 0
   25|       |
   26|       |#if !os(Linux)
   27|       |
   28|       |/**
   29|       |KVO is a tricky mechanism.
   30|       |
   31|       |When observing child in a ownership hierarchy, usually retaining observing target is wanted behavior.
   32|       |When observing parent in a ownership hierarchy, usually retaining target isn't wanter behavior.
   33|       |
   34|       |KVO with weak references is especially tricky. For it to work, some kind of swizzling is required.
   35|       |That can be done by
   36|       |    * replacing object class dynamically (like KVO does)
   37|       |    * by swizzling `dealloc` method on all instances for a class.
   38|       |    * some third method ...
   39|       |
   40|       |Both approaches can fail in certain scenarios:
   41|       |    * problems arise when swizzlers return original object class (like KVO does when nobody is observing)
   42|       |    * Problems can arise because replacing dealloc method isn't atomic operation (get implementation,
   43|       |    set implementation).
   44|       |
   45|       |Second approach is chosen. It can fail in case there are multiple libraries dynamically trying
   46|       |to replace dealloc method. In case that isn't the case, it should be ok.
   47|       |*/
   48|       |extension Reactive where Base: NSObject {
   49|       |
   50|       |
   51|       |    /**
   52|       |     Observes values on `keyPath` starting from `self` with `options` and retains `self` if `retainSelf` is set.
   53|       |
   54|       |     `observe` is just a simple and performant wrapper around KVO mechanism.
   55|       |
   56|       |     * it can be used to observe paths starting from `self` or from ancestors in ownership graph (`retainSelf = false`)
   57|       |     * it can be used to observe paths starting from descendants in ownership graph (`retainSelf = true`)
   58|       |     * the paths have to consist only of `strong` properties, otherwise you are risking crashing the system by not unregistering KVO observer before dealloc.
   59|       |
   60|       |     If support for weak properties is needed or observing arbitrary or unknown relationships in the
   61|       |     ownership tree, `observeWeakly` is the preferred option.
   62|       |
   63|       |     - parameter keyPath: Key path of property names to observe.
   64|       |     - parameter options: KVO mechanism notification options.
   65|       |     - parameter retainSelf: Retains self during observation if set `true`.
   66|       |     - returns: Observable sequence of objects on `keyPath`.
   67|       |     */
   68|      0|    public func observe<E>(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -> Observable<E?> {
   69|      0|        return KVOObservable(object: base, keyPath: keyPath, options: options, retainTarget: retainSelf).asObservable()
   70|      0|    }
   71|       |}
   72|       |
   73|       |#endif
   74|       |
   75|       |#if !DISABLE_SWIZZLING && !os(Linux)
   76|       |// KVO
   77|       |extension Reactive where Base: NSObject {
   78|       |    /**
   79|       |     Observes values on `keyPath` starting from `self` with `options` and doesn't retain `self`.
   80|       |
   81|       |     It can be used in all cases where `observe` can be used and additionally
   82|       |
   83|       |     * because it won't retain observed target, it can be used to observe arbitrary object graph whose ownership relation is unknown
   84|       |     * it can be used to observe `weak` properties
   85|       |
   86|       |     **Since it needs to intercept object deallocation process it needs to perform swizzling of `dealloc` method on observed object.**
   87|       |
   88|       |     - parameter keyPath: Key path of property names to observe.
   89|       |     - parameter options: KVO mechanism notification options.
   90|       |     - returns: Observable sequence of objects on `keyPath`.
   91|       |     */
   92|      0|    public func observeWeakly<E>(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial]) -> Observable<E?> {
   93|      0|        return observeWeaklyKeyPathFor(base, keyPath: keyPath, options: options)
   94|      0|            .map { n in
   95|      0|                return n as? E
   96|      0|            }
   97|      0|    }
   98|       |}
   99|       |#endif
  100|       |
  101|       |// Dealloc
  102|       |extension Reactive where Base: AnyObject {
  103|       |    
  104|       |    /**
  105|       |    Observable sequence of object deallocated events.
  106|       |    
  107|       |    After object is deallocated one `()` element will be produced and sequence will immediately complete.
  108|       |    
  109|       |    - returns: Observable sequence of object deallocated events.
  110|       |    */
  111|    374|    public var deallocated: Observable<Void> {
  112|    374|        return synchronized {
  113|     92|            if let deallocObservable = objc_getAssociatedObject(base, &deallocatedSubjectContext) as? DeallocObservable {
  114|     92|                return deallocObservable._subject
  115|    282|            }
  116|    282|
  117|    282|            let deallocObservable = DeallocObservable()
  118|    282|
  119|    282|            objc_setAssociatedObject(base, &deallocatedSubjectContext, deallocObservable, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  120|    282|            return deallocObservable._subject
  121|    374|        }
  122|    374|    }
  123|       |
  124|       |#if !DISABLE_SWIZZLING && !os(Linux)
  125|       |
  126|       |    /**
  127|       |     Observable sequence of message arguments that completes when object is deallocated.
  128|       |     
  129|       |     Each element is produced before message is invoked on target object. `methodInvoked`
  130|       |     exists in case observing of invoked messages is needed.
  131|       |
  132|       |     In case an error occurs sequence will fail with `RxCocoaObjCRuntimeError`.
  133|       |     
  134|       |     In case some argument is `nil`, instance of `NSNull()` will be sent.
  135|       |
  136|       |     - returns: Observable sequence of object deallocating events.
  137|       |     */
  138|      0|    public func sentMessage(_ selector: Selector) -> Observable<[Any]> {
  139|      0|        return synchronized {
  140|      0|            // in case of dealloc selector replay subject behavior needs to be used
  141|      0|            if selector == deallocSelector {
  142|      0|                return deallocating.map { _ in [] }
  143|      0|            }
  144|      0|
  145|      0|            do {
  146|      0|                let proxy: MessageSentProxy = try registerMessageInterceptor(selector)
  147|      0|                return proxy.messageSent.asObservable()
  148|      0|            }
  149|      0|            catch let e {
  150|      0|                return Observable.error(e)
  151|      0|            }
  152|      0|        }
  153|      0|    }
  154|       |
  155|       |    /**
  156|       |     Observable sequence of message arguments that completes when object is deallocated.
  157|       |
  158|       |     Each element is produced after message is invoked on target object. `sentMessage`
  159|       |     exists in case interception of sent messages before they were invoked is needed.
  160|       |
  161|       |     In case an error occurs sequence will fail with `RxCocoaObjCRuntimeError`.
  162|       |
  163|       |     In case some argument is `nil`, instance of `NSNull()` will be sent.
  164|       |
  165|       |     - returns: Observable sequence of object deallocating events.
  166|       |     */
  167|      0|    public func methodInvoked(_ selector: Selector) -> Observable<[Any]> {
  168|      0|        return synchronized {
  169|      0|            // in case of dealloc selector replay subject behavior needs to be used
  170|      0|            if selector == deallocSelector {
  171|      0|                return deallocated.map { _ in [] }
  172|      0|            }
  173|      0|
  174|      0|
  175|      0|            do {
  176|      0|                let proxy: MessageSentProxy = try registerMessageInterceptor(selector)
  177|      0|                return proxy.methodInvoked.asObservable()
  178|      0|            }
  179|      0|            catch let e {
  180|      0|                return Observable.error(e)
  181|      0|            }
  182|      0|        }
  183|      0|    }
  184|       |
  185|       |    /**
  186|       |    Observable sequence of object deallocating events.
  187|       |    
  188|       |    When `dealloc` message is sent to `self` one `()` element will be produced and after object is deallocated sequence
  189|       |    will immediately complete.
  190|       |     
  191|       |    In case an error occurs sequence will fail with `RxCocoaObjCRuntimeError`.
  192|       |    
  193|       |    - returns: Observable sequence of object deallocating events.
  194|       |    */
  195|      0|    public var deallocating: Observable<()> {
  196|      0|        return synchronized {
  197|      0|            do {
  198|      0|                let proxy: DeallocatingProxy = try registerMessageInterceptor(deallocSelector)
  199|      0|                return proxy.messageSent.asObservable()
  200|      0|            }
  201|      0|            catch let e {
  202|      0|                return Observable.error(e)
  203|      0|            }
  204|      0|        }
  205|      0|    }
  206|       |
  207|      0|    fileprivate func registerMessageInterceptor<T: MessageInterceptorSubject>(_ selector: Selector) throws -> T {
  208|      0|        let rxSelector = RX_selector(selector)
  209|      0|        let selectorReference = RX_reference_from_selector(rxSelector)
  210|      0|
  211|      0|        let subject: T
  212|      0|        if let existingSubject = objc_getAssociatedObject(base, selectorReference) as? T {
  213|      0|            subject = existingSubject
  214|      0|        }
  215|      0|        else {
  216|      0|            subject = T()
  217|      0|            objc_setAssociatedObject(
  218|      0|                base,
  219|      0|                selectorReference,
  220|      0|                subject,
  221|      0|                .OBJC_ASSOCIATION_RETAIN_NONATOMIC
  222|      0|            )
  223|      0|        }
  224|      0|
  225|      0|        if subject.isActive {
  226|      0|            return subject
  227|      0|        }
  228|      0|
  229|      0|        var error: NSError?
  230|      0|        let targetImplementation = RX_ensure_observing(base, selector, &error)
  231|      0|        if targetImplementation == nil {
  232|      0|            throw error?.rxCocoaErrorForTarget(base) ?? RxCocoaError.unknown
  233|      0|        }
  234|      0|
  235|      0|        subject.targetImplementation = targetImplementation!
  236|      0|
  237|      0|        return subject
  238|      0|    }
  239|       |#endif
  240|       |}
  241|       |
  242|       |// MARK: Message interceptors
  243|       |
  244|       |#if !DISABLE_SWIZZLING && !os(Linux)
  245|       |
  246|       |    fileprivate protocol MessageInterceptorSubject: class {
  247|       |        init()
  248|       |
  249|       |        var isActive: Bool {
  250|       |            get
  251|       |        }
  252|       |
  253|       |        var targetImplementation: IMP { get set }
  254|       |    }
  255|       |
  256|       |    fileprivate final class DeallocatingProxy
  257|       |        : MessageInterceptorSubject
  258|       |        , RXDeallocatingObserver {
  259|       |        typealias E = ()
  260|       |
  261|       |        let messageSent = ReplaySubject<()>.create(bufferSize: 1)
  262|       |
  263|       |        @objc var targetImplementation: IMP = RX_default_target_implementation()
  264|       |
  265|      0|        var isActive: Bool {
  266|      0|            return targetImplementation != RX_default_target_implementation()
  267|      0|        }
  268|       |
  269|      0|        init() {
  270|      0|        }
  271|       |
  272|      0|        @objc func deallocating() -> Void {
  273|      0|            messageSent.on(.next())
  274|      0|        }
  275|       |
  276|      0|        deinit {
  277|      0|            messageSent.on(.completed)
  278|      0|        }
  279|       |    }
  280|       |
  281|       |    fileprivate final class MessageSentProxy
  282|       |        : MessageInterceptorSubject
  283|       |        , RXMessageSentObserver {
  284|       |        typealias E = [AnyObject]
  285|       |
  286|       |        let messageSent = PublishSubject<[Any]>()
  287|       |        let methodInvoked = PublishSubject<[Any]>()
  288|       |
  289|       |        @objc var targetImplementation: IMP = RX_default_target_implementation()
  290|       |
  291|      0|        var isActive: Bool {
  292|      0|            return targetImplementation != RX_default_target_implementation()
  293|      0|        }
  294|       |
  295|      0|        init() {
  296|      0|        }
  297|       |
  298|      0|        @objc func messageSent(withArguments arguments: [Any]) -> Void {
  299|      0|            messageSent.on(.next(arguments))
  300|      0|        }
  301|       |
  302|      0|        @objc func methodInvoked(withArguments arguments: [Any]) -> Void {
  303|      0|            methodInvoked.on(.next(arguments))
  304|      0|        }
  305|       |
  306|      0|        deinit {
  307|      0|            messageSent.on(.completed)
  308|      0|            methodInvoked.on(.completed)
  309|      0|        }
  310|       |    }
  311|       |
  312|       |#endif
  313|       |
  314|       |
  315|       |fileprivate final class DeallocObservable {
  316|       |    let _subject = ReplaySubject<Void>.create(bufferSize:1)
  317|       |
  318|    282|    init() {
  319|    282|    }
  320|       |
  321|      0|    deinit {
  322|      0|        _subject.on(.next(()))
  323|      0|        _subject.on(.completed)
  324|      0|    }
  325|       |}
  326|       |
  327|       |// MARK: KVO
  328|       |
  329|       |#if !os(Linux)
  330|       |
  331|       |fileprivate protocol KVOObservableProtocol {
  332|       |    var target: AnyObject { get }
  333|       |    var keyPath: String { get }
  334|       |    var retainTarget: Bool { get }
  335|       |    var options: NSKeyValueObservingOptions { get }
  336|       |}
  337|       |
  338|       |fileprivate final class KVOObserver
  339|       |    : _RXKVOObserver
  340|       |    , Disposable {
  341|       |    typealias Callback = (Any?) -> Void
  342|       |
  343|       |    var retainSelf: KVOObserver? = nil
  344|       |
  345|      0|    init(parent: KVOObservableProtocol, callback: @escaping Callback) {
  346|      0|        #if TRACE_RESOURCES
  347|      0|            _ = Resources.incrementTotal()
  348|      0|        #endif
  349|      0|
  350|      0|        super.init(target: parent.target, retainTarget: parent.retainTarget, keyPath: parent.keyPath, options: parent.options, callback: callback)
  351|      0|        self.retainSelf = self
  352|      0|    }
  353|       |
  354|      0|    override func dispose() {
  355|      0|        super.dispose()
  356|      0|        self.retainSelf = nil
  357|      0|    }
  358|       |
  359|      0|    deinit {
  360|      0|        #if TRACE_RESOURCES
  361|      0|            _ = Resources.decrementTotal()
  362|      0|        #endif
  363|      0|    }
  364|       |}
  365|       |
  366|       |fileprivate final class KVOObservable<Element>
  367|       |    : ObservableType
  368|       |    , KVOObservableProtocol {
  369|       |    typealias E = Element?
  370|       |
  371|       |    unowned var target: AnyObject
  372|       |    var strongTarget: AnyObject?
  373|       |
  374|       |    var keyPath: String
  375|       |    var options: NSKeyValueObservingOptions
  376|       |    var retainTarget: Bool
  377|       |
  378|      0|    init(object: AnyObject, keyPath: String, options: NSKeyValueObservingOptions, retainTarget: Bool) {
  379|      0|        self.target = object
  380|      0|        self.keyPath = keyPath
  381|      0|        self.options = options
  382|      0|        self.retainTarget = retainTarget
  383|      0|        if retainTarget {
  384|      0|            self.strongTarget = object
  385|      0|        }
  386|      0|    }
  387|       |
  388|      0|    func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == Element? {
  389|      0|        let observer = KVOObserver(parent: self) { (value) in
  390|      0|            if value as? NSNull != nil {
  391|      0|                observer.on(.next(nil))
  392|      0|                return
  393|      0|            }
  394|      0|            observer.on(.next(value as? Element))
  395|      0|        }
  396|      0|
  397|      0|        return Disposables.create(with: observer.dispose)
  398|      0|    }
  399|       |
  400|       |}
  401|       |
  402|       |#endif
  403|       |
  404|       |#if !DISABLE_SWIZZLING && !os(Linux)
  405|       |
  406|      0|    fileprivate func observeWeaklyKeyPathFor(_ target: NSObject, keyPath: String, options: NSKeyValueObservingOptions) -> Observable<AnyObject?> {
  407|      0|        let components = keyPath.components(separatedBy: ".").filter { $0 != "self" }
  408|      0|
  409|      0|        let observable = observeWeaklyKeyPathFor(target, keyPathSections: components, options: options)
  410|      0|            .finishWithNilWhenDealloc(target)
  411|      0|
  412|      0|        if !options.intersection(.initial).isEmpty {
  413|      0|            return observable
  414|      0|        }
  415|      0|        else {
  416|      0|            return observable
  417|      0|                .skip(1)
  418|      0|        }
  419|      0|    }
  420|       |
  421|       |    // This should work correctly
  422|       |    // Identifiers can't contain `,`, so the only place where `,` can appear
  423|       |    // is as a delimiter.
  424|       |    // This means there is `W` as element in an array of property attributes.
  425|      0|    fileprivate func isWeakProperty(_ properyRuntimeInfo: String) -> Bool {
  426|      0|        return properyRuntimeInfo.range(of: ",W,") != nil
  427|      0|    }
  428|       |
  429|       |    fileprivate extension ObservableType where E == AnyObject? {
  430|       |        func finishWithNilWhenDealloc(_ target: NSObject)
  431|      0|            -> Observable<AnyObject?> {
  432|      0|                let deallocating = target.rx.deallocating
  433|      0|
  434|      0|                return deallocating
  435|      0|                    .map { _ in
  436|      0|                        return Observable.just(nil)
  437|      0|                    }
  438|      0|                    .startWith(self.asObservable())
  439|      0|                    .switchLatest()
  440|      0|        }
  441|       |    }
  442|       |
  443|       |    fileprivate func observeWeaklyKeyPathFor(
  444|       |        _ target: NSObject,
  445|       |        keyPathSections: [String],
  446|       |        options: NSKeyValueObservingOptions
  447|      0|        ) -> Observable<AnyObject?> {
  448|      0|
  449|      0|        weak var weakTarget: AnyObject? = target
  450|      0|
  451|      0|        let propertyName = keyPathSections[0]
  452|      0|        let remainingPaths = Array(keyPathSections[1..<keyPathSections.count])
  453|      0|
  454|      0|        let property = class_getProperty(object_getClass(target), propertyName)
  455|      0|        if property == nil {
  456|      0|            return Observable.error(RxCocoaError.invalidPropertyName(object: target, propertyName: propertyName))
  457|      0|        }
  458|      0|        let propertyAttributes = property_getAttributes(property)
  459|      0|
  460|      0|        // should dealloc hook be in place if week property, or just create strong reference because it doesn't matter
  461|      0|        let isWeak = isWeakProperty(propertyAttributes.map(String.init) ?? "")
  462|      0|        let propertyObservable = KVOObservable(object: target, keyPath: propertyName, options: options.union(.initial), retainTarget: false) as KVOObservable<AnyObject>
  463|      0|
  464|      0|        // KVO recursion for value changes
  465|      0|        return propertyObservable
  466|      0|            .flatMapLatest { (nextTarget: AnyObject?) -> Observable<AnyObject?> in
  467|      0|                if nextTarget == nil {
  468|      0|                    return Observable.just(nil)
  469|      0|                }
  470|      0|                let nextObject = nextTarget! as? NSObject
  471|      0|
  472|      0|                let strongTarget: AnyObject? = weakTarget
  473|      0|
  474|      0|                if nextObject == nil {
  475|      0|                    return Observable.error(RxCocoaError.invalidObjectOnKeyPath(object: nextTarget!, sourceObject: strongTarget ?? NSNull(), propertyName: propertyName))
  476|      0|                }
  477|      0|
  478|      0|                // if target is alive, then send change
  479|      0|                // if it's deallocated, don't send anything
  480|      0|                if strongTarget == nil {
  481|      0|                    return Observable.empty()
  482|      0|                }
  483|      0|
  484|      0|                let nextElementsObservable = keyPathSections.count == 1
  485|      0|                    ? Observable.just(nextTarget)
  486|      0|                    : observeWeaklyKeyPathFor(nextObject!, keyPathSections: remainingPaths, options: options)
  487|      0|                
  488|      0|                if isWeak {
  489|      0|                    return nextElementsObservable
  490|      0|                        .finishWithNilWhenDealloc(nextObject!)
  491|      0|                }
  492|      0|                else {
  493|      0|                    return nextElementsObservable
  494|      0|                }
  495|      0|        }
  496|      0|    }
  497|       |#endif
  498|       |
  499|       |// MARK Constants
  500|       |
  501|       |fileprivate let deallocSelector = NSSelectorFromString("dealloc")
  502|       |
  503|       |// MARK: AnyObject + Reactive
  504|       |
  505|       |extension Reactive where Base: AnyObject {
  506|    374|    func synchronized<T>( _ action: () -> T) -> T {
  507|    374|        objc_sync_enter(self.base)
  508|    374|        let result = action()
  509|    374|        objc_sync_exit(self.base)
  510|    374|        return result
  511|    374|    }
  512|       |}
  513|       |
  514|       |extension Reactive where Base: AnyObject {
  515|       |    /**
  516|       |     Helper to make sure that `Observable` returned from `createCachedObservable` is only created once.
  517|       |     This is important because there is only one `target` and `action` properties on `NSControl` or `UIBarButtonItem`.
  518|       |     */
  519|      4|    func lazyInstanceObservable<T: AnyObject>(_ key: UnsafeRawPointer, createCachedObservable: () -> T) -> T {
  520|      0|        if let value = objc_getAssociatedObject(base, key) {
  521|      0|            return value as! T
  522|      4|        }
  523|      4|        
  524|      4|        let observable = createCachedObservable()
  525|      4|        
  526|      4|        objc_setAssociatedObject(base, key, observable, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
  527|      4|        
  528|      4|        return observable
  529|      4|    }
  530|       |}
  531|       |
  532|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/NotificationCenter+Rx.swift:
    1|       |//
    2|       |//  NotificationCenter+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 5/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NotificationCenter
   10|       |import struct Foundation.Notification
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: NotificationCenter {
   17|       |    /**
   18|       |    Transforms notifications posted to notification center to observable sequence of notifications.
   19|       |    
   20|       |    - parameter name: Optional name used to filter notifications.
   21|       |    - parameter object: Optional object used to filter notifications.
   22|       |    - returns: Observable sequence of posted notifications.
   23|       |    */
   24|      0|    public func notification(_ name: Notification.Name?, object: AnyObject? = nil) -> Observable<Notification> {
   25|      0|        return Observable.create { [weak object] observer in
   26|      0|            let nsObserver = self.base.addObserver(forName: name, object: object, queue: nil) { notification in
   27|      0|                observer.on(.next(notification))
   28|      0|            }
   29|      0|            
   30|      0|            return Disposables.create {
   31|      0|                self.base.removeObserver(nsObserver)
   32|      0|            }
   33|      0|        }
   34|      0|    }
   35|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Foundation/URLSession+Rx.swift:
    1|       |//
    2|       |//  URLSession+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import struct Foundation.URL
   10|       |import struct Foundation.URLRequest
   11|       |import struct Foundation.Data
   12|       |import struct Foundation.Date
   13|       |import struct Foundation.TimeInterval
   14|       |import class Foundation.HTTPURLResponse
   15|       |import class Foundation.URLSession
   16|       |import class Foundation.URLResponse
   17|       |import class Foundation.JSONSerialization
   18|       |import class Foundation.NSError
   19|       |import var Foundation.NSURLErrorCancelled
   20|       |import var Foundation.NSURLErrorDomain
   21|       |
   22|       |#if os(Linux)
   23|       |    // don't know why
   24|       |    import Foundation
   25|       |#endif
   26|       |
   27|       |#if !RX_NO_MODULE
   28|       |import RxSwift
   29|       |#endif
   30|       |
   31|       |/// RxCocoa URL errors.
   32|       |public enum RxCocoaURLError
   33|       |    : Swift.Error {
   34|       |    /// Unknown error occurred.
   35|       |    case unknown
   36|       |    /// Response is not NSHTTPURLResponse
   37|       |    case nonHTTPResponse(response: URLResponse)
   38|       |    /// Response is not successful. (not in `200 ..< 300` range)
   39|       |    case httpRequestFailed(response: HTTPURLResponse, data: Data?)
   40|       |    /// Deserialization error.
   41|       |    case deserializationError(error: Swift.Error)
   42|       |}
   43|       |
   44|       |extension RxCocoaURLError
   45|       |    : CustomDebugStringConvertible {
   46|       |    /// A textual representation of `self`, suitable for debugging.
   47|      0|    public var debugDescription: String {
   48|      0|        switch self {
   49|      0|        case .unknown:
   50|      0|            return "Unknown error has occurred."
   51|      0|        case let .nonHTTPResponse(response):
   52|      0|            return "Response is not NSHTTPURLResponse `\(response)`."
   53|      0|        case let .httpRequestFailed(response, _):
   54|      0|            return "HTTP request failed with `\(response.statusCode)`."
   55|      0|        case let .deserializationError(error):
   56|      0|            return "Error during deserialization of the response: \(error)"
   57|      0|        }
   58|      0|    }
   59|       |}
   60|       |
   61|     66|fileprivate func escapeTerminalString(_ value: String) -> String {
   62|     66|    return value.replacingOccurrences(of: "\"", with: "\\\"", options:[], range: nil)
   63|     66|}
   64|       |
   65|     13|fileprivate func convertURLRequestToCurlCommand(_ request: URLRequest) -> String {
   66|      0|    let method = request.httpMethod ?? "GET"
   67|     13|    var returnValue = "curl -X \(method) "
   68|     13|
   69|      1|    if let httpBody = request.httpBody, request.httpMethod == "POST" {
   70|      1|        let maybeBody = String(data: httpBody, encoding: String.Encoding.utf8)
   71|      1|        if let body = maybeBody {
   72|      1|            returnValue += "-d \"\(escapeTerminalString(body))\" "
   73|      1|        }
   74|     13|    }
   75|     13|
   76|     26|    for (key, value) in request.allHTTPHeaderFields ?? [:] {
   77|     26|        let escapedKey = escapeTerminalString(key as String)
   78|     26|        let escapedValue = escapeTerminalString(value as String)
   79|     26|        returnValue += "\n    -H \"\(escapedKey): \(escapedValue)\" "
   80|     13|    }
   81|     13|
   82|      0|    let URLString = request.url?.absoluteString ?? "<unknown url>"
   83|     13|
   84|     13|    returnValue += "\n\"\(escapeTerminalString(URLString))\""
   85|     13|
   86|     13|    returnValue += " -i -v"
   87|     13|
   88|     13|    return returnValue
   89|     13|}
   90|       |
   91|     13|fileprivate func convertResponseToString(_ response: URLResponse?, _ error: NSError?, _ interval: TimeInterval) -> String {
   92|     13|    let ms = Int(interval * 1000)
   93|     13|
   94|     13|    if let response = response as? HTTPURLResponse {
   95|     13|        if 200 ..< 300 ~= response.statusCode {
   96|     13|            return "Success (\(ms)ms): Status \(response.statusCode)"
   97|      0|        }
   98|      0|        else {
   99|      0|            return "Failure (\(ms)ms): Status \(response.statusCode)"
  100|      0|        }
  101|      0|    }
  102|      0|
  103|      0|    if let error = error {
  104|      0|        if error.domain == NSURLErrorDomain && error.code == NSURLErrorCancelled {
  105|      0|            return "Cancelled (\(ms)ms)"
  106|      0|        }
  107|      0|        return "Failure (\(ms)ms): NSError > \(error)"
  108|      0|    }
  109|      0|
  110|      0|    return "<Unhandled response from server>"
  111|      0|}
  112|       |
  113|       |extension Reactive where Base: URLSession {
  114|       |    /**
  115|       |    Observable sequence of responses for URL request.
  116|       |    
  117|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  118|       |    
  119|       |    **URL requests will be performed per subscribed observer.**
  120|       |    
  121|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  122|       |    
  123|       |    - parameter request: URL request.
  124|       |    - returns: Observable sequence of URL responses.
  125|       |    */
  126|     17|    public func response(request: URLRequest) -> Observable<(HTTPURLResponse, Data)> {
  127|     13|        return Observable.create { observer in
  128|     13|
  129|     13|            // smart compiler should be able to optimize this out
  130|     13|            let d: Date?
  131|     13|
  132|     13|            if Logging.URLRequests(request) {
  133|     13|                d = Date()
  134|     13|            }
  135|      0|            else {
  136|      0|               d = nil
  137|     13|            }
  138|     13|
  139|     13|            let task = self.base.dataTask(with: request) { (data, response, error) in
  140|     13|
  141|     13|                if Logging.URLRequests(request) {
  142|      0|                    let interval = Date().timeIntervalSince(d ?? Date())
  143|     13|                    print(convertURLRequestToCurlCommand(request))
  144|      0|                    print(convertResponseToString(response, error.map { $0 as NSError }, interval))
  145|     13|                }
  146|     13|                
  147|      0|                guard let response = response, let data = data else {
  148|      0|                    observer.on(.error(error ?? RxCocoaURLError.unknown))
  149|      0|                    return
  150|     13|                }
  151|     13|
  152|      0|                guard let httpResponse = response as? HTTPURLResponse else {
  153|      0|                    observer.on(.error(RxCocoaURLError.nonHTTPResponse(response: response)))
  154|      0|                    return
  155|     13|                }
  156|     13|
  157|     13|                observer.on(.next(httpResponse, data))
  158|     13|                observer.on(.completed)
  159|     13|            }
  160|     13|
  161|     13|            task.resume()
  162|     13|
  163|     13|            return Disposables.create(with: task.cancel)
  164|     13|        }
  165|     17|    }
  166|       |
  167|       |    /**
  168|       |    Observable sequence of response data for URL request.
  169|       |    
  170|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  171|       |    
  172|       |    **URL requests will be performed per subscribed observer.**
  173|       |    
  174|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  175|       |    
  176|       |    If response is not HTTP response with status code in the range of `200 ..< 300`, sequence
  177|       |    will terminate with `(RxCocoaErrorDomain, RxCocoaError.NetworkError)`.
  178|       |    
  179|       |    - parameter request: URL request.
  180|       |    - returns: Observable sequence of response data.
  181|       |    */
  182|     17|    public func data(request: URLRequest) -> Observable<Data> {
  183|     13|        return response(request: request).map { (response, data) -> Data in
  184|     13|            if 200 ..< 300 ~= response.statusCode {
  185|     13|                return data
  186|      0|            }
  187|      0|            else {
  188|      0|                throw RxCocoaURLError.httpRequestFailed(response: response, data: data)
  189|      0|            }
  190|      0|        }
  191|     17|    }
  192|       |
  193|       |    /**
  194|       |    Observable sequence of response JSON for URL request.
  195|       |    
  196|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  197|       |    
  198|       |    **URL requests will be performed per subscribed observer.**
  199|       |    
  200|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  201|       |    
  202|       |    If response is not HTTP response with status code in the range of `200 ..< 300`, sequence
  203|       |    will terminate with `(RxCocoaErrorDomain, RxCocoaError.NetworkError)`.
  204|       |    
  205|       |    If there is an error during JSON deserialization observable sequence will fail with that error.
  206|       |    
  207|       |    - parameter request: URL request.
  208|       |    - returns: Observable sequence of response JSON.
  209|       |    */
  210|     17|    public func json(request: URLRequest, options: JSONSerialization.ReadingOptions = []) -> Observable<Any> {
  211|     13|        return data(request: request).map { (data) -> Any in
  212|     13|            do {
  213|     13|                return try JSONSerialization.jsonObject(with: data, options: options)
  214|      0|            } catch let error {
  215|      0|                throw RxCocoaURLError.deserializationError(error: error)
  216|      0|            }
  217|      0|        }
  218|     17|    }
  219|       |
  220|       |    /**
  221|       |    Observable sequence of response JSON for GET request with `URL`.
  222|       |     
  223|       |    Performing of request starts after observer is subscribed and not after invoking this method.
  224|       |    
  225|       |    **URL requests will be performed per subscribed observer.**
  226|       |    
  227|       |    Any error during fetching of the response will cause observed sequence to terminate with error.
  228|       |    
  229|       |    If response is not HTTP response with status code in the range of `200 ..< 300`, sequence
  230|       |    will terminate with `(RxCocoaErrorDomain, RxCocoaError.NetworkError)`.
  231|       |    
  232|       |    If there is an error during JSON deserialization observable sequence will fail with that error.
  233|       |    
  234|       |    - parameter url: URL of `NSURLRequest` request.
  235|       |    - returns: Observable sequence of response JSON.
  236|       |    */
  237|      0|    public func json(url: Foundation.URL) -> Observable<Any> {
  238|      0|        return json(request: URLRequest(url: url))
  239|      0|    }
  240|       |}
  241|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Runtime/_RXDelegateProxy.m:
    1|       |//
    2|       |//  _RXDelegateProxy.m
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "include/_RXDelegateProxy.h"
   10|       |#import "include/_RX.h"
   11|       |#import "include/_RXObjCRuntime.h"
   12|       |
   13|       |@interface _RXDelegateProxy () {
   14|       |    id __weak __forwardToDelegate;
   15|       |}
   16|       |
   17|       |@property (nonatomic, strong) id strongForwardDelegate;
   18|       |
   19|       |@end
   20|       |
   21|       |static NSMutableDictionary *voidSelectorsPerClass = nil;
   22|       |
   23|       |@implementation _RXDelegateProxy
   24|       |
   25|     35|+(NSSet*)collectVoidSelectorsForProtocol:(Protocol *)protocol {
   26|     35|    NSMutableSet *selectors = [NSMutableSet set];
   27|     35|
   28|     35|    unsigned int protocolMethodCount = 0;
   29|     35|    struct objc_method_description *pMethods = protocol_copyMethodDescriptionList(protocol, NO, YES, &protocolMethodCount);
   30|     35|
   31|    171|    for (unsigned int i = 0; i < protocolMethodCount; ++i) {
   32|    136|        struct objc_method_description method = pMethods[i];
   33|    136|        if (RX_is_method_with_description_void(method)) {
   34|     55|            [selectors addObject:SEL_VALUE(method.name)];
   35|     55|        }
   36|    136|    }
   37|     35|            
   38|     35|    free(pMethods);
   39|     35|
   40|     35|    unsigned int numberOfBaseProtocols = 0;
   41|     35|    Protocol * __unsafe_unretained * pSubprotocols = protocol_copyProtocolList(protocol, &numberOfBaseProtocols);
   42|     35|
   43|     51|    for (unsigned int i = 0; i < numberOfBaseProtocols; ++i) {
   44|     16|        [selectors unionSet:[self collectVoidSelectorsForProtocol:pSubprotocols[i]]];
   45|     16|    }
   46|     35|    
   47|     35|    free(pSubprotocols);
   48|     35|
   49|     35|    return selectors;
   50|     35|}
   51|       |
   52|      5|+(void)initialize {
   53|      5|    @synchronized (_RXDelegateProxy.class) {
   54|      5|        if (voidSelectorsPerClass == nil) {
   55|      1|            voidSelectorsPerClass = [[NSMutableDictionary alloc] init];
   56|      1|        }
   57|      5|
   58|      5|        NSMutableSet *voidSelectors = [NSMutableSet set];
   59|      5|
   60|     28|#define CLASS_HIERARCHY_MAX_DEPTH 100
   61|      5|
   62|      5|        NSInteger  classHierarchyDepth = 0;
   63|      5|        Class      targetClass         = NULL;
   64|      5|
   65|      5|        for (classHierarchyDepth = 0, targetClass = self;
   66|     23|             classHierarchyDepth < CLASS_HIERARCHY_MAX_DEPTH && targetClass != nil;
   67|     18|             ++classHierarchyDepth, targetClass = class_getSuperclass(targetClass)
   68|     18|        ) {
   69|     18|            unsigned int count;
   70|     18|            Protocol *__unsafe_unretained *pProtocols = class_copyProtocolList(targetClass, &count);
   71|     18|            
   72|     37|            for (unsigned int i = 0; i < count; i++) {
   73|     19|                NSSet *selectorsForProtocol = [self collectVoidSelectorsForProtocol:pProtocols[i]];
   74|     19|                [voidSelectors unionSet:selectorsForProtocol];
   75|     19|            }
   76|     18|            
   77|     18|            free(pProtocols);
   78|     18|        }
   79|      5|
   80|      5|        if (classHierarchyDepth == CLASS_HIERARCHY_MAX_DEPTH) {
   81|      0|            NSLog(@"Detected weird class hierarchy with depth over %d. Starting with this class -> %@", CLASS_HIERARCHY_MAX_DEPTH, self);
   82|      0|#if DEBUG
   83|      0|            abort();
   84|      0|#endif
   85|      0|        }
   86|      5|        
   87|      5|        voidSelectorsPerClass[CLASS_VALUE(self)] = voidSelectors;
   88|      5|    }
   89|      5|}
   90|       |
   91|  8.22k|-(id)_forwardToDelegate {
   92|  8.22k|    return __forwardToDelegate;
   93|  8.22k|}
   94|       |
   95|     50|-(void)_setForwardToDelegate:(id __nullable)forwardToDelegate retainDelegate:(BOOL)retainDelegate {
   96|     50|    __forwardToDelegate = forwardToDelegate;
   97|     50|    if (retainDelegate) {
   98|      4|        self.strongForwardDelegate = forwardToDelegate;
   99|      4|    }
  100|     46|    else {
  101|     46|        self.strongForwardDelegate = nil;
  102|     46|    }
  103|     50|}
  104|       |
  105|     38|-(BOOL)hasWiredImplementationForSelector:(SEL)selector {
  106|     38|    return [super respondsToSelector:selector];
  107|     38|}
  108|       |
  109|  5.75k|-(BOOL)voidDelegateMethodsContain:(SEL)selector {
  110|  5.75k|    @synchronized(_RXDelegateProxy.class) {
  111|  5.75k|        NSSet *voidSelectors = voidSelectorsPerClass[CLASS_VALUE(self.class)];
  112|  5.75k|        NSAssert(voidSelectors != nil, @"Set of allowed methods not initialized");
  113|  5.75k|        return [voidSelectors containsObject:SEL_VALUE(selector)];
  114|  5.75k|    }
  115|  5.75k|}
  116|       |
  117|    574|-(void)forwardInvocation:(NSInvocation *)anInvocation {
  118|    574|    BOOL isVoid = RX_is_method_signature_void(anInvocation.methodSignature);
  119|    574|    NSArray *arguments = nil;
  120|    574|    if (isVoid) {
  121|      0|        arguments = RX_extract_arguments(anInvocation);
  122|      0|        [self _sentMessage:anInvocation.selector withArguments:arguments];
  123|      0|    }
  124|    574|    
  125|    574|    if (self._forwardToDelegate && [self._forwardToDelegate respondsToSelector:anInvocation.selector]) {
  126|    574|        [anInvocation invokeWithTarget:self._forwardToDelegate];
  127|    574|    }
  128|    574|
  129|    574|    if (isVoid) {
  130|      0|        [self _methodInvoked:anInvocation.selector withArguments:arguments];
  131|      0|    }
  132|    574|}
  133|       |
  134|       |// abstract method
  135|      0|-(void)_sentMessage:(SEL)selector withArguments:(NSArray *)arguments {
  136|      0|
  137|      0|}
  138|       |
  139|       |// abstract method
  140|      0|-(void)_methodInvoked:(SEL)selector withArguments:(NSArray *)arguments {
  141|      0|
  142|      0|}
  143|       |
  144|      0|-(void)dealloc {
  145|      0|}
  146|       |
  147|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Runtime/_RXKVOObserver.m:
    1|       |//
    2|       |//  _RXKVOObserver.m
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import "include/_RXKVOObserver.h"
   10|       |
   11|       |@interface _RXKVOObserver ()
   12|       |
   13|       |@property (nonatomic, unsafe_unretained) id            target;
   14|       |@property (nonatomic, strong           ) id            retainedTarget;
   15|       |@property (nonatomic, copy             ) NSString     *keyPath;
   16|       |@property (nonatomic, copy             ) void (^callback)(id);
   17|       |
   18|       |@end
   19|       |
   20|       |@implementation _RXKVOObserver
   21|       |
   22|       |-(instancetype)initWithTarget:(id)target
   23|       |                 retainTarget:(BOOL)retainTarget
   24|       |                      keyPath:(NSString*)keyPath
   25|       |                      options:(NSKeyValueObservingOptions)options
   26|      0|                     callback:(void (^)(id))callback {
   27|      0|    self = [super init];
   28|      0|    if (!self) return nil;
   29|      0|    
   30|      0|    self.target = target;
   31|      0|    if (retainTarget) {
   32|      0|        self.retainedTarget = target;
   33|      0|    }
   34|      0|    self.keyPath = keyPath;
   35|      0|    self.callback = callback;
   36|      0|    
   37|      0|    [self.target addObserver:self forKeyPath:self.keyPath options:options context:nil];
   38|      0|    
   39|      0|    return self;
   40|      0|}
   41|       |
   42|      0|-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context {
   43|      0|    @synchronized(self) {
   44|      0|        self.callback(change[NSKeyValueChangeNewKey]);
   45|      0|    }
   46|      0|}
   47|       |
   48|      0|-(void)dispose {
   49|      0|    [self.target removeObserver:self forKeyPath:self.keyPath context:nil];
   50|      0|    self.target = nil;
   51|      0|    self.retainedTarget = nil;
   52|      0|}
   53|       |
   54|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Runtime/_RXObjCRuntime.m:
    1|       |//
    2|       |//  _RXObjCRuntime.m
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/11/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import <pthread.h>
   10|       |#import <Foundation/Foundation.h>
   11|       |#import <objc/runtime.h>
   12|       |#import <objc/message.h>
   13|       |#import <libkern/OSAtomic.h>
   14|       |
   15|       |#import "include/_RX.h"
   16|       |#import "include/_RXObjCRuntime.h"
   17|       |
   18|       |#if !DISABLE_SWIZZLING
   19|       |
   20|       |// self + cmd
   21|      0|#define HIDDEN_ARGUMENT_COUNT   2
   22|       |
   23|       |@class RXObjCRuntime;
   24|       |
   25|       |BOOL RXAbortOnThreadingHazard = NO;
   26|       |
   27|       |typedef NSInvocation       *NSInvocationRef;
   28|       |typedef NSMethodSignature  *NSMethodSignatureRef;
   29|       |typedef unsigned char       rx_uchar;
   30|       |typedef unsigned short      rx_ushort;
   31|       |typedef unsigned int        rx_uint;
   32|       |typedef unsigned long       rx_ulong;
   33|       |typedef id (^rx_block)(id);
   34|       |typedef BOOL (^RXInterceptWithOptimizedObserver)(RXObjCRuntime * __nonnull self, Class __nonnull class, SEL __nonnull selector, NSError ** __nonnull error);
   35|       |
   36|       |static CFTypeID  defaultTypeID;
   37|       |static SEL       deallocSelector;
   38|       |
   39|       |static int RxSwizzlingTargetClassKey = 0;
   40|       |
   41|       |#if TRACE_RESOURCES
   42|       |static int32_t numberOInterceptedMethods = 0;
   43|       |static int32_t numberOfForwardedMethods = 0;
   44|       |#endif
   45|       |
   46|       |#define THREADING_HAZARD(class) \
   47|      0|    NSLog(@"There was a problem swizzling on `%@`.\nYou have probably two libraries performing swizzling in runtime.\nWe didn't want to crash your program, but this is not good ...\nYou an solve this problem by either not using swizzling in this library, removing one of those other libraries, or making sure that swizzling parts are synchronized (only perform them on main thread).\nAnd yes, this message will self destruct when you clear the console, and since it's non deterministic, the problem could still exist and it will be hard for you to reproduce it.", NSStringFromClass(class)); ABORT_IN_DEBUG if (RXAbortOnThreadingHazard) { abort(); }
   48|       |
   49|    108|#define ALWAYS(condition, message) if (!(condition)) { [NSException raise:@"RX Invalid Operator" format:@"%@", message]; }
   50|       |#define ALWAYS_WITH_INFO(condition, message) NSAssert((condition), @"%@ [%@] > %@", NSStringFromClass(class), NSStringFromSelector(selector), (message))
   51|       |#define C_ALWAYS(condition, message) NSCAssert((condition), @"%@ [%@] > %@", NSStringFromClass(class), NSStringFromSelector(selector), (message))
   52|       |
   53|      0|#define RX_PREFIX @"_RX_namespace_"
   54|       |
   55|      0|#define RX_ARG_id(value)           ((value) ?: [NSNull null])
   56|      0|#define RX_ARG_char(value)         [NSNumber numberWithChar:value]
   57|      0|#define RX_ARG_short(value)        [NSNumber numberWithShort:value]
   58|      0|#define RX_ARG_int(value)          [NSNumber numberWithInt:value]
   59|      0|#define RX_ARG_long(value)         [NSNumber numberWithLong:value]
   60|       |#define RX_ARG_BOOL(value)         [NSNumber numberWithBool:value]
   61|      0|#define RX_ARG_SEL(value)          [NSNumber valueWithPointer:value]
   62|      0|#define RX_ARG_rx_uchar(value)     [NSNumber numberWithUnsignedInt:value]
   63|      0|#define RX_ARG_rx_ushort(value)    [NSNumber numberWithUnsignedInt:value]
   64|      0|#define RX_ARG_rx_uint(value)      [NSNumber numberWithUnsignedInt:value]
   65|      0|#define RX_ARG_rx_ulong(value)     [NSNumber numberWithUnsignedLong:value]
   66|      0|#define RX_ARG_rx_block(value)     ((id)(value) ?: [NSNull null])
   67|      0|#define RX_ARG_float(value)        [NSNumber numberWithFloat:value]
   68|      0|#define RX_ARG_double(value)       [NSNumber numberWithDouble:value]
   69|       |
   70|       |typedef struct supported_type {
   71|       |    const char *encoding;
   72|       |} supported_type_t;
   73|       |
   74|       |static supported_type_t supported_types[] = {
   75|       |    { .encoding = @encode(void)},
   76|       |    { .encoding = @encode(id)},
   77|       |    { .encoding = @encode(Class)},
   78|       |    { .encoding = @encode(void (^)())},
   79|       |    { .encoding = @encode(char)},
   80|       |    { .encoding = @encode(short)},
   81|       |    { .encoding = @encode(int)},
   82|       |    { .encoding = @encode(long)},
   83|       |    { .encoding = @encode(long long)},
   84|       |    { .encoding = @encode(unsigned char)},
   85|       |    { .encoding = @encode(unsigned short)},
   86|       |    { .encoding = @encode(unsigned int)},
   87|       |    { .encoding = @encode(unsigned long)},
   88|       |    { .encoding = @encode(unsigned long long)},
   89|       |    { .encoding = @encode(float)},
   90|       |    { .encoding = @encode(double)},
   91|       |    { .encoding = @encode(BOOL)},
   92|       |    { .encoding = @encode(const char*)},
   93|       |};
   94|       |
   95|       |NSString * __nonnull const RXObjCRuntimeErrorDomain   = @"RXObjCRuntimeErrorDomain";
   96|       |NSString * __nonnull const RXObjCRuntimeErrorIsKVOKey = @"RXObjCRuntimeErrorIsKVOKey";
   97|       |
   98|      0|BOOL RX_return_type_is_supported(const char *type) {
   99|      0|    if (type == nil) {
  100|      0|        return NO;
  101|      0|    }
  102|      0|
  103|      0|    for (int i = 0; i < sizeof(supported_types) / sizeof(supported_type_t); ++i) {
  104|      0|        if (supported_types[i].encoding[0] != type[0]) {
  105|      0|            continue;
  106|      0|        }
  107|      0|        if (strcmp(supported_types[i].encoding, type) == 0) {
  108|      0|            return YES;
  109|      0|        }
  110|      0|    }
  111|      0|
  112|      0|    return NO;
  113|      0|}
  114|       |
  115|      0|static BOOL RX_method_has_supported_return_type(Method method) {
  116|      0|    const char *rawEncoding = method_getTypeEncoding(method);
  117|      0|    ALWAYS(rawEncoding != nil, @"Example encoding method is nil.");
  118|      0|
  119|      0|    NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:rawEncoding];
  120|      0|    ALWAYS(methodSignature != nil, @"Method signature method is nil.");
  121|      0|
  122|      0|    return RX_return_type_is_supported(methodSignature.methodReturnType);
  123|      0|}
  124|       |
  125|      0|SEL __nonnull RX_selector(SEL __nonnull selector) {
  126|      0|    NSString *selectorString = NSStringFromSelector(selector);
  127|      0|    return NSSelectorFromString([RX_PREFIX stringByAppendingString:selectorString]);
  128|      0|}
  129|       |
  130|    574|BOOL RX_is_method_signature_void(NSMethodSignature * __nonnull methodSignature) {
  131|    574|    const char *methodReturnType = methodSignature.methodReturnType;
  132|    574|    return strcmp(methodReturnType, @encode(void)) == 0;
  133|    574|}
  134|       |
  135|    136|BOOL RX_is_method_with_description_void(struct objc_method_description method) {
  136|    136|    return strncmp(method.types, @encode(void), 1) == 0;
  137|    136|}
  138|       |
  139|       |// inspired by https://github.com/ReactiveCocoa/ReactiveCocoa/blob/swift-development/ReactiveCocoa/Objective-C/NSInvocation%2BRACTypeParsing.m
  140|       |// awesome work
  141|      0|id __nonnull RX_extract_argument_at_index(NSInvocation * __nonnull invocation, NSUInteger index) {
  142|      0|    const char *argumentType = [invocation.methodSignature getArgumentTypeAtIndex:index];
  143|      0|    
  144|      0|#define RETURN_VALUE(type) \
  145|      0|    else if (strcmp(argumentType, @encode(type)) == 0) {\
  146|      0|        type val = 0; \
  147|      0|        [invocation getArgument:&val atIndex:index]; \
  148|      0|        return @(val); \
  149|      0|    }
  150|      0|
  151|      0|    // Skip const type qualifier.
  152|      0|    if (argumentType[0] == 'r') {
  153|      0|        argumentType++;
  154|      0|    }
  155|      0|    
  156|      0|    if (strcmp(argumentType, @encode(id)) == 0
  157|      0|        || strcmp(argumentType, @encode(Class)) == 0
  158|      0|        || strcmp(argumentType, @encode(void (^)())) == 0
  159|      0|    ) {
  160|      0|        __unsafe_unretained id argument = nil;
  161|      0|        [invocation getArgument:&argument atIndex:index];
  162|      0|        return argument;
  163|      0|    }
  164|      0|    RETURN_VALUE(char)
  165|      0|    RETURN_VALUE(short)
  166|      0|    RETURN_VALUE(int)
  167|      0|    RETURN_VALUE(long)
  168|      0|    RETURN_VALUE(long long)
  169|      0|    RETURN_VALUE(unsigned char)
  170|      0|    RETURN_VALUE(unsigned short)
  171|      0|    RETURN_VALUE(unsigned int)
  172|      0|    RETURN_VALUE(unsigned long)
  173|      0|    RETURN_VALUE(unsigned long long)
  174|      0|    RETURN_VALUE(float)
  175|      0|    RETURN_VALUE(double)
  176|      0|    RETURN_VALUE(BOOL)
  177|      0|    RETURN_VALUE(const char *)
  178|      0|    else {
  179|      0|        NSUInteger size = 0;
  180|      0|        NSGetSizeAndAlignment(argumentType, &size, NULL);
  181|      0|        NSCParameterAssert(size > 0);
  182|      0|        uint8_t data[size];
  183|      0|        [invocation getArgument:&data atIndex:index];
  184|      0|        
  185|      0|        return [NSValue valueWithBytes:&data objCType:argumentType];
  186|      0|    }
  187|      0|}
  188|       |
  189|      0|NSArray *RX_extract_arguments(NSInvocation *invocation) {
  190|      0|    NSUInteger numberOfArguments = invocation.methodSignature.numberOfArguments;
  191|      0|    NSUInteger numberOfVisibleArguments = numberOfArguments - HIDDEN_ARGUMENT_COUNT;
  192|      0|    
  193|      0|    NSCParameterAssert(numberOfVisibleArguments >= 0);
  194|      0|    
  195|      0|    NSMutableArray *arguments = [NSMutableArray arrayWithCapacity:numberOfVisibleArguments];
  196|      0|    
  197|      0|    for (NSUInteger index = HIDDEN_ARGUMENT_COUNT; index < numberOfArguments; ++index) {
  198|      0|        [arguments addObject:RX_extract_argument_at_index(invocation, index) ?: [NSNull null]];
  199|      0|    }
  200|      0|    
  201|      0|    return arguments;
  202|      0|}
  203|       |
  204|      0|void * __nonnull RX_reference_from_selector(SEL __nonnull selector) {
  205|      0|    return selector;
  206|      0|}
  207|       |
  208|      0|static BOOL RX_forward_invocation(id __nonnull __unsafe_unretained self, NSInvocation *invocation) {
  209|      0|    SEL originalSelector = RX_selector(invocation.selector);
  210|      0|
  211|      0|    id<RXMessageSentObserver> messageSentObserver = objc_getAssociatedObject(self, originalSelector);
  212|      0|
  213|      0|    if (messageSentObserver != nil) {
  214|      0|        NSArray *arguments = RX_extract_arguments(invocation);
  215|      0|        [messageSentObserver messageSentWithArguments:arguments];
  216|      0|    }
  217|      0|
  218|      0|    if ([self respondsToSelector:originalSelector]) {
  219|      0|        invocation.selector = originalSelector;
  220|      0|        [invocation invokeWithTarget:self];
  221|      0|
  222|      0|        if (messageSentObserver != nil) {
  223|      0|            NSArray *arguments = RX_extract_arguments(invocation);
  224|      0|            [messageSentObserver methodInvokedWithArguments:arguments];
  225|      0|        }
  226|      0|
  227|      0|        return YES;
  228|      0|    }
  229|      0|
  230|      0|    return NO;
  231|      0|}
  232|       |
  233|      0|static BOOL RX_responds_to_selector(id __nonnull __unsafe_unretained self, SEL selector) {
  234|      0|    Class class = object_getClass(self);
  235|      0|    if (class == nil) { return NO; }
  236|      0|
  237|      0|    Method m = class_getInstanceMethod(class, selector);
  238|      0|    return m != nil;
  239|      0|
  240|      0|}
  241|       |
  242|      0|static NSMethodSignatureRef RX_method_signature(id __nonnull __unsafe_unretained self, SEL selector) {
  243|      0|    Class class = object_getClass(self);
  244|      0|    if (class == nil) { return nil; }
  245|      0|
  246|      0|    Method method = class_getInstanceMethod(class, selector);
  247|      0|    if (method == nil) { return nil; }
  248|      0|
  249|      0|    const char *encoding = method_getTypeEncoding(method);
  250|      0|    if (encoding == nil) { return nil; }
  251|      0|
  252|      0|    return [NSMethodSignature signatureWithObjCTypes:encoding];
  253|      0|}
  254|       |
  255|     27|static NSString * __nonnull RX_method_encoding(Method __nonnull method) {
  256|     27|    const char *typeEncoding = method_getTypeEncoding(method);
  257|     27|    ALWAYS(typeEncoding != nil, @"Method encoding is nil.");
  258|     27|
  259|     27|    NSString *encoding = [NSString stringWithCString:typeEncoding encoding:NSASCIIStringEncoding];
  260|     27|    ALWAYS(encoding != nil, @"Can't convert encoding to NSString.");
  261|     27|    return encoding;
  262|     27|}
  263|       |
  264|       |// inspired by
  265|       |// https://github.com/mikeash/MAZeroingWeakRef/blob/master/Source/MAZeroingWeakRef.m
  266|       |// https://github.com/ReactiveCocoa/ReactiveCocoa/blob/swift-development/ReactiveCocoa/Objective-C/NSObject%2BRACDeallocating.m
  267|       |// https://github.com/steipete/Aspects
  268|       |@interface RXObjCRuntime: NSObject
  269|       |
  270|       |@property (nonatomic, assign) pthread_mutex_t lock;
  271|       |
  272|       |@property (nonatomic, strong) NSMutableSet<NSValue *> *classesThatSupportObservingByForwarding;
  273|       |@property (nonatomic, strong) NSMutableDictionary<NSValue *, NSMutableSet<NSValue*> *> *forwardedSelectorsByClass;
  274|       |
  275|       |@property (nonatomic, strong) NSMutableDictionary<NSValue *, Class> *dynamicSubclassByRealClass;
  276|       |@property (nonatomic, strong) NSMutableDictionary<NSValue *, NSMutableDictionary<NSValue*, NSValue *>*> *interceptorIMPbySelectorsByClass;
  277|       |
  278|       |+(RXObjCRuntime*)instance;
  279|       |
  280|       |-(void)performLocked:(void (^)(RXObjCRuntime* __nonnull))action;
  281|       |-(IMP __nullable)ensurePrepared:(id __nonnull)target forObserving:(SEL __nonnull)selector error:(NSError** __nonnull)error;
  282|       |-(BOOL)ensureSwizzledSelector:(SEL __nonnull)selector
  283|       |                      ofClass:(Class __nonnull)class
  284|       |   newImplementationGenerator:(IMP(^)())newImplementationGenerator
  285|       |replacementImplementationGenerator:(IMP (^)(IMP originalImplementation))replacementImplementationGenerator
  286|       |                        error:(NSError ** __nonnull)error;
  287|       |
  288|       |
  289|       |+(void)registerOptimizedObserver:(RXInterceptWithOptimizedObserver)registration encodedAs:(SEL)selector;
  290|       |
  291|       |@end
  292|       |
  293|       |/**
  294|       | All API methods perform work on locked instance of `RXObjCRuntime`. In that way it's easy to prove
  295|       | that every action is properly locked.
  296|       | */
  297|      0|IMP __nullable RX_ensure_observing(id __nonnull target, SEL __nonnull selector, NSError ** __nonnull error) {
  298|      0|    __block IMP targetImplementation = nil;
  299|      0|    // Target is the second object that needs to be synchronized to TRY to make sure other swizzling framework
  300|      0|    // won't do something in parallel.
  301|      0|    // Even though this is too fine grained locking and more coarse grained locks should exist, this is just in case
  302|      0|    // someone calls this method directly without any external lock.
  303|      0|    @synchronized(target) {
  304|      0|        // The only other resource that all other swizzling libraries have in common without introducing external
  305|      0|        // dependencies is class object.
  306|      0|        //
  307|      0|        // It is polite to try to synchronize it in hope other unknown entities will also attempt to do so.
  308|      0|        // It's like trying to figure out how to communicate with aliens without actually communicating,
  309|      0|        // save for the fact that aliens are people, programmers, authors of swizzling libraries.
  310|      0|        @synchronized([target class]) {
  311|      0|            [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
  312|      0|                targetImplementation = [self ensurePrepared:target
  313|      0|                                               forObserving:selector
  314|      0|                                                      error:error];
  315|      0|            }];
  316|      0|        }
  317|      0|    }
  318|      0|
  319|      0|    return targetImplementation;
  320|      0|}
  321|       |
  322|      0|IMP __nonnull RX_default_target_implementation() {
  323|      0|    return _objc_msgForward;
  324|      0|}
  325|       |
  326|       |// bodies
  327|       |
  328|      0|#define FORWARD_BODY(invocation)                        if (RX_forward_invocation(self, NAME_CAT(_, 0, invocation))) { return; }
  329|       |
  330|      0|#define RESPONDS_TO_SELECTOR_BODY(selector)             if (RX_responds_to_selector(self, NAME_CAT(_, 0, selector))) return YES;
  331|       |
  332|      0|#define CLASS_BODY(...)                                 return actAsClass;
  333|       |
  334|       |#define METHOD_SIGNATURE_FOR_SELECTOR_BODY(selector)                                            \
  335|      0|    NSMethodSignatureRef methodSignature = RX_method_signature(self, NAME_CAT(_, 0, selector)); \
  336|      0|    if (methodSignature != nil) {                                                               \
  337|      0|        return methodSignature;                                                                 \
  338|      0|    }
  339|       |
  340|       |#define DEALLOCATING_BODY(...)                                                        \
  341|      0|    id<RXDeallocatingObserver> observer = objc_getAssociatedObject(self, rxSelector); \
  342|      0|    if (observer != nil && observer.targetImplementation == thisIMP) {                \
  343|      0|        [observer deallocating];                                                      \
  344|      0|    }
  345|       |
  346|       |#define OBSERVE_BODY(...)                                                              \
  347|      0|    id<RXMessageSentObserver> observer = objc_getAssociatedObject(self, rxSelector);   \
  348|      0|                                                                                       \
  349|      0|    if (observer != nil && observer.targetImplementation == thisIMP) {                 \
  350|      0|        [observer messageSentWithArguments:@[COMMA_DELIMITED_ARGUMENTS(__VA_ARGS__)]]; \
  351|      0|    }                                                                                  \
  352|       |
  353|       |
  354|       |#define OBSERVE_INVOKED_BODY(...)                                                        \
  355|      0|    if (observer != nil && observer.targetImplementation == thisIMP) {                   \
  356|      0|        [observer methodInvokedWithArguments:@[COMMA_DELIMITED_ARGUMENTS(__VA_ARGS__)]]; \
  357|      0|    }                                                                                    \
  358|       |
  359|       |
  360|      0|#define BUILD_ARG_WRAPPER(type)                   RX_ARG_ ## type                                                     //RX_ARG_ ## type
  361|       |
  362|       |#define CAT(_1, _2, head, tail)                   RX_CAT2(head, tail)
  363|      0|#define SEPARATE_BY_COMMA(_1, _2, head, tail)     head, tail
  364|       |#define SEPARATE_BY_SPACE(_1, _2, head, tail)     head tail
  365|      0|#define SEPARATE_BY_UNDERSCORE(head, tail)        RX_CAT2(RX_CAT2(head, _), tail)
  366|       |
  367|       |#define UNDERSCORE_TYPE_CAT(_1, index, type)      RX_CAT2(_, type)                                                    // generates -> _type
  368|      0|#define NAME_CAT(_1, index, type)                 SEPARATE_BY_UNDERSCORE(type, index)                                 // generates -> type_0
  369|       |#define TYPE_AND_NAME_CAT(_1, index, type)        type SEPARATE_BY_UNDERSCORE(type, index)                            // generates -> type type_0
  370|      0|#define NOT_NULL_ARGUMENT_CAT(_1, index, type)    BUILD_ARG_WRAPPER(type)(NAME_CAT(_1, index, type))                  // generates -> ((id)(type_0) ?: [NSNull null])
  371|       |#define EXAMPLE_PARAMETER(_1, index, type)        RX_CAT2(_, type):(type)SEPARATE_BY_UNDERSCORE(type, index)          // generates -> _type:(type)type_0
  372|       |#define SELECTOR_PART(_1, index, type)            RX_CAT2(_, type:)                                                   // generates -> _type:
  373|       |
  374|      0|#define COMMA_DELIMITED_ARGUMENTS(...)            RX_FOR(_, SEPARATE_BY_COMMA, NOT_NULL_ARGUMENT_CAT, ## __VA_ARGS__)
  375|      0|#define ARGUMENTS(...)                            RX_FOR_COMMA(_, NAME_CAT, ## __VA_ARGS__)
  376|       |#define DECLARE_ARGUMENTS(...)                    RX_FOR_COMMA(_, TYPE_AND_NAME_CAT, ## __VA_ARGS__)
  377|       |
  378|       |// optimized observe methods
  379|       |
  380|       |#define GENERATE_METHOD_IDENTIFIER(...)          RX_CAT2(swizzle, RX_FOR(_, CAT, UNDERSCORE_TYPE_CAT, ## __VA_ARGS__))
  381|       |
  382|       |#define GENERATE_OBSERVE_METHOD_DECLARATION(...)                                 \
  383|       |    -(BOOL)GENERATE_METHOD_IDENTIFIER(__VA_ARGS__):(Class __nonnull)class        \
  384|       |                                          selector:(SEL)selector                 \
  385|       |                                             error:(NSError ** __nonnull)error { \
  386|       |
  387|       |
  388|       |#define BUILD_EXAMPLE_METHOD(return_value, ...) \
  389|      0|    +(return_value)RX_CAT2(RX_CAT2(example_, return_value), RX_FOR(_, SEPARATE_BY_SPACE, EXAMPLE_PARAMETER, ## __VA_ARGS__)) {}
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uint) example_void_rx_uint:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_SEL) example_void_id:_SEL:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_double) example_void_id:_double:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_float) example_void_id:_float:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_block) example_void_id:_rx_block:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ulong) example_void_id:_rx_ulong:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uint) example_void_id:_rx_uint:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ushort) example_void_id:_rx_ushort:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uchar) example_void_id:_rx_uchar:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_long) example_void_id:_long:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_int) example_void_id:_int:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_short) example_void_id:_short:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_char) example_void_id:_char:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_id) example_void_id:_id:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_SEL) example_void_SEL:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_double) example_void_double:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_float) example_void_float:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_block) example_void_rx_block:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ulong) example_void_rx_ulong:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ushort) example_void_rx_ushort:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uchar) example_void_rx_uchar:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_long) example_void_long:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_int) example_void_int:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_short) example_void_short:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_char) example_void_char:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id) example_void_id:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void) example_void]
  ------------------
  390|       |
  391|       |#define BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ...) \
  392|       |    RX_CAT2(RX_CAT2(example_, return_value), RX_FOR(_, SEPARATE_BY_SPACE, SELECTOR_PART, ## __VA_ARGS__))
  393|       |
  394|       |#define SWIZZLE_OBSERVE_METHOD(return_value, ...)                                                                                                       \
  395|       |    @interface RXObjCRuntime (GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__))                                                                 \
  396|       |    @end                                                                                                                                                \
  397|       |                                                                                                                                                        \
  398|       |    @implementation RXObjCRuntime(GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__))                                                             \
  399|       |    BUILD_EXAMPLE_METHOD(return_value, ## __VA_ARGS__)                                                                                                  \
  400|      0|    SWIZZLE_METHOD(return_value, GENERATE_OBSERVE_METHOD_DECLARATION(return_value, ## __VA_ARGS__), OBSERVE_BODY, OBSERVE_INVOKED_BODY, ## __VA_ARGS__) \
  401|       |                                                                                                                                                        \
  402|     27|    +(void)load {                                                                                                                                       \
  403|     27|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  404|     27|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  405|      0|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  406|      0|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  407|      0|       } encodedAs:exampleSelector];                                                                                                                    \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__42+[RXObjCRuntime(swizzle_void_id_SEL) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__45+[RXObjCRuntime(swizzle_void_id_double) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_id_float) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__47+[RXObjCRuntime(swizzle_void_id_rx_block) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__47+[RXObjCRuntime(swizzle_void_id_rx_ulong) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__38+[RXObjCRuntime(swizzle_void_id) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__40+[RXObjCRuntime(swizzle_void_char) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__41+[RXObjCRuntime(swizzle_void_short) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__39+[RXObjCRuntime(swizzle_void_int) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__40+[RXObjCRuntime(swizzle_void_long) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_rx_uchar) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__45+[RXObjCRuntime(swizzle_void_rx_ushort) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__43+[RXObjCRuntime(swizzle_void_rx_uint) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__35+[RXObjCRuntime(swizzle_void) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_rx_ulong) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_rx_block) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__41+[RXObjCRuntime(swizzle_void_float) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__42+[RXObjCRuntime(swizzle_void_double) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__39+[RXObjCRuntime(swizzle_void_SEL) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__41+[RXObjCRuntime(swizzle_void_id_id) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__43+[RXObjCRuntime(swizzle_void_id_char) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__44+[RXObjCRuntime(swizzle_void_id_short) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__42+[RXObjCRuntime(swizzle_void_id_int) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__43+[RXObjCRuntime(swizzle_void_id_long) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__47+[RXObjCRuntime(swizzle_void_id_rx_uchar) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__48+[RXObjCRuntime(swizzle_void_id_rx_ushort) load]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__46+[RXObjCRuntime(swizzle_void_id_rx_uint) load]_block_invoke
  ------------------
  408|     27|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uint) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ulong) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_block) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_float) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_double) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_ushort) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_rx_uchar) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_long) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_int) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_short) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_char) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_id) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_SEL) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_double) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_float) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_block) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ulong) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uint) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_ushort) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_rx_uchar) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_long) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_int) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_short) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_char) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  | _RXObjCRuntime.m:+[RXObjCRuntime(swizzle_void_id_SEL) load]:
  |  402|      1|    +(void)load {                                                                                                                                       \
  |  403|      1|       __unused SEL exampleSelector = @selector(BUILD_EXAMPLE_METHOD_SELECTOR(return_value, ## __VA_ARGS__));                                           \
  |  404|      1|       [self registerOptimizedObserver:^BOOL(RXObjCRuntime * __nonnull self, Class __nonnull class,                                                     \
  |  405|      1|            SEL __nonnull selector, NSError **__nonnull error) {                                                                                        \
  |  406|      1|            return [self GENERATE_METHOD_IDENTIFIER(return_value, ## __VA_ARGS__):class selector:selector error:error];                                 \
  |  407|      1|       } encodedAs:exampleSelector];                                                                                                                    \
  |  408|      1|    }                                                                                                                                                   \
  ------------------
  409|       |                                                                                                                                                        \
  410|       |    @end                                                                                                                                                \
  411|       |
  412|       |// infrastructure method
  413|       |
  414|       |#define NO_BODY(...)
  415|       |
  416|       |#define SWIZZLE_INFRASTRUCTURE_METHOD(return_value, method_name, parameters, method_selector, body, ...)               \
  417|       |    SWIZZLE_METHOD(return_value, -(BOOL)method_name:(Class __nonnull)class parameters error:(NSError **__nonnull)error \
  418|       |        {                                                                                                              \
  419|       |            SEL selector = method_selector; , body, NO_BODY, __VA_ARGS__)                                                       \
  420|       |
  421|       |
  422|       |// common base
  423|       |
  424|      0|#define SWIZZLE_METHOD(return_value, method_prototype, body, invoked_body, ...)                                          \
  425|      0|method_prototype                                                                                                         \
  426|      0|    __unused SEL rxSelector = RX_selector(selector);                                                                     \
  427|      0|    IMP (^newImplementationGenerator)() = ^() {                                                                          \
  428|      0|        __block IMP thisIMP = nil;                                                                                       \
  429|      0|        id newImplementation = ^return_value(__unsafe_unretained id self DECLARE_ARGUMENTS(__VA_ARGS__)) {               \
  430|      0|            body(__VA_ARGS__)                                                                                            \
  431|      0|                                                                                                                         \
  432|      0|            struct objc_super superInfo = {                                                                              \
  433|      0|                .receiver = self,                                                                                        \
  434|      0|                .super_class = class_getSuperclass(class)                                                                \
  435|      0|            };                                                                                                           \
  436|      0|                                                                                                                         \
  437|      0|            return_value (*msgSend)(struct objc_super *, SEL DECLARE_ARGUMENTS(__VA_ARGS__))                             \
  438|      0|                = (__typeof__(msgSend))objc_msgSendSuper;                                                                \
  439|      0|            @try {                                                                                                       \
  440|      0|              return msgSend(&superInfo, selector ARGUMENTS(__VA_ARGS__));                                               \
  441|      0|            }                                                                                                            \
  442|      0|            @finally { invoked_body(__VA_ARGS__) }                                                                       \
  443|      0|        };                                                                                                               \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke_2
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke_2
  ------------------
  444|      0|                                                                                                                         \
  445|      0|        thisIMP = imp_implementationWithBlock(newImplementation);                                                        \
  446|      0|        return thisIMP;                                                                                                  \
  447|      0|    };                                                                                                                   \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke
  ------------------
  448|      0|                                                                                                                         \
  449|      0|    IMP (^replacementImplementationGenerator)(IMP) = ^(IMP originalImplementation) {                                     \
  450|      0|        __block return_value (*originalImplementationTyped)(__unsafe_unretained id, SEL DECLARE_ARGUMENTS(__VA_ARGS__) ) \
  451|      0|            = (__typeof__(originalImplementationTyped))(originalImplementation);                                         \
  452|      0|                                                                                                                         \
  453|      0|        __block IMP thisIMP = nil;                                                                                       \
  454|      0|        id implementationReplacement = ^return_value(__unsafe_unretained id self DECLARE_ARGUMENTS(__VA_ARGS__) ) {      \
  455|      0|            body(__VA_ARGS__)                                                                                            \
  456|      0|            @try {                                                                                                       \
  457|      0|                return originalImplementationTyped(self, selector ARGUMENTS(__VA_ARGS__));                               \
  458|      0|            }                                                                                                            \
  459|      0|            @finally { invoked_body(__VA_ARGS__) }                                                                       \
  460|      0|        };                                                                                                               \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke_2.676
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke_2.698
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke_2.720
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke_2.742
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke_2.764
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke_2.654
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke_2.632
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke_2.610
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke_2.588
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke_2.566
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke_2.544
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke_2.522
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke_2.500
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke_2.478
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke_2.454
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke_2.432
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke_2.410
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke_2.388
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke_2.366
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke_2.344
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke_2.322
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke_2.300
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke_2.278
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke_2.256
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke_2.234
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke_2.212
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke_2.186
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke_2.159
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke_4
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke_4
  ------------------
  461|      0|                                                                                                                         \
  462|      0|        thisIMP = imp_implementationWithBlock(implementationReplacement);                                                \
  463|      0|        return thisIMP;                                                                                                  \
  464|      0|    };                                                                                                                   \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]_block_invoke.763
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]_block_invoke.741
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]_block_invoke.719
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]_block_invoke.697
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]_block_invoke.675
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__81-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]_block_invoke.653
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__85-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]_block_invoke.631
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__83-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]_block_invoke.609
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]_block_invoke.587
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]_block_invoke.565
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]_block_invoke.543
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]_block_invoke.521
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]_block_invoke.499
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]_block_invoke.477
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__73-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]_block_invoke.453
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]_block_invoke.431
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]_block_invoke.409
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]_block_invoke.387
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__75-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]_block_invoke.365
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__79-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]_block_invoke.343
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__77-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]_block_invoke.321
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]_block_invoke.299
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]_block_invoke.277
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__71-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]_block_invoke.255
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__69-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]_block_invoke.233
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__65-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]_block_invoke.211
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__59-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]_block_invoke.185
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__66-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]_block_invoke.158
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__80-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__67-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]_block_invoke_3
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:__72-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]_block_invoke_3
  ------------------
  465|      0|                                                                                                                         \
  466|      0|    return [self ensureSwizzledSelector:selector                                                                         \
  467|      0|                                ofClass:class                                                                            \
  468|      0|             newImplementationGenerator:newImplementationGenerator                                                       \
  469|      0|     replacementImplementationGenerator:replacementImplementationGenerator                                               \
  470|      0|                                  error:error];                                                                          \
  471|      0| }                                                                                                                       \
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleForwardInvocation:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleRespondsToSelector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleClass:toActAs:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleMethodSignatureForSelector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(InfrastructureMethods) swizzleDeallocating:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void) swizzle_void:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id) swizzle_void_id:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_char) swizzle_void_char:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_short) swizzle_void_short:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_int) swizzle_void_int:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_long) swizzle_void_long:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_uchar) swizzle_void_rx_uchar:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_ushort) swizzle_void_rx_ushort:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_uint) swizzle_void_rx_uint:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_ulong) swizzle_void_rx_ulong:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_rx_block) swizzle_void_rx_block:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_float) swizzle_void_float:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_double) swizzle_void_double:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_SEL) swizzle_void_SEL:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_id) swizzle_void_id_id:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_char) swizzle_void_id_char:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_short) swizzle_void_id_short:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_int) swizzle_void_id_int:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_long) swizzle_void_id_long:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_uchar) swizzle_void_id_rx_uchar:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_ushort) swizzle_void_id_rx_ushort:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_uint) swizzle_void_id_rx_uint:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_ulong) swizzle_void_id_rx_ulong:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_rx_block) swizzle_void_id_rx_block:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_float) swizzle_void_id_float:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_double) swizzle_void_id_double:selector:error:]
  ------------------
  | Unexecuted instantiation: _RXObjCRuntime.m:-[RXObjCRuntime(swizzle_void_id_SEL) swizzle_void_id_SEL:selector:error:]
  ------------------
  472|       |
  473|       |
  474|       |@interface RXObjCRuntime (InfrastructureMethods)
  475|       |@end
  476|       |
  477|       |// MARK: Infrastructure Methods
  478|       |
  479|       |@implementation RXObjCRuntime (InfrastructureMethods)
  480|       |
  481|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  482|       |    void,
  483|       |    swizzleForwardInvocation,
  484|       |    ,
  485|       |    @selector(forwardInvocation:),
  486|      0|    FORWARD_BODY,
  487|       |    NSInvocationRef
  488|       |)
  489|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  490|       |    BOOL,
  491|       |    swizzleRespondsToSelector,
  492|       |    ,
  493|       |    @selector(respondsToSelector:),
  494|      0|    RESPONDS_TO_SELECTOR_BODY,
  495|       |    SEL
  496|       |)
  497|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  498|       |    Class __nonnull,
  499|       |    swizzleClass,
  500|       |    toActAs:(Class)actAsClass,
  501|       |    @selector(class),
  502|      0|    CLASS_BODY
  503|       |)
  504|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  505|       |    NSMethodSignatureRef,
  506|       |    swizzleMethodSignatureForSelector,
  507|       |    ,
  508|       |    @selector(methodSignatureForSelector:),
  509|      0|    METHOD_SIGNATURE_FOR_SELECTOR_BODY,
  510|       |    SEL
  511|       |)
  512|       |SWIZZLE_INFRASTRUCTURE_METHOD(
  513|       |    void,
  514|       |    swizzleDeallocating,
  515|       |    ,
  516|       |    deallocSelector,
  517|      0|    DEALLOCATING_BODY
  518|       |)
  519|       |
  520|       |@end
  521|       |
  522|       |// MARK: Optimized intercepting methods for specific combination of parameter types
  523|       |
  524|       |SWIZZLE_OBSERVE_METHOD(void)
  525|       |
  526|       |SWIZZLE_OBSERVE_METHOD(void, id)
  527|       |SWIZZLE_OBSERVE_METHOD(void, char)
  528|       |SWIZZLE_OBSERVE_METHOD(void, short)
  529|       |SWIZZLE_OBSERVE_METHOD(void, int)
  530|       |SWIZZLE_OBSERVE_METHOD(void, long)
  531|       |SWIZZLE_OBSERVE_METHOD(void, rx_uchar)
  532|       |SWIZZLE_OBSERVE_METHOD(void, rx_ushort)
  533|       |SWIZZLE_OBSERVE_METHOD(void, rx_uint)
  534|       |SWIZZLE_OBSERVE_METHOD(void, rx_ulong)
  535|       |SWIZZLE_OBSERVE_METHOD(void, rx_block)
  536|       |SWIZZLE_OBSERVE_METHOD(void, float)
  537|       |SWIZZLE_OBSERVE_METHOD(void, double)
  538|       |SWIZZLE_OBSERVE_METHOD(void, SEL)
  539|       |
  540|       |SWIZZLE_OBSERVE_METHOD(void, id, id)
  541|       |SWIZZLE_OBSERVE_METHOD(void, id, char)
  542|       |SWIZZLE_OBSERVE_METHOD(void, id, short)
  543|       |SWIZZLE_OBSERVE_METHOD(void, id, int)
  544|       |SWIZZLE_OBSERVE_METHOD(void, id, long)
  545|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_uchar)
  546|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_ushort)
  547|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_uint)
  548|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_ulong)
  549|       |SWIZZLE_OBSERVE_METHOD(void, id, rx_block)
  550|       |SWIZZLE_OBSERVE_METHOD(void, id, float)
  551|       |SWIZZLE_OBSERVE_METHOD(void, id, double)
  552|       |SWIZZLE_OBSERVE_METHOD(void, id, SEL)
  553|       |
  554|       |// MARK: RXObjCRuntime
  555|       |
  556|       |@implementation RXObjCRuntime
  557|       |
  558|       |static RXObjCRuntime *_instance = nil;
  559|       |static NSMutableDictionary<NSString *, RXInterceptWithOptimizedObserver> *optimizedObserversByMethodEncoding = nil;
  560|       |
  561|      0|+(RXObjCRuntime*)instance {
  562|      0|    return _instance;
  563|      0|}
  564|       |
  565|      1|+(void)initialize {
  566|      1|    _instance = [[RXObjCRuntime alloc] init];
  567|      1|    defaultTypeID = CFGetTypeID((CFTypeRef)RXObjCRuntime.class); // just need a reference of some object not from CF
  568|      1|    deallocSelector = NSSelectorFromString(@"dealloc");
  569|      1|    NSAssert(_instance != nil, @"Failed to initialize swizzling");
  570|      1|}
  571|       |
  572|      1|-(instancetype)init {
  573|      1|    self = [super init];
  574|      1|    if (!self) return nil;
  575|      1|
  576|      1|    self.classesThatSupportObservingByForwarding = [NSMutableSet set];
  577|      1|    self.forwardedSelectorsByClass = [NSMutableDictionary dictionary];
  578|      1|
  579|      1|    self.dynamicSubclassByRealClass = [NSMutableDictionary dictionary];
  580|      1|    self.interceptorIMPbySelectorsByClass = [NSMutableDictionary dictionary];
  581|      1|
  582|      1|    pthread_mutexattr_t lock_attr;
  583|      1|    pthread_mutexattr_init(&lock_attr);
  584|      1|    pthread_mutexattr_settype(&lock_attr, PTHREAD_MUTEX_RECURSIVE);
  585|      1|    pthread_mutex_init(&_lock, &lock_attr);
  586|      1|    pthread_mutexattr_destroy(&lock_attr);
  587|      1|    
  588|      1|    return self;
  589|      1|}
  590|       |
  591|      0|-(void)performLocked:(void (^)(RXObjCRuntime* __nonnull))action {
  592|      0|    pthread_mutex_lock(&_lock);
  593|      0|    action(self);
  594|      0|    pthread_mutex_unlock(&_lock);
  595|      0|}
  596|       |
  597|     27|+(void)registerOptimizedObserver:(RXInterceptWithOptimizedObserver)registration encodedAs:(SEL)selector {
  598|     27|    Method exampleEncodingMethod = class_getClassMethod(self, selector);
  599|     27|    ALWAYS(exampleEncodingMethod != nil, @"Example encoding method is nil.");
  600|     27|
  601|     27|    NSString *methodEncoding = RX_method_encoding(exampleEncodingMethod);
  602|     27|
  603|     27|    if (optimizedObserversByMethodEncoding == nil) {
  604|      1|        optimizedObserversByMethodEncoding = [NSMutableDictionary dictionary];
  605|      1|    }
  606|     27|
  607|     27|    DLOG(@"Added optimized method: %@ (%@)", methodEncoding, NSStringFromSelector(selector));
  608|     27|    ALWAYS(optimizedObserversByMethodEncoding[methodEncoding] == nil, @"Optimized observer already registered")
  609|     27|    optimizedObserversByMethodEncoding[methodEncoding] = registration;
  610|     27|}
  611|       |
  612|       |/**
  613|       | This is the main entry point for observing messages sent to arbitrary objects.
  614|       | */
  615|      0|-(IMP __nullable)ensurePrepared:(id __nonnull)target forObserving:(SEL __nonnull)selector error:(NSError** __nonnull)error {
  616|      0|    Method instanceMethod = class_getInstanceMethod([target class], selector);
  617|      0|    if (instanceMethod == nil) {
  618|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  619|      0|                                           code:RXObjCRuntimeErrorSelectorNotImplemented
  620|      0|                                       userInfo:nil], nil);
  621|      0|    }
  622|      0|
  623|      0|    if (selector == @selector(class)
  624|      0|    ||  selector == @selector(forwardingTargetForSelector:)
  625|      0|    ||  selector == @selector(methodSignatureForSelector:)
  626|      0|    ||  selector == @selector(respondsToSelector:)) {
  627|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  628|      0|                                           code:RXObjCRuntimeErrorObservingPerformanceSensitiveMessages
  629|      0|                                       userInfo:nil], nil);
  630|      0|    }
  631|      0|
  632|      0|    // For `dealloc` message, original implementation will be swizzled.
  633|      0|    // This is a special case because observing `dealloc` message is performed when `observeWeakly` is used.
  634|      0|    //
  635|      0|    // Some toll free bridged classes don't handle `object_setClass` well and cause crashes.
  636|      0|    //
  637|      0|    // To make `deallocating` as robust as possible, original implementation will be replaced.
  638|      0|    if (selector == deallocSelector) {
  639|      0|        Class __nonnull deallocSwizzingTarget = [target class];
  640|      0|        IMP interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:deallocSwizzingTarget];
  641|      0|        if (interceptorIMPForSelector != nil) {
  642|      0|            return interceptorIMPForSelector;
  643|      0|        }
  644|      0|
  645|      0|        if (![self swizzleDeallocating:deallocSwizzingTarget error:error]) {
  646|      0|            return nil;
  647|      0|        }
  648|      0|
  649|      0|        interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:deallocSwizzingTarget];
  650|      0|        if (interceptorIMPForSelector != nil) {
  651|      0|            return interceptorIMPForSelector;
  652|      0|        }
  653|      0|    }
  654|      0|    else {
  655|      0|        Class __nullable swizzlingImplementorClass = [self prepareTargetClassForObserving:target error:error];
  656|      0|        if (swizzlingImplementorClass == nil) {
  657|      0|            return nil;
  658|      0|        }
  659|      0|
  660|      0|        NSString *methodEncoding = RX_method_encoding(instanceMethod);
  661|      0|        RXInterceptWithOptimizedObserver optimizedIntercept = optimizedObserversByMethodEncoding[methodEncoding];
  662|      0|
  663|      0|        if (!RX_method_has_supported_return_type(instanceMethod)) {
  664|      0|            RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  665|      0|                                               code:RXObjCRuntimeErrorObservingMessagesWithUnsupportedReturnType
  666|      0|                                           userInfo:nil], nil);
  667|      0|        }
  668|      0|
  669|      0|        // optimized interception method
  670|      0|        if (optimizedIntercept != nil) {
  671|      0|            IMP interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:swizzlingImplementorClass];
  672|      0|            if (interceptorIMPForSelector != nil) {
  673|      0|                return interceptorIMPForSelector;
  674|      0|            }
  675|      0|
  676|      0|            if (!optimizedIntercept(self, swizzlingImplementorClass, selector, error)) {
  677|      0|                return nil;
  678|      0|            }
  679|      0|
  680|      0|            interceptorIMPForSelector = [self interceptorImplementationForSelector:selector forClass:swizzlingImplementorClass];
  681|      0|            if (interceptorIMPForSelector != nil) {
  682|      0|                return interceptorIMPForSelector;
  683|      0|            }
  684|      0|        }
  685|      0|        // default fallback to observing by forwarding messages
  686|      0|        else {
  687|      0|            if ([self forwardingSelector:selector forClass:swizzlingImplementorClass]) {
  688|      0|                return RX_default_target_implementation();
  689|      0|            }
  690|      0|
  691|      0|            if (![self observeByForwardingMessages:swizzlingImplementorClass
  692|      0|                                          selector:selector
  693|      0|                                            target:target
  694|      0|                                             error:error]) {
  695|      0|                return nil;
  696|      0|            }
  697|      0|
  698|      0|            if ([self forwardingSelector:selector forClass:swizzlingImplementorClass]) {
  699|      0|                return RX_default_target_implementation();
  700|      0|            }
  701|      0|        }
  702|      0|    }
  703|      0|
  704|      0|    RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  705|      0|                                       code:RXObjCRuntimeErrorUnknown
  706|      0|                                   userInfo:nil], nil);
  707|      0|}
  708|       |
  709|      0|-(Class __nullable)prepareTargetClassForObserving:(id __nonnull)target error:(NSError **__nonnull)error {
  710|      0|    Class swizzlingClass = objc_getAssociatedObject(target, &RxSwizzlingTargetClassKey);
  711|      0|    if (swizzlingClass != nil) {
  712|      0|        return swizzlingClass;
  713|      0|    }
  714|      0|
  715|      0|    Class __nonnull wannaBeClass = [target class];
  716|      0|    /**
  717|      0|     Core Foundation classes are usually toll free bridged. Those classes crash the program in case
  718|      0|     `object_setClass` is performed on them.
  719|      0|
  720|      0|     There is a possibility to just swizzle methods on original object, but since those won't be usual use
  721|      0|     cases for this library, then an error will just be reported for now.
  722|      0|     */
  723|      0|    BOOL isThisTollFreeFoundationClass = CFGetTypeID((CFTypeRef)target) != defaultTypeID;
  724|      0|
  725|      0|    if (isThisTollFreeFoundationClass) {
  726|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  727|      0|                                           code:RXObjCRuntimeErrorCantInterceptCoreFoundationTollFreeBridgedObjects
  728|      0|                                       userInfo:nil], nil);
  729|      0|    }
  730|      0|
  731|      0|    /**
  732|      0|     If the object is reporting a different class then what it's real class, that means that there is probably
  733|      0|     already some interception mechanism in place or something weird is happening.
  734|      0|     
  735|      0|     Most common case when this would happen is when using KVO (`observe`) and `sentMessage`.
  736|      0|
  737|      0|     This error is easily resolved by just using `sentMessage` observing before `observe`.
  738|      0|     
  739|      0|     The reason why other way around could create issues is because KVO will unregister it's interceptor 
  740|      0|     class and restore original class. Unfortunately that will happen no matter was there another interceptor
  741|      0|     subclass registered in hierarchy or not.
  742|      0|     
  743|      0|     Failure scenario:
  744|      0|     * KVO sets class to be `__KVO__OriginalClass` (subclass of `OriginalClass`)
  745|      0|     * `sentMessage` sets object class to be `_RX_namespace___KVO__OriginalClass` (subclass of `__KVO__OriginalClass`)
  746|      0|     * then unobserving with KVO will restore class to be `OriginalClass` -> failure point
  747|      0|
  748|      0|     The reason why changing order of observing works is because any interception method should return
  749|      0|     object's original real class (if that doesn't happen then it's really easy to argue that's a bug
  750|      0|     in that other library).
  751|      0|     
  752|      0|     This library won't remove registered interceptor even if there aren't any observers left because
  753|      0|     it's highly unlikely it would have any benefit in real world use cases, and it's even more
  754|      0|     dangerous.
  755|      0|     */
  756|      0|    if ([target class] != object_getClass(target)) {
  757|      0|        BOOL isKVO = [target respondsToSelector:NSSelectorFromString(@"_isKVOA")];
  758|      0|
  759|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  760|      0|                                           code:RXObjCRuntimeErrorObjectMessagesAlreadyBeingIntercepted
  761|      0|                                       userInfo:@{
  762|      0|                                                  RXObjCRuntimeErrorIsKVOKey : @(isKVO)
  763|      0|                                                  }], nil);
  764|      0|    }
  765|      0|
  766|      0|    Class __nullable dynamicFakeSubclass = [self ensureHasDynamicFakeSubclass:wannaBeClass error:error];
  767|      0|
  768|      0|    if (dynamicFakeSubclass == nil) {
  769|      0|        return nil;
  770|      0|    }
  771|      0|
  772|      0|    Class previousClass = object_setClass(target, dynamicFakeSubclass);
  773|      0|    if (previousClass != wannaBeClass) {
  774|      0|        THREADING_HAZARD(wannaBeClass);
  775|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  776|      0|                                           code:RXObjCRuntimeErrorThreadingCollisionWithOtherInterceptionMechanism
  777|      0|                                       userInfo:nil], nil);
  778|      0|    }
  779|      0|
  780|      0|    objc_setAssociatedObject(target, &RxSwizzlingTargetClassKey, dynamicFakeSubclass, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
  781|      0|    return dynamicFakeSubclass;
  782|      0|}
  783|       |
  784|       |
  785|      0|-(BOOL)forwardingSelector:(SEL)selector forClass:(Class __nonnull)class {
  786|      0|    return [self.forwardedSelectorsByClass[CLASS_VALUE(class)] containsObject:SEL_VALUE(selector)];
  787|      0|}
  788|       |
  789|      0|-(void)registerForwardedSelector:(SEL)selector forClass:(Class __nonnull)class {
  790|      0|    NSValue *classValue = CLASS_VALUE(class);
  791|      0|
  792|      0|    NSMutableSet<NSValue *> *forwardedSelectors = self.forwardedSelectorsByClass[classValue];
  793|      0|
  794|      0|    if (forwardedSelectors == nil) {
  795|      0|        forwardedSelectors = [NSMutableSet set];
  796|      0|        self.forwardedSelectorsByClass[classValue] = forwardedSelectors;
  797|      0|    }
  798|      0|
  799|      0|    [forwardedSelectors addObject:SEL_VALUE(selector)];
  800|      0|}
  801|       |
  802|       |-(BOOL)observeByForwardingMessages:(Class __nonnull)swizzlingImplementorClass
  803|       |                          selector:(SEL)selector
  804|       |                            target:(id __nonnull)target
  805|      0|                             error:(NSError **__nonnull)error {
  806|      0|    if (![self ensureForwardingMethodsAreSwizzled:swizzlingImplementorClass error:error]) {
  807|      0|        return NO;
  808|      0|    }
  809|      0|
  810|      0|    ALWAYS(![self forwardingSelector:selector forClass:swizzlingImplementorClass], @"Already observing selector for class");
  811|      0|
  812|      0|#if TRACE_RESOURCES
  813|       |    OSAtomicIncrement32Barrier(&numberOfForwardedMethods);
  814|       |#endif
  815|      0|    SEL rxSelector = RX_selector(selector);
  816|      0|
  817|      0|    Method instanceMethod = class_getInstanceMethod(swizzlingImplementorClass, selector);
  818|      0|    ALWAYS(instanceMethod != nil, @"Instance method is nil");
  819|      0|
  820|      0|    const char* methodEncoding = method_getTypeEncoding(instanceMethod);
  821|      0|    ALWAYS(methodEncoding != nil, @"Method encoding is nil.");
  822|      0|    NSMethodSignature *methodSignature = [NSMethodSignature signatureWithObjCTypes:methodEncoding];
  823|      0|    ALWAYS(methodSignature != nil, @"Method signature is invalid.");
  824|      0|
  825|      0|    IMP implementation = method_getImplementation(instanceMethod);
  826|      0|
  827|      0|    if (implementation == nil) {
  828|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  829|      0|                                           code:RXObjCRuntimeErrorSelectorNotImplemented
  830|      0|                                       userInfo:nil], NO);
  831|      0|    }
  832|      0|
  833|      0|    if (!class_addMethod(swizzlingImplementorClass, rxSelector, implementation, methodEncoding)) {
  834|      0|        RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  835|      0|                                           code:RXObjCRuntimeErrorSavingOriginalForwardingMethodFailed
  836|      0|                                       userInfo:nil], NO);
  837|      0|    }
  838|      0|
  839|      0|    if (!class_addMethod(swizzlingImplementorClass, selector, _objc_msgForward, methodEncoding)) {
  840|      0|        if (implementation != method_setImplementation(instanceMethod, _objc_msgForward)) {
  841|      0|            THREADING_HAZARD(swizzlingImplementorClass);
  842|      0|            RX_THROW_ERROR([NSError errorWithDomain:RXObjCRuntimeErrorDomain
  843|      0|                                               code:RXObjCRuntimeErrorReplacingMethodWithForwardingImplementation
  844|      0|                                           userInfo:nil], NO);
  845|      0|        }
  846|      0|    }
  847|      0|
  848|      0|    DLOG(@"Rx uses forwarding to observe `%@` for `%@`.", NSStringFromSelector(selector), swizzlingImplementorClass);
  849|      0|    [self registerForwardedSelector:selector forClass:swizzlingImplementorClass];
  850|      0|
  851|      0|    return YES;
  852|      0|}
  853|       |
  854|       |/**
  855|       | If object don't have some weird behavior, claims it's the same class that runtime shows,
  856|       | then dynamic subclass is created (only this instance will have performance hit).
  857|       | 
  858|       | In case something weird is detected, then original base class is being swizzled and all instances
  859|       | will have somewhat reduced performance.
  860|       | 
  861|       | This is especially handy optimization for weak KVO. Nobody will swizzle for example `NSString`,
  862|       | but to know when instance of a `NSString` was deallocated, performance hit will be only felt on a 
  863|       | single instance of `NSString`, not all instances of `NSString`s.
  864|       | */
  865|      0|-(Class __nullable)ensureHasDynamicFakeSubclass:(Class __nonnull)class error:(NSError **)error {
  866|      0|    Class dynamicFakeSubclass = self.dynamicSubclassByRealClass[CLASS_VALUE(class)];
  867|      0|    if (dynamicFakeSubclass != nil) {
  868|      0|        return dynamicFakeSubclass;
  869|      0|    }
  870|      0|
  871|      0|    NSString *dynamicFakeSubclassName = [RX_PREFIX stringByAppendingString:NSStringFromClass(class)];
  872|      0|    const char *dynamicFakeSubclassNameRaw = dynamicFakeSubclassName.UTF8String;
  873|      0|    dynamicFakeSubclass = objc_allocateClassPair(class, dynamicFakeSubclassNameRaw, 0);
  874|      0|    ALWAYS(dynamicFakeSubclass != nil, @"Class not generated");
  875|      0|
  876|      0|    if (![self swizzleClass:dynamicFakeSubclass toActAs:class error:error]) {
  877|      0|        return nil;
  878|      0|    }
  879|      0|
  880|      0|    objc_registerClassPair(dynamicFakeSubclass);
  881|      0|
  882|      0|    [self.dynamicSubclassByRealClass setObject:dynamicFakeSubclass forKey:CLASS_VALUE(class)];
  883|      0|    ALWAYS(self.dynamicSubclassByRealClass[CLASS_VALUE(class)] != nil, @"Class not registered");
  884|      0|
  885|      0|    return dynamicFakeSubclass;
  886|      0|}
  887|       |
  888|      0|-(BOOL)ensureForwardingMethodsAreSwizzled:(Class __nonnull)class error:(NSError ** __nonnull)error {
  889|      0|    NSValue *classValue = CLASS_VALUE(class);
  890|      0|    if ([self.classesThatSupportObservingByForwarding containsObject:classValue]) {
  891|      0|        return YES;
  892|      0|    }
  893|      0|
  894|      0|    if (![self swizzleForwardInvocation:class error:error]) { return NO; }
  895|      0|    if (![self swizzleMethodSignatureForSelector:class error:error]) { return NO; }
  896|      0|    if (![self swizzleRespondsToSelector:class error:error]) { return NO; }
  897|      0|
  898|      0|    [self.classesThatSupportObservingByForwarding addObject:classValue];
  899|      0|
  900|      0|    return YES;
  901|      0|}
  902|       |
  903|      0|-(void)registerInterceptedSelector:(SEL)selector implementation:(IMP)implementation forClass:(Class)class {
  904|      0|    NSValue * __nonnull classValue = CLASS_VALUE(class);
  905|      0|    NSValue * __nonnull selectorValue = SEL_VALUE(selector);
  906|      0|
  907|      0|    NSMutableDictionary *swizzledIMPBySelectorsForClass = self.interceptorIMPbySelectorsByClass[classValue];
  908|      0|
  909|      0|    if (swizzledIMPBySelectorsForClass == nil) {
  910|      0|        swizzledIMPBySelectorsForClass = [NSMutableDictionary dictionary];
  911|      0|        self.interceptorIMPbySelectorsByClass[classValue] = swizzledIMPBySelectorsForClass;
  912|      0|    }
  913|      0|
  914|      0|    swizzledIMPBySelectorsForClass[selectorValue] = IMP_VALUE(implementation);
  915|      0|
  916|      0|    ALWAYS([self interceptorImplementationForSelector:selector forClass:class] != nil, @"Class should have been swizzled");
  917|      0|}
  918|       |
  919|      0|-(IMP)interceptorImplementationForSelector:(SEL)selector forClass:(Class)class {
  920|      0|    NSValue * __nonnull classValue = CLASS_VALUE(class);
  921|      0|    NSValue * __nonnull selectorValue = SEL_VALUE(selector);
  922|      0|
  923|      0|    NSMutableDictionary *swizzledIMPBySelectorForClass = self.interceptorIMPbySelectorsByClass[classValue];
  924|      0|
  925|      0|    NSValue *impValue = swizzledIMPBySelectorForClass[selectorValue];
  926|      0|    return impValue.pointerValue;
  927|      0|}
  928|       |
  929|       |-(BOOL)ensureSwizzledSelector:(SEL __nonnull)selector
  930|       |                      ofClass:(Class __nonnull)class
  931|       |   newImplementationGenerator:(IMP(^)())newImplementationGenerator
  932|       |replacementImplementationGenerator:(IMP (^)(IMP originalImplementation))replacementImplementationGenerator
  933|      0|                        error:(NSError ** __nonnull)error {
  934|      0|    if ([self interceptorImplementationForSelector:selector forClass:class] != nil) {
  935|      0|        DLOG(@"Trying to register same intercept at least once, this sounds like a possible bug");
  936|      0|        return YES;
  937|      0|    }
  938|      0|
  939|      0|#if TRACE_RESOURCES
  940|       |    OSAtomicIncrement32Barrier(&numberOInterceptedMethods);
  941|       |#endif
  942|      0|    
  943|      0|    DLOG(@"Rx is swizzling `%@` for `%@`", NSStringFromSelector(selector), class);
  944|      0|
  945|      0|    Method existingMethod = class_getInstanceMethod(class, selector);
  946|      0|    ALWAYS(existingMethod != nil, @"Method doesn't exist");
  947|      0|
  948|      0|    const char *encoding = method_getTypeEncoding(existingMethod);
  949|      0|    ALWAYS(encoding != nil, @"Encoding is nil");
  950|      0|
  951|      0|    IMP newImplementation = newImplementationGenerator();
  952|      0|
  953|      0|    if (class_addMethod(class, selector, newImplementation, encoding)) {
  954|      0|        // new method added, job done
  955|      0|        [self registerInterceptedSelector:selector implementation:newImplementation forClass:class];
  956|      0|
  957|      0|        return YES;
  958|      0|    }
  959|      0|
  960|      0|    imp_removeBlock(newImplementation);
  961|      0|
  962|      0|    // if add fails, that means that method already exists on targetClass
  963|      0|    Method existingMethodOnTargetClass = existingMethod;
  964|      0|
  965|      0|    IMP originalImplementation = method_getImplementation(existingMethodOnTargetClass);
  966|      0|    ALWAYS(originalImplementation != nil, @"Method must exist.");
  967|      0|    IMP implementationReplacementIMP = replacementImplementationGenerator(originalImplementation);
  968|      0|    ALWAYS(implementationReplacementIMP != nil, @"Method must exist.");
  969|      0|    IMP originalImplementationAfterChange = method_setImplementation(existingMethodOnTargetClass, implementationReplacementIMP);
  970|      0|    ALWAYS(originalImplementation != nil, @"Method must exist.");
  971|      0|
  972|      0|    // If method replacing failed, who knows what happened, better not trying again, otherwise program can get
  973|      0|    // corrupted.
  974|      0|    [self registerInterceptedSelector:selector implementation:implementationReplacementIMP forClass:class];
  975|      0|
  976|      0|    // ¯\_(ツ)_/¯
  977|      0|    if (originalImplementationAfterChange != originalImplementation) {
  978|      0|        THREADING_HAZARD(class);
  979|      0|        return NO;
  980|      0|    }
  981|      0|
  982|      0|    return YES;
  983|      0|}
  984|       |
  985|       |@end
  986|       |
  987|       |#if TRACE_RESOURCES
  988|       |
  989|       |NSInteger RX_number_of_dynamic_subclasses() {
  990|       |    __block NSInteger count = 0;
  991|       |    [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
  992|       |        count = self.dynamicSubclassByRealClass.count;
  993|       |    }];
  994|       |
  995|       |    return count;
  996|       |}
  997|       |
  998|       |NSInteger RX_number_of_forwarding_enabled_classes() {
  999|       |    __block NSInteger count = 0;
 1000|       |    [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
 1001|       |        count = self.classesThatSupportObservingByForwarding.count;
 1002|       |    }];
 1003|       |
 1004|       |    return count;
 1005|       |}
 1006|       |
 1007|       |NSInteger RX_number_of_intercepting_classes() {
 1008|       |    __block NSInteger count = 0;
 1009|       |    [[RXObjCRuntime instance] performLocked:^(RXObjCRuntime * __nonnull self) {
 1010|       |        count = self.interceptorIMPbySelectorsByClass.count;
 1011|       |    }];
 1012|       |
 1013|       |    return count;
 1014|       |}
 1015|       |
 1016|       |NSInteger RX_number_of_forwarded_methods() {
 1017|       |    return numberOfForwardedMethods;
 1018|       |}
 1019|       |
 1020|       |NSInteger RX_number_of_swizzled_methods() {
 1021|       |    return numberOInterceptedMethods;
 1022|       |}
 1023|       |
 1024|       |#endif
 1025|       |
 1026|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Runtime/include/_RX.h:
    1|       |//
    2|       |//  _RX.h
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#import <Foundation/Foundation.h>
   10|       |#import <objc/runtime.h>
   11|       |
   12|       |/**
   13|       | ################################################################################
   14|       | This file is part of RX private API
   15|       | ################################################################################
   16|       | */
   17|       |
   18|       |#if        TRACE_RESOURCES >= 2
   19|       |#   define DLOG(...)         NSLog(__VA_ARGS__)
   20|       |#else
   21|       |#   define DLOG(...)
   22|       |#endif
   23|       |
   24|       |#if        DEBUG
   25|      0|#   define ABORT_IN_DEBUG    abort();
   26|       |#else
   27|       |#   define ABORT_IN_DEBUG
   28|       |#endif
   29|       |
   30|       |
   31|  5.81k|#define SEL_VALUE(x)      [NSValue valueWithPointer:(x)]
   32|  17.2k|#define CLASS_VALUE(x)    [NSValue valueWithNonretainedObject:(x)]
   33|      0|#define IMP_VALUE(x)      [NSValue valueWithPointer:(x)]
   34|       |
   35|       |/**
   36|       | Checks that the local `error` instance exists before assigning it's value by reference.
   37|       | This macro exists to work around static analysis warnings — `NSError` is always assumed to be `nullable`, even though we explictly define the method parameter as `nonnull`. See http://www.openradar.me/21766176 for more details.
   38|       | */
   39|      0|#define RX_THROW_ERROR(errorValue, returnValue) if (error != nil) { *error = (errorValue); } return (returnValue);
   40|       |
   41|       |// Inspired by http://p99.gforge.inria.fr
   42|       |
   43|       |// https://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC26
   44|      0|#define RX_CAT2(_1, _2) _RX_CAT2(_1, _2)
   45|       |
   46|       |#define RX_ELEMENT_AT(n, ...) RX_CAT2(_RX_ELEMENT_AT_, n)(__VA_ARGS__)
   47|       |
   48|       |#define RX_COUNT(...) RX_ELEMENT_AT(6, ## __VA_ARGS__, 6, 5, 4, 3, 2, 1, 0)
   49|       |
   50|       |/**
   51|       | #define JOIN(context, index, head, tail) head; tail
   52|       | #define APPLY(context, index, item) item = (context)[index]
   53|       |
   54|       | RX_FOR(A, JOIN, APPLY, toto, tutu);
   55|       |
   56|       | toto = (A)[0]; tutu = (A)[1];
   57|       | */
   58|      0|#define RX_FOR(context, join, generate, ...) RX_CAT2( _RX_FOR_, RX_COUNT(__VA_ARGS__))(context, 0, join, generate, ## __VA_ARGS__)
   59|       |
   60|       |/**
   61|       | #define JOIN(context, index, head, tail) head tail
   62|       | #define APPLY(context, index, item) item = (context)[index]
   63|       |
   64|       | RX_FOR(A, JOIN, APPLY, toto, tutu);
   65|       |
   66|       | , toto = (A)[0], tutu = (A)[1]
   67|       | */
   68|      0|#define RX_FOR_COMMA(context, generate, ...) RX_CAT2( _RX_FOR_COMMA_, RX_COUNT(__VA_ARGS__))(context, 0, generate, ## __VA_ARGS__)
   69|       |
   70|       |#define RX_INC(x) RX_CAT2(_RX_INC_, x)
   71|       |
   72|       |// element at
   73|       |
   74|       |#define _RX_ELEMENT_AT_0(x, ...) x
   75|       |#define _RX_ELEMENT_AT_1(_0, x, ...) x
   76|       |#define _RX_ELEMENT_AT_2(_0, _1, x, ...) x
   77|       |#define _RX_ELEMENT_AT_3(_0, _1, _2, x, ...) x
   78|       |#define _RX_ELEMENT_AT_4(_0, _1, _2, _3, x, ...) x
   79|       |#define _RX_ELEMENT_AT_5(_0, _1, _2, _3, _4, x, ...) x
   80|       |#define _RX_ELEMENT_AT_6(_0, _1, _2, _3, _4, _5, x, ...) x
   81|       |
   82|       |// rx for
   83|       |
   84|       |#define _RX_FOR_0(context, index, join, generate)
   85|       |
   86|       |#define _RX_FOR_1(context, index, join, generate, head) \
   87|      0|    generate(context, index, head)
   88|       |
   89|       |#define _RX_FOR_2(context, index, join, generate, head, ...) \
   90|      0|    join(context, index, generate(context, index, head), _RX_FOR_1(context, RX_INC(index), join, generate, __VA_ARGS__))
   91|       |
   92|       |#define _RX_FOR_3(context, index, join, generate, head, ...) \
   93|       |    join(context, index, generate(context, index, head), _RX_FOR_2(context, RX_INC(index), join, generate, __VA_ARGS__))
   94|       |
   95|       |#define _RX_FOR_4(context, index, join, generate, head, ...) \
   96|       |    join(context, index, generate(context, index, head), _RX_FOR_3(context, RX_INC(index), join, generate, __VA_ARGS__))
   97|       |
   98|       |#define _RX_FOR_5(context, index, join, generate, head, ...) \
   99|       |    join(context, index, generate(context, index, head), _RX_FOR_4(context, RX_INC(index), join, generate, __VA_ARGS__))
  100|       |
  101|       |#define _RX_FOR_6(context, index, join, generate, head, ...) \
  102|       |    join(context, index, generate(context, index, head), _RX_FOR_5(context, RX_INC(index), join, generate, __VA_ARGS__))
  103|       |
  104|       |// rx for
  105|       |
  106|       |#define _RX_FOR_COMMA_0(context, index, generate)
  107|       |
  108|       |#define _RX_FOR_COMMA_1(context, index, generate, head) \
  109|      0|    , generate(context, index, head)
  110|       |
  111|       |#define _RX_FOR_COMMA_2(context, index, generate, head, ...) \
  112|      0|    , generate(context, index, head) _RX_FOR_COMMA_1(context, RX_INC(index), generate, __VA_ARGS__)
  113|       |
  114|       |#define _RX_FOR_COMMA_3(context, index, generate, head, ...) \
  115|       |    , generate(context, index, head) _RX_FOR_COMMA_2(context, RX_INC(index), generate, __VA_ARGS__)
  116|       |
  117|       |#define _RX_FOR_COMMA_4(context, index, generate, head, ...) \
  118|       |    , generate(context, index, head) _RX_FOR_COMMA_3(context, RX_INC(index), generate, __VA_ARGS__)
  119|       |
  120|       |#define _RX_FOR_COMMA_5(context, index, generate, head, ...) \
  121|       |    , generate(context, index, head) _RX_FOR_COMMA_4(context, RX_INC(index), generate, __VA_ARGS__)
  122|       |
  123|       |#define _RX_FOR_COMMA_6(context, index, generate, head, ...) \
  124|       |    , generate(context, index, head) _RX_FOR_COMMA_5(context, RX_INC(index), generate, __VA_ARGS__)
  125|       |
  126|       |
  127|       |// rx inc
  128|       |
  129|       |#define _RX_INC_0   1
  130|       |#define _RX_INC_1   2
  131|       |#define _RX_INC_2   3
  132|       |#define _RX_INC_3   4
  133|       |#define _RX_INC_4   5
  134|       |#define _RX_INC_5   6
  135|       |#define _RX_INC_6   7
  136|       |
  137|       |// rx cat
  138|       |
  139|      0|#define _RX_CAT2(_1, _2) _1 ## _2

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/RxCocoa.swift:
    1|       |//
    2|       |//  RxCocoa.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import class Foundation.NSNull
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |#if os(iOS)
   15|       |    import UIKit
   16|       |#endif
   17|       |
   18|       |/// RxCocoa errors.
   19|       |public enum RxCocoaError
   20|       |    : Swift.Error
   21|       |    , CustomDebugStringConvertible {
   22|       |    /// Unknown error has occurred.
   23|       |    case unknown
   24|       |    /// Invalid operation was attempted.
   25|       |    case invalidOperation(object: Any)
   26|       |    /// Items are not yet bound to user interface but have been requested.
   27|       |    case itemsNotYetBound(object: Any)
   28|       |    /// Invalid KVO Path.
   29|       |    case invalidPropertyName(object: Any, propertyName: String)
   30|       |    /// Invalid object on key path.
   31|       |    case invalidObjectOnKeyPath(object: Any, sourceObject: AnyObject, propertyName: String)
   32|       |    /// Error during swizzling.
   33|       |    case errorDuringSwizzling
   34|       |    /// Casting error.
   35|       |    case castingError(object: Any, targetType: Any.Type)
   36|       |}
   37|       |
   38|       |
   39|       |// MARK: Debug descriptions
   40|       |
   41|       |extension RxCocoaError {
   42|       |    /// A textual representation of `self`, suitable for debugging.
   43|      0|    public var debugDescription: String {
   44|      0|        switch self {
   45|      0|        case .unknown:
   46|      0|            return "Unknown error occurred."
   47|      0|        case let .invalidOperation(object):
   48|      0|            return "Invalid operation was attempted on `\(object)`."
   49|      0|        case let .itemsNotYetBound(object):
   50|      0|            return "Data source is set, but items are not yet bound to user interface for `\(object)`."
   51|      0|        case let .invalidPropertyName(object, propertyName):
   52|      0|            return "Object `\(object)` dosn't have a property named `\(propertyName)`."
   53|      0|        case let .invalidObjectOnKeyPath(object, sourceObject, propertyName):
   54|      0|            return "Unobservable object `\(object)` was observed as `\(propertyName)` of `\(sourceObject)`."
   55|      0|        case .errorDuringSwizzling:
   56|      0|            return "Error during swizzling."
   57|      0|        case .castingError(let object, let targetType):
   58|      0|            return "Error casting `\(object)` to `\(targetType)`"
   59|      0|        }
   60|      0|    }
   61|       |}
   62|       |
   63|       |
   64|       |
   65|       |// MARK: Error binding policies
   66|       |
   67|      0|func bindingErrorToInterface(_ error: Swift.Error) {
   68|      0|    let error = "Binding error to UI: \(error)"
   69|      0|#if DEBUG
   70|      0|    rxFatalError(error)
   71|      0|#else
   72|      0|    print(error)
   73|      0|#endif
   74|      0|}
   75|       |
   76|       |/// Swift does not implement abstract methods. This method is used as a runtime check to ensure that methods which intended to be abstract (i.e., they should be implemented in subclasses) are not called directly on the superclass.
   77|      0|func rxAbstractMethod(message: String = "Abstract method", file: StaticString = #file, line: UInt = #line) -> Swift.Never {
   78|      0|    rxFatalError(message, file: file, line: line)
   79|      0|}
   80|       |
   81|      0|func rxFatalError(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) -> Swift.Never  {
   82|      0|    // The temptation to comment this line is great, but please don't, it's for your own good. The choice is yours.
   83|      0|    fatalError(lastMessage(), file: file, line: line)
   84|      0|}
   85|       |
   86|      0|func rxFatalErrorInDebug(_ lastMessage: @autoclosure () -> String, file: StaticString = #file, line: UInt = #line) {
   87|      0|    #if DEBUG
   88|      0|        fatalError(lastMessage(), file: file, line: line)
   89|      0|    #else
   90|      0|        print("\(file):\(line): \(lastMessage())")
   91|      0|    #endif
   92|      0|}
   93|       |
   94|       |// MARK: casts or fatal error
   95|       |
   96|       |// workaround for Swift compiler bug, cheers compiler team :)
   97|    238|func castOptionalOrFatalError<T>(_ value: Any?) -> T? {
   98|     92|    if value == nil {
   99|     92|        return nil
  100|    146|    }
  101|    146|    let v: T = castOrFatalError(value)
  102|    146|    return v
  103|    238|}
  104|       |
  105|      0|func castOrThrow<T>(_ resultType: T.Type, _ object: Any) throws -> T {
  106|      0|    guard let returnValue = object as? T else {
  107|      0|        throw RxCocoaError.castingError(object: object, targetType: resultType)
  108|      0|    }
  109|      0|
  110|      0|    return returnValue
  111|      0|}
  112|       |
  113|      0|func castOptionalOrThrow<T>(_ resultType: T.Type, _ object: AnyObject) throws -> T? {
  114|      0|    if NSNull().isEqual(object) {
  115|      0|        return nil
  116|      0|    }
  117|      0|
  118|      0|    guard let returnValue = object as? T else {
  119|      0|        throw RxCocoaError.castingError(object: object, targetType: resultType)
  120|      0|    }
  121|      0|
  122|      0|    return returnValue
  123|      0|}
  124|       |
  125|      0|func castOrFatalError<T>(_ value: AnyObject!, message: String) -> T {
  126|      0|    let maybeResult: T? = value as? T
  127|      0|    guard let result = maybeResult else {
  128|      0|        rxFatalError(message)
  129|      0|    }
  130|      0|    
  131|      0|    return result
  132|      0|}
  133|       |
  134|    623|func castOrFatalError<T>(_ value: Any!) -> T {
  135|    623|    let maybeResult: T? = value as? T
  136|      0|    guard let result = maybeResult else {
  137|      0|        rxFatalError("Failure converting from \(value) to \(T.self)")
  138|    623|    }
  139|    623|    
  140|    623|    return result
  141|    623|}
  142|       |
  143|       |// MARK: Error messages
  144|       |
  145|       |let dataSourceNotSet = "DataSource not set"
  146|       |let delegateNotSet = "Delegate not set"
  147|       |
  148|       |// MARK: Shared with RxSwift
  149|       |
  150|       |#if !RX_NO_MODULE
  151|       |
  152|      0|func rxFatalError(_ lastMessage: String) -> Never  {
  153|      0|    // The temptation to comment this line is great, but please don't, it's for your own good. The choice is yours.
  154|      0|    fatalError(lastMessage)
  155|      0|}
  156|       |
  157|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/ControlEvent.swift:
    1|       |//
    2|       |//  ControlEvent.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |/// Protocol that enables extension of `ControlEvent`.
   14|       |public protocol ControlEventType : ObservableType {
   15|       |
   16|       |    /// - returns: `ControlEvent` interface
   17|       |    func asControlEvent() -> ControlEvent<E>
   18|       |}
   19|       |
   20|       |/**
   21|       |    Trait for `Observable`/`ObservableType` that represents event on UI element.
   22|       |
   23|       |    It's properties are:
   24|       |
   25|       |    - it never fails
   26|       |    - it won't send any initial value on subscription
   27|       |    - it will `Complete` sequence on control being deallocated
   28|       |    - it never errors out
   29|       |    - it delivers events on `MainScheduler.instance`
   30|       |
   31|       |    **The implementation of `ControlEvent` will ensure that sequence of events is being subscribed on main scheduler
   32|       |     (`subscribeOn(ConcurrentMainScheduler.instance)` behavior).**
   33|       |
   34|       |    **It is implementor's responsibility to make sure that that all other properties enumerated above are satisfied.**
   35|       |
   36|       |    **If they aren't, then using this trait communicates wrong properties and could potentially break someone's code.**
   37|       |
   38|       |    **In case `events` observable sequence that is being passed into initializer doesn't satisfy all enumerated
   39|       |     properties, please don't use this unit.**
   40|       |*/
   41|       |public struct ControlEvent<PropertyType> : ControlEventType {
   42|       |    public typealias E = PropertyType
   43|       |
   44|       |    let _events: Observable<PropertyType>
   45|       |
   46|       |    /// Initializes control event with a observable sequence that represents events.
   47|       |    ///
   48|       |    /// - parameter events: Observable sequence that represents events.
   49|       |    /// - returns: Control event created with a observable sequence of events.
   50|    260|    public init<Ev: ObservableType>(events: Ev) where Ev.E == E {
   51|    260|        _events = events.subscribeOn(ConcurrentMainScheduler.instance)
   52|    260|    }
   53|       |
   54|       |    /// Subscribes an observer to control events.
   55|       |    ///
   56|       |    /// - parameter observer: Observer to subscribe to events.
   57|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from receiving control events.
   58|      0|    public func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   59|      0|        return _events.subscribe(observer)
   60|      0|    }
   61|       |
   62|       |    /// - returns: `Observable` interface.
   63|    260|    public func asObservable() -> Observable<E> {
   64|    260|        return _events
   65|    260|    }
   66|       |
   67|       |    /// - returns: `ControlEvent` interface.
   68|      0|    public func asControlEvent() -> ControlEvent<E> {
   69|      0|        return self
   70|      0|    }
   71|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/ControlProperty.swift:
    1|       |//
    2|       |//  ControlProperty.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |/// Protocol that enables extension of `ControlProperty`.
   14|       |public protocol ControlPropertyType : ObservableType, ObserverType {
   15|       |
   16|       |    /// - returns: `ControlProperty` interface
   17|       |    func asControlProperty() -> ControlProperty<E>
   18|       |}
   19|       |
   20|       |/**
   21|       |    Trait for `Observable`/`ObservableType` that represents property of UI element.
   22|       | 
   23|       |    Sequence of values only represents initial control value and user initiated value changes.
   24|       |    Programatic value changes won't be reported.
   25|       |
   26|       |    It's properties are:
   27|       |
   28|       |    - it never fails
   29|       |    - `shareReplay(1)` behavior
   30|       |        - it's stateful, upon subscription (calling subscribe) last element is immediately replayed if it was produced
   31|       |    - it will `Complete` sequence on control being deallocated
   32|       |    - it never errors out
   33|       |    - it delivers events on `MainScheduler.instance`
   34|       |
   35|       |    **The implementation of `ControlProperty` will ensure that sequence of values is being subscribed on main scheduler
   36|       |    (`subscribeOn(ConcurrentMainScheduler.instance)` behavior).**
   37|       |
   38|       |    **It is implementor's responsibility to make sure that that all other properties enumerated above are satisfied.**
   39|       |
   40|       |    **If they aren't, then using this trait communicates wrong properties and could potentially break someone's code.**
   41|       |
   42|       |    **In case `values` observable sequence that is being passed into initializer doesn't satisfy all enumerated
   43|       |    properties, please don't use this unit.**
   44|       |*/
   45|       |public struct ControlProperty<PropertyType> : ControlPropertyType {
   46|       |    public typealias E = PropertyType
   47|       |
   48|       |    let _values: Observable<PropertyType>
   49|       |    let _valueSink: AnyObserver<PropertyType>
   50|       |
   51|       |    /// Initializes control property with a observable sequence that represents property values and observer that enables
   52|       |    /// binding values to property.
   53|       |    ///
   54|       |    /// - parameter values: Observable sequence that represents property values.
   55|       |    /// - parameter valueSink: Observer that enables binding values to control property.
   56|       |    /// - returns: Control property created with a observable sequence of values and an observer that enables binding values
   57|       |    /// to property.
   58|    296|    public init<V: ObservableType, S: ObserverType>(values: V, valueSink: S) where E == V.E, E == S.E {
   59|    296|        _values = values.subscribeOn(ConcurrentMainScheduler.instance)
   60|    296|        _valueSink = valueSink.asObserver()
   61|    296|    }
   62|       |
   63|       |    /// Subscribes an observer to control property values.
   64|       |    ///
   65|       |    /// - parameter observer: Observer to subscribe to property values.
   66|       |    /// - returns: Disposable object that can be used to unsubscribe the observer from receiving control property values.
   67|      0|    public func subscribe<O : ObserverType>(_ observer: O) -> Disposable where O.E == E {
   68|      0|        return _values.subscribe(observer)
   69|      0|    }
   70|       |
   71|       |    /// `ControlEvent` of user initiated value changes. Every time user updates control value change event
   72|       |    /// will be emitted from `changed` event.
   73|       |    ///
   74|       |    /// Programatic changes to control value won't be reported.
   75|       |    ///
   76|       |    /// It contains all control property values except for first one.
   77|       |    ///
   78|       |    /// The name only implies that sequence element will be generated once user changes a value and not that
   79|       |    /// adjacent sequence values need to be different (e.g. because of interaction between programatic and user updates,
   80|       |    /// or for any other reason).
   81|       |    public var changed: ControlEvent<PropertyType> {
   82|      0|        get {
   83|      0|            return ControlEvent(events: _values.skip(1))
   84|      0|        }
   85|       |    }
   86|       |
   87|       |    /// - returns: `Observable` interface.
   88|    148|    public func asObservable() -> Observable<E> {
   89|    148|        return _values
   90|    148|    }
   91|       |
   92|       |    /// - returns: `ControlProperty` interface.
   93|    148|    public func asControlProperty() -> ControlProperty<E> {
   94|    148|        return self
   95|    148|    }
   96|       |
   97|       |    /// Binds event to user interface.
   98|       |    ///
   99|       |    /// - In case next element is received, it is being set to control value.
  100|       |    /// - In case error is received, DEBUG buids raise fatal error, RELEASE builds log event to standard output.
  101|       |    /// - In case sequence completes, nothing happens.
  102|      0|    public func on(_ event: Event<E>) {
  103|      0|        switch event {
  104|      0|        case .error(let error):
  105|      0|            bindingErrorToInterface(error)
  106|      0|        case .next:
  107|      0|            _valueSink.on(event)
  108|      0|        case .completed:
  109|      0|            _valueSink.on(event)
  110|      0|        }
  111|      0|    }
  112|       |}
  113|       |
  114|       |extension ControlPropertyType where E == String? {
  115|       |    /// Transforms control property of type `String?` into control property of type `String`.
  116|    148|    public var orEmpty: ControlProperty<String> {
  117|    148|        let original: ControlProperty<String?> = self.asControlProperty()
  118|    148|
  119|    148|        let values: Observable<String> = original._values.map { $0 ?? "" }
  120|      0|        let valueSink: AnyObserver<String> = original._valueSink.mapObserver { $0 }
  121|    148|        return ControlProperty<String>(values: values, valueSink: valueSink)
  122|    148|    }
  123|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/ControlEvent+Driver.swift:
    1|       |//
    2|       |//  ControlEvent+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |    
   13|       |extension ControlEvent {
   14|       |    /// Converts `ControlEvent` to `Driver` trait.
   15|       |    ///
   16|       |    /// `ControlEvent` already can't fail, so no special case needs to be handled.
   17|      0|    public func asDriver() -> Driver<E> {
   18|      0|        return self.asDriver { (error) -> Driver<E> in
   19|      0|            #if DEBUG
   20|      0|                rxFatalError("Somehow driver received error from a source that shouldn't fail.")
   21|      0|            #else
   22|      0|                return Driver.empty()
   23|      0|            #endif
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/ControlProperty+Driver.swift:
    1|       |//
    2|       |//  ControlProperty+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |extension ControlProperty {
   14|       |    /// Converts `ControlProperty` to `Driver` trait.
   15|       |    ///
   16|       |    /// `ControlProperty` already can't fail, so no special case needs to be handled.
   17|      0|    public func asDriver() -> Driver<E> {
   18|      0|        return self.asDriver { (error) -> Driver<E> in
   19|      0|            #if DEBUG
   20|      0|                rxFatalError("Somehow driver received error from a source that shouldn't fail.")
   21|      0|            #else
   22|      0|                return Driver.empty()
   23|      0|            #endif
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/Driver+Subscription.swift:
    1|       |//
    2|       |//  Driver+Subscription.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |private let driverErrorMessage = "`drive*` family of methods can be only called from `MainThread`.\n" +
   14|       |"This is required to ensure that the last replayed `Driver` element is delivered on `MainThread`.\n"
   15|       |
   16|       |// This would ideally be Driver, but unfortunatelly Driver can't be extended in Swift 3.0
   17|       |extension SharedSequenceConvertibleType where SharingStrategy == DriverSharingStrategy {
   18|       |    /**
   19|       |    Creates new subscription and sends elements to observer.
   20|       |    This method can be only called from `MainThread`.
   21|       |
   22|       |    In this form it's equivalent to `subscribe` method, but it communicates intent better.
   23|       |
   24|       |    - parameter observer: Observer that receives events.
   25|       |    - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   26|       |    */
   27|      0|    public func drive<O: ObserverType>(_ observer: O) -> Disposable where O.E == E {
   28|      0|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
   29|      0|        return self.asSharedSequence().asObservable().subscribe(observer)
   30|      0|    }
   31|       |
   32|       |    /**
   33|       |     Creates new subscription and sends elements to observer.
   34|       |     This method can be only called from `MainThread`.
   35|       |
   36|       |     In this form it's equivalent to `subscribe` method, but it communicates intent better.
   37|       |
   38|       |     - parameter observer: Observer that receives events.
   39|       |     - returns: Disposable object that can be used to unsubscribe the observer from the subject.
   40|       |     */
   41|      0|    public func drive<O: ObserverType>(_ observer: O) -> Disposable where O.E == E? {
   42|      0|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
   43|      0|        return self.asSharedSequence().asObservable().map { $0 as E? }.subscribe(observer)
   44|      0|    }
   45|       |
   46|       |    /**
   47|       |    Creates new subscription and sends elements to variable.
   48|       |    This method can be only called from `MainThread`.
   49|       |
   50|       |    - parameter variable: Target variable for sequence elements.
   51|       |    - returns: Disposable object that can be used to unsubscribe the observer from the variable.
   52|       |    */
   53|      0|    public func drive(_ variable: Variable<E>) -> Disposable {
   54|      0|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
   55|      0|        return drive(onNext: { e in
   56|      0|            variable.value = e
   57|      0|        })
   58|      0|    }
   59|       |
   60|       |    /**
   61|       |     Creates new subscription and sends elements to variable.
   62|       |     This method can be only called from `MainThread`.
   63|       |
   64|       |     - parameter variable: Target variable for sequence elements.
   65|       |     - returns: Disposable object that can be used to unsubscribe the observer from the variable.
   66|       |     */
   67|      0|    public func drive(_ variable: Variable<E?>) -> Disposable {
   68|      0|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
   69|      0|        return drive(onNext: { e in
   70|      0|            variable.value = e
   71|      0|        })
   72|      0|    }
   73|       |
   74|       |    /**
   75|       |    Subscribes to observable sequence using custom binder function.
   76|       |    This method can be only called from `MainThread`.
   77|       |
   78|       |    - parameter with: Function used to bind elements from `self`.
   79|       |    - returns: Object representing subscription.
   80|       |    */
   81|      0|    public func drive<R>(_ transformation: (Observable<E>) -> R) -> R {
   82|      0|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
   83|      0|        return transformation(self.asObservable())
   84|      0|    }
   85|       |
   86|       |    /**
   87|       |    Subscribes to observable sequence using custom binder function and final parameter passed to binder function
   88|       |    after `self` is passed.
   89|       |
   90|       |        public func drive<R1, R2>(with: Self -> R1 -> R2, curriedArgument: R1) -> R2 {
   91|       |            return with(self)(curriedArgument)
   92|       |        }
   93|       |
   94|       |    This method can be only called from `MainThread`.
   95|       |
   96|       |    - parameter with: Function used to bind elements from `self`.
   97|       |    - parameter curriedArgument: Final argument passed to `binder` to finish binding process.
   98|       |    - returns: Object representing subscription.
   99|       |    */
  100|      0|    public func drive<R1, R2>(_ with: (Observable<E>) -> (R1) -> R2, curriedArgument: R1) -> R2 {
  101|      0|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
  102|      0|        return with(self.asObservable())(curriedArgument)
  103|      0|    }
  104|       |    
  105|       |    /**
  106|       |    Subscribes an element handler, a completion handler and disposed handler to an observable sequence.
  107|       |    This method can be only called from `MainThread`.
  108|       |    
  109|       |    Error callback is not exposed because `Driver` can't error out.
  110|       |    
  111|       |    - parameter onNext: Action to invoke for each element in the observable sequence.
  112|       |    - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  113|       |    gracefully completed, errored, or if the generation is cancelled by disposing subscription)
  114|       |    - parameter onDisposed: Action to invoke upon any type of termination of sequence (if the sequence has
  115|       |    gracefully completed, errored, or if the generation is cancelled by disposing subscription)
  116|       |    - returns: Subscription object used to unsubscribe from the observable sequence.
  117|       |    */
  118|     14|    public func drive(onNext: ((E) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onDisposed: (() -> Void)? = nil) -> Disposable {
  119|     14|        MainScheduler.ensureExecutingOnScheduler(errorMessage: driverErrorMessage)
  120|     14|        return self.asObservable().subscribe(onNext: onNext, onCompleted: onCompleted, onDisposed: onDisposed)
  121|     14|    }
  122|       |}
  123|       |
  124|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/Driver.swift:
    1|       |//
    2|       |//  Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/26/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |
   14|       |/**
   15|       | Trait that represents observable sequence with following properties:
   16|       |
   17|       | - it never fails
   18|       | - it delivers events on `MainScheduler.instance`
   19|       | - `shareReplayLatestWhileConnected()` behavior
   20|       | - all observers share sequence computation resources
   21|       | - it's stateful, upon subscription (calling subscribe) last element is immediatelly replayed if it was produced
   22|       | - computation of elements is reference counted with respect to the number of observers
   23|       | - if there are no subscribers, it will release sequence computation resources
   24|       |
   25|       | `Driver<Element>` can be considered a builder pattern for observable sequences that drive the application.
   26|       |
   27|       | If observable sequence has produced at least one element, after new subscription is made last produced element will be
   28|       | immediately replayed on the same thread on which the subscription was made.
   29|       |
   30|       | When using `drive*`, `subscribe*` and `bind*` family of methods, they should always be called from main thread.
   31|       |
   32|       | If `drive*`, `subscribe*` and `bind*` are called from background thread, it is possible that initial replay
   33|       | will happen on background thread, and subsequent events will arrive on main thread.
   34|       |
   35|       | To find out more about traits and how to use them, please visit `Documentation/Traits.md`.
   36|       | */
   37|       |public typealias Driver<E> = SharedSequence<DriverSharingStrategy, E>
   38|       |
   39|       |public struct DriverSharingStrategy: SharingStrategyProtocol {
   40|     19|    public static var scheduler: SchedulerType { return driverObserveOnScheduler }
   41|     31|    public static func share<E>(_ source: Observable<E>) -> Observable<E> {
   42|     31|        return source.shareReplayLatestWhileConnected()
   43|     31|    }
   44|       |}
   45|       |
   46|       |extension SharedSequenceConvertibleType where SharingStrategy == DriverSharingStrategy {
   47|       |    /// Adds `asDriver` to `SharingSequence` with `DriverSharingStrategy`.
   48|      0|    public func asDriver() -> Driver<E> {
   49|      0|        return self.asSharedSequence()
   50|      0|    }
   51|       |}
   52|       |
   53|       |/**
   54|       | This method can be used in unit tests to ensure that driver is using mock schedulers instead of
   55|       | main schedulers.
   56|       |
   57|       | **This shouldn't be used in normal release builds.**
   58|       |*/
   59|      0|public func driveOnScheduler(_ scheduler: SchedulerType, action: () -> ()) {
   60|      0|    let originalObserveOnScheduler = driverObserveOnScheduler
   61|      0|    driverObserveOnScheduler = scheduler
   62|      0|
   63|      0|    action()
   64|      0|
   65|      0|    // If you remove this line , compiler buggy optimizations will change behavior of this code
   66|      0|    _forceCompilerToStopDoingInsaneOptimizationsThatBreakCode(driverObserveOnScheduler)
   67|      0|    // Scary, I know
   68|      0|
   69|      0|    driverObserveOnScheduler = originalObserveOnScheduler
   70|      0|}
   71|       |
   72|       |#if os(Linux)
   73|       |    import Glibc
   74|       |#else
   75|       |    import func Foundation.arc4random
   76|       |#endif
   77|       |
   78|      0|func _forceCompilerToStopDoingInsaneOptimizationsThatBreakCode(_ scheduler: SchedulerType) {
   79|      0|    let a: Int32 = 1
   80|      0|#if os(Linux)
   81|      0|    let b = 314 + Int32(Glibc.random() & 1)
   82|      0|#else
   83|      0|    let b = 314 + Int32(arc4random() & 1)
   84|      0|#endif
   85|      0|    if a == b {
   86|      0|        print(scheduler)
   87|      0|    }
   88|      0|}
   89|       |
   90|       |fileprivate var driverObserveOnScheduler: SchedulerType = MainScheduler.instance

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/ObservableConvertibleType+Driver.swift:
    1|       |//
    2|       |//  ObservableConvertibleType+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |extension ObservableConvertibleType {
   14|       |    /**
   15|       |    Converts anything convertible to `Observable` to `Driver` unit.
   16|       |    
   17|       |    - parameter onErrorJustReturn: Element to return in case of error and after that complete the sequence.
   18|       |    - returns: Driving observable sequence.
   19|       |    */
   20|      5|    public func asDriver(onErrorJustReturn: E) -> Driver<E> {
   21|      5|        let source = self
   22|      5|            .asObservable()
   23|      5|            .observeOn(DriverSharingStrategy.scheduler)
   24|      5|            .catchErrorJustReturn(onErrorJustReturn)
   25|      5|        return Driver(source)
   26|      5|    }
   27|       |    
   28|       |    /**
   29|       |    Converts anything convertible to `Observable` to `Driver` unit.
   30|       |    
   31|       |    - parameter onErrorDriveWith: Driver that continues to drive the sequence in case of error.
   32|       |    - returns: Driving observable sequence.
   33|       |    */
   34|      0|    public func asDriver(onErrorDriveWith: Driver<E>) -> Driver<E> {
   35|      0|        let source = self
   36|      0|            .asObservable()
   37|      0|            .observeOn(DriverSharingStrategy.scheduler)
   38|      0|            .catchError { _ in
   39|      0|                onErrorDriveWith.asObservable()
   40|      0|            }
   41|      0|        return Driver(source)
   42|      0|    }
   43|       |
   44|       |    /**
   45|       |    Converts anything convertible to `Observable` to `Driver` unit.
   46|       |    
   47|       |    - parameter onErrorRecover: Calculates driver that continues to drive the sequence in case of error.
   48|       |    - returns: Driving observable sequence.
   49|       |    */
   50|      0|    public func asDriver(onErrorRecover: @escaping (_ error: Swift.Error) -> Driver<E>) -> Driver<E> {
   51|      0|        let source = self
   52|      0|            .asObservable()
   53|      0|            .observeOn(DriverSharingStrategy.scheduler)
   54|      0|            .catchError { error in
   55|      0|                onErrorRecover(error).asObservable()
   56|      0|            }
   57|      0|        return Driver(source)
   58|      0|    }
   59|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/Driver/Variable+Driver.swift:
    1|       |//
    2|       |//  Variable+Driver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |extension Variable {
   14|       |    /// Converts `Variable` to `Driver` unit.
   15|       |    ///
   16|       |    /// - returns: Driving observable sequence.
   17|     14|    public func asDriver() -> Driver<E> {
   18|     14|        let source = self.asObservable()
   19|     14|            .observeOn(DriverSharingStrategy.scheduler)
   20|     14|        return Driver(source)
   21|     14|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/ObservableConvertibleType+SharedSequence.swift:
    1|       |//
    2|       |//  ObservableConvertibleType+SharedSequence.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |extension ObservableConvertibleType {
   14|       |    /**
   15|       |    Converts anything convertible to `Observable` to `SharedSequence` unit.
   16|       |    
   17|       |    - parameter onErrorJustReturn: Element to return in case of error and after that complete the sequence.
   18|       |    - returns: Driving observable sequence.
   19|       |    */
   20|      0|    public func asSharedSequence<S: SharingStrategyProtocol>(sharingStrategy: S.Type = S.self, onErrorJustReturn: E) -> SharedSequence<S, E> {
   21|      0|        let source = self
   22|      0|            .asObservable()
   23|      0|            .observeOn(S.scheduler)
   24|      0|            .catchErrorJustReturn(onErrorJustReturn)
   25|      0|        return SharedSequence(source)
   26|      0|    }
   27|       |    
   28|       |    /**
   29|       |    Converts anything convertible to `Observable` to `SharedSequence` unit.
   30|       |    
   31|       |    - parameter onErrorDriveWith: SharedSequence that provides elements of the sequence in case of error.
   32|       |    - returns: Driving observable sequence.
   33|       |    */
   34|      0|    public func asSharedSequence<S: SharingStrategyProtocol>(sharingStrategy: S.Type = S.self, onErrorDriveWith: SharedSequence<S, E>) -> SharedSequence<S, E> {
   35|      0|        let source = self
   36|      0|            .asObservable()
   37|      0|            .observeOn(S.scheduler)
   38|      0|            .catchError { _ in
   39|      0|                onErrorDriveWith.asObservable()
   40|      0|            }
   41|      0|        return SharedSequence(source)
   42|      0|    }
   43|       |
   44|       |    /**
   45|       |    Converts anything convertible to `Observable` to `SharedSequence` unit.
   46|       |    
   47|       |    - parameter onErrorRecover: Calculates driver that continues to drive the sequence in case of error.
   48|       |    - returns: Driving observable sequence.
   49|       |    */
   50|      0|    public func asSharedSequence<S: SharingStrategyProtocol>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (_ error: Swift.Error) -> SharedSequence<S, E>) -> SharedSequence<S, E> {
   51|      0|        let source = self
   52|      0|            .asObservable()
   53|      0|            .observeOn(S.scheduler)
   54|      0|            .catchError { error in
   55|      0|                onErrorRecover(error).asObservable()
   56|      0|            }
   57|      0|        return SharedSequence(source)
   58|      0|    }
   59|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SharedSequence+Operators+arity.swift:
    1|       |// This file is autogenerated. Take a look at `Preprocessor` target in RxSwift project 
    2|       |//
    3|       |//  SharedSequence+Operators+arity.swift
    4|       |//  RxCocoa
    5|       |//
    6|       |//  Created by Krunoslav Zaher on 10/14/15.
    7|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    8|       |//
    9|       |
   10|       |#if !RX_NO_MODULE
   11|       |import RxSwift
   12|       |#endif
   13|       |
   14|       |
   15|       |
   16|       |// 2
   17|       |
   18|       |extension SharedSequence {
   19|       |    /**
   20|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   21|       |
   22|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   23|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   24|       |    */
   25|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType>
   26|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   27|      0|        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy {
   28|      0|        let source = Observable.zip(
   29|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(),
   30|      0|            resultSelector: resultSelector
   31|      0|        )
   32|      0|
   33|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
   34|      0|    }
   35|       |}
   36|       |
   37|       |extension SharedSequence {
   38|       |    /**
   39|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   40|       |
   41|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   42|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   43|       |    */
   44|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType>
   45|       |        (_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.E, O2.E) throws -> E)
   46|      0|        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy {
   47|      0|        let source = Observable.combineLatest(
   48|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(),
   49|      0|                resultSelector: resultSelector
   50|      0|            )
   51|      0|
   52|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
   53|      0|    }
   54|       |}
   55|       |
   56|       |
   57|       |
   58|       |// 3
   59|       |
   60|       |extension SharedSequence {
   61|       |    /**
   62|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
   63|       |
   64|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
   65|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   66|       |    */
   67|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType>
   68|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
   69|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
   70|      0|            O1.SharingStrategy == O3.SharingStrategy {
   71|      0|        let source = Observable.zip(
   72|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(),
   73|      0|            resultSelector: resultSelector
   74|      0|        )
   75|      0|
   76|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
   77|      0|    }
   78|       |}
   79|       |
   80|       |extension SharedSequence {
   81|       |    /**
   82|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
   83|       |
   84|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
   85|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
   86|       |    */
   87|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType>
   88|       |        (_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.E, O2.E, O3.E) throws -> E)
   89|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
   90|      0|            O1.SharingStrategy == O3.SharingStrategy {
   91|      0|        let source = Observable.combineLatest(
   92|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(),
   93|      0|                resultSelector: resultSelector
   94|      0|            )
   95|      0|
   96|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
   97|      0|    }
   98|       |}
   99|       |
  100|       |
  101|       |
  102|       |// 4
  103|       |
  104|       |extension SharedSequence {
  105|       |    /**
  106|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  107|       |
  108|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  109|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  110|       |    */
  111|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType>
  112|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  113|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  114|       |            O1.SharingStrategy == O3.SharingStrategy,
  115|      0|            O1.SharingStrategy == O4.SharingStrategy {
  116|      0|        let source = Observable.zip(
  117|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(),
  118|      0|            resultSelector: resultSelector
  119|      0|        )
  120|      0|
  121|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  122|      0|    }
  123|       |}
  124|       |
  125|       |extension SharedSequence {
  126|       |    /**
  127|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  128|       |
  129|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  130|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  131|       |    */
  132|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType>
  133|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E) throws -> E)
  134|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  135|       |            O1.SharingStrategy == O3.SharingStrategy,
  136|      0|            O1.SharingStrategy == O4.SharingStrategy {
  137|      0|        let source = Observable.combineLatest(
  138|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(),
  139|      0|                resultSelector: resultSelector
  140|      0|            )
  141|      0|
  142|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  143|      0|    }
  144|       |}
  145|       |
  146|       |
  147|       |
  148|       |// 5
  149|       |
  150|       |extension SharedSequence {
  151|       |    /**
  152|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  153|       |
  154|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  155|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  156|       |    */
  157|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType>
  158|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  159|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  160|       |            O1.SharingStrategy == O3.SharingStrategy,
  161|       |            O1.SharingStrategy == O4.SharingStrategy,
  162|      0|            O1.SharingStrategy == O5.SharingStrategy {
  163|      0|        let source = Observable.zip(
  164|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(),
  165|      0|            resultSelector: resultSelector
  166|      0|        )
  167|      0|
  168|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  169|      0|    }
  170|       |}
  171|       |
  172|       |extension SharedSequence {
  173|       |    /**
  174|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  175|       |
  176|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  177|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  178|       |    */
  179|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType>
  180|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E) throws -> E)
  181|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  182|       |            O1.SharingStrategy == O3.SharingStrategy,
  183|       |            O1.SharingStrategy == O4.SharingStrategy,
  184|      0|            O1.SharingStrategy == O5.SharingStrategy {
  185|      0|        let source = Observable.combineLatest(
  186|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(),
  187|      0|                resultSelector: resultSelector
  188|      0|            )
  189|      0|
  190|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  191|      0|    }
  192|       |}
  193|       |
  194|       |
  195|       |
  196|       |// 6
  197|       |
  198|       |extension SharedSequence {
  199|       |    /**
  200|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  201|       |
  202|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  203|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  204|       |    */
  205|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType>
  206|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  207|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  208|       |            O1.SharingStrategy == O3.SharingStrategy,
  209|       |            O1.SharingStrategy == O4.SharingStrategy,
  210|       |            O1.SharingStrategy == O5.SharingStrategy,
  211|      0|            O1.SharingStrategy == O6.SharingStrategy {
  212|      0|        let source = Observable.zip(
  213|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(),
  214|      0|            resultSelector: resultSelector
  215|      0|        )
  216|      0|
  217|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  218|      0|    }
  219|       |}
  220|       |
  221|       |extension SharedSequence {
  222|       |    /**
  223|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  224|       |
  225|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  226|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  227|       |    */
  228|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType>
  229|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E) throws -> E)
  230|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  231|       |            O1.SharingStrategy == O3.SharingStrategy,
  232|       |            O1.SharingStrategy == O4.SharingStrategy,
  233|       |            O1.SharingStrategy == O5.SharingStrategy,
  234|      0|            O1.SharingStrategy == O6.SharingStrategy {
  235|      0|        let source = Observable.combineLatest(
  236|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(),
  237|      0|                resultSelector: resultSelector
  238|      0|            )
  239|      0|
  240|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  241|      0|    }
  242|       |}
  243|       |
  244|       |
  245|       |
  246|       |// 7
  247|       |
  248|       |extension SharedSequence {
  249|       |    /**
  250|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  251|       |
  252|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  253|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  254|       |    */
  255|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType>
  256|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  257|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  258|       |            O1.SharingStrategy == O3.SharingStrategy,
  259|       |            O1.SharingStrategy == O4.SharingStrategy,
  260|       |            O1.SharingStrategy == O5.SharingStrategy,
  261|       |            O1.SharingStrategy == O6.SharingStrategy,
  262|      0|            O1.SharingStrategy == O7.SharingStrategy {
  263|      0|        let source = Observable.zip(
  264|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(),
  265|      0|            resultSelector: resultSelector
  266|      0|        )
  267|      0|
  268|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  269|      0|    }
  270|       |}
  271|       |
  272|       |extension SharedSequence {
  273|       |    /**
  274|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  275|       |
  276|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  277|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  278|       |    */
  279|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType>
  280|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E) throws -> E)
  281|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  282|       |            O1.SharingStrategy == O3.SharingStrategy,
  283|       |            O1.SharingStrategy == O4.SharingStrategy,
  284|       |            O1.SharingStrategy == O5.SharingStrategy,
  285|       |            O1.SharingStrategy == O6.SharingStrategy,
  286|      0|            O1.SharingStrategy == O7.SharingStrategy {
  287|      0|        let source = Observable.combineLatest(
  288|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(),
  289|      0|                resultSelector: resultSelector
  290|      0|            )
  291|      0|
  292|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  293|      0|    }
  294|       |}
  295|       |
  296|       |
  297|       |
  298|       |// 8
  299|       |
  300|       |extension SharedSequence {
  301|       |    /**
  302|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  303|       |
  304|       |    - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  305|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  306|       |    */
  307|       |    public static func zip<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType, O8: SharedSequenceConvertibleType>
  308|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  309|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  310|       |            O1.SharingStrategy == O3.SharingStrategy,
  311|       |            O1.SharingStrategy == O4.SharingStrategy,
  312|       |            O1.SharingStrategy == O5.SharingStrategy,
  313|       |            O1.SharingStrategy == O6.SharingStrategy,
  314|       |            O1.SharingStrategy == O7.SharingStrategy,
  315|      0|            O1.SharingStrategy == O8.SharingStrategy {
  316|      0|        let source = Observable.zip(
  317|      0|            source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(), source8.asSharedSequence().asObservable(),
  318|      0|            resultSelector: resultSelector
  319|      0|        )
  320|      0|
  321|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  322|      0|    }
  323|       |}
  324|       |
  325|       |extension SharedSequence {
  326|       |    /**
  327|       |    Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  328|       |
  329|       |    - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  330|       |    - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  331|       |    */
  332|       |    public static func combineLatest<O1: SharedSequenceConvertibleType, O2: SharedSequenceConvertibleType, O3: SharedSequenceConvertibleType, O4: SharedSequenceConvertibleType, O5: SharedSequenceConvertibleType, O6: SharedSequenceConvertibleType, O7: SharedSequenceConvertibleType, O8: SharedSequenceConvertibleType>
  333|       |        (_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.E, O2.E, O3.E, O4.E, O5.E, O6.E, O7.E, O8.E) throws -> E)
  334|       |        -> SharedSequence<O1.SharingStrategy, E> where O1.SharingStrategy == O2.SharingStrategy,
  335|       |            O1.SharingStrategy == O3.SharingStrategy,
  336|       |            O1.SharingStrategy == O4.SharingStrategy,
  337|       |            O1.SharingStrategy == O5.SharingStrategy,
  338|       |            O1.SharingStrategy == O6.SharingStrategy,
  339|       |            O1.SharingStrategy == O7.SharingStrategy,
  340|      0|            O1.SharingStrategy == O8.SharingStrategy {
  341|      0|        let source = Observable.combineLatest(
  342|      0|                source1.asSharedSequence().asObservable(), source2.asSharedSequence().asObservable(), source3.asSharedSequence().asObservable(), source4.asSharedSequence().asObservable(), source5.asSharedSequence().asObservable(), source6.asSharedSequence().asObservable(), source7.asSharedSequence().asObservable(), source8.asSharedSequence().asObservable(),
  343|      0|                resultSelector: resultSelector
  344|      0|            )
  345|      0|
  346|      0|        return SharedSequence<O1.SharingStrategy, E>(source)
  347|      0|    }
  348|       |}
  349|       |
  350|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SharedSequence+Operators.swift:
    1|       |//
    2|       |//  SharedSequence+Operators.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 9/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |// MARK: map
   14|       |extension SharedSequenceConvertibleType {
   15|       |    
   16|       |    /**
   17|       |    Projects each element of an observable sequence into a new form.
   18|       |    
   19|       |    - parameter selector: A transform function to apply to each source element.
   20|       |    - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source.
   21|       |    */
   22|      0|    public func map<R>(_ selector: @escaping (E) -> R) -> SharedSequence<SharingStrategy, R> {
   23|      0|        let source = self
   24|      0|            .asObservable()
   25|      0|            .map(selector)
   26|      0|        return SharedSequence<SharingStrategy, R>(source)
   27|      0|    }
   28|       |}
   29|       |
   30|       |// MARK: filter
   31|       |extension SharedSequenceConvertibleType {
   32|       |    /**
   33|       |    Filters the elements of an observable sequence based on a predicate.
   34|       |    
   35|       |    - parameter predicate: A function to test each source element for a condition.
   36|       |    - returns: An observable sequence that contains elements from the input sequence that satisfy the condition.
   37|       |    */
   38|      0|    public func filter(_ predicate: @escaping (E) -> Bool) -> SharedSequence<SharingStrategy, E> {
   39|      0|        let source = self
   40|      0|            .asObservable()
   41|      0|            .filter(predicate)
   42|      0|        return SharedSequence(source)
   43|      0|    }
   44|       |}
   45|       |
   46|       |// MARK: switchLatest
   47|       |extension SharedSequenceConvertibleType where E : SharedSequenceConvertibleType, E.SharingStrategy == SharingStrategy {
   48|       |    
   49|       |    /**
   50|       |    Transforms an observable sequence of observable sequences into an observable sequence
   51|       |    producing values only from the most recent observable sequence.
   52|       |    
   53|       |    Each time a new inner observable sequence is received, unsubscribe from the
   54|       |    previous inner observable sequence.
   55|       |    
   56|       |    - returns: The observable sequence that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   57|       |    */
   58|      0|    public func switchLatest() -> SharedSequence<SharingStrategy, E.E> {
   59|      0|        let source: Observable<E.E> = self
   60|      0|            .asObservable()
   61|      0|            .map { $0.asSharedSequence() }
   62|      0|            .switchLatest()
   63|      0|        return SharedSequence<SharingStrategy, E.E>(source)
   64|      0|    }
   65|       |}
   66|       |
   67|       |// MARK: flatMapLatest
   68|       |extension SharedSequenceConvertibleType {
   69|       |    /**
   70|       |     Projects each element of an observable sequence into a new sequence of observable sequences and then
   71|       |     transforms an observable sequence of observable sequences into an observable sequence producing values only from the most recent observable sequence.
   72|       |
   73|       |     It is a combination of `map` + `switchLatest` operator
   74|       |
   75|       |     - parameter selector: A transform function to apply to each element.
   76|       |     - returns: An observable sequence whose elements are the result of invoking the transform function on each element of source producing an
   77|       |     Observable of Observable sequences and that at any point in time produces the elements of the most recent inner observable sequence that has been received.
   78|       |     */
   79|       |    public func flatMapLatest<R>(_ selector: @escaping (E) -> SharedSequence<SharingStrategy, R>)
   80|      0|        -> SharedSequence<SharingStrategy, R> {
   81|      0|        let source: Observable<R> = self
   82|      0|            .asObservable()
   83|      0|            .flatMapLatest(selector)
   84|      0|        return SharedSequence<SharingStrategy, R>(source)
   85|      0|    }
   86|       |}
   87|       |
   88|       |// MARK: flatMapFirst
   89|       |extension SharedSequenceConvertibleType {
   90|       |
   91|       |    /**
   92|       |     Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
   93|       |     If element is received while there is some projected observable sequence being merged it will simply be ignored.
   94|       |
   95|       |     - parameter selector: A transform function to apply to element that was observed while no observable is executing in parallel.
   96|       |     - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence that was received while no other sequence was being calculated.
   97|       |     */
   98|       |    public func flatMapFirst<R>(_ selector: @escaping (E) -> SharedSequence<SharingStrategy, R>)
   99|      0|        -> SharedSequence<SharingStrategy, R> {
  100|      0|        let source: Observable<R> = self
  101|      0|            .asObservable()
  102|      0|            .flatMapFirst(selector)
  103|      0|        return SharedSequence<SharingStrategy, R>(source)
  104|      0|    }
  105|       |}
  106|       |
  107|       |// MARK: do
  108|       |extension SharedSequenceConvertibleType {
  109|       |    /**
  110|       |     Invokes an action for each event in the observable sequence, and propagates all observer messages through the result sequence.
  111|       |
  112|       |     - parameter onNext: Action to invoke for each element in the observable sequence.
  113|       |     - parameter onCompleted: Action to invoke upon graceful termination of the observable sequence.
  114|       |     - parameter onSubscribe: Action to invoke before subscribing to source observable sequence.
  115|       |     - parameter onDispose: Action to invoke after subscription to source observable has been disposed for any reason. It can be either because sequence terminates for some reason or observer subscription being disposed.
  116|       |     - returns: The source sequence with the side-effecting behavior applied.
  117|       |     */
  118|       |    public func `do`(onNext: ((E) -> Void)? = nil, onCompleted: (() -> Void)? = nil, onSubscribe: (() -> ())? = nil, onDispose: (() -> ())? = nil)
  119|      0|        -> SharedSequence<SharingStrategy, E> {
  120|      0|        let source = self.asObservable()
  121|      0|            .do(onNext: onNext, onCompleted: onCompleted, onSubscribe: onSubscribe, onDispose: onDispose)
  122|      0|
  123|      0|        return SharedSequence(source)
  124|      0|    }
  125|       |}
  126|       |
  127|       |// MARK: debug
  128|       |extension SharedSequenceConvertibleType {
  129|       |    
  130|       |    /**
  131|       |    Prints received events for all observers on standard output.
  132|       |    
  133|       |    - parameter identifier: Identifier that is printed together with event description to standard output.
  134|       |    - returns: An observable sequence whose events are printed to standard output.
  135|       |    */
  136|      5|    public func debug(_ identifier: String? = nil, file: String = #file, line: UInt = #line, function: String = #function) -> SharedSequence<SharingStrategy, E> {
  137|      5|        let source = self.asObservable()
  138|      5|            .debug(identifier, file: file, line: line, function: function)
  139|      5|        return SharedSequence(source)
  140|      5|    }
  141|       |}
  142|       |
  143|       |// MARK: distinctUntilChanged
  144|       |extension SharedSequenceConvertibleType where E: Equatable {
  145|       |    
  146|       |    /**
  147|       |    Returns an observable sequence that contains only distinct contiguous elements according to equality operator.
  148|       |    
  149|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on equality operator, from the source sequence.
  150|       |    */
  151|       |    public func distinctUntilChanged()
  152|      0|        -> SharedSequence<SharingStrategy, E> {
  153|      0|        let source = self.asObservable()
  154|      0|            .distinctUntilChanged({ $0 }, comparer: { ($0 == $1) })
  155|      0|            
  156|      0|        return SharedSequence(source)
  157|      0|    }
  158|       |}
  159|       |
  160|       |extension SharedSequenceConvertibleType {
  161|       |    
  162|       |    /**
  163|       |    Returns an observable sequence that contains only distinct contiguous elements according to the `keySelector`.
  164|       |    
  165|       |    - parameter keySelector: A function to compute the comparison key for each element.
  166|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value, from the source sequence.
  167|       |    */
  168|      0|    public func distinctUntilChanged<K: Equatable>(_ keySelector: @escaping (E) -> K) -> SharedSequence<SharingStrategy, E> {
  169|      0|        let source = self.asObservable()
  170|      0|            .distinctUntilChanged(keySelector, comparer: { $0 == $1 })
  171|      0|        return SharedSequence(source)
  172|      0|    }
  173|       |   
  174|       |    /**
  175|       |    Returns an observable sequence that contains only distinct contiguous elements according to the `comparer`.
  176|       |    
  177|       |    - parameter comparer: Equality comparer for computed key values.
  178|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on `comparer`, from the source sequence.
  179|       |    */
  180|      0|    public func distinctUntilChanged(_ comparer: @escaping (E, E) -> Bool) -> SharedSequence<SharingStrategy, E> {
  181|      0|        let source = self.asObservable()
  182|      0|            .distinctUntilChanged({ $0 }, comparer: comparer)
  183|      0|        return SharedSequence<SharingStrategy, E>(source)
  184|      0|    }
  185|       |    
  186|       |    /**
  187|       |    Returns an observable sequence that contains only distinct contiguous elements according to the keySelector and the comparer.
  188|       |    
  189|       |    - parameter keySelector: A function to compute the comparison key for each element.
  190|       |    - parameter comparer: Equality comparer for computed key values.
  191|       |    - returns: An observable sequence only containing the distinct contiguous elements, based on a computed key value and the comparer, from the source sequence.
  192|       |    */
  193|      0|    public func distinctUntilChanged<K>(_ keySelector: @escaping (E) -> K, comparer: @escaping (K, K) -> Bool) -> SharedSequence<SharingStrategy, E> {
  194|      0|        let source = self.asObservable()
  195|      0|            .distinctUntilChanged(keySelector, comparer: comparer)
  196|      0|        return SharedSequence<SharingStrategy, E>(source)
  197|      0|    }
  198|       |}
  199|       |
  200|       |
  201|       |// MARK: flatMap
  202|       |extension SharedSequenceConvertibleType {
  203|       |    
  204|       |    /**
  205|       |    Projects each element of an observable sequence to an observable sequence and merges the resulting observable sequences into one observable sequence.
  206|       |    
  207|       |    - parameter selector: A transform function to apply to each element.
  208|       |    - returns: An observable sequence whose elements are the result of invoking the one-to-many transform function on each element of the input sequence.
  209|       |    */
  210|      0|    public func flatMap<R>(_ selector: @escaping (E) -> SharedSequence<SharingStrategy, R>) -> SharedSequence<SharingStrategy, R> {
  211|      0|        let source = self.asObservable()
  212|      0|            .flatMap(selector)
  213|      0|        
  214|      0|        return SharedSequence(source)
  215|      0|    }
  216|       |}
  217|       |
  218|       |// MARK: merge
  219|       |extension SharedSequenceConvertibleType {
  220|       |    /**
  221|       |     Merges elements from all observable sequences from collection into a single observable sequence.
  222|       |
  223|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  224|       |
  225|       |     - parameter sources: Collection of observable sequences to merge.
  226|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  227|       |     */
  228|       |    public static func merge<C: Collection>(_ sources: C) -> SharedSequence<SharingStrategy, E>
  229|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, E> {
  230|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  231|      0|        return SharedSequence<SharingStrategy, E>(source)
  232|      0|    }
  233|       |
  234|       |    /**
  235|       |     Merges elements from all observable sequences from array into a single observable sequence.
  236|       |
  237|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  238|       |
  239|       |     - parameter sources: Array of observable sequences to merge.
  240|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  241|       |     */
  242|      0|    public static func merge(_ sources: [SharedSequence<SharingStrategy, E>]) -> SharedSequence<SharingStrategy, E> {
  243|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  244|      0|        return SharedSequence<SharingStrategy, E>(source)
  245|      0|    }
  246|       |
  247|       |    /**
  248|       |     Merges elements from all observable sequences into a single observable sequence.
  249|       |
  250|       |     - seealso: [merge operator on reactivex.io](http://reactivex.io/documentation/operators/merge.html)
  251|       |
  252|       |     - parameter sources: Collection of observable sequences to merge.
  253|       |     - returns: The observable sequence that merges the elements of the observable sequences.
  254|       |     */
  255|      0|    public static func merge(_ sources: SharedSequence<SharingStrategy, E>...) -> SharedSequence<SharingStrategy, E> {
  256|      0|        let source = Observable.merge(sources.map { $0.asObservable() })
  257|      0|        return SharedSequence<SharingStrategy, E>(source)
  258|      0|    }
  259|       |    
  260|       |}
  261|       |
  262|       |// MARK: merge
  263|       |extension SharedSequenceConvertibleType where E : SharedSequenceConvertibleType, E.SharingStrategy == SharingStrategy {
  264|       |    /**
  265|       |    Merges elements from all observable sequences in the given enumerable sequence into a single observable sequence.
  266|       |    
  267|       |    - parameter maxConcurrent: Maximum number of inner observable sequences being subscribed to concurrently.
  268|       |    - returns: The observable sequence that merges the elements of the observable sequences.
  269|       |    */
  270|      0|    public func merge() -> SharedSequence<SharingStrategy, E.E> {
  271|      0|        let source = self.asObservable()
  272|      0|            .map { $0.asSharedSequence() }
  273|      0|            .merge()
  274|      0|        return SharedSequence<SharingStrategy, E.E>(source)
  275|      0|    }
  276|       |    
  277|       |    /**
  278|       |    Merges elements from all inner observable sequences into a single observable sequence, limiting the number of concurrent subscriptions to inner sequences.
  279|       |    
  280|       |    - returns: The observable sequence that merges the elements of the inner sequences.
  281|       |    */
  282|       |    public func merge(maxConcurrent: Int)
  283|      0|        -> SharedSequence<SharingStrategy, E.E> {
  284|      0|        let source = self.asObservable()
  285|      0|            .map { $0.asSharedSequence() }
  286|      0|            .merge(maxConcurrent: maxConcurrent)
  287|      0|        return SharedSequence<SharingStrategy, E.E>(source)
  288|      0|    }
  289|       |}
  290|       |
  291|       |// MARK: throttle
  292|       |extension SharedSequenceConvertibleType {
  293|       |    
  294|       |    /**
  295|       |     Returns an Observable that emits the first and the latest item emitted by the source Observable during sequential time windows of a specified duration.
  296|       |
  297|       |     This operator makes sure that no two elements are emitted in less then dueTime.
  298|       |
  299|       |     - seealso: [debounce operator on reactivex.io](http://reactivex.io/documentation/operators/debounce.html)
  300|       |
  301|       |     - parameter dueTime: Throttling duration for each element.
  302|       |     - parameter latest: Should latest element received in a dueTime wide time window since last element emission be emitted.
  303|       |     - returns: The throttled sequence.
  304|       |    */
  305|       |    public func throttle(_ dueTime: RxTimeInterval, latest: Bool = true)
  306|      0|        -> SharedSequence<SharingStrategy, E> {
  307|      0|        let source = self.asObservable()
  308|      0|            .throttle(dueTime, latest: latest, scheduler: SharingStrategy.scheduler)
  309|      0|
  310|      0|        return SharedSequence(source)
  311|      0|    }
  312|       |
  313|       |    /**
  314|       |    Ignores elements from an observable sequence which are followed by another element within a specified relative time duration, using the specified scheduler to run throttling timers.
  315|       |    
  316|       |    - parameter dueTime: Throttling duration for each element.
  317|       |    - returns: The throttled sequence.
  318|       |    */
  319|       |    public func debounce(_ dueTime: RxTimeInterval)
  320|      0|        -> SharedSequence<SharingStrategy, E> {
  321|      0|        let source = self.asObservable()
  322|      0|            .debounce(dueTime, scheduler: SharingStrategy.scheduler)
  323|      0|
  324|      0|        return SharedSequence(source)
  325|      0|    }
  326|       |}
  327|       |
  328|       |// MARK: scan
  329|       |extension SharedSequenceConvertibleType {
  330|       |    /**
  331|       |    Applies an accumulator function over an observable sequence and returns each intermediate result. The specified seed value is used as the initial accumulator value.
  332|       |    
  333|       |    For aggregation behavior with no intermediate results, see `reduce`.
  334|       |    
  335|       |    - parameter seed: The initial accumulator value.
  336|       |    - parameter accumulator: An accumulator function to be invoked on each element.
  337|       |    - returns: An observable sequence containing the accumulated values.
  338|       |    */
  339|       |    public func scan<A>(_ seed: A, accumulator: @escaping (A, E) -> A)
  340|      0|        -> SharedSequence<SharingStrategy, A> {
  341|      0|        let source = self.asObservable()
  342|      0|            .scan(seed, accumulator: accumulator)
  343|      0|        return SharedSequence<SharingStrategy, A>(source)
  344|      0|    }
  345|       |}
  346|       |
  347|       |// MARK: concat
  348|       |
  349|       |extension SharedSequence {
  350|       |    /**
  351|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  352|       |
  353|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  354|       |     */
  355|       |    public static func concat<S: Sequence>(_ sequence: S) -> SharedSequence<SharingStrategy, Element>
  356|      0|        where S.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  357|      0|            let source = Observable.concat(sequence.lazy.map { $0.asObservable() })
  358|      0|            return SharedSequence<SharingStrategy, Element>(source)
  359|      0|    }
  360|       |
  361|       |    /**
  362|       |     Concatenates all observable sequences in the given sequence, as long as the previous observable sequence terminated successfully.
  363|       |
  364|       |     - returns: An observable sequence that contains the elements of each given sequence, in sequential order.
  365|       |     */
  366|       |    public static func concat<C: Collection>(_ collection: C) -> SharedSequence<SharingStrategy, Element>
  367|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  368|      0|        let source = Observable.concat(collection.map { $0.asObservable() })
  369|      0|        return SharedSequence<SharingStrategy, Element>(source)
  370|      0|    }
  371|       |}
  372|       |
  373|       |// MARK: zip
  374|       |
  375|       |extension SharedSequence {
  376|       |    /**
  377|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever all of the observable sequences have produced an element at a corresponding index.
  378|       |
  379|       |     - parameter resultSelector: Function to invoke for each series of elements at corresponding indexes in the sources.
  380|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  381|       |     */
  382|       |    public static func zip<C: Collection, R>(_ collection: C, _ resultSelector: @escaping ([Element]) throws -> R) -> SharedSequence<SharingStrategy, R>
  383|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  384|      0|        let source = Observable.zip(collection.map { $0.asSharedSequence().asObservable() }, resultSelector)
  385|      0|        return SharedSequence<SharingStrategy, R>(source)
  386|      0|    }
  387|       |}
  388|       |
  389|       |// MARK: combineLatest
  390|       |
  391|       |extension SharedSequence {
  392|       |    /**
  393|       |     Merges the specified observable sequences into one observable sequence by using the selector function whenever any of the observable sequences produces an element.
  394|       |
  395|       |     - parameter resultSelector: Function to invoke whenever any of the sources produces an element.
  396|       |     - returns: An observable sequence containing the result of combining elements of the sources using the specified result selector function.
  397|       |     */
  398|       |    public static func combineLatest<C: Collection, R>(_ collection: C, _ resultSelector: @escaping ([Element]) throws -> R) -> SharedSequence<SharingStrategy, R>
  399|      0|        where C.Iterator.Element == SharedSequence<SharingStrategy, Element> {
  400|      0|        let source = Observable.combineLatest(collection.map { $0.asObservable() }, resultSelector)
  401|      0|        return SharedSequence<SharingStrategy, R>(source)
  402|      0|    }
  403|       |}
  404|       |
  405|       |// MARK: withLatestFrom
  406|       |extension SharedSequenceConvertibleType {
  407|       |
  408|       |    /**
  409|       |    Merges two observable sequences into one observable sequence by combining each element from self with the latest element from the second source, if any.
  410|       |
  411|       |    - parameter second: Second observable source.
  412|       |    - parameter resultSelector: Function to invoke for each element from the self combined with the latest element from the second source, if any.
  413|       |    - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
  414|       |    */
  415|      0|    public func withLatestFrom<SecondO: SharedSequenceConvertibleType, ResultType>(_ second: SecondO, resultSelector: @escaping (E, SecondO.E) -> ResultType) -> SharedSequence<SharingStrategy, ResultType> where SecondO.SharingStrategy == SecondO.SharingStrategy {
  416|      0|        let source = self.asObservable()
  417|      0|            .withLatestFrom(second.asSharedSequence(), resultSelector: resultSelector)
  418|      0|
  419|      0|        return SharedSequence<SharingStrategy, ResultType>(source)
  420|      0|    }
  421|       |
  422|       |    /**
  423|       |    Merges two observable sequences into one observable sequence by using latest element from the second sequence every time when `self` emitts an element.
  424|       |
  425|       |    - parameter second: Second observable source.
  426|       |    - returns: An observable sequence containing the result of combining each element of the self  with the latest element from the second source, if any, using the specified result selector function.
  427|       |    */
  428|      0|    public func withLatestFrom<SecondO: SharedSequenceConvertibleType>(_ second: SecondO) -> SharedSequence<SharingStrategy, SecondO.E> {
  429|      0|        let source = self.asObservable()
  430|      0|            .withLatestFrom(second.asSharedSequence())
  431|      0|
  432|      0|        return SharedSequence<SharingStrategy, SecondO.E>(source)
  433|      0|    }
  434|       |}
  435|       |
  436|       |// MARK: skip
  437|       |extension SharedSequenceConvertibleType {
  438|       |
  439|       |    /**
  440|       |     Bypasses a specified number of elements in an observable sequence and then returns the remaining elements.
  441|       |
  442|       |     - seealso: [skip operator on reactivex.io](http://reactivex.io/documentation/operators/skip.html)
  443|       |
  444|       |     - parameter count: The number of elements to skip before returning the remaining elements.
  445|       |     - returns: An observable sequence that contains the elements that occur after the specified index in the input sequence.
  446|       |     */
  447|       |    public func skip(_ count: Int)
  448|      7|        -> SharedSequence<SharingStrategy, E> {
  449|      7|        let source = self.asObservable()
  450|      7|            .skip(count)
  451|      7|        return SharedSequence(source)
  452|      7|    }
  453|       |}
  454|       |
  455|       |// MARK: startWith
  456|       |extension SharedSequenceConvertibleType {
  457|       |    
  458|       |    /**
  459|       |    Prepends a value to an observable sequence.
  460|       |
  461|       |    - seealso: [startWith operator on reactivex.io](http://reactivex.io/documentation/operators/startwith.html)
  462|       |    
  463|       |    - parameter element: Element to prepend to the specified sequence.
  464|       |    - returns: The source sequence prepended with the specified values.
  465|       |    */
  466|       |    public func startWith(_ element: E)
  467|      0|        -> SharedSequence<SharingStrategy, E> {
  468|      0|        let source = self.asObservable()
  469|      0|                .startWith(element)
  470|      0|
  471|      0|        return SharedSequence(source)
  472|      0|    }
  473|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/SharedSequence.swift:
    1|       |//
    2|       |//  SharedSequence.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 8/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |/**
   14|       |    Trait that represents observable sequence that shares computation resources with following properties:
   15|       |
   16|       |    - it never fails
   17|       |    - it delivers events on `SharingStrategy.scheduler`
   18|       |    - sharing strategy is customizable using `SharingStrategy.share` behavior
   19|       |
   20|       |    `SharedSequence<Element>` can be considered a builder pattern for observable sequences that share computation resources.
   21|       |
   22|       |    To find out more about units and how to use them, please visit `Documentation/Traits.md`.
   23|       |*/
   24|       |public struct SharedSequence<S: SharingStrategyProtocol, Element> : SharedSequenceConvertibleType {
   25|       |    public typealias E = Element
   26|       |    public typealias SharingStrategy = S
   27|       |
   28|       |    let _source: Observable<E>
   29|       |
   30|     31|    init(_ source: Observable<E>) {
   31|     31|        self._source = S.share(source)
   32|     31|    }
   33|       |
   34|      0|    init(raw: Observable<E>) {
   35|      0|        self._source = raw
   36|      0|    }
   37|       |
   38|       |    #if EXPANDABLE_SHARED_SEQUENCE
   39|       |    /**
   40|       |     This method is extension hook in case this unit needs to extended from outside the library.
   41|       |     
   42|       |     By defining `EXPANDABLE_SHARED_SEQUENCE` one agrees that it's up to him to ensure shared sequence
   43|       |     properties are preserved after extension.
   44|       |    */
   45|       |    public static func createUnsafe<O: ObservableType>(source: O) -> SharedSequence<S, O.E> {
   46|       |        return SharedSequence<S, O.E>(raw: source.asObservable())
   47|       |    }
   48|       |    #endif
   49|       |
   50|       |    /**
   51|       |    - returns: Built observable sequence.
   52|       |    */
   53|     26|    public func asObservable() -> Observable<E> {
   54|     26|        return _source
   55|     26|    }
   56|       |
   57|       |    /**
   58|       |    - returns: `self`
   59|       |    */
   60|      0|    public func asSharedSequence() -> SharedSequence<SharingStrategy, E> {
   61|      0|        return self
   62|      0|    }
   63|       |}
   64|       |
   65|       |/**
   66|       | Different `SharedSequence` sharing strategies must conform to this protocol.
   67|       | */
   68|       |public protocol SharingStrategyProtocol {
   69|       |    /**
   70|       |     Scheduled on which all sequence events will be delivered.
   71|       |    */
   72|       |    static var scheduler: SchedulerType { get }
   73|       |
   74|       |    /**
   75|       |     Computation resources sharing strategy for multiple sequence observers.
   76|       |     
   77|       |     E.g. One can choose `shareReplayWhenConnected`, `shareReplay` or `share`
   78|       |     as sequence event sharing strategies, but also do something more exotic, like
   79|       |     implementing promises or lazy loading chains.
   80|       |    */
   81|       |    static func share<E>(_ source: Observable<E>) -> Observable<E>
   82|       |}
   83|       |
   84|       |/**
   85|       |A type that can be converted to `SharedSequence`.
   86|       |*/
   87|       |public protocol SharedSequenceConvertibleType : ObservableConvertibleType {
   88|       |    associatedtype SharingStrategy: SharingStrategyProtocol
   89|       |
   90|       |    /**
   91|       |    Converts self to `SharedSequence`.
   92|       |    */
   93|       |    func asSharedSequence() -> SharedSequence<SharingStrategy, E>
   94|       |}
   95|       |
   96|       |extension SharedSequenceConvertibleType {
   97|      0|    public func asObservable() -> Observable<E> {
   98|      0|        return asSharedSequence().asObservable()
   99|      0|    }
  100|       |}
  101|       |
  102|       |
  103|       |extension SharedSequence {
  104|       |
  105|       |    /**
  106|       |    Returns an empty observable sequence, using the specified scheduler to send out the single `Completed` message.
  107|       |
  108|       |    - returns: An observable sequence with no elements.
  109|       |    */
  110|      0|    public static func empty() -> SharedSequence<S, E> {
  111|      0|        return SharedSequence(raw: Observable.empty().subscribeOn(S.scheduler))
  112|      0|    }
  113|       |
  114|       |    /**
  115|       |    Returns a non-terminating observable sequence, which can be used to denote an infinite duration.
  116|       |
  117|       |    - returns: An observable sequence whose observers will never get called.
  118|       |    */
  119|      0|    public static func never() -> SharedSequence<S, E> {
  120|      0|        return SharedSequence(raw: Observable.never())
  121|      0|    }
  122|       |
  123|       |    /**
  124|       |    Returns an observable sequence that contains a single element.
  125|       |
  126|       |    - parameter element: Single element in the resulting observable sequence.
  127|       |    - returns: An observable sequence containing the single specified element.
  128|       |    */
  129|      0|    public static func just(_ element: E) -> SharedSequence<S, E> {
  130|      0|        return SharedSequence(raw: Observable.just(element).subscribeOn(S.scheduler))
  131|      0|    }
  132|       |
  133|       |    /**
  134|       |     Returns an observable sequence that invokes the specified factory function whenever a new observer subscribes.
  135|       |
  136|       |     - parameter observableFactory: Observable factory function to invoke for each observer that subscribes to the resulting sequence.
  137|       |     - returns: An observable sequence whose observers trigger an invocation of the given observable factory function.
  138|       |     */
  139|       |    public static func deferred(_ observableFactory: @escaping () -> SharedSequence<S, E>)
  140|      0|        -> SharedSequence<S, E> {
  141|      0|        return SharedSequence(Observable.deferred { observableFactory().asObservable() })
  142|      0|    }
  143|       |
  144|       |    /**
  145|       |    This method creates a new Observable instance with a variable number of elements.
  146|       |
  147|       |    - seealso: [from operator on reactivex.io](http://reactivex.io/documentation/operators/from.html)
  148|       |
  149|       |    - parameter elements: Elements to generate.
  150|       |    - returns: The observable sequence whose elements are pulled from the given arguments.
  151|       |    */
  152|      0|    public static func of(_ elements: E ...) -> SharedSequence<S, E> {
  153|      0|        let source = Observable.from(elements, scheduler: S.scheduler)
  154|      0|        return SharedSequence(raw: source)
  155|      0|    }
  156|       |}
  157|       |
  158|       |extension SharedSequence where Element : SignedInteger {
  159|       |    /**
  160|       |     Returns an observable sequence that produces a value after each period, using the specified scheduler to run timers and to send out observer messages.
  161|       |
  162|       |     - seealso: [interval operator on reactivex.io](http://reactivex.io/documentation/operators/interval.html)
  163|       |
  164|       |     - parameter period: Period for producing the values in the resulting sequence.
  165|       |     - returns: An observable sequence that produces a value after each period.
  166|       |     */
  167|       |    public static func interval(_ period: RxTimeInterval)
  168|      0|        -> SharedSequence<S, E> {
  169|      0|        return SharedSequence(Observable.interval(period, scheduler: S.scheduler))
  170|      0|    }
  171|       |}
  172|       |
  173|       |// MARK: timer
  174|       |
  175|       |extension SharedSequence where Element: SignedInteger {
  176|       |    /**
  177|       |     Returns an observable sequence that periodically produces a value after the specified initial relative due time has elapsed, using the specified scheduler to run timers.
  178|       |
  179|       |     - seealso: [timer operator on reactivex.io](http://reactivex.io/documentation/operators/timer.html)
  180|       |
  181|       |     - parameter dueTime: Relative time at which to produce the first value.
  182|       |     - parameter period: Period to produce subsequent values.
  183|       |     - returns: An observable sequence that produces a value after due time has elapsed and then each period.
  184|       |     */
  185|       |    public static func timer(_ dueTime: RxTimeInterval, period: RxTimeInterval)
  186|      0|        -> SharedSequence<S, E> {
  187|      0|        return SharedSequence(Observable.timer(dueTime, period: period, scheduler: S.scheduler))
  188|      0|    }
  189|       |}
  190|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/SharedSequence/Variable+SharedSequence.swift:
    1|       |//
    2|       |//  Variable+SharedSequence.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |extension Variable {
   14|       |    /// Converts `Variable` to `SharedSequence` unit.
   15|       |    ///
   16|       |    /// - returns: Observable sequence.
   17|      0|    public func asSharedSequence<SharingStrategy: SharingStrategyProtocol>(strategy: SharingStrategy.Type = SharingStrategy.self) -> SharedSequence<SharingStrategy, E> {
   18|      0|        let source = self.asObservable()
   19|      0|            .observeOn(SharingStrategy.scheduler)
   20|      0|        return SharedSequence(source)
   21|      0|    }
   22|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/Traits/UIBindingObserver.swift:
    1|       |//
    2|       |//  UIBindingObserver.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/7/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |#if !RX_NO_MODULE
   11|       |    import RxSwift
   12|       |#endif
   13|       |
   14|       |/**
   15|       |Observer that enforces interface binding rules:
   16|       | * can't bind errors (in debug builds binding of errors causes `fatalError` in release builds errors are being logged)
   17|       | * ensures binding is performed on main thread
   18|       | 
   19|       |`UIBindingObserver` doesn't retain target interface and in case owned interface element is released, element isn't bound.
   20|       | 
   21|       | In case event binding is attempted from non main dispatch queue, event binding will be dispatched async to main dispatch
   22|       | queue.
   23|       |*/
   24|       |public final class UIBindingObserver<UIElementType, Value> : ObserverType where UIElementType: AnyObject {
   25|       |    public typealias E = Value
   26|       |
   27|       |    weak var UIElement: UIElementType?
   28|       |
   29|       |    let binding: (UIElementType, Value) -> Void
   30|       |
   31|       |    /// Initializes `ViewBindingObserver` using
   32|    226|    public init(UIElement: UIElementType, binding: @escaping (UIElementType, Value) -> Void) {
   33|    226|        self.UIElement = UIElement
   34|    226|        self.binding = binding
   35|    226|    }
   36|       |
   37|       |    /// Binds next element to owner view as described in `binding`.
   38|     79|    public func on(_ event: Event<Value>) {
   39|      0|        if !DispatchQueue.isMain {
   40|      0|            DispatchQueue.main.async {
   41|      0|                self.on(event)
   42|      0|            }
   43|      0|            return
   44|     79|        }
   45|     79|
   46|     79|        switch event {
   47|     79|        case .next(let element):
   48|     79|            if let view = self.UIElement {
   49|     79|                binding(view, element)
   50|     79|            }
   51|      0|        case .error(let error):
   52|      0|            bindingErrorToInterface(error)
   53|      0|        case .completed:
   54|      0|            break
   55|     79|        }
   56|     79|    }
   57|       |
   58|       |    /// Erases type of observer.
   59|       |    ///
   60|       |    /// - returns: type erased observer.
   61|      0|    public func asObserver() -> AnyObserver<Value> {
   62|      0|        return AnyObserver(eventHandler: on)
   63|      0|    }
   64|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/DataSources/RxCollectionViewReactiveArrayDataSource.swift:
    1|       |//
    2|       |//  RxCollectionViewReactiveArrayDataSource.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |// objc monkey business
   17|       |class _RxCollectionViewReactiveArrayDataSource
   18|       |    : NSObject
   19|       |    , UICollectionViewDataSource {
   20|       |    
   21|       |    @objc(numberOfSectionsInCollectionView:)
   22|      0|    func numberOfSections(in: UICollectionView) -> Int {
   23|      0|        return 1
   24|      0|    }
   25|       |
   26|      0|    func _collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   27|      0|        return 0
   28|      0|    }
   29|       |    
   30|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   31|      0|        return _collectionView(collectionView, numberOfItemsInSection: section)
   32|      0|    }
   33|       |
   34|      0|    fileprivate func _collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   35|      0|        rxAbstractMethod()
   36|      0|    }
   37|       |
   38|      0|    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   39|      0|        return _collectionView(collectionView, cellForItemAt: indexPath)
   40|      0|    }
   41|       |}
   42|       |
   43|       |class RxCollectionViewReactiveArrayDataSourceSequenceWrapper<S: Sequence>
   44|       |    : RxCollectionViewReactiveArrayDataSource<S.Iterator.Element>
   45|       |    , RxCollectionViewDataSourceType {
   46|       |    typealias Element = S
   47|       |
   48|      0|    override init(cellFactory: @escaping CellFactory) {
   49|      0|        super.init(cellFactory: cellFactory)
   50|      0|    }
   51|       |    
   52|      0|    func collectionView(_ collectionView: UICollectionView, observedEvent: Event<S>) {
   53|      0|        UIBindingObserver(UIElement: self) { collectionViewDataSource, sectionModels in
   54|      0|            let sections = Array(sectionModels)
   55|      0|            collectionViewDataSource.collectionView(collectionView, observedElements: sections)
   56|      0|        }.on(observedEvent)
   57|      0|    }
   58|       |}
   59|       |
   60|       |
   61|       |// Please take a look at `DelegateProxyType.swift`
   62|       |class RxCollectionViewReactiveArrayDataSource<Element>
   63|       |    : _RxCollectionViewReactiveArrayDataSource
   64|       |    , SectionedViewDataSourceType {
   65|       |    
   66|       |    typealias CellFactory = (UICollectionView, Int, Element) -> UICollectionViewCell
   67|       |    
   68|       |    var itemModels: [Element]? = nil
   69|       |    
   70|      0|    func modelAtIndex(_ index: Int) -> Element? {
   71|      0|        return itemModels?[index]
   72|      0|    }
   73|       |
   74|      0|    func model(at indexPath: IndexPath) throws -> Any {
   75|      0|        precondition(indexPath.section == 0)
   76|      0|        guard let item = itemModels?[indexPath.item] else {
   77|      0|            throw RxCocoaError.itemsNotYetBound(object: self)
   78|      0|        }
   79|      0|        return item
   80|      0|    }
   81|       |    
   82|       |    var cellFactory: CellFactory
   83|       |    
   84|      0|    init(cellFactory: @escaping CellFactory) {
   85|      0|        self.cellFactory = cellFactory
   86|      0|    }
   87|       |    
   88|       |    // data source
   89|       |    
   90|      0|    override func _collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   91|      0|        return itemModels?.count ?? 0
   92|      0|    }
   93|       |    
   94|      0|    override func _collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   95|      0|        return cellFactory(collectionView, indexPath.item, itemModels![indexPath.item])
   96|      0|    }
   97|       |    
   98|       |    // reactive
   99|       |    
  100|      0|    func collectionView(_ collectionView: UICollectionView, observedElements: [Element]) {
  101|      0|        self.itemModels = observedElements
  102|      0|        
  103|      0|        collectionView.reloadData()
  104|      0|
  105|      0|        // workaround for http://stackoverflow.com/questions/39867325/ios-10-bug-uicollectionview-received-layout-attributes-for-a-cell-with-an-index
  106|      0|        collectionView.collectionViewLayout.invalidateLayout()
  107|      0|    }
  108|       |}
  109|       |
  110|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/DataSources/RxTableViewReactiveArrayDataSource.swift:
    1|       |//
    2|       |//  RxTableViewReactiveArrayDataSource.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/26/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |// objc monkey business
   17|       |class _RxTableViewReactiveArrayDataSource
   18|       |    : NSObject
   19|       |    , UITableViewDataSource {
   20|       |    
   21|      0|    func numberOfSections(in tableView: UITableView) -> Int {
   22|      0|        return 1
   23|      0|    }
   24|       |   
   25|      0|    func _tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   26|      0|        return 0
   27|      0|    }
   28|       |    
   29|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   30|      0|        return _tableView(tableView, numberOfRowsInSection: section)
   31|      0|    }
   32|       |
   33|      0|    fileprivate func _tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   34|      0|        rxAbstractMethod()
   35|      0|    }
   36|       |
   37|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   38|      0|        return _tableView(tableView, cellForRowAt: indexPath)
   39|      0|    }
   40|       |}
   41|       |
   42|       |
   43|       |class RxTableViewReactiveArrayDataSourceSequenceWrapper<S: Sequence>
   44|       |    : RxTableViewReactiveArrayDataSource<S.Iterator.Element>
   45|       |    , RxTableViewDataSourceType {
   46|       |    typealias Element = S
   47|       |
   48|      0|    override init(cellFactory: @escaping CellFactory) {
   49|      0|        super.init(cellFactory: cellFactory)
   50|      0|    }
   51|       |
   52|      0|    func tableView(_ tableView: UITableView, observedEvent: Event<S>) {
   53|      0|        UIBindingObserver(UIElement: self) { tableViewDataSource, sectionModels in
   54|      0|            let sections = Array(sectionModels)
   55|      0|            tableViewDataSource.tableView(tableView, observedElements: sections)
   56|      0|        }.on(observedEvent)
   57|      0|    }
   58|       |}
   59|       |
   60|       |// Please take a look at `DelegateProxyType.swift`
   61|       |class RxTableViewReactiveArrayDataSource<Element>
   62|       |    : _RxTableViewReactiveArrayDataSource
   63|       |    , SectionedViewDataSourceType {
   64|       |    typealias CellFactory = (UITableView, Int, Element) -> UITableViewCell
   65|       |    
   66|       |    var itemModels: [Element]? = nil
   67|       |    
   68|      0|    func modelAtIndex(_ index: Int) -> Element? {
   69|      0|        return itemModels?[index]
   70|      0|    }
   71|       |
   72|      0|    func model(at indexPath: IndexPath) throws -> Any {
   73|      0|        precondition(indexPath.section == 0)
   74|      0|        guard let item = itemModels?[indexPath.item] else {
   75|      0|            throw RxCocoaError.itemsNotYetBound(object: self)
   76|      0|        }
   77|      0|        return item
   78|      0|    }
   79|       |
   80|       |    let cellFactory: CellFactory
   81|       |    
   82|      0|    init(cellFactory: @escaping CellFactory) {
   83|      0|        self.cellFactory = cellFactory
   84|      0|    }
   85|       |    
   86|      0|    override func _tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   87|      0|        return itemModels?.count ?? 0
   88|      0|    }
   89|       |    
   90|      0|    override func _tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   91|      0|        return cellFactory(tableView, indexPath.item, itemModels![indexPath.row])
   92|      0|    }
   93|       |    
   94|       |    // reactive
   95|       |    
   96|      0|    func tableView(_ tableView: UITableView, observedElements: [Element]) {
   97|      0|        self.itemModels = observedElements
   98|      0|        
   99|      0|        tableView.reloadData()
  100|      0|    }
  101|       |}
  102|       |
  103|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/NSTextStorage+Rx.swift:
    1|       |//
    2|       |//  NSTextStorage+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 12/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |#if !RX_NO_MODULE
   11|       |    import RxSwift
   12|       |#endif
   13|       |    import UIKit
   14|       |
   15|       |    extension NSTextStorage {
   16|       |        /// Factory method that enables subclasses to implement their own `delegate`.
   17|       |        ///
   18|       |        /// - returns: Instance of delegate proxy that wraps `delegate`.
   19|      0|        public func createRxDelegateProxy() -> RxTextStorageDelegateProxy {
   20|      0|            return RxTextStorageDelegateProxy(parentObject: self)
   21|      0|        }
   22|       |    }
   23|       |    
   24|       |    extension Reactive where Base: NSTextStorage {
   25|       |
   26|       |        /// Reactive wrapper for `delegate`.
   27|       |        ///
   28|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   29|      0|        public var delegate: DelegateProxy {
   30|      0|            return RxTextStorageDelegateProxy.proxyForObject(base)
   31|      0|        }
   32|       |
   33|       |        /// Reactive wrapper for `delegate` message.
   34|      0|        public var didProcessEditingRangeChangeInLength: Observable<(editedMask:NSTextStorageEditActions, editedRange:NSRange, delta:Int)> {
   35|      0|            return delegate
   36|      0|                .methodInvoked(#selector(NSTextStorageDelegate.textStorage(_:didProcessEditing:range:changeInLength:)))
   37|      0|                .map { a in
   38|      0|                    let editedMask = NSTextStorageEditActions(rawValue: try castOrThrow(UInt.self, a[1]) )
   39|      0|                    let editedRange = try castOrThrow(NSValue.self, a[2]).rangeValue
   40|      0|                    let delta = try castOrThrow(Int.self, a[3])
   41|      0|                    
   42|      0|                    return (editedMask, editedRange, delta)
   43|      0|                }
   44|      0|        }
   45|       |    }
   46|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxCollectionViewDataSourceProxy.swift:
    1|       |//
    2|       |//  RxCollectionViewDataSourceProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |let collectionViewDataSourceNotSet = CollectionViewDataSourceNotSet()
   17|       |
   18|       |final class CollectionViewDataSourceNotSet
   19|       |    : NSObject
   20|       |    , UICollectionViewDataSource {
   21|       |
   22|       |
   23|      0|    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   24|      0|        return 0
   25|      0|    }
   26|       |    
   27|       |    // The cell that is returned must be retrieved from a call to -dequeueReusableCellWithReuseIdentifier:forIndexPath:
   28|      0|    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   29|      0|        rxAbstractMethod(message: dataSourceNotSet)
   30|      0|    }
   31|       |    
   32|       |}
   33|       |
   34|       |/// For more information take a look at `DelegateProxyType`.
   35|       |public class RxCollectionViewDataSourceProxy
   36|       |    : DelegateProxy
   37|       |    , UICollectionViewDataSource
   38|       |    , DelegateProxyType {
   39|       |
   40|       |    /// Typed parent object.
   41|       |    public weak private(set) var collectionView: UICollectionView?
   42|       |
   43|       |    private weak var _requiredMethodsDataSource: UICollectionViewDataSource? = collectionViewDataSourceNotSet
   44|       |
   45|       |    /// Initializes `RxCollectionViewDataSourceProxy`
   46|       |    ///
   47|       |    /// - parameter parentObject: Parent object for delegate proxy.
   48|      0|    public required init(parentObject: AnyObject) {
   49|      0|        self.collectionView = castOrFatalError(parentObject)
   50|      0|        super.init(parentObject: parentObject)
   51|      0|    }
   52|       |    
   53|       |    // MARK: delegate
   54|       |
   55|       |    /// Required delegate method implementation.
   56|      0|    public func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
   57|      0|        return (_requiredMethodsDataSource ?? collectionViewDataSourceNotSet).collectionView(collectionView, numberOfItemsInSection: section)
   58|      0|    }
   59|       |    
   60|       |    /// Required delegate method implementation.
   61|      0|    public func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
   62|      0|        return (_requiredMethodsDataSource ?? collectionViewDataSourceNotSet).collectionView(collectionView, cellForItemAt: indexPath)
   63|      0|    }
   64|       |    
   65|       |    // MARK: proxy
   66|       |
   67|       |    /// For more information take a look at `DelegateProxyType`.
   68|      0|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   69|      0|        let collectionView: UICollectionView = castOrFatalError(object)
   70|      0|        return collectionView.createRxDataSourceProxy()
   71|      0|    }
   72|       |
   73|       |    /// For more information take a look at `DelegateProxyType`.
   74|      0|    public override class func delegateAssociatedObjectTag() -> UnsafeRawPointer {
   75|      0|        return dataSourceAssociatedTag
   76|      0|    }
   77|       |
   78|       |    /// For more information take a look at `DelegateProxyType`.
   79|      0|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   80|      0|        let collectionView: UICollectionView = castOrFatalError(object)
   81|      0|        collectionView.dataSource = castOptionalOrFatalError(delegate)
   82|      0|    }
   83|       |
   84|       |    /// For more information take a look at `DelegateProxyType`.
   85|      0|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   86|      0|        let collectionView: UICollectionView = castOrFatalError(object)
   87|      0|        return collectionView.dataSource
   88|      0|    }
   89|       |
   90|       |    /// For more information take a look at `DelegateProxyType`.
   91|      0|    public override func setForwardToDelegate(_ forwardToDelegate: AnyObject?, retainDelegate: Bool) {
   92|      0|        let requiredMethodsDataSource: UICollectionViewDataSource? = castOptionalOrFatalError(forwardToDelegate)
   93|      0|        _requiredMethodsDataSource = requiredMethodsDataSource ?? collectionViewDataSourceNotSet
   94|      0|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   95|      0|    }
   96|       |}
   97|       |
   98|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxCollectionViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxCollectionViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxCollectionViewDelegateProxy
   18|       |    : RxScrollViewDelegateProxy
   19|       |    , UICollectionViewDelegate
   20|       |    , UICollectionViewDelegateFlowLayout {
   21|       |
   22|       |    /// Typed parent object.
   23|       |    public weak private(set) var collectionView: UICollectionView?
   24|       |
   25|       |    /// Initializes `RxCollectionViewDelegateProxy`
   26|       |    ///
   27|       |    /// - parameter parentObject: Parent object for delegate proxy.
   28|      0|    public required init(parentObject: AnyObject) {
   29|      0|        self.collectionView = castOrFatalError(parentObject)
   30|      0|        super.init(parentObject: parentObject)
   31|      0|    }
   32|       |}
   33|       |
   34|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxPickerViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxPickerViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 5/12/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |    import RxSwift
   13|       |#endif
   14|       |    import UIKit
   15|       |
   16|       |    public class RxPickerViewDelegateProxy
   17|       |        : DelegateProxy
   18|       |        , DelegateProxyType
   19|       |        , UIPickerViewDelegate {
   20|       |
   21|       |        /// For more information take a look at `DelegateProxyType`.
   22|      0|        public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   23|      0|            let pickerView: UIPickerView = castOrFatalError(object)
   24|      0|            return pickerView.createRxDelegateProxy()
   25|      0|        }
   26|       |        
   27|       |        /// For more information take a look at `DelegateProxyType`.
   28|      0|        public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   29|      0|            let pickerView: UIPickerView = castOrFatalError(object)
   30|      0|            pickerView.delegate = castOptionalOrFatalError(delegate)
   31|      0|        }
   32|       |        
   33|       |        /// For more information take a look at `DelegateProxyType`.
   34|      0|        public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   35|      0|            let pickerView: UIPickerView = castOrFatalError(object)
   36|      0|            return pickerView.delegate
   37|      0|        }
   38|       |    }
   39|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxScrollViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxScrollViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxScrollViewDelegateProxy
   18|       |    : DelegateProxy
   19|       |    , UIScrollViewDelegate
   20|       |    , DelegateProxyType {
   21|       |
   22|       |    fileprivate var _contentOffsetBehaviorSubject: BehaviorSubject<CGPoint>?
   23|       |    fileprivate var _contentOffsetPublishSubject: PublishSubject<()>?
   24|       |
   25|       |    /// Typed parent object.
   26|       |    public weak fileprivate(set) var scrollView: UIScrollView?
   27|       |
   28|       |    /// Optimized version used for observing content offset changes.
   29|      0|    internal var contentOffsetBehaviorSubject: BehaviorSubject<CGPoint> {
   30|      0|        if let subject = _contentOffsetBehaviorSubject {
   31|      0|            return subject
   32|      0|        }
   33|      0|
   34|      0|        let subject = BehaviorSubject<CGPoint>(value: self.scrollView?.contentOffset ?? CGPoint.zero)
   35|      0|        _contentOffsetBehaviorSubject = subject
   36|      0|
   37|      0|        return subject
   38|      0|    }
   39|       |
   40|       |    /// Optimized version used for observing content offset changes.
   41|      0|    internal var contentOffsetPublishSubject: PublishSubject<()> {
   42|      0|        if let subject = _contentOffsetPublishSubject {
   43|      0|            return subject
   44|      0|        }
   45|      0|
   46|      0|        let subject = PublishSubject<()>()
   47|      0|        _contentOffsetPublishSubject = subject
   48|      0|
   49|      0|        return subject
   50|      0|    }
   51|       |
   52|       |    /// Initializes `RxScrollViewDelegateProxy`
   53|       |    ///
   54|       |    /// - parameter parentObject: Parent object for delegate proxy.
   55|     38|    public required init(parentObject: AnyObject) {
   56|     38|        self.scrollView = castOrFatalError(parentObject)
   57|     38|        super.init(parentObject: parentObject)
   58|     38|    }
   59|       |    
   60|       |    // MARK: delegate methods
   61|       |
   62|       |    /// For more information take a look at `DelegateProxyType`.
   63|      0|    public func scrollViewDidScroll(_ scrollView: UIScrollView) {
   64|      0|        if let subject = _contentOffsetBehaviorSubject {
   65|      0|            subject.on(.next(scrollView.contentOffset))
   66|      0|        }
   67|      0|        if let subject = _contentOffsetPublishSubject {
   68|      0|            subject.on(.next())
   69|      0|        }
   70|      0|        self._forwardToDelegate?.scrollViewDidScroll?(scrollView)
   71|      0|    }
   72|       |    
   73|       |    // MARK: delegate proxy
   74|       |
   75|       |    /// For more information take a look at `DelegateProxyType`.
   76|     38|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   77|     38|        let scrollView: UIScrollView = castOrFatalError(object)
   78|     38|        return scrollView.createRxDelegateProxy()
   79|     38|    }
   80|       |
   81|       |    /// For more information take a look at `DelegateProxyType`.
   82|    122|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   83|    122|        let scrollView: UIScrollView = castOrFatalError(object)
   84|    122|        scrollView.delegate = castOptionalOrFatalError(delegate)
   85|    122|    }
   86|       |
   87|       |    /// For more information take a look at `DelegateProxyType`.
   88|    164|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   89|    164|        let scrollView: UIScrollView = castOrFatalError(object)
   90|    164|        return scrollView.delegate
   91|    164|    }
   92|       |    
   93|      0|    deinit {
   94|      0|        if let subject = _contentOffsetBehaviorSubject {
   95|      0|            subject.on(.completed)
   96|      0|        }
   97|      0|
   98|      0|        if let subject = _contentOffsetPublishSubject {
   99|      0|            subject.on(.completed)
  100|      0|        }
  101|      0|    }
  102|       |}
  103|       |
  104|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxSearchBarDelegateProxy.swift:
    1|       |//
    2|       |//  RxSearchBarDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/4/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxSearchBarDelegateProxy
   18|       |    : DelegateProxy
   19|       |    , UISearchBarDelegate
   20|       |    , DelegateProxyType {
   21|       |
   22|       |    /// For more information take a look at `DelegateProxyType`.
   23|      0|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   24|      0|        let searchBar: UISearchBar = castOrFatalError(object)
   25|      0|        return searchBar.delegate
   26|      0|    }
   27|       |
   28|       |    /// For more information take a look at `DelegateProxyType`.
   29|      0|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   30|      0|        let searchBar: UISearchBar = castOrFatalError(object)
   31|      0|        searchBar.delegate = castOptionalOrFatalError(delegate)
   32|      0|    }
   33|       |
   34|       |    // MARK: Delegate proxy methods
   35|       |    
   36|       |#if os(iOS)
   37|       |    /// For more information take a look at `DelegateProxyType`.
   38|      0|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   39|      0|        let searchBar: UISearchBar = castOrFatalError(object)
   40|      0|        return searchBar.createRxDelegateProxy()
   41|      0|    }
   42|       |#endif
   43|       |    
   44|       |}
   45|       |
   46|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxSearchControllerDelegateProxy.swift:
    1|       |//
    2|       |//  RxSearchControllerDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 3/17/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |   
   11|       |#if !RX_NO_MODULE
   12|       |   import RxSwift
   13|       |#endif
   14|       |   import UIKit
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |@available(iOS 8.0, *)
   18|       |public class RxSearchControllerDelegateProxy
   19|       |    : DelegateProxy
   20|       |    , DelegateProxyType
   21|       |    , UISearchControllerDelegate {
   22|       |
   23|       |    /// For more information take a look at `DelegateProxyType`.
   24|      0|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   25|      0|        let pickerView: UISearchController = castOrFatalError(object)
   26|      0|        return pickerView.createRxDelegateProxy()
   27|      0|    }
   28|       |    
   29|       |    /// For more information take a look at `DelegateProxyType`.
   30|      0|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   31|      0|        let searchController: UISearchController = castOrFatalError(object)
   32|      0|        searchController.delegate = castOptionalOrFatalError(delegate)
   33|      0|    }
   34|       |    
   35|       |    /// For more information take a look at `DelegateProxyType`.
   36|      0|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   37|      0|        let searchController: UISearchController = castOrFatalError(object)
   38|      0|        return searchController.delegate
   39|      0|    }
   40|       |    
   41|       |}
   42|       |   
   43|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTabBarControllerDelegateProxy.swift:
    1|       |//
    2|       |//  RxTabBarControllerDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yusuke Kita on 2016/12/07.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxTabBarControllerDelegateProxy
   18|       |    : DelegateProxy
   19|       |    , UITabBarControllerDelegate
   20|       |    , DelegateProxyType {
   21|       |    
   22|       |    /// For more information take a look at `DelegateProxyType`.
   23|      0|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   24|      0|        let tabBarController: UITabBarController = castOrFatalError(object)
   25|      0|        return tabBarController.delegate
   26|      0|    }
   27|       |    
   28|       |    /// For more information take a look at `DelegateProxyType`.
   29|      0|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   30|      0|        let tabBarController: UITabBarController = castOrFatalError(object)
   31|      0|        tabBarController.delegate = castOptionalOrFatalError(delegate)
   32|      0|    }
   33|       |    
   34|       |    /// For more information take a look at `DelegateProxyType`.
   35|      0|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   36|      0|        let tabBarController: UITabBarController = castOrFatalError(object)
   37|      0|        return tabBarController.createRxDelegateProxy()
   38|      0|    }
   39|       |}
   40|       |
   41|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTabBarDelegateProxy.swift:
    1|       |//
    2|       |//  RxTabBarDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Jesse Farless on 5/14/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxTabBarDelegateProxy
   18|       |    : DelegateProxy
   19|       |    , UITabBarDelegate
   20|       |    , DelegateProxyType {
   21|       |
   22|       |    /// For more information take a look at `DelegateProxyType`.
   23|      0|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   24|      0|        let tabBar: UITabBar = castOrFatalError(object)
   25|      0|        return tabBar.delegate
   26|      0|    }
   27|       |
   28|       |    /// For more information take a look at `DelegateProxyType`.
   29|      0|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   30|      0|        let tabBar: UITabBar = castOrFatalError(object)
   31|      0|        tabBar.delegate = castOptionalOrFatalError(delegate)
   32|      0|    }
   33|       |
   34|       |    /// For more information take a look at `DelegateProxyType`.
   35|      0|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   36|      0|        let tabBar: UITabBar = castOrFatalError(object)
   37|      0|        return tabBar.createRxDelegateProxy()
   38|      0|    }
   39|       |
   40|       |}
   41|       |
   42|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTableViewDataSourceProxy.swift:
    1|       |//
    2|       |//  RxTableViewDataSourceProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |let tableViewDataSourceNotSet = TableViewDataSourceNotSet()
   17|       |
   18|       |final class TableViewDataSourceNotSet
   19|       |    : NSObject
   20|       |    , UITableViewDataSource {
   21|       |
   22|      0|    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   23|      0|        return 0
   24|      0|    }
   25|       |    
   26|      0|    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   27|      0|        rxAbstractMethod(message: dataSourceNotSet)
   28|      0|    }
   29|       |}
   30|       |
   31|       |/// For more information take a look at `DelegateProxyType`.
   32|       |public class RxTableViewDataSourceProxy
   33|       |    : DelegateProxy
   34|       |    , UITableViewDataSource
   35|       |    , DelegateProxyType {
   36|       |
   37|       |    /// Typed parent object.
   38|       |    public weak fileprivate(set) var tableView: UITableView?
   39|       |
   40|       |    fileprivate weak var _requiredMethodsDataSource: UITableViewDataSource? = tableViewDataSourceNotSet
   41|       |
   42|       |    /// Initializes `RxTableViewDataSourceProxy`
   43|       |    ///
   44|       |    /// - parameter parentObject: Parent object for delegate proxy.
   45|      4|    public required init(parentObject: AnyObject) {
   46|      4|        self.tableView = castOrFatalError(parentObject)
   47|      4|        super.init(parentObject: parentObject)
   48|      4|    }
   49|       |
   50|       |    // MARK: delegate
   51|       |
   52|       |    /// Required delegate method implementation.
   53|    228|    public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
   54|      0|        return (_requiredMethodsDataSource ?? tableViewDataSourceNotSet).tableView(tableView, numberOfRowsInSection: section)
   55|    228|    }
   56|       |
   57|       |    /// Required delegate method implementation.
   58|      0|    public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
   59|      0|        return (_requiredMethodsDataSource ?? tableViewDataSourceNotSet).tableView(tableView, cellForRowAt: indexPath)
   60|      0|    }
   61|       |    
   62|       |    // MARK: proxy
   63|       |
   64|       |    /// For more information take a look at `DelegateProxyType`.
   65|      4|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   66|      4|        let tableView: UITableView = castOrFatalError(object)
   67|      4|        return tableView.createRxDataSourceProxy()
   68|      4|    }
   69|       |
   70|       |    /// For more information take a look at `DelegateProxyType`.
   71|     16|    public override class func delegateAssociatedObjectTag() -> UnsafeRawPointer {
   72|     16|        return dataSourceAssociatedTag
   73|     16|    }
   74|       |
   75|       |    /// For more information take a look at `DelegateProxyType`.
   76|     12|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   77|     12|        let tableView: UITableView = castOrFatalError(object)
   78|     12|        tableView.dataSource = castOptionalOrFatalError(delegate)
   79|     12|    }
   80|       |
   81|       |    /// For more information take a look at `DelegateProxyType`.
   82|     57|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   83|     57|        let tableView: UITableView = castOrFatalError(object)
   84|     57|        return tableView.dataSource
   85|     57|    }
   86|       |
   87|       |    /// For more information take a look at `DelegateProxyType`.
   88|      8|    public override func setForwardToDelegate(_ forwardToDelegate: AnyObject?, retainDelegate: Bool) {
   89|      8|        let requiredMethodsDataSource: UITableViewDataSource? = castOptionalOrFatalError(forwardToDelegate)
   90|      4|        _requiredMethodsDataSource = requiredMethodsDataSource ?? tableViewDataSourceNotSet
   91|      8|        super.setForwardToDelegate(forwardToDelegate, retainDelegate: retainDelegate)
   92|      8|    }
   93|       |
   94|       |}
   95|       |
   96|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTableViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxTableViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/15/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxTableViewDelegateProxy
   18|       |    : RxScrollViewDelegateProxy
   19|       |    , UITableViewDelegate {
   20|       |
   21|       |
   22|       |    /// Typed parent object.
   23|       |    public weak private(set) var tableView: UITableView?
   24|       |
   25|       |    /// Initializes `RxTableViewDelegateProxy`
   26|       |    ///
   27|       |    /// - parameter parentObject: Parent object for delegate proxy.
   28|     38|    public required init(parentObject: AnyObject) {
   29|     38|        self.tableView = castOrFatalError(parentObject)
   30|     38|        super.init(parentObject: parentObject)
   31|     38|    }
   32|       |
   33|       |}
   34|       |
   35|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTextStorageDelegateProxy.swift:
    1|       |//
    2|       |//  RxTextStorageDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 12/30/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    
   11|       |    #if !RX_NO_MODULE
   12|       |        import RxSwift
   13|       |    #endif
   14|       |    import UIKit
   15|       |    
   16|       |    public class RxTextStorageDelegateProxy
   17|       |        : DelegateProxy
   18|       |        , DelegateProxyType
   19|       |        , NSTextStorageDelegate {
   20|       |
   21|       |        /// For more information take a look at `DelegateProxyType`.
   22|      0|        public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   23|      0|            let pickerView: NSTextStorage = castOrFatalError(object)
   24|      0|            return pickerView.createRxDelegateProxy()
   25|      0|        }
   26|       |        
   27|       |        /// For more information take a look at `DelegateProxyType`.
   28|      0|        public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   29|      0|            let textStorage: NSTextStorage = castOrFatalError(object)
   30|      0|            textStorage.delegate = castOptionalOrFatalError(delegate)
   31|      0|        }
   32|       |        
   33|       |        /// For more information take a look at `DelegateProxyType`.
   34|      0|        public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   35|      0|            let textStorage: NSTextStorage = castOrFatalError(object)
   36|      0|            return textStorage.delegate
   37|      0|        }
   38|       |    }
   39|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxTextViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxTextViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yuta ToKoRo on 7/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/// For more information take a look at `DelegateProxyType`.
   17|       |public class RxTextViewDelegateProxy
   18|       |    : RxScrollViewDelegateProxy
   19|       |    , UITextViewDelegate {
   20|       |
   21|       |    /// Typed parent object.
   22|       |    public weak private(set) var textView: UITextView?
   23|       |
   24|       |    /// Initializes `RxTextViewDelegateProxy`
   25|       |    ///
   26|       |    /// - parameter parentObject: Parent object for delegate proxy.
   27|      0|    public required init(parentObject: AnyObject) {
   28|      0|        self.textView = castOrFatalError(parentObject)
   29|      0|        super.init(parentObject: parentObject)
   30|      0|    }
   31|       |
   32|       |    // MARK: delegate methods
   33|       |
   34|       |    /// For more information take a look at `DelegateProxyType`.
   35|      0|    @objc public func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
   36|      0|        /**
   37|      0|         We've had some issues with observing text changes. This is here just in case we need the same hack in future and that 
   38|      0|         we wouldn't need to change the public interface.
   39|      0|        */
   40|      0|        let forwardToDelegate = self.forwardToDelegate() as? UITextViewDelegate
   41|      0|        return forwardToDelegate?.textView?(textView,
   42|      0|            shouldChangeTextIn: range,
   43|      0|            replacementText: text) ?? true
   44|      0|    }
   45|       |}
   46|       |
   47|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/Proxies/RxWebViewDelegateProxy.swift:
    1|       |//
    2|       |//  RxWebViewDelegateProxy.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Andrew Breckenridge on 9/26/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |public class RxWebViewDelegateProxy
   17|       |    : DelegateProxy
   18|       |    , DelegateProxyType
   19|       |    , UIWebViewDelegate {
   20|       |
   21|       |    /// For more information take a look at `DelegateProxyType`.
   22|      0|    public override class func createProxyForObject(_ object: AnyObject) -> AnyObject {
   23|      0|        let pickerView: UIWebView = castOrFatalError(object)
   24|      0|        return pickerView.createRxDelegateProxy()
   25|      0|    }
   26|       |    
   27|       |    /// For more information take a look at `DelegateProxyType`.
   28|      0|    public class func setCurrentDelegate(_ delegate: AnyObject?, toObject object: AnyObject) {
   29|      0|        let webView: UIWebView = castOrFatalError(object)
   30|      0|        webView.delegate = castOptionalOrFatalError(delegate)
   31|      0|    }
   32|       |
   33|       |    /// For more information take a look at `DelegateProxyType`.
   34|      0|    public class func currentDelegateFor(_ object: AnyObject) -> AnyObject? {
   35|      0|        let webView: UIWebView = castOrFatalError(object)
   36|      0|        return webView.delegate
   37|      0|    }
   38|       |
   39|       |
   40|       |}
   41|       |
   42|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIActivityIndicatorView+Rx.swift:
    1|       |//
    2|       |//  UIActivityIndicatorView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Ivan Persidskiy on 02/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: UIActivityIndicatorView {
   17|       |
   18|       |    /// Bindable sink for `startAnimating()`, `stopAnimating()` methods.
   19|      0|    public var isAnimating: UIBindingObserver<Base, Bool> {
   20|      0|        return UIBindingObserver(UIElement: self.base) { activityIndicator, active in
   21|      0|            if active {
   22|      0|                activityIndicator.startAnimating()
   23|      0|            } else {
   24|      0|                activityIndicator.stopAnimating()
   25|      0|            }
   26|      0|        }
   27|      0|    }
   28|       |
   29|       |}
   30|       |
   31|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIAlertAction+Rx.swift:
    1|       |//
    2|       |//  UIAlertAction+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Andrew Breckenridge on 5/7/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |    
   13|       |#if !RX_NO_MODULE
   14|       |import RxSwift
   15|       |#endif
   16|       |
   17|       |extension Reactive where Base: UIAlertAction {
   18|       |
   19|       |    /// Bindable sink for `enabled` property.
   20|      0|    public var isEnabled: UIBindingObserver<Base, Bool> {
   21|      0|        return UIBindingObserver(UIElement: self.base) { alertAction, value in
   22|      0|            alertAction.isEnabled = value
   23|      0|        }
   24|      0|    }
   25|       |    
   26|       |}
   27|       |    
   28|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIApplication+Rx.swift:
    1|       |//
    2|       |//  UIApplication+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Mads Bøgeskov on 18/01/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |    import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |    import RxSwift
   14|       |#endif
   15|       |
   16|       |    extension Reactive where Base: UIApplication {
   17|       |        
   18|       |        /// Bindable sink for `networkActivityIndicatorVisible`.
   19|      0|        public var isNetworkActivityIndicatorVisible: UIBindingObserver<Base, Bool> {
   20|      0|            return UIBindingObserver(UIElement: self.base) { application, active in
   21|      0|                application.isNetworkActivityIndicatorVisible = active
   22|      0|            }
   23|      0|        }
   24|       |    }
   25|       |#endif
   26|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIBarButtonItem+Rx.swift:
    1|       |//
    2|       |//  UIBarButtonItem+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Daniel Tartaglia on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |fileprivate var rx_tap_key: UInt8 = 0
   17|       |
   18|       |extension Reactive where Base: UIBarButtonItem {
   19|       |    
   20|       |    /// Bindable sink for `enabled` property.
   21|      0|    public var isEnabled: UIBindingObserver<Base, Bool> {
   22|      0|        return UIBindingObserver(UIElement: self.base) { UIElement, value in
   23|      0|            UIElement.isEnabled = value
   24|      0|        }
   25|      0|    }
   26|       |    
   27|       |    /// Bindable sink for `title` property.
   28|      0|    public var title: UIBindingObserver<Base, String> {
   29|      0|        return UIBindingObserver(UIElement: self.base) { UIElement, value in
   30|      0|            UIElement.title = value
   31|      0|        }
   32|      0|    }
   33|       |
   34|       |    /// Reactive wrapper for target action pattern on `self`.
   35|      4|    public var tap: ControlEvent<Void> {
   36|      4|        let source = lazyInstanceObservable(&rx_tap_key) { () -> Observable<Void> in
   37|      4|            Observable.create { [weak control = self.base] observer in
   38|      0|                guard let control = control else {
   39|      0|                    observer.on(.completed)
   40|      0|                    return Disposables.create()
   41|      4|                }
   42|      0|                let target = BarButtonItemTarget(barButtonItem: control) {
   43|      0|                    observer.on(.next())
   44|      0|                }
   45|      4|                return target
   46|      4|            }
   47|      4|            .takeUntil(self.deallocated)
   48|      4|            .share()
   49|      4|        }
   50|      4|        
   51|      4|        return ControlEvent(events: source)
   52|      4|    }
   53|       |}
   54|       |
   55|       |
   56|       |@objc
   57|       |final class BarButtonItemTarget: RxTarget {
   58|       |    typealias Callback = () -> Void
   59|       |    
   60|       |    weak var barButtonItem: UIBarButtonItem?
   61|       |    var callback: Callback!
   62|       |    
   63|      4|    init(barButtonItem: UIBarButtonItem, callback: @escaping () -> Void) {
   64|      4|        self.barButtonItem = barButtonItem
   65|      4|        self.callback = callback
   66|      4|        super.init()
   67|      4|        barButtonItem.target = self
   68|      4|        barButtonItem.action = #selector(BarButtonItemTarget.action(_:))
   69|      4|    }
   70|       |    
   71|      0|    override func dispose() {
   72|      0|        super.dispose()
   73|      0|#if DEBUG
   74|      0|        MainScheduler.ensureExecutingOnScheduler()
   75|      0|#endif
   76|      0|        
   77|      0|        barButtonItem?.target = nil
   78|      0|        barButtonItem?.action = nil
   79|      0|        
   80|      0|        callback = nil
   81|      0|    }
   82|       |    
   83|      0|    func action(_ sender: AnyObject) {
   84|      0|        callback()
   85|      0|    }
   86|       |    
   87|       |}
   88|       |
   89|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIButton+Rx.swift:
    1|       |//
    2|       |//  UIButton+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UIButton {
   17|       |    
   18|       |    /// Reactive wrapper for `TouchUpInside` control event.
   19|     92|    public var tap: ControlEvent<Void> {
   20|     92|        return controlEvent(.touchUpInside)
   21|     92|    }
   22|       |}
   23|       |
   24|       |#endif
   25|       |
   26|       |#if os(tvOS)
   27|       |
   28|       |#if !RX_NO_MODULE
   29|       |    import RxSwift
   30|       |#endif
   31|       |import UIKit
   32|       |
   33|       |extension Reactive where Base: UIButton {
   34|       |
   35|       |    /// Reactive wrapper for `PrimaryActionTriggered` control event.
   36|       |    public var primaryAction: ControlEvent<Void> {
   37|       |        return controlEvent(.primaryActionTriggered)
   38|       |    }
   39|       |
   40|       |}
   41|       |
   42|       |#endif
   43|       |
   44|       |#if os(iOS) || os(tvOS)
   45|       |
   46|       |#if !RX_NO_MODULE
   47|       |    import RxSwift
   48|       |#endif
   49|       |    import UIKit
   50|       |
   51|       |extension Reactive where Base: UIButton {
   52|       |    
   53|       |    /// Reactive wrapper for `setTitle(_:controlState:)`
   54|      0|    public func title(for controlState: UIControlState = []) -> UIBindingObserver<Base, String?> {
   55|      0|        return UIBindingObserver<Base, String?>(UIElement: self.base) { (button, title) -> () in
   56|      0|            button.setTitle(title, for: controlState)
   57|      0|        }
   58|      0|    }
   59|       |    
   60|       |}
   61|       |#endif
   62|       |
   63|       |#if os(iOS) || os(tvOS)
   64|       |    
   65|       |#if !RX_NO_MODULE
   66|       |    import RxSwift
   67|       |#endif
   68|       |    import UIKit
   69|       |    
   70|       |    extension Reactive where Base: UIButton {
   71|       |        
   72|       |        /// Reactive wrapper for `setAttributedTitle(_:controlState:)`
   73|      0|        public func attributedTitle(for controlState: UIControlState = []) -> UIBindingObserver<Base, NSAttributedString?> {
   74|      0|            return UIBindingObserver<Base, NSAttributedString?>(UIElement: self.base) { (button, attributedTitle) -> () in
   75|      0|                button.setAttributedTitle(attributedTitle, for: controlState)
   76|      0|            }
   77|      0|        }
   78|       |        
   79|       |    }
   80|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UICollectionView+Rx.swift:
    1|       |//
    2|       |//  UICollectionView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |// Items
   17|       |
   18|       |extension Reactive where Base: UICollectionView {
   19|       |
   20|       |    /**
   21|       |    Binds sequences of elements to collection view items.
   22|       |    
   23|       |    - parameter source: Observable sequence of items.
   24|       |    - parameter cellFactory: Transform between sequence elements and view cells.
   25|       |    - returns: Disposable object that can be used to unbind.
   26|       |     
   27|       |     Example
   28|       |    
   29|       |         let items = Observable.just([
   30|       |             1,
   31|       |             2,
   32|       |             3
   33|       |         ])
   34|       |
   35|       |         items
   36|       |         .bind(to: collectionView.rx.items) { (collectionView, row, element) in
   37|       |            let indexPath = IndexPath(row: row, section: 0)
   38|       |            let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath) as! NumberCell
   39|       |             cell.value?.text = "\(element) @ \(row)"
   40|       |             return cell
   41|       |         }
   42|       |         .disposed(by: disposeBag)
   43|       |    */
   44|       |    public func items<S: Sequence, O: ObservableType>
   45|       |        (_ source: O)
   46|       |        -> (_ cellFactory: @escaping (UICollectionView, Int, S.Iterator.Element) -> UICollectionViewCell)
   47|      0|        -> Disposable where O.E == S {
   48|      0|        return { cellFactory in
   49|      0|            let dataSource = RxCollectionViewReactiveArrayDataSourceSequenceWrapper<S>(cellFactory: cellFactory)
   50|      0|            return self.items(dataSource: dataSource)(source)
   51|      0|        }
   52|      0|        
   53|      0|    }
   54|       |    
   55|       |    /**
   56|       |    Binds sequences of elements to collection view items.
   57|       |    
   58|       |    - parameter cellIdentifier: Identifier used to dequeue cells.
   59|       |    - parameter source: Observable sequence of items.
   60|       |    - parameter configureCell: Transform between sequence elements and view cells.
   61|       |    - parameter cellType: Type of table view cell.
   62|       |    - returns: Disposable object that can be used to unbind.
   63|       |     
   64|       |     Example
   65|       |
   66|       |         let items = Observable.just([
   67|       |             1,
   68|       |             2,
   69|       |             3
   70|       |         ])
   71|       |
   72|       |         items
   73|       |             .bind(to: collectionView.rx.items(cellIdentifier: "Cell", cellType: NumberCell.self)) { (row, element, cell) in
   74|       |                cell.value?.text = "\(element) @ \(row)"
   75|       |             }
   76|       |             .disposed(by: disposeBag)
   77|       |    */
   78|       |    public func items<S: Sequence, Cell: UICollectionViewCell, O : ObservableType>
   79|       |        (cellIdentifier: String, cellType: Cell.Type = Cell.self)
   80|       |        -> (_ source: O)
   81|       |        -> (_ configureCell: @escaping (Int, S.Iterator.Element, Cell) -> Void)
   82|      0|        -> Disposable where O.E == S {
   83|      0|        return { source in
   84|      0|            return { configureCell in
   85|      0|                let dataSource = RxCollectionViewReactiveArrayDataSourceSequenceWrapper<S> { (cv, i, item) in
   86|      0|                    let indexPath = IndexPath(item: i, section: 0)
   87|      0|                    let cell = cv.dequeueReusableCell(withReuseIdentifier: cellIdentifier, for: indexPath) as! Cell
   88|      0|                    configureCell(i, item, cell)
   89|      0|                    return cell
   90|      0|                }
   91|      0|                    
   92|      0|                return self.items(dataSource: dataSource)(source)
   93|      0|            }
   94|      0|        }
   95|      0|    }
   96|       |
   97|       |    
   98|       |    /**
   99|       |    Binds sequences of elements to collection view items using a custom reactive data used to perform the transformation.
  100|       |    
  101|       |    - parameter dataSource: Data source used to transform elements to view cells.
  102|       |    - parameter source: Observable sequence of items.
  103|       |    - returns: Disposable object that can be used to unbind.
  104|       |     
  105|       |     Example
  106|       |     
  107|       |         let dataSource = RxCollectionViewSectionedReloadDataSource<SectionModel<String, Double>>()
  108|       |
  109|       |         let items = Observable.just([
  110|       |             SectionModel(model: "First section", items: [
  111|       |                 1.0,
  112|       |                 2.0,
  113|       |                 3.0
  114|       |             ]),
  115|       |             SectionModel(model: "Second section", items: [
  116|       |                 1.0,
  117|       |                 2.0,
  118|       |                 3.0
  119|       |             ]),
  120|       |             SectionModel(model: "Third section", items: [
  121|       |                 1.0,
  122|       |                 2.0,
  123|       |                 3.0
  124|       |             ])
  125|       |         ])
  126|       |
  127|       |         dataSource.configureCell = { (dataSource, cv, indexPath, element) in
  128|       |             let cell = cv.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath) as! NumberCell
  129|       |             cell.value?.text = "\(element) @ row \(indexPath.row)"
  130|       |             return cell
  131|       |         }
  132|       |
  133|       |         items
  134|       |            .bind(to: collectionView.rx.items(dataSource: dataSource))
  135|       |            .disposed(by: disposeBag)
  136|       |    */
  137|       |    public func items<
  138|       |            DataSource: RxCollectionViewDataSourceType & UICollectionViewDataSource,
  139|       |            O: ObservableType>
  140|       |        (dataSource: DataSource)
  141|       |        -> (_ source: O)
  142|       |        -> Disposable where DataSource.Element == O.E
  143|      0|          {
  144|      0|        return { source in
  145|      0|            // This is called for sideeffects only, and to make sure delegate proxy is in place when
  146|      0|            // data source is being bound.
  147|      0|            // This is needed because theoretically the data source subscription itself might
  148|      0|            // call `self.rx.delegate`. If that happens, it might cause weird side effects since
  149|      0|            // setting data source will set delegate, and UICollectionView might get into a weird state.
  150|      0|            // Therefore it's better to set delegate proxy first, just to be sure.
  151|      0|            _ = self.delegate
  152|      0|            // Strong reference is needed because data source is in use until result subscription is disposed
  153|      0|            return source.subscribeProxyDataSource(ofObject: self.base, dataSource: dataSource, retainDataSource: true) { [weak collectionView = self.base] (_: RxCollectionViewDataSourceProxy, event) -> Void in
  154|      0|                guard let collectionView = collectionView else {
  155|      0|                    return
  156|      0|                }
  157|      0|                dataSource.collectionView(collectionView, observedEvent: event)
  158|      0|            }
  159|      0|        }
  160|      0|    }
  161|       |}
  162|       |
  163|       |extension UICollectionView {
  164|       |   
  165|       |    /// Factory method that enables subclasses to implement their own `delegate`.
  166|       |    ///
  167|       |    /// - returns: Instance of delegate proxy that wraps `delegate`.
  168|      0|    public override func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
  169|      0|        return RxCollectionViewDelegateProxy(parentObject: self)
  170|      0|    }
  171|       |
  172|       |    /// Factory method that enables subclasses to implement their own `rx.dataSource`.
  173|       |    ///
  174|       |    /// - returns: Instance of delegate proxy that wraps `dataSource`.
  175|      0|    public func createRxDataSourceProxy() -> RxCollectionViewDataSourceProxy {
  176|      0|        return RxCollectionViewDataSourceProxy(parentObject: self)
  177|      0|    }
  178|       |
  179|       |}
  180|       |
  181|       |extension Reactive where Base: UICollectionView {
  182|       |
  183|       |    /// Reactive wrapper for `dataSource`.
  184|       |    ///
  185|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
  186|      0|    public var dataSource: DelegateProxy {
  187|      0|        return RxCollectionViewDataSourceProxy.proxyForObject(base)
  188|      0|    }
  189|       |    
  190|       |    /// Installs data source as forwarding delegate on `rx.dataSource`.
  191|       |    /// Data source won't be retained.
  192|       |    ///
  193|       |    /// It enables using normal delegate mechanism with reactive delegate mechanism.
  194|       |    ///
  195|       |    /// - parameter dataSource: Data source object.
  196|       |    /// - returns: Disposable object that can be used to unbind the data source.
  197|       |    public func setDataSource(_ dataSource: UICollectionViewDataSource)
  198|      0|        -> Disposable {
  199|      0|        return RxCollectionViewDataSourceProxy.installForwardDelegate(dataSource, retainDelegate: false, onProxyForObject: self.base)
  200|      0|    }
  201|       |   
  202|       |    /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.
  203|      0|    public var itemSelected: ControlEvent<IndexPath> {
  204|      0|        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:)))
  205|      0|            .map { a in
  206|      0|                return a[1] as! IndexPath
  207|      0|            }
  208|      0|        
  209|      0|        return ControlEvent(events: source)
  210|      0|    }
  211|       |
  212|       |    /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.
  213|      0|    public var itemDeselected: ControlEvent<IndexPath> {
  214|      0|        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didDeselectItemAt:)))
  215|      0|            .map { a in
  216|      0|                return a[1] as! IndexPath
  217|      0|        }
  218|      0|
  219|      0|        return ControlEvent(events: source)
  220|      0|    }
  221|       |
  222|       |    /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.
  223|       |    ///
  224|       |    /// It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  225|       |    /// or any other data source conforming to `SectionedViewDataSourceType` protocol.
  226|       |    ///
  227|       |    /// ```
  228|       |    ///     collectionView.rx.modelSelected(MyModel.self)
  229|       |    ///        .map { ...
  230|       |    /// ```
  231|      0|    public func modelSelected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  232|      0|        let source: Observable<T> = itemSelected.flatMap { [weak view = self.base as UICollectionView] indexPath -> Observable<T> in
  233|      0|            guard let view = view else {
  234|      0|                return Observable.empty()
  235|      0|            }
  236|      0|
  237|      0|            return Observable.just(try view.rx.model(at: indexPath))
  238|      0|        }
  239|      0|        
  240|      0|        return ControlEvent(events: source)
  241|      0|    }
  242|       |
  243|       |    /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.
  244|       |    ///
  245|       |    /// It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  246|       |    /// or any other data source conforming to `SectionedViewDataSourceType` protocol.
  247|       |    ///
  248|       |    /// ```
  249|       |    ///     collectionView.rx.modelDeselected(MyModel.self)
  250|       |    ///        .map { ...
  251|       |    /// ```
  252|      0|    public func modelDeselected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  253|      0|        let source: Observable<T> = itemDeselected.flatMap { [weak view = self.base as UICollectionView] indexPath -> Observable<T> in
  254|      0|            guard let view = view else {
  255|      0|                return Observable.empty()
  256|      0|            }
  257|      0|
  258|      0|            return Observable.just(try view.rx.model(at: indexPath))
  259|      0|        }
  260|      0|
  261|      0|        return ControlEvent(events: source)
  262|      0|    }
  263|       |    
  264|       |    /// Syncronous helper method for retrieving a model at indexPath through a reactive data source
  265|      0|    public func model<T>(at indexPath: IndexPath) throws -> T {
  266|      0|        let dataSource: SectionedViewDataSourceType = castOrFatalError(self.dataSource.forwardToDelegate(), message: "This method only works in case one of the `rx.itemsWith*` methods was used.")
  267|      0|        
  268|      0|        let element = try dataSource.model(at: indexPath)
  269|      0|
  270|      0|        return element as! T
  271|      0|    }
  272|       |}
  273|       |#endif
  274|       |
  275|       |#if os(tvOS)
  276|       |
  277|       |extension Reactive where Base: UICollectionView {
  278|       |    
  279|       |    /// Reactive wrapper for `delegate` message `collectionView:didUpdateFocusInContext:withAnimationCoordinator:`.
  280|       |    public var didUpdateFocusInContextWithAnimationCoordinator: ControlEvent<(context: UICollectionViewFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator)> {
  281|       |
  282|       |        let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didUpdateFocusIn:with:)))
  283|       |            .map { a -> (context: UICollectionViewFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator) in
  284|       |                let context = a[1] as! UICollectionViewFocusUpdateContext
  285|       |                let animationCoordinator = a[2] as! UIFocusAnimationCoordinator
  286|       |                return (context: context, animationCoordinator: animationCoordinator)
  287|       |            }
  288|       |
  289|       |        return ControlEvent(events: source)
  290|       |    }
  291|       |}
  292|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIControl+Rx.swift:
    1|       |//
    2|       |//  UIControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Daniel Tartaglia on 5/23/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UIControl {
   17|       |    
   18|       |    /// Bindable sink for `enabled` property.
   19|     34|    public var isEnabled: UIBindingObserver<Base, Bool> {
   20|     35|        return UIBindingObserver(UIElement: self.base) { control, value in
   21|     35|            control.isEnabled = value
   22|     35|        }
   23|     34|    }
   24|       |
   25|       |    /// Bindable sink for `selected` property.
   26|      0|    public var isSelected: UIBindingObserver<Base, Bool> {
   27|      0|        return UIBindingObserver(UIElement: self.base) { control, selected in
   28|      0|            control.isSelected = selected
   29|      0|        }
   30|      0|    }
   31|       |
   32|       |    /// Reactive wrapper for target action pattern.
   33|       |    ///
   34|       |    /// - parameter controlEvents: Filter for observed event types.
   35|    218|    public func controlEvent(_ controlEvents: UIControlEvents) -> ControlEvent<Void> {
   36|    218|        let source: Observable<Void> = Observable.create { [weak control = self.base] observer in
   37|    218|            MainScheduler.ensureExecutingOnScheduler()
   38|    218|
   39|      0|            guard let control = control else {
   40|      0|                observer.on(.completed)
   41|      0|                return Disposables.create()
   42|    218|            }
   43|    218|
   44|      6|            let controlTarget = ControlTarget(control: control, controlEvents: controlEvents) {
   45|      6|                control in
   46|      6|                observer.on(.next())
   47|      6|            }
   48|    218|            
   49|    218|            return Disposables.create(with: controlTarget.dispose)
   50|    218|        }.takeUntil(deallocated)
   51|    218|
   52|    218|        return ControlEvent(events: source)
   53|    218|    }
   54|       |
   55|       |    /// This is internal convenience method
   56|       |    /// https://github.com/ReactiveX/RxSwift/issues/681
   57|       |    /// In case similar behavior is externally needed, one can use the following snippet
   58|       |    ///
   59|       |    /// ```swift
   60|       |    /// extension UIControl {
   61|       |    ///     static func valuePublic<T, ControlType: UIControl>(_ control: ControlType, getter:  @escaping (ControlType) -> T, setter: @escaping (ControlType, T) -> ()) -> ControlProperty<T> {
   62|       |    ///        let values: Observable<T> = Observable.deferred { [weak control] in
   63|       |    ///            guard let existingSelf = control else {
   64|       |    ///                return Observable.empty()
   65|       |    ///            }
   66|       |    ///
   67|       |    ///            return (existingSelf as UIControl).rx.controlEvent([.allEditingEvents, .valueChanged])
   68|       |    ///                .flatMap { _ in
   69|       |    ///                    return control.map { Observable.just(getter($0)) } ?? Observable.empty()
   70|       |    ///                }
   71|       |    ///                .startWith(getter(existingSelf))
   72|       |    ///        }
   73|       |    ///        return ControlProperty(values: values, valueSink: UIBindingObserver(UIElement: control) { control, value in
   74|       |    ///            setter(control, value)
   75|       |    ///        })
   76|       |    ///    }
   77|       |    ///}
   78|       |    ///```
   79|    148|    static func value<C: UIControl, T>(_ control: C, getter: @escaping (C) -> T, setter: @escaping (C, T) -> Void) -> ControlProperty<T> {
   80|    148|        let source: Observable<T> = Observable.create { [weak weakControl = control] observer in
   81|      0|                guard let control = weakControl else {
   82|      0|                    observer.on(.completed)
   83|      0|                    return Disposables.create()
   84|    148|                }
   85|    148|
   86|    148|                observer.on(.next(getter(control)))
   87|    148|
   88|      0|                let controlTarget = ControlTarget(control: control, controlEvents: [.allEditingEvents, .valueChanged]) { _ in
   89|      0|                    if let control = weakControl {
   90|      0|                        observer.on(.next(getter(control)))
   91|      0|                    }
   92|      0|                }
   93|    148|                
   94|    148|                return Disposables.create(with: controlTarget.dispose)
   95|    148|            }
   96|    148|            .takeUntil((control as NSObject).rx.deallocated)
   97|    148|
   98|    148|        let bindingObserver = UIBindingObserver(UIElement: control, binding: setter)
   99|    148|
  100|    148|        return ControlProperty<T>(values: source, valueSink: bindingObserver)
  101|    148|    }
  102|       |
  103|       |}
  104|       |
  105|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIDatePicker+Rx.swift:
    1|       |//
    2|       |//  UIDatePicker+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Daniel Tartaglia on 5/31/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UIDatePicker {
   17|       |    /// Reactive wrapper for `date` property.
   18|      0|    public var date: ControlProperty<Date> {
   19|      0|        return value
   20|      0|    }
   21|       |
   22|       |    /// Reactive wrapper for `date` property.
   23|      0|    public var value: ControlProperty<Date> {
   24|      0|        return UIControl.rx.value(
   25|      0|            self.base,
   26|      0|            getter: { datePicker in
   27|      0|                datePicker.date
   28|      0|            }, setter: { datePicker, value in
   29|      0|                datePicker.date = value
   30|      0|            }
   31|      0|        )
   32|      0|    }
   33|       |
   34|       |    /// Reactive wrapper for `countDownDuration` property.
   35|      0|    public var countDownDuration: ControlProperty<TimeInterval> {
   36|      0|        return UIControl.rx.value(
   37|      0|            self.base,
   38|      0|            getter: { datePicker in
   39|      0|                datePicker.countDownDuration
   40|      0|            }, setter: { datePicker, value in
   41|      0|                datePicker.countDownDuration = value
   42|      0|            }
   43|      0|        )
   44|      0|    }
   45|       |}
   46|       |
   47|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIGestureRecognizer+Rx.swift:
    1|       |//
    2|       |//  UIGestureRecognizer+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Carlos García on 10/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |
   17|       |// This should be only used from `MainScheduler`
   18|       |final class GestureTarget<Recognizer: UIGestureRecognizer>: RxTarget {
   19|       |    typealias Callback = (Recognizer) -> Void
   20|       |    
   21|       |    let selector = #selector(ControlTarget.eventHandler(_:))
   22|       |    
   23|       |    weak var gestureRecognizer: Recognizer?
   24|       |    var callback: Callback?
   25|       |    
   26|      0|    init(_ gestureRecognizer: Recognizer, callback: @escaping Callback) {
   27|      0|        self.gestureRecognizer = gestureRecognizer
   28|      0|        self.callback = callback
   29|      0|        
   30|      0|        super.init()
   31|      0|        
   32|      0|        gestureRecognizer.addTarget(self, action: selector)
   33|      0|
   34|      0|        let method = self.method(for: selector)
   35|      0|        if method == nil {
   36|      0|            fatalError("Can't find method")
   37|      0|        }
   38|      0|    }
   39|       |    
   40|      0|    func eventHandler(_ sender: UIGestureRecognizer!) {
   41|      0|        if let callback = self.callback, let gestureRecognizer = self.gestureRecognizer {
   42|      0|            callback(gestureRecognizer)
   43|      0|        }
   44|      0|    }
   45|       |    
   46|      0|    override func dispose() {
   47|      0|        super.dispose()
   48|      0|        
   49|      0|        self.gestureRecognizer?.removeTarget(self, action: self.selector)
   50|      0|        self.callback = nil
   51|      0|    }
   52|       |}
   53|       |
   54|       |extension Reactive where Base: UIGestureRecognizer {
   55|       |    
   56|       |    /// Reactive wrapper for gesture recognizer events.
   57|      0|    public var event: ControlEvent<Base> {
   58|      0|        let source: Observable<Base> = Observable.create { [weak control = self.base] observer in
   59|      0|            MainScheduler.ensureExecutingOnScheduler()
   60|      0|
   61|      0|            guard let control = control else {
   62|      0|                observer.on(.completed)
   63|      0|                return Disposables.create()
   64|      0|            }
   65|      0|            
   66|      0|            let observer = GestureTarget(control) {
   67|      0|                control in
   68|      0|                observer.on(.next(control))
   69|      0|            }
   70|      0|            
   71|      0|            return observer
   72|      0|        }.takeUntil(deallocated)
   73|      0|        
   74|      0|        return ControlEvent(events: source)
   75|      0|    }
   76|       |    
   77|       |}
   78|       |
   79|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIImageView+Rx.swift:
    1|       |//
    2|       |//  UIImageView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UIImageView {
   17|       |    
   18|       |    /// Bindable sink for `image` property.
   19|      0|    public var image: UIBindingObserver<Base, UIImage?> {
   20|      0|        return image(transitionType: nil)
   21|      0|    }
   22|       |    
   23|       |    /// Bindable sink for `image` property.
   24|       |
   25|       |    /// - parameter transitionType: Optional transition type while setting the image (kCATransitionFade, kCATransitionMoveIn, ...)
   26|      0|    public func image(transitionType: String? = nil) -> UIBindingObserver<Base, UIImage?> {
   27|      0|        return UIBindingObserver(UIElement: base) { imageView, image in
   28|      0|            if let transitionType = transitionType {
   29|      0|                if image != nil {
   30|      0|                    let transition = CATransition()
   31|      0|                    transition.duration = 0.25
   32|      0|                    transition.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
   33|      0|                    transition.type = transitionType
   34|      0|                    imageView.layer.add(transition, forKey: kCATransition)
   35|      0|                }
   36|      0|            }
   37|      0|            else {
   38|      0|                imageView.layer.removeAllAnimations()
   39|      0|            }
   40|      0|            imageView.image = image
   41|      0|        }
   42|      0|    }
   43|       |}
   44|       |
   45|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UILabel+Rx.swift:
    1|       |//
    2|       |//  UILabel+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UILabel {
   17|       |    
   18|       |    /// Bindable sink for `text` property.
   19|      7|    public var text: UIBindingObserver<Base, String?> {
   20|      7|        return UIBindingObserver(UIElement: self.base) { label, text in
   21|      7|            label.text = text
   22|      7|        }
   23|      7|    }
   24|       |
   25|       |    /// Bindable sink for `attributedText` property.
   26|      0|    public var attributedText: UIBindingObserver<Base, NSAttributedString?> {
   27|      0|        return UIBindingObserver(UIElement: self.base) { label, text in
   28|      0|            label.attributedText = text
   29|      0|        }
   30|      0|    }
   31|       |    
   32|       |}
   33|       |
   34|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UINavigationItem+Rx.swift:
    1|       |//
    2|       |//  UINavigationItem+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by kumapo on 2016/05/09.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |    
   16|       |extension Reactive where Base: UINavigationItem {
   17|       |    
   18|       |    /// Bindable sink for `title` property.
   19|      0|    public var title: UIBindingObserver<Base, String?> {
   20|      0|        return UIBindingObserver(UIElement: self.base) { navigationItem, text in
   21|      0|            navigationItem.title = text
   22|      0|        }
   23|      0|    }
   24|       |        
   25|       |}
   26|       |    
   27|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIPageControl+Rx.swift:
    1|       |//
    2|       |//  UIPageControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Francesco Puntillo on 14/04/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |    
   16|       |extension Reactive where Base: UIPageControl {
   17|       |    
   18|       |    /// Bindable sink for `currentPage` property.
   19|      0|    public var currentPage: UIBindingObserver<Base, Int> {
   20|      0|        return UIBindingObserver(UIElement: self.base) { controller, page in
   21|      0|            controller.currentPage = page
   22|      0|        }
   23|      0|    }
   24|       |    
   25|       |    /// Bindable sink for `numberOfPages` property.
   26|      0|    public var numberOfPages: UIBindingObserver<Base, Int> {
   27|      0|        return UIBindingObserver(UIElement: self.base) { controller, page in
   28|      0|            controller.numberOfPages = page
   29|      0|        }
   30|      0|    }
   31|       |    
   32|       |}
   33|       |    
   34|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIPickerView+Rx.swift:
    1|       |//
    2|       |//  UIPickerView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 5/12/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |    
   11|       |#if !RX_NO_MODULE
   12|       |    import RxSwift
   13|       |#endif
   14|       |    import UIKit
   15|       |
   16|       |    extension UIPickerView {
   17|       |
   18|       |        /// Factory method that enables subclasses to implement their own `delegate`.
   19|       |        ///
   20|       |        /// - returns: Instance of delegate proxy that wraps `delegate`.
   21|      0|        public func createRxDelegateProxy() -> RxPickerViewDelegateProxy {
   22|      0|            return RxPickerViewDelegateProxy(parentObject: self)
   23|      0|        }
   24|       |        
   25|       |    }
   26|       |    
   27|       |    extension Reactive where Base: UIPickerView {
   28|       |
   29|       |        /// Reactive wrapper for `delegate`.
   30|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   31|      0|        public var delegate: DelegateProxy {
   32|      0|            return RxPickerViewDelegateProxy.proxyForObject(base)
   33|      0|        }
   34|       |        
   35|      0|        public var itemSelected: ControlEvent<(Int, Int)> {
   36|      0|            let source = delegate
   37|      0|                .methodInvoked(#selector(UIPickerViewDelegate.pickerView(_:didSelectRow:inComponent:)))
   38|      0|                .map {
   39|      0|                    return (try castOrThrow(Int.self, $0[1]), try castOrThrow(Int.self, $0[2]))
   40|      0|                }
   41|      0|            return ControlEvent(events: source)
   42|      0|        }
   43|       |    }
   44|       |
   45|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIProgressView+Rx.swift:
    1|       |//
    2|       |//  UIProgressView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Samuel Bae on 2/27/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UIProgressView {
   17|       |
   18|       |    /// Bindable sink for `progress` property
   19|      0|    public var progress: UIBindingObserver<Base, Float> {
   20|      0|        return UIBindingObserver(UIElement: self.base) { progressView, progress in
   21|      0|            progressView.progress = progress
   22|      0|        }
   23|      0|    }
   24|       |
   25|       |}
   26|       |
   27|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIRefreshControl+Rx.swift:
    1|       |//
    2|       |//  UIRefreshControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yosuke Ishikawa on 1/31/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: UIRefreshControl {
   17|       |
   18|       |    /// Bindable sink for `beginRefreshing()`, `endRefreshing()` methods.
   19|       |    @available(*, deprecated, renamed: "isRefreshing")
   20|      0|    public var refreshing: UIBindingObserver<Base, Bool> {
   21|      0|        return self.isRefreshing
   22|      0|    }
   23|       |
   24|       |    /// Bindable sink for `beginRefreshing()`, `endRefreshing()` methods.
   25|      0|    public var isRefreshing: UIBindingObserver<Base, Bool> {
   26|      0|        return UIBindingObserver(UIElement: self.base) { refreshControl, refresh in
   27|      0|            if refresh {
   28|      0|                refreshControl.beginRefreshing()
   29|      0|            } else {
   30|      0|                refreshControl.endRefreshing()
   31|      0|            }
   32|      0|        }
   33|      0|    }
   34|       |
   35|       |}
   36|       |
   37|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIScrollView+Rx.swift:
    1|       |//
    2|       |//  UIScrollView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/3/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |    #if !RX_NO_MODULE
   12|       |        import RxSwift
   13|       |    #endif
   14|       |
   15|       |    import UIKit
   16|       |
   17|       |    extension UIScrollView {
   18|       |        
   19|       |        /// Factory method that enables subclasses to implement their own `delegate`.
   20|       |        ///
   21|       |        /// - returns: Instance of delegate proxy that wraps `delegate`.
   22|      0|        public func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
   23|      0|            return RxScrollViewDelegateProxy(parentObject: self)
   24|      0|        }
   25|       |        
   26|       |    }
   27|       |
   28|       |    extension Reactive where Base: UIScrollView {
   29|       |
   30|       |        /// Reactive wrapper for `delegate`.
   31|       |        ///
   32|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   33|     42|        public var delegate: DelegateProxy {
   34|     42|            return RxScrollViewDelegateProxy.proxyForObject(base)
   35|     42|        }
   36|       |        
   37|       |        /// Reactive wrapper for `contentOffset`.
   38|      0|        public var contentOffset: ControlProperty<CGPoint> {
   39|      0|            let proxy = RxScrollViewDelegateProxy.proxyForObject(base)
   40|      0|
   41|      0|            let bindingObserver = UIBindingObserver(UIElement: self.base) { scrollView, contentOffset in
   42|      0|                scrollView.contentOffset = contentOffset
   43|      0|            }
   44|      0|
   45|      0|            return ControlProperty(values: proxy.contentOffsetBehaviorSubject, valueSink: bindingObserver)
   46|      0|        }
   47|       |
   48|       |        /// Bindable sink for `scrollEnabled` property.
   49|      0|        public var isScrollEnabled: UIBindingObserver<Base, Bool> {
   50|      0|            return UIBindingObserver(UIElement: self.base) { scrollView, scrollEnabled in
   51|      0|                scrollView.isScrollEnabled = scrollEnabled
   52|      0|            }
   53|      0|        }
   54|       |
   55|       |        /// Reactive wrapper for delegate method `scrollViewDidScroll`
   56|      0|        public var didScroll: ControlEvent<Void> {
   57|      0|            let source = RxScrollViewDelegateProxy.proxyForObject(base).contentOffsetPublishSubject
   58|      0|            return ControlEvent(events: source)
   59|      0|        }
   60|       |    	
   61|       |    	/// Reactive wrapper for delegate method `scrollViewDidEndDecelerating`
   62|      0|    	public var didEndDecelerating: ControlEvent<Void> {
   63|      0|    		let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndDecelerating(_:))).map { _ in }
   64|      0|    		return ControlEvent(events: source)
   65|      0|    	}
   66|       |    	
   67|       |    	/// Reactive wrapper for delegate method `scrollViewDidEndDragging(_:willDecelerate:)`
   68|      0|    	public var didEndDragging: ControlEvent<Bool> {
   69|      0|    		let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndDragging(_:willDecelerate:))).map { value -> Bool in
   70|      0|    			return try castOrThrow(Bool.self, value[1])
   71|      0|    		}
   72|      0|    		return ControlEvent(events: source)
   73|      0|    	}
   74|       |
   75|       |        /// Reactive wrapper for delegate method `scrollViewDidZoom`
   76|      0|        public var didZoom: ControlEvent<Void> {
   77|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidZoom)).map { _ in }
   78|      0|            return ControlEvent(events: source)
   79|      0|        }
   80|       |
   81|       |
   82|       |        /// Reactive wrapper for delegate method `scrollViewDidScrollToTop`
   83|      0|        public var didScrollToTop: ControlEvent<Void> {
   84|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidScrollToTop(_:))).map { _ in }
   85|      0|            return ControlEvent(events: source)
   86|      0|        }
   87|       |        
   88|       |        /// Reactive wrapper for delegate method `scrollViewDidEndScrollingAnimation`
   89|      0|        public var didEndScrollingAnimation: ControlEvent<Void> {
   90|      0|            let source = delegate.methodInvoked(#selector(UIScrollViewDelegate.scrollViewDidEndScrollingAnimation(_:))).map { _ in }
   91|      0|            return ControlEvent(events: source)
   92|      0|        }
   93|       |
   94|       |        /// Installs delegate as forwarding delegate on `delegate`.
   95|       |        /// Delegate won't be retained.
   96|       |        ///
   97|       |        /// It enables using normal delegate mechanism with reactive delegate mechanism.
   98|       |        ///
   99|       |        /// - parameter delegate: Delegate object.
  100|       |        /// - returns: Disposable object that can be used to unbind the delegate.
  101|       |        public func setDelegate(_ delegate: UIScrollViewDelegate)
  102|      4|            -> Disposable {
  103|      4|            return RxScrollViewDelegateProxy.installForwardDelegate(delegate, retainDelegate: false, onProxyForObject: self.base)
  104|      4|        }
  105|       |    }
  106|       |
  107|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UISearchBar+Rx.swift:
    1|       |//
    2|       |//  UISearchBar+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |
   17|       |#if os(iOS)
   18|       |    extension UISearchBar {
   19|       |        /// Factory method that enables subclasses to implement their own `delegate`.
   20|       |        ///
   21|       |        /// - returns: Instance of delegate proxy that wraps `delegate`.
   22|      0|        public func createRxDelegateProxy() -> RxSearchBarDelegateProxy {
   23|      0|            return RxSearchBarDelegateProxy(parentObject: self)
   24|      0|        }
   25|       |        
   26|       |    }
   27|       |#endif
   28|       |
   29|       |extension Reactive where Base: UISearchBar {
   30|       |
   31|       |    /// Reactive wrapper for `delegate`.
   32|       |    ///
   33|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   34|      0|    public var delegate: DelegateProxy {
   35|      0|        return RxSearchBarDelegateProxy.proxyForObject(base)
   36|      0|    }
   37|       |
   38|       |    /// Reactive wrapper for `text` property.
   39|      0|    public var text: ControlProperty<String?> {
   40|      0|        return value
   41|      0|    }
   42|       |    
   43|       |    /// Reactive wrapper for `text` property.
   44|      0|    public var value: ControlProperty<String?> {
   45|      0|        let source: Observable<String?> = Observable.deferred { [weak searchBar = self.base as UISearchBar] () -> Observable<String?> in
   46|      0|            let text = searchBar?.text
   47|      0|            
   48|      0|            return (searchBar?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty())
   49|      0|                    .map { a in
   50|      0|                        return a[1] as? String
   51|      0|                    }
   52|      0|                    .startWith(text)
   53|      0|        }
   54|      0|
   55|      0|        let bindingObserver = UIBindingObserver(UIElement: self.base) { (searchBar, text: String?) in
   56|      0|            searchBar.text = text
   57|      0|        }
   58|      0|        
   59|      0|        return ControlProperty(values: source, valueSink: bindingObserver)
   60|      0|    }
   61|       |    
   62|       |    /// Reactive wrapper for `selectedScopeButtonIndex` property.
   63|      0|    public var selectedScopeButtonIndex: ControlProperty<Int> {
   64|      0|        let source: Observable<Int> = Observable.deferred { [weak source = self.base as UISearchBar] () -> Observable<Int> in
   65|      0|            let index = source?.selectedScopeButtonIndex ?? 0
   66|      0|            
   67|      0|            return (source?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:selectedScopeButtonIndexDidChange:))) ?? Observable.empty())
   68|      0|                .map { a in
   69|      0|                    return try castOrThrow(Int.self, a[1])
   70|      0|                }
   71|      0|                .startWith(index)
   72|      0|        }
   73|      0|        
   74|      0|        let bindingObserver = UIBindingObserver(UIElement: self.base) { (searchBar, index: Int) in
   75|      0|            searchBar.selectedScopeButtonIndex = index
   76|      0|        }
   77|      0|        
   78|      0|        return ControlProperty(values: source, valueSink: bindingObserver)
   79|      0|    }
   80|       |    
   81|       |#if os(iOS)
   82|       |    /// Reactive wrapper for delegate method `searchBarCancelButtonClicked`.
   83|      0|    public var cancelButtonClicked: ControlEvent<Void> {
   84|      0|        let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarCancelButtonClicked(_:)))
   85|      0|            .map { _ in
   86|      0|                return ()
   87|      0|            }
   88|      0|        return ControlEvent(events: source)
   89|      0|    }
   90|       |
   91|       |	/// Reactive wrapper for delegate method `searchBarBookmarkButtonClicked`.
   92|      0|	public var bookmarkButtonClicked: ControlEvent<Void> {
   93|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarBookmarkButtonClicked(_:)))
   94|      0|			.map { _ in
   95|      0|				return ()
   96|      0|			}
   97|      0|		return ControlEvent(events: source)
   98|      0|	}
   99|       |
  100|       |	/// Reactive wrapper for delegate method `searchBarResultsListButtonClicked`.
  101|      0|	public var resultsListButtonClicked: ControlEvent<Void> {
  102|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarResultsListButtonClicked(_:)))
  103|      0|			.map { _ in
  104|      0|				return ()
  105|      0|		}
  106|      0|		return ControlEvent(events: source)
  107|      0|	}
  108|       |#endif
  109|       |	
  110|       |    /// Reactive wrapper for delegate method `searchBarSearchButtonClicked`.
  111|      0|    public var searchButtonClicked: ControlEvent<Void> {
  112|      0|        let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarSearchButtonClicked(_:)))
  113|      0|            .map { _ in
  114|      0|                return ()
  115|      0|        }
  116|      0|        return ControlEvent(events: source)
  117|      0|    }
  118|       |	
  119|       |	/// Reactive wrapper for delegate method `searchBarTextDidBeginEditing`.
  120|      0|	public var textDidBeginEditing: ControlEvent<Void> {
  121|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarTextDidBeginEditing(_:)))
  122|      0|			.map { _ in
  123|      0|				return ()
  124|      0|		}
  125|      0|		return ControlEvent(events: source)
  126|      0|	}
  127|       |	
  128|       |	/// Reactive wrapper for delegate method `searchBarTextDidEndEditing`.
  129|      0|	public var textDidEndEditing: ControlEvent<Void> {
  130|      0|		let source: Observable<Void> = self.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBarTextDidEndEditing(_:)))
  131|      0|			.map { _ in
  132|      0|				return ()
  133|      0|		}
  134|      0|		return ControlEvent(events: source)
  135|      0|	}
  136|       |	
  137|       |}
  138|       |
  139|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UISearchController+Rx.swift:
    1|       |//
    2|       |//  UISearchController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Segii Shulga on 3/17/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |    
   11|       |#if !RX_NO_MODULE
   12|       |    import RxSwift
   13|       |#endif
   14|       |    import UIKit
   15|       |
   16|       |    extension UISearchController {
   17|       |        /// Factory method that enables subclasses to implement their own `delegate`.
   18|       |        ///
   19|       |        /// - returns: Instance of delegate proxy that wraps `delegate`.
   20|      0|        public func createRxDelegateProxy() -> RxSearchControllerDelegateProxy {
   21|      0|            return RxSearchControllerDelegateProxy(parentObject: self)
   22|      0|        }
   23|       |    }
   24|       |    
   25|       |    @available(iOS 8.0, *)
   26|       |    extension Reactive where Base: UISearchController {
   27|       |        /// Reactive wrapper for `delegate`.
   28|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   29|      0|        public var delegate: DelegateProxy {
   30|      0|            return RxSearchControllerDelegateProxy.proxyForObject(base)
   31|      0|        }
   32|       |
   33|       |        /// Reactive wrapper for `delegate` message.
   34|      0|        public var didDismiss: Observable<Void> {
   35|      0|            return delegate
   36|      0|                .methodInvoked( #selector(UISearchControllerDelegate.didDismissSearchController(_:)))
   37|      0|                .map {_ in}
   38|      0|        }
   39|       |
   40|       |        /// Reactive wrapper for `delegate` message.
   41|      0|        public var didPresent: Observable<Void> {
   42|      0|            return delegate
   43|      0|                .methodInvoked(#selector(UISearchControllerDelegate.didPresentSearchController(_:)))
   44|      0|                .map {_ in}
   45|      0|        }
   46|       |
   47|       |        /// Reactive wrapper for `delegate` message.
   48|      0|        public var present: Observable<Void> {
   49|      0|            return delegate
   50|      0|                .methodInvoked( #selector(UISearchControllerDelegate.presentSearchController(_:)))
   51|      0|                .map {_ in}
   52|      0|        }
   53|       |
   54|       |        /// Reactive wrapper for `delegate` message.
   55|      0|        public var willDismiss: Observable<Void> {
   56|      0|            return delegate
   57|      0|                .methodInvoked(#selector(UISearchControllerDelegate.willDismissSearchController(_:)))
   58|      0|                .map {_ in}
   59|      0|        }
   60|       |        
   61|       |        /// Reactive wrapper for `delegate` message.
   62|      0|        public var willPresent: Observable<Void> {
   63|      0|            return delegate
   64|      0|                .methodInvoked( #selector(UISearchControllerDelegate.willPresentSearchController(_:)))
   65|      0|                .map {_ in}
   66|      0|        }
   67|       |        
   68|       |    }
   69|       |    
   70|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UISegmentedControl+Rx.swift:
    1|       |//
    2|       |//  UISegmentedControl+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Carlos García on 8/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |
   17|       |extension Reactive where Base: UISegmentedControl {
   18|       |    /// Reactive wrapper for `selectedSegmentIndex` property.
   19|      0|    public var selectedSegmentIndex: ControlProperty<Int> {
   20|      0|        return value
   21|      0|    }
   22|       |    
   23|       |    /// Reactive wrapper for `selectedSegmentIndex` property.
   24|      0|    public var value: ControlProperty<Int> {
   25|      0|        return UIControl.rx.value(
   26|      0|            self.base,
   27|      0|            getter: { segmentedControl in
   28|      0|                segmentedControl.selectedSegmentIndex
   29|      0|            }, setter: { segmentedControl, value in
   30|      0|                segmentedControl.selectedSegmentIndex = value
   31|      0|            }
   32|      0|        )
   33|      0|    }
   34|       |    
   35|       |}
   36|       |
   37|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UISlider+Rx.swift:
    1|       |//
    2|       |//  UISlider+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Alexander van der Werff on 28/05/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UISlider {
   17|       |    
   18|       |    /// Reactive wrapper for `value` property.
   19|      0|    public var value: ControlProperty<Float> {
   20|      0|        return UIControl.rx.value(
   21|      0|            self.base,
   22|      0|            getter: { slider in
   23|      0|                slider.value
   24|      0|            }, setter: { slider, value in
   25|      0|                slider.value = value
   26|      0|            }
   27|      0|        )
   28|      0|    }
   29|       |    
   30|       |}
   31|       |
   32|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIStepper+Rx.swift:
    1|       |//
    2|       |//  UIStepper+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yuta ToKoRo on 9/1/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: UIStepper {
   17|       |    
   18|       |    /// Reactive wrapper for `value` property.
   19|      0|    public var value: ControlProperty<Double> {
   20|      0|        return UIControl.rx.value(
   21|      0|            self.base,
   22|      0|            getter: { stepper in
   23|      0|                stepper.value
   24|      0|            }, setter: { stepper, value in
   25|      0|                stepper.value = value
   26|      0|            }
   27|      0|        )
   28|      0|    }
   29|       |    
   30|       |}
   31|       |
   32|       |#endif
   33|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UISwitch+Rx.swift:
    1|       |//
    2|       |//  UISwitch+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Carlos García on 8/7/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |
   17|       |extension Reactive where Base: UISwitch {
   18|       |
   19|       |    /// Reactive wrapper for `isOn` property.
   20|      0|    public var isOn: ControlProperty<Bool> {
   21|      0|        return value
   22|      0|    }
   23|       |    
   24|       |    /**
   25|       |    Reactive wrapper for `isOn` property.
   26|       |    
   27|       |    **⚠️ Versions prior to iOS 10.2 were leaking `UIButton`s, so on those versions
   28|       |     underlying observable sequence won't complete when nothing holds a strong reference
   29|       |     to UISwitch.⚠️**
   30|       |    */
   31|      0|    public var value: ControlProperty<Bool> {
   32|      0|        return UIControl.rx.value(
   33|      0|            self.base,
   34|      0|            getter: { uiSwitch in
   35|      0|                uiSwitch.isOn
   36|      0|            }, setter: { uiSwitch, value in
   37|      0|                uiSwitch.isOn = value
   38|      0|            }
   39|      0|        )
   40|      0|    }
   41|       |    
   42|       |}
   43|       |
   44|       |#endif
   45|       |

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UITabBar+Rx.swift:
    1|       |//
    2|       |//  UITabBar+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Jesse Farless on 5/13/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |/**
   17|       | iOS only
   18|       | */
   19|       |#if os(iOS)
   20|       |extension Reactive where Base: UITabBar {
   21|       |
   22|       |    /// Reactive wrapper for `delegate` message `tabBar:willBeginCustomizingItems:`.
   23|      0|    public var willBeginCustomizing: ControlEvent<[UITabBarItem]> {
   24|      0|        
   25|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:willBeginCustomizing:)))
   26|      0|            .map { a in
   27|      0|                return try castOrThrow([UITabBarItem].self, a[1])
   28|      0|            }
   29|      0|
   30|      0|        return ControlEvent(events: source)
   31|      0|    }
   32|       |
   33|       |    /// Reactive wrapper for `delegate` message `tabBar:didBeginCustomizingItems:`.
   34|      0|    public var didBeginCustomizing: ControlEvent<[UITabBarItem]> {
   35|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:didBeginCustomizing:)))
   36|      0|            .map { a in
   37|      0|                return try castOrThrow([UITabBarItem].self, a[1])
   38|      0|            }
   39|      0|
   40|      0|        return ControlEvent(events: source)
   41|      0|    }
   42|       |
   43|       |    /// Reactive wrapper for `delegate` message `tabBar:willEndCustomizingItems:changed:`.
   44|      0|    public var willEndCustomizing: ControlEvent<([UITabBarItem], Bool)> {
   45|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:willEndCustomizing:changed:)))
   46|      0|            .map { (a: [Any]) -> (([UITabBarItem], Bool)) in
   47|      0|                let items = try castOrThrow([UITabBarItem].self, a[1])
   48|      0|                let changed = try castOrThrow(Bool.self, a[2])
   49|      0|                return (items, changed)
   50|      0|            }
   51|      0|
   52|      0|        return ControlEvent(events: source)
   53|      0|    }
   54|       |
   55|       |    /// Reactive wrapper for `delegate` message `tabBar:didEndCustomizingItems:changed:`.
   56|      0|    public var didEndCustomizing: ControlEvent<([UITabBarItem], Bool)> {
   57|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:didEndCustomizing:changed:)))
   58|      0|            .map { (a: [Any]) -> (([UITabBarItem], Bool)) in
   59|      0|                let items = try castOrThrow([UITabBarItem].self, a[1])
   60|      0|                let changed = try castOrThrow(Bool.self, a[2])
   61|      0|                return (items, changed)
   62|      0|            }
   63|      0|
   64|      0|        return ControlEvent(events: source)
   65|      0|    }
   66|       |
   67|       |}
   68|       |#endif
   69|       |
   70|       |/**
   71|       | iOS and tvOS
   72|       | */
   73|       |extension UITabBar {
   74|       |    
   75|       |    /// Factory method that enables subclasses to implement their own `delegate`.
   76|       |    ///
   77|       |    /// - returns: Instance of delegate proxy that wraps `delegate`.
   78|      0|    public func createRxDelegateProxy() -> RxTabBarDelegateProxy {
   79|      0|        return RxTabBarDelegateProxy(parentObject: self)
   80|      0|    }
   81|       |
   82|       |}
   83|       |
   84|       |extension Reactive where Base: UITabBar {
   85|       |    /// Reactive wrapper for `delegate`.
   86|       |    ///
   87|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   88|      0|    public var delegate: DelegateProxy {
   89|      0|        return RxTabBarDelegateProxy.proxyForObject(base)
   90|      0|    }
   91|       |
   92|       |    /// Reactive wrapper for `delegate` message `tabBar:didSelectItem:`.
   93|      0|    public var didSelectItem: ControlEvent<UITabBarItem> {
   94|      0|        let source = delegate.methodInvoked(#selector(UITabBarDelegate.tabBar(_:didSelect:)))
   95|      0|            .map { a in
   96|      0|                return try castOrThrow(UITabBarItem.self, a[1])
   97|      0|            }
   98|      0|
   99|      0|        return ControlEvent(events: source)
  100|      0|    }
  101|       |
  102|       |}
  103|       |
  104|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UITabBarController+Rx.swift:
    1|       |//
    2|       |//  UITabBarController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yusuke Kita on 2016/12/07.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |import UIKit
   11|       |    
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |    
   16|       |/**
   17|       | iOS only
   18|       | */
   19|       |#if os(iOS)
   20|       |extension Reactive where Base: UITabBarController {
   21|       |    
   22|       |    /// Reactive wrapper for `delegate` message `tabBarController:willBeginCustomizing:`.
   23|      0|    public var willBeginCustomizing: ControlEvent<[UIViewController]> {
   24|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:willBeginCustomizing:)))
   25|      0|            .map { a in
   26|      0|                return try castOrThrow([UIViewController].self, a[1])
   27|      0|        }
   28|      0|        
   29|      0|        return ControlEvent(events: source)
   30|      0|    }
   31|       |    
   32|       |    /// Reactive wrapper for `delegate` message `tabBarController:willEndCustomizing:changed:`.
   33|      0|    public var willEndCustomizing: ControlEvent<(viewControllers: [UIViewController], changed: Bool)> {
   34|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:willEndCustomizing:changed:)))
   35|      0|            .map { (a: [Any]) -> (viewControllers: [UIViewController], changed: Bool) in
   36|      0|                let viewControllers = try castOrThrow([UIViewController].self, a[1])
   37|      0|                let changed = try castOrThrow(Bool.self, a[2])
   38|      0|                return (viewControllers, changed)
   39|      0|        }
   40|      0|        
   41|      0|        return ControlEvent(events: source)
   42|      0|    }
   43|       |    
   44|       |    /// Reactive wrapper for `delegate` message `tabBarController:didEndCustomizing:changed:`.
   45|      0|    public var didEndCustomizing: ControlEvent<(viewControllers: [UIViewController], changed: Bool)> {
   46|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:didEndCustomizing:changed:)))
   47|      0|            .map { (a: [Any]) -> (viewControllers: [UIViewController], changed: Bool) in
   48|      0|                let viewControllers = try castOrThrow([UIViewController].self, a[1])
   49|      0|                let changed = try castOrThrow(Bool.self, a[2])
   50|      0|                return (viewControllers, changed)
   51|      0|        }
   52|      0|        
   53|      0|        return ControlEvent(events: source)
   54|      0|    }
   55|       |}
   56|       |#endif
   57|       |    
   58|       |/**
   59|       | iOS and tvOS
   60|       | */
   61|       |extension UITabBarController {
   62|       |    
   63|       |    /// Factory method that enables subclasses to implement their own `delegate`.
   64|       |    ///
   65|       |    /// - returns: Instance of delegate proxy that wraps `delegate`.
   66|      0|    public func createRxDelegateProxy() -> RxTabBarControllerDelegateProxy {
   67|      0|        return RxTabBarControllerDelegateProxy(parentObject: self)
   68|      0|    }
   69|       |    
   70|       |}
   71|       |    
   72|       |extension Reactive where Base: UITabBarController {
   73|       |    /// Reactive wrapper for `delegate`.
   74|       |    ///
   75|       |    /// For more information take a look at `DelegateProxyType` protocol documentation.
   76|      0|    public var delegate: DelegateProxy {
   77|      0|        return RxTabBarControllerDelegateProxy.proxyForObject(base)
   78|      0|    }
   79|       |    
   80|       |    /// Reactive wrapper for `delegate` message `tabBarController:didSelect:`.
   81|      0|    public var didSelect: ControlEvent<UIViewController> {
   82|      0|        let source = delegate.methodInvoked(#selector(UITabBarControllerDelegate.tabBarController(_:didSelect:)))
   83|      0|            .map { a in
   84|      0|                return try castOrThrow(UIViewController.self, a[1])
   85|      0|        }
   86|      0|        
   87|      0|        return ControlEvent(events: source)
   88|      0|    }
   89|       |}
   90|       |
   91|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UITabBarItem+Rx.swift:
    1|       |//
    2|       |//  UITabBarItem+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Mateusz Derks on 04/03/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |    
   11|       |    import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |    import RxSwift
   14|       |#endif
   15|       |    
   16|       |extension Reactive where Base: UITabBarItem {
   17|       |    
   18|       |    /// Bindable sink for `badgeValue` property.
   19|      0|    public var badgeValue: UIBindingObserver<Base, String?> {
   20|      0|        return UIBindingObserver(UIElement: self.base) { tabBarItem, badgeValue in
   21|      0|            tabBarItem.badgeValue = badgeValue
   22|      0|        }
   23|      0|    }
   24|       |    
   25|       |}
   26|       |    
   27|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UITableView+Rx.swift:
    1|       |//
    2|       |//  UITableView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 4/2/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |// Items
   17|       |
   18|       |extension Reactive where Base: UITableView {
   19|       |
   20|       |    /**
   21|       |    Binds sequences of elements to table view rows.
   22|       |    
   23|       |    - parameter source: Observable sequence of items.
   24|       |    - parameter cellFactory: Transform between sequence elements and view cells.
   25|       |    - returns: Disposable object that can be used to unbind.
   26|       |     
   27|       |     Example:
   28|       |    
   29|       |         let items = Observable.just([
   30|       |             "First Item",
   31|       |             "Second Item",
   32|       |             "Third Item"
   33|       |         ])
   34|       |
   35|       |         items
   36|       |         .bind(to: tableView.rx.items) { (tableView, row, element) in
   37|       |             let cell = tableView.dequeueReusableCell(withIdentifier: "Cell")!
   38|       |             cell.textLabel?.text = "\(element) @ row \(row)"
   39|       |             return cell
   40|       |         }
   41|       |         .disposed(by: disposeBag)
   42|       |
   43|       |     */
   44|       |    public func items<S: Sequence, O: ObservableType>
   45|       |        (_ source: O)
   46|       |        -> (_ cellFactory: @escaping (UITableView, Int, S.Iterator.Element) -> UITableViewCell)
   47|       |        -> Disposable
   48|      0|        where O.E == S {
   49|      0|            return { cellFactory in
   50|      0|                let dataSource = RxTableViewReactiveArrayDataSourceSequenceWrapper<S>(cellFactory: cellFactory)
   51|      0|                return self.items(dataSource: dataSource)(source)
   52|      0|            }
   53|      0|    }
   54|       |
   55|       |    /**
   56|       |    Binds sequences of elements to table view rows.
   57|       |    
   58|       |    - parameter cellIdentifier: Identifier used to dequeue cells.
   59|       |    - parameter source: Observable sequence of items.
   60|       |    - parameter configureCell: Transform between sequence elements and view cells.
   61|       |    - parameter cellType: Type of table view cell.
   62|       |    - returns: Disposable object that can be used to unbind.
   63|       |     
   64|       |     Example:
   65|       |
   66|       |         let items = Observable.just([
   67|       |             "First Item",
   68|       |             "Second Item",
   69|       |             "Third Item"
   70|       |         ])
   71|       |
   72|       |         items
   73|       |             .bind(to: tableView.rx.items(cellIdentifier: "Cell", cellType: UITableViewCell.self)) { (row, element, cell) in
   74|       |                cell.textLabel?.text = "\(element) @ row \(row)"
   75|       |             }
   76|       |             .disposed(by: disposeBag)
   77|       |    */
   78|       |    public func items<S: Sequence, Cell: UITableViewCell, O : ObservableType>
   79|       |        (cellIdentifier: String, cellType: Cell.Type = Cell.self)
   80|       |        -> (_ source: O)
   81|       |        -> (_ configureCell: @escaping (Int, S.Iterator.Element, Cell) -> Void)
   82|       |        -> Disposable
   83|      0|        where O.E == S {
   84|      0|        return { source in
   85|      0|            return { configureCell in
   86|      0|                let dataSource = RxTableViewReactiveArrayDataSourceSequenceWrapper<S> { (tv, i, item) in
   87|      0|                    let indexPath = IndexPath(item: i, section: 0)
   88|      0|                    let cell = tv.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! Cell
   89|      0|                    configureCell(i, item, cell)
   90|      0|                    return cell
   91|      0|                }
   92|      0|                return self.items(dataSource: dataSource)(source)
   93|      0|            }
   94|      0|        }
   95|      0|    }
   96|       |
   97|       |
   98|       |    /**
   99|       |    Binds sequences of elements to table view rows using a custom reactive data used to perform the transformation.
  100|       |    This method will retain the data source for as long as the subscription isn't disposed (result `Disposable` 
  101|       |    being disposed).
  102|       |    In case `source` observable sequence terminates sucessfully, the data source will present latest element
  103|       |    until the subscription isn't disposed.
  104|       |    
  105|       |    - parameter dataSource: Data source used to transform elements to view cells.
  106|       |    - parameter source: Observable sequence of items.
  107|       |    - returns: Disposable object that can be used to unbind.
  108|       |     
  109|       |     Example 
  110|       |
  111|       |        let dataSource = RxTableViewSectionedReloadDataSource<SectionModel<String, Double>>()
  112|       |
  113|       |        let items = Observable.just([
  114|       |            SectionModel(model: "First section", items: [
  115|       |                1.0,
  116|       |                2.0,
  117|       |                3.0
  118|       |                ]),
  119|       |            SectionModel(model: "Second section", items: [
  120|       |                1.0,
  121|       |                2.0,
  122|       |                3.0
  123|       |                ]),
  124|       |            SectionModel(model: "Third section", items: [
  125|       |                1.0,
  126|       |                2.0,
  127|       |                3.0
  128|       |                ])
  129|       |            ])
  130|       |
  131|       |        dataSource.configureCell = { (dataSource, tv, indexPath, element) in
  132|       |            let cell = tv.dequeueReusableCell(withIdentifier: "Cell")!
  133|       |            cell.textLabel?.text = "\(element) @ row \(indexPath.row)"
  134|       |            return cell
  135|       |        }
  136|       |
  137|       |        items
  138|       |            .bind(to: tableView.rx.items(dataSource: dataSource))
  139|       |            .disposed(by: disposeBag)
  140|       |    */
  141|       |    public func items<
  142|       |            DataSource: RxTableViewDataSourceType & UITableViewDataSource,
  143|       |            O: ObservableType>
  144|       |        (dataSource: DataSource)
  145|       |        -> (_ source: O)
  146|       |        -> Disposable
  147|      4|        where DataSource.Element == O.E {
  148|      4|        return { source in
  149|      4|            // This is called for sideeffects only, and to make sure delegate proxy is in place when
  150|      4|            // data source is being bound.
  151|      4|            // This is needed because theoretically the data source subscription itself might
  152|      4|            // call `self.rx.delegate`. If that happens, it might cause weird side effects since
  153|      4|            // setting data source will set delegate, and UITableView might get into a weird state.
  154|      4|            // Therefore it's better to set delegate proxy first, just to be sure.
  155|      4|            _ = self.delegate
  156|      4|            // Strong reference is needed because data source is in use until result subscription is disposed
  157|     37|            return source.subscribeProxyDataSource(ofObject: self.base, dataSource: dataSource, retainDataSource: true) { [weak tableView = self.base] (_: RxTableViewDataSourceProxy, event) -> Void in
  158|      0|                guard let tableView = tableView else {
  159|      0|                    return
  160|     37|                }
  161|     37|                dataSource.tableView(tableView, observedEvent: event)
  162|     37|            }
  163|      4|        }
  164|      4|    }
  165|       |
  166|       |}
  167|       |
  168|       |extension UITableView {
  169|       | 
  170|       |    /**
  171|       |    Factory method that enables subclasses to implement their own `delegate`.
  172|       |    
  173|       |    - returns: Instance of delegate proxy that wraps `delegate`.
  174|       |    */
  175|     38|    public override func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
  176|     38|        return RxTableViewDelegateProxy(parentObject: self)
  177|     38|    }
  178|       |
  179|       |    /**
  180|       |    Factory method that enables subclasses to implement their own `rx.dataSource`.
  181|       |    
  182|       |    - returns: Instance of delegate proxy that wraps `dataSource`.
  183|       |    */
  184|      4|    public func createRxDataSourceProxy() -> RxTableViewDataSourceProxy {
  185|      4|        return RxTableViewDataSourceProxy(parentObject: self)
  186|      4|    }
  187|       |
  188|       |}
  189|       |
  190|       |extension Reactive where Base: UITableView {
  191|       |    /**
  192|       |    Reactive wrapper for `dataSource`.
  193|       |    
  194|       |    For more information take a look at `DelegateProxyType` protocol documentation.
  195|       |    */
  196|      0|    public var dataSource: DelegateProxy {
  197|      0|        return RxTableViewDataSourceProxy.proxyForObject(base)
  198|      0|    }
  199|       |   
  200|       |    /**
  201|       |    Installs data source as forwarding delegate on `rx.dataSource`.
  202|       |    Data source won't be retained.
  203|       |    
  204|       |    It enables using normal delegate mechanism with reactive delegate mechanism.
  205|       |     
  206|       |    - parameter dataSource: Data source object.
  207|       |    - returns: Disposable object that can be used to unbind the data source.
  208|       |    */
  209|       |    public func setDataSource(_ dataSource: UITableViewDataSource)
  210|      0|        -> Disposable {
  211|      0|        return RxTableViewDataSourceProxy.installForwardDelegate(dataSource, retainDelegate: false, onProxyForObject: self.base)
  212|      0|    }
  213|       |    
  214|       |    // events
  215|       |    
  216|       |    /**
  217|       |    Reactive wrapper for `delegate` message `tableView:didSelectRowAtIndexPath:`.
  218|       |    */
  219|     38|    public var itemSelected: ControlEvent<IndexPath> {
  220|     38|        let source = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didSelectRowAt:)))
  221|      0|            .map { a in
  222|      0|                return try castOrThrow(IndexPath.self, a[1])
  223|      0|            }
  224|     38|
  225|     38|        return ControlEvent(events: source)
  226|     38|    }
  227|       |
  228|       |    /**
  229|       |     Reactive wrapper for `delegate` message `tableView:didDeselectRowAtIndexPath:`.
  230|       |     */
  231|      0|    public var itemDeselected: ControlEvent<IndexPath> {
  232|      0|        let source = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didDeselectRowAt:)))
  233|      0|            .map { a in
  234|      0|                return try castOrThrow(IndexPath.self, a[1])
  235|      0|            }
  236|      0|
  237|      0|        return ControlEvent(events: source)
  238|      0|    }
  239|       |
  240|       |    /**
  241|       |     Reactive wrapper for `delegate` message `tableView:accessoryButtonTappedForRowWithIndexPath:`.
  242|       |     */
  243|      0|    public var itemAccessoryButtonTapped: ControlEvent<IndexPath> {
  244|      0|        let source: Observable<IndexPath> = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:accessoryButtonTappedForRowWith:)))
  245|      0|            .map { a in
  246|      0|                return try castOrThrow(IndexPath.self, a[1])
  247|      0|            }
  248|      0|        
  249|      0|        return ControlEvent(events: source)
  250|      0|    }
  251|       |    
  252|       |    /**
  253|       |    Reactive wrapper for `delegate` message `tableView:commitEditingStyle:forRowAtIndexPath:`.
  254|       |    */
  255|      0|    public var itemInserted: ControlEvent<IndexPath> {
  256|      0|        let source = self.dataSource.methodInvoked(#selector(UITableViewDataSource.tableView(_:commit:forRowAt:)))
  257|      0|            .filter { a in
  258|      0|                return UITableViewCellEditingStyle(rawValue: (try castOrThrow(NSNumber.self, a[1])).intValue) == .insert
  259|      0|            }
  260|      0|            .map { a in
  261|      0|                return (try castOrThrow(IndexPath.self, a[2]))
  262|      0|        }
  263|      0|        
  264|      0|        return ControlEvent(events: source)
  265|      0|    }
  266|       |    
  267|       |    /**
  268|       |    Reactive wrapper for `delegate` message `tableView:commitEditingStyle:forRowAtIndexPath:`.
  269|       |    */
  270|      0|    public var itemDeleted: ControlEvent<IndexPath> {
  271|      0|        let source = self.dataSource.methodInvoked(#selector(UITableViewDataSource.tableView(_:commit:forRowAt:)))
  272|      0|            .filter { a in
  273|      0|                return UITableViewCellEditingStyle(rawValue: (try castOrThrow(NSNumber.self, a[1])).intValue) == .delete
  274|      0|            }
  275|      0|            .map { a in
  276|      0|                return try castOrThrow(IndexPath.self, a[2])
  277|      0|            }
  278|      0|        
  279|      0|        return ControlEvent(events: source)
  280|      0|    }
  281|       |    
  282|       |    /**
  283|       |    Reactive wrapper for `delegate` message `tableView:moveRowAtIndexPath:toIndexPath:`.
  284|       |    */
  285|      0|    public var itemMoved: ControlEvent<ItemMovedEvent> {
  286|      0|        let source: Observable<ItemMovedEvent> = self.dataSource.methodInvoked(#selector(UITableViewDataSource.tableView(_:moveRowAt:to:)))
  287|      0|            .map { a in
  288|      0|                return (try castOrThrow(IndexPath.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  289|      0|            }
  290|      0|        
  291|      0|        return ControlEvent(events: source)
  292|      0|    }
  293|       |
  294|       |    /**
  295|       |    Reactive wrapper for `delegate` message `tableView:willDisplayCell:forRowAtIndexPath:`.
  296|       |    */
  297|      0|    public var willDisplayCell: ControlEvent<WillDisplayCellEvent> {
  298|      0|        let source: Observable<WillDisplayCellEvent> = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:willDisplay:forRowAt:)))
  299|      0|            .map { a in
  300|      0|                return (try castOrThrow(UITableViewCell.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  301|      0|            }
  302|      0|
  303|      0|        return ControlEvent(events: source)
  304|      0|    }
  305|       |
  306|       |    /**
  307|       |    Reactive wrapper for `delegate` message `tableView:didEndDisplayingCell:forRowAtIndexPath:`.
  308|       |    */
  309|      0|    public var didEndDisplayingCell: ControlEvent<DidEndDisplayingCellEvent> {
  310|      0|        let source: Observable<DidEndDisplayingCellEvent> = self.delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didEndDisplaying:forRowAt:)))
  311|      0|            .map { a in
  312|      0|                return (try castOrThrow(UITableViewCell.self, a[1]), try castOrThrow(IndexPath.self, a[2]))
  313|      0|            }
  314|      0|
  315|      0|        return ControlEvent(events: source)
  316|      0|    }
  317|       |
  318|       |    /**
  319|       |    Reactive wrapper for `delegate` message `tableView:didSelectRowAtIndexPath:`.
  320|       |    
  321|       |    It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  322|       |    or any other data source conforming to `SectionedViewDataSourceType` protocol.
  323|       |    
  324|       |     ```
  325|       |        tableView.rx.modelSelected(MyModel.self)
  326|       |            .map { ...
  327|       |     ```
  328|       |    */
  329|      0|    public func modelSelected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  330|      0|        let source: Observable<T> = self.itemSelected.flatMap { [weak view = self.base as UITableView] indexPath -> Observable<T> in
  331|      0|            guard let view = view else {
  332|      0|                return Observable.empty()
  333|      0|            }
  334|      0|
  335|      0|            return Observable.just(try view.rx.model(at: indexPath))
  336|      0|        }
  337|      0|        
  338|      0|        return ControlEvent(events: source)
  339|      0|    }
  340|       |
  341|       |    /**
  342|       |     Reactive wrapper for `delegate` message `tableView:didDeselectRowAtIndexPath:`.
  343|       |
  344|       |     It can be only used when one of the `rx.itemsWith*` methods is used to bind observable sequence,
  345|       |     or any other data source conforming to `SectionedViewDataSourceType` protocol.
  346|       |
  347|       |     ```
  348|       |        tableView.rx.modelDeselected(MyModel.self)
  349|       |            .map { ...
  350|       |     ```
  351|       |     */
  352|      0|    public func modelDeselected<T>(_ modelType: T.Type) -> ControlEvent<T> {
  353|      0|         let source: Observable<T> = self.itemDeselected.flatMap { [weak view = self.base as UITableView] indexPath -> Observable<T> in
  354|      0|             guard let view = view else {
  355|      0|                 return Observable.empty()
  356|      0|             }
  357|      0|
  358|      0|            return Observable.just(try view.rx.model(at: indexPath))
  359|      0|        }
  360|      0|
  361|      0|        return ControlEvent(events: source)
  362|      0|    }
  363|       |
  364|       |    /**
  365|       |     Synchronous helper method for retrieving a model at indexPath through a reactive data source.
  366|       |     */
  367|      0|    public func model<T>(at indexPath: IndexPath) throws -> T {
  368|      0|        let dataSource: SectionedViewDataSourceType = castOrFatalError(self.dataSource.forwardToDelegate(), message: "This method only works in case one of the `rx.items*` methods was used.")
  369|      0|        
  370|      0|        let element = try dataSource.model(at: indexPath)
  371|      0|
  372|      0|        return castOrFatalError(element)
  373|      0|    }
  374|       |}
  375|       |
  376|       |#endif
  377|       |
  378|       |#if os(tvOS)
  379|       |    
  380|       |    extension Reactive where Base: UITableView {
  381|       |        
  382|       |        /**
  383|       |         Reactive wrapper for `delegate` message `tableView:didUpdateFocusInContext:withAnimationCoordinator:`.
  384|       |         */
  385|       |        public var didUpdateFocusInContextWithAnimationCoordinator: ControlEvent<(context: UIFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator)> {
  386|       |            
  387|       |            let source = delegate.methodInvoked(#selector(UITableViewDelegate.tableView(_:didUpdateFocusIn:with:)))
  388|       |                .map { a -> (context: UIFocusUpdateContext, animationCoordinator: UIFocusAnimationCoordinator) in
  389|       |                    let context = a[1] as! UIFocusUpdateContext
  390|       |                    let animationCoordinator = try castOrThrow(UIFocusAnimationCoordinator.self, a[2])
  391|       |                    return (context: context, animationCoordinator: animationCoordinator)
  392|       |            }
  393|       |            
  394|       |            return ControlEvent(events: source)
  395|       |        }
  396|       |    }
  397|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UITextField+Rx.swift:
    1|       |//
    2|       |//  UITextField+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |import RxSwift
   13|       |#endif
   14|       |import UIKit
   15|       |
   16|       |extension Reactive where Base: UITextField {
   17|       |    /// Reactive wrapper for `text` property.
   18|    148|    public var text: ControlProperty<String?> {
   19|    148|        return value
   20|    148|    }
   21|       |    
   22|       |    /// Reactive wrapper for `text` property.
   23|    148|    public var value: ControlProperty<String?> {
   24|    148|        return UIControl.rx.value(
   25|    148|            base,
   26|    148|            getter: { textField in
   27|    148|                textField.text
   28|      0|            }, setter: { textField, value in
   29|      0|                // This check is important because setting text value always clears control state
   30|      0|                // including marked text selection which is imporant for proper input 
   31|      0|                // when IME input method is used.
   32|      0|                if textField.text != value {
   33|      0|                    textField.text = value
   34|      0|                }
   35|      0|            }
   36|    148|        )
   37|    148|    }
   38|       |    
   39|       |}
   40|       |
   41|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UITextView+Rx.swift:
    1|       |//
    2|       |//  UITextView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Yuta ToKoRo on 7/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |    
   17|       |    
   18|       |extension UITextView {
   19|       |    
   20|       |    /// Factory method that enables subclasses to implement their own `delegate`.
   21|       |    ///
   22|       |    /// - returns: Instance of delegate proxy that wraps `delegate`.
   23|      0|    public override func createRxDelegateProxy() -> RxScrollViewDelegateProxy {
   24|      0|        return RxTextViewDelegateProxy(parentObject: self)
   25|      0|    }
   26|       |}
   27|       |
   28|       |extension Reactive where Base: UITextView {
   29|       |    /// Reactive wrapper for `text` property
   30|      0|    public var text: ControlProperty<String?> {
   31|      0|        return value
   32|      0|    }
   33|       |    
   34|       |    /// Reactive wrapper for `text` property.
   35|      0|    public var value: ControlProperty<String?> {
   36|      0|        let source: Observable<String?> = Observable.deferred { [weak textView = self.base] in
   37|      0|            let text = textView?.text
   38|      0|            
   39|      0|            let textChanged = textView?.textStorage
   40|      0|                // This project uses text storage notifications because
   41|      0|                // that's the only way to catch autocorrect changes
   42|      0|                // in all cases. Other suggestions are welcome.
   43|      0|                .rx.didProcessEditingRangeChangeInLength
   44|      0|                // This observe on is here because text storage
   45|      0|                // will emit event while process is not completely done,
   46|      0|                // so rebinding a value will cause an exception to be thrown.
   47|      0|                .observeOn(MainScheduler.asyncInstance)
   48|      0|                .map { _ in
   49|      0|                    return textView?.textStorage.string
   50|      0|                }
   51|      0|                ?? Observable.empty()
   52|      0|            
   53|      0|            return textChanged
   54|      0|                .startWith(text)
   55|      0|        }
   56|      0|
   57|      0|        let bindingObserver = UIBindingObserver(UIElement: self.base) { (textView, text: String?) in
   58|      0|            // This check is important because setting text value always clears control state
   59|      0|            // including marked text selection which is imporant for proper input 
   60|      0|            // when IME input method is used.
   61|      0|            if textView.text != text {
   62|      0|                textView.text = text
   63|      0|            }
   64|      0|        }
   65|      0|        
   66|      0|        return ControlProperty(values: source, valueSink: bindingObserver)
   67|      0|    }
   68|       |
   69|       |    /// Reactive wrapper for `delegate` message.
   70|      0|    public var didBeginEditing: ControlEvent<()> {
   71|      0|       return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidBeginEditing(_:)))
   72|      0|            .map { a in
   73|      0|                return ()
   74|      0|            })
   75|      0|    }
   76|       |
   77|       |    /// Reactive wrapper for `delegate` message.
   78|      0|    public var didEndEditing: ControlEvent<()> {
   79|      0|        return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidEndEditing(_:)))
   80|      0|            .map { a in
   81|      0|                return ()
   82|      0|            })
   83|      0|    }
   84|       |
   85|       |    /// Reactive wrapper for `delegate` message.
   86|      0|    public var didChange: ControlEvent<()> {
   87|      0|        return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidChange(_:)))
   88|      0|            .map { a in
   89|      0|                return ()
   90|      0|            })
   91|      0|    }
   92|       |
   93|       |    /// Reactive wrapper for `delegate` message.
   94|      0|    public var didChangeSelection: ControlEvent<()> {
   95|      0|        return ControlEvent<()>(events: self.delegate.methodInvoked(#selector(UITextViewDelegate.textViewDidChangeSelection(_:)))
   96|      0|            .map { a in
   97|      0|                return ()
   98|      0|            })
   99|      0|    }
  100|       |
  101|       |}
  102|       |
  103|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIView+Rx.swift:
    1|       |//
    2|       |//  UIView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/6/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS) || os(tvOS)
   10|       |
   11|       |import UIKit
   12|       |#if !RX_NO_MODULE
   13|       |import RxSwift
   14|       |#endif
   15|       |
   16|       |extension Reactive where Base: UIView {
   17|       |    /// Bindable sink for `hidden` property.
   18|      0|    public var isHidden: UIBindingObserver<Base, Bool> {
   19|      0|        return UIBindingObserver(UIElement: self.base) { view, hidden in
   20|      0|            view.isHidden = hidden
   21|      0|        }
   22|      0|    }
   23|       |
   24|       |    /// Bindable sink for `alpha` property.
   25|      0|    public var alpha: UIBindingObserver<Base, CGFloat> {
   26|      0|        return UIBindingObserver(UIElement: self.base) { view, alpha in
   27|      0|            view.alpha = alpha
   28|      0|        }
   29|      0|    }
   30|       |
   31|       |    /// Bindable sink for `isUserInteractionEnabled` property.
   32|      0|    public var isUserInteractionEnabled: UIBindingObserver<Base, Bool> {
   33|      0|        return UIBindingObserver(UIElement: self.base) { view, userInteractionEnabled in
   34|      0|            view.isUserInteractionEnabled = userInteractionEnabled
   35|      0|        }
   36|      0|    }
   37|       |    
   38|       |}
   39|       |
   40|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIViewController+Rx.swift:
    1|       |//
    2|       |//  UIViewController+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Kyle Fuller on 27/05/2016.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |  import UIKit
   11|       |
   12|       |#if !RX_NO_MODULE
   13|       |  import RxSwift
   14|       |#endif
   15|       |
   16|       |    extension Reactive where Base: UIViewController {
   17|       |
   18|       |        /// Bindable sink for `title`.
   19|      0|        public var title: UIBindingObserver<Base, String> {
   20|      0|            return UIBindingObserver(UIElement: self.base) { viewController, title in
   21|      0|                viewController.title = title
   22|      0|            }
   23|      0|        }
   24|       |    
   25|       |    }
   26|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxCocoa/RxCocoa/iOS/UIWebView+Rx.swift:
    1|       |//
    2|       |//  UIWebView+Rx.swift
    3|       |//  RxCocoa
    4|       |//
    5|       |//  Created by Andrew Breckenridge on 8/30/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(iOS)
   10|       |
   11|       |import UIKit
   12|       |
   13|       |#if !RX_NO_MODULE
   14|       |import RxSwift
   15|       |#endif
   16|       |
   17|       |    extension UIWebView {
   18|       |
   19|       |        /// Factory method that enables subclasses to implement their own `delegate`.
   20|       |        ///
   21|       |        /// - returns: Instance of delegate proxy that wraps `delegate`.
   22|      0|        public func createRxDelegateProxy() -> RxWebViewDelegateProxy {
   23|      0|            return RxWebViewDelegateProxy(parentObject: self)
   24|      0|        }
   25|       |
   26|       |    }
   27|       |    
   28|       |    extension Reactive where Base: UIWebView {
   29|       |
   30|       |        /// Reactive wrapper for `delegate`.
   31|       |        /// For more information take a look at `DelegateProxyType` protocol documentation.
   32|      0|        public var delegate: DelegateProxy {
   33|      0|            return RxWebViewDelegateProxy.proxyForObject(base)
   34|      0|        }
   35|       |
   36|       |        /// Reactive wrapper for `delegate` message.
   37|      0|        public var didStartLoad: Observable<Void> {
   38|      0|            return delegate
   39|      0|                .methodInvoked(#selector(UIWebViewDelegate.webViewDidStartLoad(_:)))
   40|      0|                .map {_ in}
   41|      0|        }
   42|       |
   43|       |        /// Reactive wrapper for `delegate` message.
   44|      0|        public var didFinishLoad: Observable<Void> {
   45|      0|            return delegate
   46|      0|                .methodInvoked(#selector(UIWebViewDelegate.webViewDidFinishLoad(_:)))
   47|      0|                .map {_ in}
   48|      0|        }
   49|       |        
   50|       |        /// Reactive wrapper for `delegate` message.
   51|      0|        public var didFailLoad: Observable<Error> {
   52|      0|            return delegate
   53|      0|                .methodInvoked(#selector(UIWebViewDelegate.webView(_:didFailLoadWithError:)))
   54|      0|                .map { a in
   55|      0|                    return try castOrThrow(Error.self, a[1])
   56|      0|                }
   57|      0|        }
   58|       |    }
   59|       |
   60|       |#endif

