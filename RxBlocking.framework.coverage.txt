/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/Platform/DataStructures/Bag.swift:
    1|       |//
    2|       |//  Bag.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 2/28/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Swift
   10|       |
   11|       |let arrayDictionaryMaxSize = 30
   12|       |
   13|       |struct BagKey {
   14|       |    /**
   15|       |    Unique identifier for object added to `Bag`.
   16|       |     
   17|       |    It's underlying type is UInt64. If we assume there in an idealized CPU that works at 4GHz,
   18|       |     it would take ~150 years of continuous running time for it to overflow.
   19|       |    */
   20|       |    fileprivate let rawValue: UInt64
   21|       |}
   22|       |
   23|       |/**
   24|       |Data structure that represents a bag of elements typed `T`.
   25|       |
   26|       |Single element can be stored multiple times.
   27|       |
   28|       |Time and space complexity of insertion an deletion is O(n). 
   29|       |
   30|       |It is suitable for storing small number of elements.
   31|       |*/
   32|       |struct Bag<T> : CustomDebugStringConvertible {
   33|       |    /// Type of identifier for inserted elements.
   34|       |    typealias KeyType = BagKey
   35|       |    
   36|       |    typealias Entry = (key: BagKey, value: T)
   37|       | 
   38|       |    fileprivate var _nextKey: BagKey = BagKey(rawValue: 0)
   39|       |
   40|       |    // data
   41|       |
   42|       |    // first fill inline variables
   43|       |    var _key0: BagKey? = nil
   44|       |    var _value0: T? = nil
   45|       |
   46|       |    // then fill "array dictionary"
   47|       |    var _pairs = ContiguousArray<Entry>()
   48|       |
   49|       |    // last is sparse dictionary
   50|       |    var _dictionary: [BagKey : T]? = nil
   51|       |
   52|       |    var _onlyFastPath = true
   53|       |
   54|       |    /// Creates new empty `Bag`.
   55|      0|    init() {
   56|      0|    }
   57|       |    
   58|       |    /**
   59|       |    Inserts `value` into bag.
   60|       |    
   61|       |    - parameter element: Element to insert.
   62|       |    - returns: Key that can be used to remove element from bag.
   63|       |    */
   64|      0|    mutating func insert(_ element: T) -> BagKey {
   65|      0|        let key = _nextKey
   66|      0|
   67|      0|        _nextKey = BagKey(rawValue: _nextKey.rawValue &+ 1)
   68|      0|
   69|      0|        if _key0 == nil {
   70|      0|            _key0 = key
   71|      0|            _value0 = element
   72|      0|            return key
   73|      0|        }
   74|      0|
   75|      0|        _onlyFastPath = false
   76|      0|
   77|      0|        if _dictionary != nil {
   78|      0|            _dictionary![key] = element
   79|      0|            return key
   80|      0|        }
   81|      0|
   82|      0|        if _pairs.count < arrayDictionaryMaxSize {
   83|      0|            _pairs.append(key: key, value: element)
   84|      0|            return key
   85|      0|        }
   86|      0|
   87|      0|        if _dictionary == nil {
   88|      0|            _dictionary = [:]
   89|      0|        }
   90|      0|
   91|      0|        _dictionary![key] = element
   92|      0|        
   93|      0|        return key
   94|      0|    }
   95|       |    
   96|       |    /// - returns: Number of elements in bag.
   97|      0|    var count: Int {
   98|      0|        let dictionaryCount: Int = _dictionary?.count ?? 0
   99|      0|        return (_value0 != nil ? 1 : 0) + _pairs.count + dictionaryCount
  100|      0|    }
  101|       |    
  102|       |    /// Removes all elements from bag and clears capacity.
  103|      0|    mutating func removeAll() {
  104|      0|        _key0 = nil
  105|      0|        _value0 = nil
  106|      0|
  107|      0|        _pairs.removeAll(keepingCapacity: false)
  108|      0|        _dictionary?.removeAll(keepingCapacity: false)
  109|      0|    }
  110|       |    
  111|       |    /**
  112|       |    Removes element with a specific `key` from bag.
  113|       |    
  114|       |    - parameter key: Key that identifies element to remove from bag.
  115|       |    - returns: Element that bag contained, or nil in case element was already removed.
  116|       |    */
  117|      0|    mutating func removeKey(_ key: BagKey) -> T? {
  118|      0|        if _key0 == key {
  119|      0|            _key0 = nil
  120|      0|            let value = _value0!
  121|      0|            _value0 = nil
  122|      0|            return value
  123|      0|        }
  124|      0|
  125|      0|        if let existingObject = _dictionary?.removeValue(forKey: key) {
  126|      0|            return existingObject
  127|      0|        }
  128|      0|
  129|      0|        for i in 0 ..< _pairs.count {
  130|      0|            if _pairs[i].key == key {
  131|      0|                let value = _pairs[i].value
  132|      0|                _pairs.remove(at: i)
  133|      0|                return value
  134|      0|            }
  135|      0|        }
  136|      0|
  137|      0|        return nil
  138|      0|    }
  139|       |}
  140|       |
  141|       |extension Bag {
  142|       |    /// A textual representation of `self`, suitable for debugging.
  143|      0|    var debugDescription : String {
  144|      0|        return "\(self.count) elements in Bag"
  145|      0|    }
  146|       |}
  147|       |
  148|       |extension Bag {
  149|       |    /// Enumerates elements inside the bag.
  150|       |    ///
  151|       |    /// - parameter action: Enumeration closure.
  152|      0|    func forEach(_ action: (T) -> Void) {
  153|      0|        if _onlyFastPath {
  154|      0|            if let value0 = _value0 {
  155|      0|                action(value0)
  156|      0|            }
  157|      0|            return
  158|      0|        }
  159|      0|
  160|      0|        let value0 = _value0
  161|      0|        let dictionary = _dictionary
  162|      0|
  163|      0|        if let value0 = value0 {
  164|      0|            action(value0)
  165|      0|        }
  166|      0|
  167|      0|        for i in 0 ..< _pairs.count {
  168|      0|            action(_pairs[i].value)
  169|      0|        }
  170|      0|
  171|      0|        if dictionary?.count ?? 0 > 0 {
  172|      0|            for element in dictionary!.values {
  173|      0|                action(element)
  174|      0|            }
  175|      0|        }
  176|      0|    }
  177|       |}
  178|       |
  179|       |extension BagKey: Hashable {
  180|      0|    var hashValue: Int {
  181|      0|        return rawValue.hashValue
  182|      0|    }
  183|       |}
  184|       |
  185|      0|func ==(lhs: BagKey, rhs: BagKey) -> Bool {
  186|      0|    return lhs.rawValue == rhs.rawValue
  187|      0|}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/Platform/DataStructures/InfiniteSequence.swift:
    1|       |//
    2|       |//  InfiniteSequence.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 6/13/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/// Sequence that repeats `repeatedValue` infinite number of times.
   10|       |struct InfiniteSequence<E> : Sequence {
   11|       |    typealias Element = E
   12|       |    typealias Iterator = AnyIterator<E>
   13|       |    
   14|       |    private let _repeatedValue: E
   15|       |    
   16|      0|    init(repeatedValue: E) {
   17|      0|        _repeatedValue = repeatedValue
   18|      0|    }
   19|       |    
   20|      0|    func makeIterator() -> Iterator {
   21|      0|        let repeatedValue = _repeatedValue
   22|      0|        return AnyIterator {
   23|      0|            return repeatedValue
   24|      0|        }
   25|      0|    }
   26|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/Platform/DataStructures/PriorityQueue.swift:
    1|       |//
    2|       |//  PriorityQueue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/27/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |struct PriorityQueue<Element> {
   10|       |    private let _hasHigherPriority: (Element, Element) -> Bool
   11|       |    private let _isEqual: (Element, Element) -> Bool
   12|       |
   13|       |    fileprivate var _elements = [Element]()
   14|       |
   15|      0|    init(hasHigherPriority: @escaping (Element, Element) -> Bool, isEqual: @escaping (Element, Element) -> Bool) {
   16|      0|        _hasHigherPriority = hasHigherPriority
   17|      0|        _isEqual = isEqual
   18|      0|    }
   19|       |
   20|      0|    mutating func enqueue(_ element: Element) {
   21|      0|        _elements.append(element)
   22|      0|        bubbleToHigherPriority(_elements.count - 1)
   23|      0|    }
   24|       |
   25|      0|    func peek() -> Element? {
   26|      0|        return _elements.first
   27|      0|    }
   28|       |
   29|      0|    var isEmpty: Bool {
   30|      0|        return _elements.count == 0
   31|      0|    }
   32|       |
   33|      0|    mutating func dequeue() -> Element? {
   34|      0|        guard let front = peek() else {
   35|      0|            return nil
   36|      0|        }
   37|      0|
   38|      0|        removeAt(0)
   39|      0|
   40|      0|        return front
   41|      0|    }
   42|       |
   43|      0|    mutating func remove(_ element: Element) {
   44|      0|        for i in 0 ..< _elements.count {
   45|      0|            if _isEqual(_elements[i], element) {
   46|      0|                removeAt(i)
   47|      0|                return
   48|      0|            }
   49|      0|        }
   50|      0|    }
   51|       |
   52|      0|    private mutating func removeAt(_ index: Int) {
   53|      0|        let removingLast = index == _elements.count - 1
   54|      0|        if !removingLast {
   55|      0|            swap(&_elements[index], &_elements[_elements.count - 1])
   56|      0|        }
   57|      0|
   58|      0|        _ = _elements.popLast()
   59|      0|
   60|      0|        if !removingLast {
   61|      0|            bubbleToHigherPriority(index)
   62|      0|            bubbleToLowerPriority(index)
   63|      0|        }
   64|      0|    }
   65|       |
   66|      0|    private mutating func bubbleToHigherPriority(_ initialUnbalancedIndex: Int) {
   67|      0|        precondition(initialUnbalancedIndex >= 0)
   68|      0|        precondition(initialUnbalancedIndex < _elements.count)
   69|      0|
   70|      0|        var unbalancedIndex = initialUnbalancedIndex
   71|      0|
   72|      0|        while unbalancedIndex > 0 {
   73|      0|            let parentIndex = (unbalancedIndex - 1) / 2
   74|      0|            guard _hasHigherPriority(_elements[unbalancedIndex], _elements[parentIndex]) else { break }
   75|      0|            
   76|      0|            swap(&_elements[unbalancedIndex], &_elements[parentIndex])
   77|      0|            unbalancedIndex = parentIndex
   78|      0|        }
   79|      0|    }
   80|       |
   81|      0|    private mutating func bubbleToLowerPriority(_ initialUnbalancedIndex: Int) {
   82|      0|        precondition(initialUnbalancedIndex >= 0)
   83|      0|        precondition(initialUnbalancedIndex < _elements.count)
   84|      0|
   85|      0|        var unbalancedIndex = initialUnbalancedIndex
   86|      0|        while true {
   87|      0|            let leftChildIndex = unbalancedIndex * 2 + 1
   88|      0|            let rightChildIndex = unbalancedIndex * 2 + 2
   89|      0|
   90|      0|            var highestPriorityIndex = unbalancedIndex
   91|      0|
   92|      0|            if leftChildIndex < _elements.count && _hasHigherPriority(_elements[leftChildIndex], _elements[highestPriorityIndex]) {
   93|      0|                highestPriorityIndex = leftChildIndex
   94|      0|            }
   95|      0|
   96|      0|            if rightChildIndex < _elements.count && _hasHigherPriority(_elements[rightChildIndex], _elements[highestPriorityIndex]) {
   97|      0|                highestPriorityIndex = rightChildIndex
   98|      0|            }
   99|      0|
  100|      0|            guard highestPriorityIndex != unbalancedIndex else { break }
  101|      0|
  102|      0|            swap(&_elements[highestPriorityIndex], &_elements[unbalancedIndex])
  103|      0|            unbalancedIndex = highestPriorityIndex
  104|      0|        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |extension PriorityQueue : CustomDebugStringConvertible {
  109|      0|    var debugDescription: String {
  110|      0|        return _elements.debugDescription
  111|      0|    }
  112|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/Platform/DataStructures/Queue.swift:
    1|       |//
    2|       |//  Queue.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 3/21/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |/**
   10|       |Data structure that represents queue.
   11|       |
   12|       |Complexity of `enqueue`, `dequeue` is O(1) when number of operations is
   13|       |averaged over N operations.
   14|       |
   15|       |Complexity of `peek` is O(1).
   16|       |*/
   17|       |struct Queue<T>: Sequence {
   18|       |    /// Type of generator.
   19|       |    typealias Generator = AnyIterator<T>
   20|       |
   21|       |    private let _resizeFactor = 2
   22|       |    
   23|       |    private var _storage: ContiguousArray<T?>
   24|       |    private var _count = 0
   25|       |    private var _pushNextIndex = 0
   26|       |    private let _initialCapacity: Int
   27|       |
   28|       |    /**
   29|       |    Creates new queue.
   30|       |    
   31|       |    - parameter capacity: Capacity of newly created queue.
   32|       |    */
   33|      0|    init(capacity: Int) {
   34|      0|        _initialCapacity = capacity
   35|      0|
   36|      0|        _storage = ContiguousArray<T?>(repeating: nil, count: capacity)
   37|      0|    }
   38|       |    
   39|      0|    private var dequeueIndex: Int {
   40|      0|        let index = _pushNextIndex - count
   41|      0|        return index < 0 ? index + _storage.count : index
   42|      0|    }
   43|       |    
   44|       |    /// - returns: Is queue empty.
   45|      0|    var isEmpty: Bool {
   46|      0|        return count == 0
   47|      0|    }
   48|       |    
   49|       |    /// - returns: Number of elements inside queue.
   50|      0|    var count: Int {
   51|      0|        return _count
   52|      0|    }
   53|       |    
   54|       |    /// - returns: Element in front of a list of elements to `dequeue`.
   55|      0|    func peek() -> T {
   56|      0|        precondition(count > 0)
   57|      0|        
   58|      0|        return _storage[dequeueIndex]!
   59|      0|    }
   60|       |    
   61|      0|    mutating private func resizeTo(_ size: Int) {
   62|      0|        var newStorage = ContiguousArray<T?>(repeating: nil, count: size)
   63|      0|        
   64|      0|        let count = _count
   65|      0|        
   66|      0|        let dequeueIndex = self.dequeueIndex
   67|      0|        let spaceToEndOfQueue = _storage.count - dequeueIndex
   68|      0|        
   69|      0|        // first batch is from dequeue index to end of array
   70|      0|        let countElementsInFirstBatch = Swift.min(count, spaceToEndOfQueue)
   71|      0|        // second batch is wrapped from start of array to end of queue
   72|      0|        let numberOfElementsInSecondBatch = count - countElementsInFirstBatch
   73|      0|        
   74|      0|        newStorage[0 ..< countElementsInFirstBatch] = _storage[dequeueIndex ..< (dequeueIndex + countElementsInFirstBatch)]
   75|      0|        newStorage[countElementsInFirstBatch ..< (countElementsInFirstBatch + numberOfElementsInSecondBatch)] = _storage[0 ..< numberOfElementsInSecondBatch]
   76|      0|        
   77|      0|        _count = count
   78|      0|        _pushNextIndex = count
   79|      0|        _storage = newStorage
   80|      0|    }
   81|       |    
   82|       |    /// Enqueues `element`.
   83|       |    ///
   84|       |    /// - parameter element: Element to enqueue.
   85|      0|    mutating func enqueue(_ element: T) {
   86|      0|        if count == _storage.count {
   87|      0|            resizeTo(Swift.max(_storage.count, 1) * _resizeFactor)
   88|      0|        }
   89|      0|        
   90|      0|        _storage[_pushNextIndex] = element
   91|      0|        _pushNextIndex += 1
   92|      0|        _count += 1
   93|      0|        
   94|      0|        if _pushNextIndex >= _storage.count {
   95|      0|            _pushNextIndex -= _storage.count
   96|      0|        }
   97|      0|    }
   98|       |    
   99|      0|    private mutating func dequeueElementOnly() -> T {
  100|      0|        precondition(count > 0)
  101|      0|        
  102|      0|        let index = dequeueIndex
  103|      0|
  104|      0|        defer {
  105|      0|            _storage[index] = nil
  106|      0|            _count -= 1
  107|      0|        }
  108|      0|
  109|      0|        return _storage[index]!
  110|      0|    }
  111|       |
  112|       |    /// Dequeues element or throws an exception in case queue is empty.
  113|       |    ///
  114|       |    /// - returns: Dequeued element.
  115|      0|    mutating func dequeue() -> T? {
  116|      0|        if self.count == 0 {
  117|      0|            return nil
  118|      0|        }
  119|      0|
  120|      0|        defer {
  121|      0|            let downsizeLimit = _storage.count / (_resizeFactor * _resizeFactor)
  122|      0|            if _count < downsizeLimit && downsizeLimit >= _initialCapacity {
  123|      0|                resizeTo(_storage.count / _resizeFactor)
  124|      0|            }
  125|      0|        }
  126|      0|
  127|      0|        return dequeueElementOnly()
  128|      0|    }
  129|       |    
  130|       |    /// - returns: Generator of contained elements.
  131|      0|    func makeIterator() -> AnyIterator<T> {
  132|      0|        var i = dequeueIndex
  133|      0|        var count = _count
  134|      0|
  135|      0|        return AnyIterator {
  136|      0|            if count == 0 {
  137|      0|                return nil
  138|      0|            }
  139|      0|
  140|      0|            defer {
  141|      0|                count -= 1
  142|      0|                i += 1
  143|      0|            }
  144|      0|
  145|      0|            if i >= self._storage.count {
  146|      0|                i -= self._storage.count
  147|      0|            }
  148|      0|
  149|      0|            return self._storage[i]
  150|      0|        }
  151|      0|    }
  152|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/Platform/DispatchQueue+Extensions.swift:
    1|       |//
    2|       |//  DispatchQueue+Extensions.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/22/16.
    6|       |//  Copyright © 2016 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import Dispatch
   10|       |
   11|       |extension DispatchQueue {
   12|       |    private static var token: DispatchSpecificKey<()> = {
   13|       |        let key = DispatchSpecificKey<()>()
   14|       |        DispatchQueue.main.setSpecific(key: key, value: ())
   15|       |        return key
   16|       |    }()
   17|       |
   18|      0|    static var isMain: Bool {
   19|      0|        return DispatchQueue.getSpecific(key: token) != nil
   20|      0|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/Platform/Platform.Darwin.swift:
    1|       |//
    2|       |//  Platform.Darwin.swift
    3|       |//  Platform
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 12/29/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if os(macOS) || os(iOS) || os(tvOS) || os(watchOS)
   10|       |
   11|       |    import Darwin
   12|       |    import class Foundation.Thread
   13|       |    import func Foundation.OSAtomicCompareAndSwap32Barrier
   14|       |    import func Foundation.OSAtomicIncrement32Barrier
   15|       |    import func Foundation.OSAtomicDecrement32Barrier
   16|       |    import protocol Foundation.NSCopying
   17|       |
   18|       |    typealias AtomicInt = Int32
   19|       |
   20|      0|    fileprivate func castToUInt32Pointer(_ pointer: UnsafeMutablePointer<Int32>) -> UnsafeMutablePointer<UInt32> {
   21|      0|        let raw = UnsafeMutableRawPointer(pointer)
   22|      0|        return raw.assumingMemoryBound(to: UInt32.self)
   23|      0|    }
   24|       |
   25|       |    let AtomicCompareAndSwap = OSAtomicCompareAndSwap32Barrier
   26|       |    let AtomicIncrement = OSAtomicIncrement32Barrier
   27|       |    let AtomicDecrement = OSAtomicDecrement32Barrier
   28|      0|    func AtomicOr(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Int32 {
   29|      0|        return OSAtomicOr32OrigBarrier(mask, castToUInt32Pointer(theValue))
   30|      0|    }
   31|      0|    func AtomicFlagSet(_ mask: UInt32, _ theValue : UnsafeMutablePointer<Int32>) -> Bool {
   32|      0|        // just used to create a barrier
   33|      0|        OSAtomicXor32OrigBarrier(0, castToUInt32Pointer(theValue))
   34|      0|        return (theValue.pointee & Int32(mask)) != 0
   35|      0|    }
   36|       |
   37|       |    extension Thread {
   38|       |
   39|       |        static func setThreadLocalStorageValue<T: AnyObject>(_ value: T?, forKey key: NSCopying
   40|      0|            ) {
   41|      0|            let currentThread = Thread.current
   42|      0|            let threadDictionary = currentThread.threadDictionary
   43|      0|
   44|      0|            if let newValue = value {
   45|      0|                threadDictionary[key] = newValue
   46|      0|            }
   47|      0|            else {
   48|      0|                threadDictionary[key] = nil
   49|      0|            }
   50|      0|
   51|      0|        }
   52|      0|        static func getThreadLocalStorageValueForKey<T>(_ key: NSCopying) -> T? {
   53|      0|            let currentThread = Thread.current
   54|      0|            let threadDictionary = currentThread.threadDictionary
   55|      0|            
   56|      0|            return threadDictionary[key] as? T
   57|      0|        }
   58|       |    }
   59|       |
   60|       |    extension AtomicInt {
   61|      0|        func valueSnapshot() -> Int32 {
   62|      0|            return self
   63|      0|        }
   64|       |    }
   65|       |    
   66|       |#endif

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/RxBlocking/BlockingObservable+Operators.swift:
    1|       |//
    2|       |//  BlockingObservable+Operators.swift
    3|       |//  RxBlocking
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 10/19/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |    import RxSwift
   11|       |#endif
   12|       |
   13|       |extension BlockingObservable {
   14|       |    /// Blocks current thread until sequence terminates.
   15|       |    ///
   16|       |    /// If sequence terminates with error, terminating error will be thrown.
   17|       |    ///
   18|       |    /// - returns: All elements of sequence.
   19|      0|    public func toArray() throws -> [E] {
   20|      0|        var elements: [E] = Array<E>()
   21|      0|
   22|      0|        var error: Swift.Error?
   23|      0|
   24|      0|        let lock = RunLoopLock(timeout: timeout)
   25|      0|
   26|      0|        let d = SingleAssignmentDisposable()
   27|      0|
   28|      0|        defer {
   29|      0|            d.dispose()
   30|      0|        }
   31|      0|
   32|      0|        lock.dispatch {
   33|      0|            let subscription = self.source.subscribe { e in
   34|      0|                if d.isDisposed {
   35|      0|                    return
   36|      0|                }
   37|      0|                switch e {
   38|      0|                case .next(let element):
   39|      0|                    elements.append(element)
   40|      0|                case .error(let e):
   41|      0|                    error = e
   42|      0|                    d.dispose()
   43|      0|                    lock.stop()
   44|      0|                case .completed:
   45|      0|                    d.dispose()
   46|      0|                    lock.stop()
   47|      0|                }
   48|      0|            }
   49|      0|
   50|      0|            d.setDisposable(subscription)
   51|      0|        }
   52|      0|
   53|      0|        try lock.run()
   54|      0|
   55|      0|        if let error = error {
   56|      0|            throw error
   57|      0|        }
   58|      0|
   59|      0|        return elements
   60|      0|    }
   61|       |}
   62|       |
   63|       |extension BlockingObservable {
   64|       |    /// Blocks current thread until sequence produces first element.
   65|       |    ///
   66|       |    /// If sequence terminates with error before producing first element, terminating error will be thrown.
   67|       |    ///
   68|       |    /// - returns: First element of sequence. If sequence is empty `nil` is returned.
   69|      0|    public func first() throws -> E? {
   70|      0|        var element: E?
   71|      0|
   72|      0|        var error: Swift.Error?
   73|      0|
   74|      0|        let d = SingleAssignmentDisposable()
   75|      0|
   76|      0|        defer {
   77|      0|            d.dispose()
   78|      0|        }
   79|      0|        
   80|      0|        let lock = RunLoopLock(timeout: timeout)
   81|      0|
   82|      0|        lock.dispatch {
   83|      0|            let subscription = self.source.subscribe { e in
   84|      0|                if d.isDisposed {
   85|      0|                    return
   86|      0|                }
   87|      0|
   88|      0|                switch e {
   89|      0|                case .next(let e):
   90|      0|                    if element == nil {
   91|      0|                        element = e
   92|      0|                    }
   93|      0|                    break
   94|      0|                case .error(let e):
   95|      0|                    error = e
   96|      0|                default:
   97|      0|                    break
   98|      0|                }
   99|      0|
  100|      0|                d.dispose()
  101|      0|                lock.stop()
  102|      0|            }
  103|      0|
  104|      0|            d.setDisposable(subscription)
  105|      0|        }
  106|      0|
  107|      0|        try lock.run()
  108|      0|
  109|      0|        if let error = error {
  110|      0|            throw error
  111|      0|        }
  112|      0|
  113|      0|        return element
  114|      0|    }
  115|       |}
  116|       |
  117|       |extension BlockingObservable {
  118|       |    /// Blocks current thread until sequence terminates.
  119|       |    ///
  120|       |    /// If sequence terminates with error, terminating error will be thrown.
  121|       |    ///
  122|       |    /// - returns: Last element in the sequence. If sequence is empty `nil` is returned.
  123|      0|    public func last() throws -> E? {
  124|      0|        var element: E?
  125|      0|
  126|      0|        var error: Swift.Error?
  127|      0|
  128|      0|        let d = SingleAssignmentDisposable()
  129|      0|
  130|      0|        defer {
  131|      0|            d.dispose()
  132|      0|        }
  133|      0|        
  134|      0|        let lock = RunLoopLock(timeout: timeout)
  135|      0|
  136|      0|        lock.dispatch {
  137|      0|            let subscription = self.source.subscribe { e in
  138|      0|                if d.isDisposed {
  139|      0|                    return
  140|      0|                }
  141|      0|                switch e {
  142|      0|                case .next(let e):
  143|      0|                    element = e
  144|      0|                    return
  145|      0|                case .error(let e):
  146|      0|                    error = e
  147|      0|                default:
  148|      0|                    break
  149|      0|                }
  150|      0|
  151|      0|                d.dispose()
  152|      0|                lock.stop()
  153|      0|            }
  154|      0|
  155|      0|            d.setDisposable(subscription)
  156|      0|        }
  157|      0|        
  158|      0|        try lock.run()
  159|      0|        
  160|      0|        if let error = error {
  161|      0|            throw error
  162|      0|        }
  163|      0|        
  164|      0|        return element
  165|      0|    }
  166|       |}
  167|       |
  168|       |extension BlockingObservable {
  169|       |    /// Blocks current thread until sequence terminates.
  170|       |    ///
  171|       |    /// If sequence terminates with error before producing first element, terminating error will be thrown.
  172|       |    ///
  173|       |    /// - returns: Returns the only element of an sequence, and reports an error if there is not exactly one element in the observable sequence.
  174|      0|    public func single() throws -> E? {
  175|      0|        return try single { _ in true }
  176|      0|    }
  177|       |
  178|       |    /// Blocks current thread until sequence terminates.
  179|       |    ///
  180|       |    /// If sequence terminates with error before producing first element, terminating error will be thrown.
  181|       |    ///
  182|       |    /// - parameter predicate: A function to test each source element for a condition.
  183|       |    /// - returns: Returns the only element of an sequence that satisfies the condition in the predicate, and reports an error if there is not exactly one element in the sequence.
  184|      0|    public func single(_ predicate: @escaping (E) throws -> Bool) throws -> E? {
  185|      0|        var element: E?
  186|      0|        
  187|      0|        var error: Swift.Error?
  188|      0|        
  189|      0|        let d = SingleAssignmentDisposable()
  190|      0|
  191|      0|        defer {
  192|      0|            d.dispose()
  193|      0|        }
  194|      0|        
  195|      0|        let lock = RunLoopLock(timeout: timeout)
  196|      0|        
  197|      0|        lock.dispatch {
  198|      0|            let subscription = self.source.subscribe { e in
  199|      0|                if d.isDisposed {
  200|      0|                    return
  201|      0|                }
  202|      0|                switch e {
  203|      0|                case .next(let e):
  204|      0|                    do {
  205|      0|                        if try !predicate(e) {
  206|      0|                            return
  207|      0|                        }
  208|      0|                        if element == nil {
  209|      0|                            element = e
  210|      0|                        } else {
  211|      0|                            throw RxError.moreThanOneElement
  212|      0|                        }
  213|      0|                    } catch (let err) {
  214|      0|                        error = err
  215|      0|                        d.dispose()
  216|      0|                        lock.stop()
  217|      0|                    }
  218|      0|                    return
  219|      0|                case .error(let e):
  220|      0|                    error = e
  221|      0|                case .completed:
  222|      0|                    if element == nil {
  223|      0|                        error = RxError.noElements
  224|      0|                    }
  225|      0|                }
  226|      0|
  227|      0|                d.dispose()
  228|      0|                lock.stop()
  229|      0|            }
  230|      0|
  231|      0|            d.setDisposable(subscription)
  232|      0|        }
  233|      0|        
  234|      0|        try lock.run()
  235|      0|
  236|      0|        if let error = error {
  237|      0|            throw error
  238|      0|        }
  239|      0|        
  240|      0|        return element
  241|      0|    }
  242|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/RxBlocking/ObservableConvertibleType+Blocking.swift:
    1|       |//
    2|       |//  ObservableConvertibleType+Blocking.swift
    3|       |//  RxBlocking
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 7/12/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |#if !RX_NO_MODULE
   10|       |import RxSwift
   11|       |#endif
   12|       |
   13|       |extension ObservableConvertibleType {
   14|       |    /// Converts an Observable into a `BlockingObservable` (an Observable with blocking operators).
   15|       |    ///
   16|       |    /// - parameter timeout: Maximal time interval BlockingObservable can block without throwing `RxError.timeout`.
   17|       |    /// - returns: `BlockingObservable` version of `self`
   18|      0|    public func toBlocking(timeout: RxTimeInterval? = nil) -> BlockingObservable<E> {
   19|      0|        return BlockingObservable(timeout: timeout, source: self.asObservable())
   20|      0|    }
   21|       |}

/Users/won/IO/Switcher-m-iOS/Pods/RxBlocking/RxBlocking/RunLoopLock.swift:
    1|       |//
    2|       |//  RunLoopLock.swift
    3|       |//  RxBlocking
    4|       |//
    5|       |//  Created by Krunoslav Zaher on 11/5/15.
    6|       |//  Copyright © 2015 Krunoslav Zaher. All rights reserved.
    7|       |//
    8|       |
    9|       |import CoreFoundation
   10|       |
   11|       |#if !RX_NO_MODULE
   12|       |    import RxSwift
   13|       |#endif
   14|       |
   15|       |#if os(Linux)
   16|       |    import Foundation
   17|       |    let runLoopMode: RunLoopMode = RunLoopMode.defaultRunLoopMode
   18|       |    let runLoopModeRaw: CFString = unsafeBitCast(runLoopMode.rawValue._bridgeToObjectiveC(), to: CFString.self)
   19|       |#else
   20|       |    let runLoopMode: CFRunLoopMode = CFRunLoopMode.defaultMode
   21|       |    let runLoopModeRaw = runLoopMode.rawValue
   22|       |#endif
   23|       |
   24|       |final class RunLoopLock {
   25|       |    let _currentRunLoop: CFRunLoop
   26|       |
   27|       |    var _calledRun: AtomicInt = 0
   28|       |    var _calledStop: AtomicInt = 0
   29|       |    var _timeout: RxTimeInterval?
   30|       |
   31|      0|    init(timeout: RxTimeInterval?) {
   32|      0|        _timeout = timeout
   33|      0|        _currentRunLoop = CFRunLoopGetCurrent()
   34|      0|    }
   35|       |
   36|      0|    func dispatch(_ action: @escaping () -> ()) {
   37|      0|        CFRunLoopPerformBlock(_currentRunLoop, runLoopModeRaw) {
   38|      0|            if CurrentThreadScheduler.isScheduleRequired {
   39|      0|                _ = CurrentThreadScheduler.instance.schedule(()) { _ in
   40|      0|                    action()
   41|      0|                    return Disposables.create()
   42|      0|                }
   43|      0|            }
   44|      0|            else {
   45|      0|                action()
   46|      0|            }
   47|      0|        }
   48|      0|        CFRunLoopWakeUp(_currentRunLoop)
   49|      0|    }
   50|       |
   51|      0|    func stop() {
   52|      0|        if AtomicIncrement(&_calledStop) != 1 {
   53|      0|            return
   54|      0|        }
   55|      0|        CFRunLoopPerformBlock(_currentRunLoop, runLoopModeRaw) {
   56|      0|            CFRunLoopStop(self._currentRunLoop)
   57|      0|        }
   58|      0|        CFRunLoopWakeUp(_currentRunLoop)
   59|      0|    }
   60|       |
   61|      0|    func run() throws {
   62|      0|        if AtomicIncrement(&_calledRun) != 1 {
   63|      0|            fatalError("Run can be only called once")
   64|      0|        }
   65|      0|        if let timeout = _timeout {
   66|      0|            #if os(Linux)
   67|      0|                switch Int(CFRunLoopRunInMode(runLoopModeRaw, timeout, false)) {
   68|      0|                case kCFRunLoopRunFinished:
   69|      0|                    return
   70|      0|                case kCFRunLoopRunHandledSource:
   71|      0|                    return
   72|      0|                case kCFRunLoopRunStopped:
   73|      0|                    return
   74|      0|                case kCFRunLoopRunTimedOut:
   75|      0|                    throw RxError.timeout
   76|      0|                default:
   77|      0|                    fatalError("This failed because `CFRunLoopRunResult` wasn't bridged to Swift.")
   78|      0|                }
   79|      0|            #else
   80|      0|                switch CFRunLoopRunInMode(runLoopMode, timeout, false) {
   81|      0|                case .finished:
   82|      0|                    return
   83|      0|                case .handledSource:
   84|      0|                    return
   85|      0|                case .stopped:
   86|      0|                    return
   87|      0|                case .timedOut:
   88|      0|                    throw RxError.timeout
   89|      0|                }
   90|      0|            #endif
   91|      0|        }
   92|      0|        else {
   93|      0|            CFRunLoopRun()
   94|      0|        }
   95|      0|    }
   96|       |}

