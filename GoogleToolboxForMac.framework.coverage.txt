/Users/won/IO/Switcher-m-iOS/Pods/GoogleToolboxForMac/Foundation/GTMNSData+zlib.m:
    1|       |//
    2|       |//  GTMNSData+zlib.m
    3|       |//
    4|       |//  Copyright 2007-2008 Google Inc.
    5|       |//
    6|       |//  Licensed under the Apache License, Version 2.0 (the "License"); you may not
    7|       |//  use this file except in compliance with the License.  You may obtain a copy
    8|       |//  of the License at
    9|       |//
   10|       |//  http://www.apache.org/licenses/LICENSE-2.0
   11|       |//
   12|       |//  Unless required by applicable law or agreed to in writing, software
   13|       |//  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   14|       |//  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
   15|       |//  License for the specific language governing permissions and limitations under
   16|       |//  the License.
   17|       |//
   18|       |
   19|       |#import "GTMNSData+zlib.h"
   20|       |#import <zlib.h>
   21|       |#import "GTMDefines.h"
   22|       |
   23|      6|#define kChunkSize 1024
   24|       |
   25|       |NSString *const GTMNSDataZlibErrorDomain = @"com.google.GTMNSDataZlibErrorDomain";
   26|       |NSString *const GTMNSDataZlibErrorKey = @"GTMNSDataZlibErrorKey";
   27|       |NSString *const GTMNSDataZlibRemainingBytesKey = @"GTMNSDataZlibRemainingBytesKey";
   28|       |
   29|       |typedef enum {
   30|       |  CompressionModeZlib,
   31|       |  CompressionModeGzip,
   32|       |  CompressionModeRaw,
   33|       |} CompressionMode;
   34|       |
   35|       |@interface NSData (GTMZlibAdditionsPrivate)
   36|       |+ (NSData *)gtm_dataByCompressingBytes:(const void *)bytes
   37|       |                                length:(NSUInteger)length
   38|       |                      compressionLevel:(int)level
   39|       |                                  mode:(CompressionMode)mode
   40|       |                                 error:(NSError **)error;
   41|       |+ (NSData *)gtm_dataByInflatingBytes:(const void *)bytes
   42|       |                              length:(NSUInteger)length
   43|       |                           isRawData:(BOOL)isRawData
   44|       |                               error:(NSError **)error;
   45|       |@end
   46|       |
   47|       |@implementation NSData (GTMZlibAdditionsPrivate)
   48|       |
   49|       |+ (NSData *)gtm_dataByCompressingBytes:(const void *)bytes
   50|       |                                length:(NSUInteger)length
   51|       |                      compressionLevel:(int)level
   52|       |                                  mode:(CompressionMode)mode
   53|      3|                                 error:(NSError **)error {
   54|      3|  if (!bytes || !length) {
   55|      0|    return nil;
   56|      0|  }
   57|      3|
   58|      3|#if defined(__LP64__) && __LP64__
   59|      3|  // Don't support > 32bit length for 64 bit, see note in header.
   60|      3|  if (length > UINT_MAX) {
   61|      0|    if (error) {
   62|      0|      *error = [NSError errorWithDomain:GTMNSDataZlibErrorDomain
   63|      0|                                   code:GTMNSDataZlibErrorGreaterThan32BitsToCompress
   64|      0|                               userInfo:nil];
   65|      0|    }
   66|      0|    return nil;
   67|      0|  }
   68|      3|#endif
   69|      3|
   70|      3|  if (level == Z_DEFAULT_COMPRESSION) {
   71|      3|    // the default value is actually outside the range, so we have to let it
   72|      3|    // through specifically.
   73|      0|  } else if (level < Z_BEST_SPEED) {
   74|      0|    level = Z_BEST_SPEED;
   75|      0|  } else if (level > Z_BEST_COMPRESSION) {
   76|      0|    level = Z_BEST_COMPRESSION;
   77|      0|  }
   78|      3|
   79|      3|  z_stream strm;
   80|      3|  bzero(&strm, sizeof(z_stream));
   81|      3|
   82|      3|  int memLevel = 8; // the default
   83|      3|  int windowBits = 15; // the default
   84|      3|  switch (mode) {
   85|      0|    case CompressionModeZlib:
   86|      0|      // nothing to do
   87|      0|      break;
   88|      0|
   89|      3|    case CompressionModeGzip:
   90|      3|      windowBits += 16; // enable gzip header instead of zlib header
   91|      3|      break;
   92|      0|
   93|      0|    case CompressionModeRaw:
   94|      0|      windowBits *= -1; // Negative to mean no header.
   95|      0|      break;
   96|      3|  }
   97|      3|  int retCode;
   98|      3|  if ((retCode = deflateInit2(&strm, level, Z_DEFLATED, windowBits,
   99|      0|                              memLevel, Z_DEFAULT_STRATEGY)) != Z_OK) {
  100|      0|    // COV_NF_START - no real way to force this in a unittest (we guard all args)
  101|      0|    if (error) {
  102|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  103|      0|                                                           forKey:GTMNSDataZlibErrorKey];
  104|      0|      *error = [NSError errorWithDomain:GTMNSDataZlibErrorDomain
  105|      0|                                   code:GTMNSDataZlibErrorInternal
  106|      0|                               userInfo:userInfo];
  107|      0|    }
  108|      0|    return nil;
  109|      0|    // COV_NF_END
  110|      0|  }
  111|      3|
  112|      3|  // hint the size at 1/4 the input size
  113|      3|  NSMutableData *result = [NSMutableData dataWithCapacity:(length/4)];
  114|      3|  unsigned char output[kChunkSize];
  115|      3|
  116|      3|  // setup the input
  117|      3|  strm.avail_in = (unsigned int)length;
  118|      3|  strm.next_in = (unsigned char*)bytes;
  119|      3|
  120|      3|  // loop to collect the data
  121|      3|  do {
  122|      3|    // update what we're passing in
  123|      3|    strm.avail_out = kChunkSize;
  124|      3|    strm.next_out = output;
  125|      3|    retCode = deflate(&strm, Z_FINISH);
  126|      3|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
  127|      0|      // COV_NF_START - no real way to force this in a unittest
  128|      0|      // (in inflate, we can feed bogus/truncated data to test, but an error
  129|      0|      // here would be some internal issue w/in zlib, and there isn't any real
  130|      0|      // way to test it)
  131|      0|      if (error) {
  132|      0|        NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  133|      0|                                                             forKey:GTMNSDataZlibErrorKey];
  134|      0|        *error = [NSError errorWithDomain:GTMNSDataZlibErrorDomain
  135|      0|                                     code:GTMNSDataZlibErrorInternal
  136|      0|                                 userInfo:userInfo];
  137|      0|      }
  138|      0|      deflateEnd(&strm);
  139|      0|      return nil;
  140|      0|      // COV_NF_END
  141|      0|    }
  142|      3|    // collect what we got
  143|      3|    unsigned gotBack = kChunkSize - strm.avail_out;
  144|      3|    if (gotBack > 0) {
  145|      3|      [result appendBytes:output length:gotBack];
  146|      3|    }
  147|      3|
  148|      3|  } while (retCode == Z_OK);
  149|      3|
  150|      3|  // if the loop exits, we used all input and the stream ended
  151|      3|  _GTMDevAssert(strm.avail_in == 0,
  152|      3|                @"thought we finished deflate w/o using all input, %u bytes left",
  153|      3|                strm.avail_in);
  154|      3|  _GTMDevAssert(retCode == Z_STREAM_END,
  155|      3|                @"thought we finished deflate w/o getting a result of stream end, code %d",
  156|      3|                retCode);
  157|      3|
  158|      3|  // clean up
  159|      3|  deflateEnd(&strm);
  160|      3|
  161|      3|  return result;
  162|      3|} // gtm_dataByCompressingBytes:length:compressionLevel:useGzip:
  163|       |
  164|       |+ (NSData *)gtm_dataByInflatingBytes:(const void *)bytes
  165|       |                              length:(NSUInteger)length
  166|       |                           isRawData:(BOOL)isRawData
  167|      0|                               error:(NSError **)error {
  168|      0|  if (!bytes || !length) {
  169|      0|    return nil;
  170|      0|  }
  171|      0|
  172|      0|#if defined(__LP64__) && __LP64__
  173|      0|  // Don't support > 32bit length for 64 bit, see note in header.
  174|      0|  if (length > UINT_MAX) {
  175|      0|    return nil;
  176|      0|  }
  177|      0|#endif
  178|      0|
  179|      0|  z_stream strm;
  180|      0|  bzero(&strm, sizeof(z_stream));
  181|      0|
  182|      0|  // setup the input
  183|      0|  strm.avail_in = (unsigned int)length;
  184|      0|  strm.next_in = (unsigned char*)bytes;
  185|      0|
  186|      0|  int windowBits = 15; // 15 to enable any window size
  187|      0|  if (isRawData) {
  188|      0|    windowBits *= -1; // make it negative to signal no header.
  189|      0|  } else {
  190|      0|    windowBits += 32; // and +32 to enable zlib or gzip header detection.
  191|      0|  }
  192|      0|
  193|      0|  int retCode;
  194|      0|  if ((retCode = inflateInit2(&strm, windowBits)) != Z_OK) {
  195|      0|    // COV_NF_START - no real way to force this in a unittest (we guard all args)
  196|      0|    if (error) {
  197|      0|      NSDictionary *userInfo = [NSDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  198|      0|                                                           forKey:GTMNSDataZlibErrorKey];
  199|      0|      *error = [NSError errorWithDomain:GTMNSDataZlibErrorDomain
  200|      0|                                   code:GTMNSDataZlibErrorInternal
  201|      0|                               userInfo:userInfo];
  202|      0|    }
  203|      0|    return nil;
  204|      0|    // COV_NF_END
  205|      0|  }
  206|      0|
  207|      0|  // hint the size at 4x the input size
  208|      0|  NSMutableData *result = [NSMutableData dataWithCapacity:(length*4)];
  209|      0|  unsigned char output[kChunkSize];
  210|      0|
  211|      0|  // loop to collect the data
  212|      0|  do {
  213|      0|    // update what we're passing in
  214|      0|    strm.avail_out = kChunkSize;
  215|      0|    strm.next_out = output;
  216|      0|    retCode = inflate(&strm, Z_NO_FLUSH);
  217|      0|    if ((retCode != Z_OK) && (retCode != Z_STREAM_END)) {
  218|      0|      if (error) {
  219|      0|        NSMutableDictionary *userInfo =
  220|      0|            [NSMutableDictionary dictionaryWithObject:[NSNumber numberWithInt:retCode]
  221|      0|                                               forKey:GTMNSDataZlibErrorKey];
  222|      0|        if (strm.msg) {
  223|      0|          NSString *message = [NSString stringWithUTF8String:strm.msg];
  224|      0|          if (message) {
  225|      0|            [userInfo setObject:message forKey:NSLocalizedDescriptionKey];
  226|      0|          }
  227|      0|        }
  228|      0|        *error = [NSError errorWithDomain:GTMNSDataZlibErrorDomain
  229|      0|                                     code:GTMNSDataZlibErrorInternal
  230|      0|                                 userInfo:userInfo];
  231|      0|      }
  232|      0|      inflateEnd(&strm);
  233|      0|      return nil;
  234|      0|    }
  235|      0|    // collect what we got
  236|      0|    unsigned gotBack = kChunkSize - strm.avail_out;
  237|      0|    if (gotBack > 0) {
  238|      0|      [result appendBytes:output length:gotBack];
  239|      0|    }
  240|      0|
  241|      0|  } while (retCode == Z_OK);
  242|      0|
  243|      0|  // make sure there wasn't more data tacked onto the end of a valid compressed
  244|      0|  // stream.
  245|      0|  if (strm.avail_in != 0) {
  246|      0|    if (error) {
  247|      0|      NSDictionary *userInfo =
  248|      0|          [NSDictionary dictionaryWithObject:[NSNumber numberWithUnsignedInt:strm.avail_in]
  249|      0|                                      forKey:GTMNSDataZlibRemainingBytesKey];
  250|      0|      *error = [NSError errorWithDomain:GTMNSDataZlibErrorDomain
  251|      0|                                   code:GTMNSDataZlibErrorDataRemaining
  252|      0|                               userInfo:userInfo];
  253|      0|    }
  254|      0|    result = nil;
  255|      0|  }
  256|      0|  // the only way out of the loop was by hitting the end of the stream
  257|      0|  _GTMDevAssert(retCode == Z_STREAM_END,
  258|      0|                @"thought we finished inflate w/o getting a result of stream end, code %d",
  259|      0|                retCode);
  260|      0|
  261|      0|  // clean up
  262|      0|  inflateEnd(&strm);
  263|      0|
  264|      0|  return result;
  265|      0|} // gtm_dataByInflatingBytes:length:windowBits:
  266|       |
  267|       |@end
  268|       |
  269|       |
  270|       |@implementation NSData (GTMZLibAdditions)
  271|       |
  272|       |+ (NSData *)gtm_dataByGzippingBytes:(const void *)bytes
  273|      0|                             length:(NSUInteger)length {
  274|      0|  return [self gtm_dataByGzippingBytes:bytes length:length error:NULL];
  275|      0|} // gtm_dataByGzippingBytes:length:
  276|       |
  277|       |+ (NSData *)gtm_dataByGzippingBytes:(const void *)bytes
  278|       |                             length:(NSUInteger)length
  279|      0|                              error:(NSError **)error {
  280|      0|  return [self gtm_dataByCompressingBytes:bytes
  281|      0|                                   length:length
  282|      0|                         compressionLevel:Z_DEFAULT_COMPRESSION
  283|      0|                                     mode:CompressionModeGzip
  284|      0|                                    error:error];
  285|      0|} // gtm_dataByGzippingBytes:length:error:
  286|       |
  287|      0|+ (NSData *)gtm_dataByGzippingData:(NSData *)data {
  288|      0|  return [self gtm_dataByGzippingData:data error:NULL];
  289|      0|} // gtm_dataByGzippingData:
  290|       |
  291|      3|+ (NSData *)gtm_dataByGzippingData:(NSData *)data error:(NSError **)error {
  292|      3|  return [self gtm_dataByCompressingBytes:[data bytes]
  293|      3|                                   length:[data length]
  294|      3|                         compressionLevel:Z_DEFAULT_COMPRESSION
  295|      3|                                     mode:CompressionModeGzip
  296|      3|                                    error:error];
  297|      3|} // gtm_dataByGzippingData:error:
  298|       |
  299|       |+ (NSData *)gtm_dataByGzippingBytes:(const void *)bytes
  300|       |                             length:(NSUInteger)length
  301|      0|                   compressionLevel:(int)level {
  302|      0|  return [self gtm_dataByGzippingBytes:bytes
  303|      0|                                length:length
  304|      0|                      compressionLevel:level
  305|      0|                                 error:NULL];
  306|      0|} // gtm_dataByGzippingBytes:length:level:
  307|       |
  308|       |+ (NSData *)gtm_dataByGzippingBytes:(const void *)bytes
  309|       |                             length:(NSUInteger)length
  310|       |                   compressionLevel:(int)level
  311|      0|                              error:(NSError **)error{
  312|      0|  return [self gtm_dataByCompressingBytes:bytes
  313|      0|                                   length:length
  314|      0|                         compressionLevel:level
  315|      0|                                     mode:CompressionModeGzip
  316|      0|                                    error:error];
  317|      0|} // gtm_dataByGzippingBytes:length:level:error
  318|       |
  319|       |+ (NSData *)gtm_dataByGzippingData:(NSData *)data
  320|      0|                  compressionLevel:(int)level {
  321|      0|  return [self gtm_dataByGzippingData:data
  322|      0|                     compressionLevel:level
  323|      0|                                error:NULL];
  324|      0|} // gtm_dataByGzippingData:level:
  325|       |
  326|       |+ (NSData *)gtm_dataByGzippingData:(NSData *)data
  327|       |                  compressionLevel:(int)level
  328|      0|                             error:(NSError **)error{
  329|      0|  return [self gtm_dataByCompressingBytes:[data bytes]
  330|      0|                                   length:[data length]
  331|      0|                         compressionLevel:level
  332|      0|                                     mode:CompressionModeGzip
  333|      0|                                    error:error];
  334|      0|} // gtm_dataByGzippingData:level:error
  335|       |
  336|       |#pragma mark -
  337|       |
  338|       |+ (NSData *)gtm_dataByDeflatingBytes:(const void *)bytes
  339|      0|                              length:(NSUInteger)length {
  340|      0|  return [self gtm_dataByDeflatingBytes:bytes
  341|      0|                                 length:length
  342|      0|                                  error:NULL];
  343|      0|} // gtm_dataByDeflatingBytes:length:
  344|       |
  345|       |+ (NSData *)gtm_dataByDeflatingBytes:(const void *)bytes
  346|       |                              length:(NSUInteger)length
  347|      0|                               error:(NSError **)error{
  348|      0|  return [self gtm_dataByCompressingBytes:bytes
  349|      0|                                   length:length
  350|      0|                         compressionLevel:Z_DEFAULT_COMPRESSION
  351|      0|                                     mode:CompressionModeZlib
  352|      0|                                    error:error];
  353|      0|} // gtm_dataByDeflatingBytes:length:error
  354|       |
  355|      0|+ (NSData *)gtm_dataByDeflatingData:(NSData *)data {
  356|      0|  return [self gtm_dataByDeflatingData:data error:NULL];
  357|      0|} // gtm_dataByDeflatingData:
  358|       |
  359|      0|+ (NSData *)gtm_dataByDeflatingData:(NSData *)data error:(NSError **)error {
  360|      0|  return [self gtm_dataByCompressingBytes:[data bytes]
  361|      0|                                   length:[data length]
  362|      0|                         compressionLevel:Z_DEFAULT_COMPRESSION
  363|      0|                                     mode:CompressionModeZlib
  364|      0|                                    error:error];
  365|      0|} // gtm_dataByDeflatingData:
  366|       |
  367|       |+ (NSData *)gtm_dataByDeflatingBytes:(const void *)bytes
  368|       |                              length:(NSUInteger)length
  369|      0|                    compressionLevel:(int)level {
  370|      0|  return [self gtm_dataByDeflatingBytes:bytes
  371|      0|                                 length:length
  372|      0|                       compressionLevel:level
  373|      0|                                  error:NULL];
  374|      0|} // gtm_dataByDeflatingBytes:length:level:
  375|       |
  376|       |+ (NSData *)gtm_dataByDeflatingBytes:(const void *)bytes
  377|       |                              length:(NSUInteger)length
  378|       |                    compressionLevel:(int)level
  379|      0|                               error:(NSError **)error {
  380|      0|  return [self gtm_dataByCompressingBytes:bytes
  381|      0|                                   length:length
  382|      0|                         compressionLevel:level
  383|      0|                                     mode:CompressionModeZlib
  384|      0|                                    error:error];
  385|      0|} // gtm_dataByDeflatingBytes:length:level:error:
  386|       |
  387|       |+ (NSData *)gtm_dataByDeflatingData:(NSData *)data
  388|      0|                   compressionLevel:(int)level {
  389|      0|  return [self gtm_dataByDeflatingData:data
  390|      0|                      compressionLevel:level
  391|      0|                                 error:NULL];
  392|      0|} // gtm_dataByDeflatingData:level:
  393|       |
  394|       |+ (NSData *)gtm_dataByDeflatingData:(NSData *)data
  395|       |                   compressionLevel:(int)level
  396|      0|                              error:(NSError **)error {
  397|      0|  return [self gtm_dataByCompressingBytes:[data bytes]
  398|      0|                                   length:[data length]
  399|      0|                         compressionLevel:level
  400|      0|                                     mode:CompressionModeZlib
  401|      0|                                    error:error];
  402|      0|} // gtm_dataByDeflatingData:level:error:
  403|       |
  404|       |#pragma mark -
  405|       |
  406|       |+ (NSData *)gtm_dataByInflatingBytes:(const void *)bytes
  407|      0|                              length:(NSUInteger)length {
  408|      0|  return [self gtm_dataByInflatingBytes:bytes
  409|      0|                                 length:length
  410|      0|                                  error:NULL];
  411|      0|} // gtm_dataByInflatingBytes:length:
  412|       |
  413|       |+ (NSData *)gtm_dataByInflatingBytes:(const void *)bytes
  414|       |                              length:(NSUInteger)length
  415|      0|                               error:(NSError **)error {
  416|      0|  return [self gtm_dataByInflatingBytes:bytes
  417|      0|                                 length:length
  418|      0|                              isRawData:NO
  419|      0|                                  error:error];
  420|      0|} // gtm_dataByInflatingBytes:length:error:
  421|       |
  422|      0|+ (NSData *)gtm_dataByInflatingData:(NSData *)data {
  423|      0|  return [self gtm_dataByInflatingData:data error:NULL];
  424|      0|} // gtm_dataByInflatingData:
  425|       |
  426|       |+ (NSData *)gtm_dataByInflatingData:(NSData *)data
  427|      0|                              error:(NSError **)error {
  428|      0|  return [self gtm_dataByInflatingBytes:[data bytes]
  429|      0|                                 length:[data length]
  430|      0|                              isRawData:NO
  431|      0|                                  error:error];
  432|      0|} // gtm_dataByInflatingData:
  433|       |
  434|       |#pragma mark -
  435|       |
  436|       |+ (NSData *)gtm_dataByRawDeflatingBytes:(const void *)bytes
  437|      0|                                 length:(NSUInteger)length {
  438|      0|  return [self gtm_dataByRawDeflatingBytes:(const void *)bytes
  439|      0|                                    length:(NSUInteger)length
  440|      0|                                     error:NULL];
  441|      0|} // gtm_dataByRawDeflatingBytes:length:
  442|       |
  443|       |+ (NSData *)gtm_dataByRawDeflatingBytes:(const void *)bytes
  444|       |                                 length:(NSUInteger)length
  445|      0|                                  error:(NSError **)error {
  446|      0|  return [self gtm_dataByCompressingBytes:bytes
  447|      0|                                   length:length
  448|      0|                         compressionLevel:Z_DEFAULT_COMPRESSION
  449|      0|                                     mode:CompressionModeRaw
  450|      0|                                    error:error];
  451|      0|} // gtm_dataByRawDeflatingBytes:length:error:
  452|       |
  453|      0|+ (NSData *)gtm_dataByRawDeflatingData:(NSData *)data {
  454|      0|  return [self gtm_dataByRawDeflatingData:data error:NULL];
  455|      0|} // gtm_dataByRawDeflatingData:
  456|       |
  457|      0|+ (NSData *)gtm_dataByRawDeflatingData:(NSData *)data error:(NSError **)error {
  458|      0|  return [self gtm_dataByCompressingBytes:[data bytes]
  459|      0|                                   length:[data length]
  460|      0|                         compressionLevel:Z_DEFAULT_COMPRESSION
  461|      0|                                     mode:CompressionModeRaw
  462|      0|                                    error:error];
  463|      0|} // gtm_dataByRawDeflatingData:error:
  464|       |
  465|       |+ (NSData *)gtm_dataByRawDeflatingBytes:(const void *)bytes
  466|       |                                 length:(NSUInteger)length
  467|      0|                       compressionLevel:(int)level {
  468|      0|  return [self gtm_dataByRawDeflatingBytes:bytes
  469|      0|                                    length:length
  470|      0|                          compressionLevel:level
  471|      0|                                     error:NULL];
  472|      0|} // gtm_dataByRawDeflatingBytes:length:compressionLevel:
  473|       |
  474|       |+ (NSData *)gtm_dataByRawDeflatingBytes:(const void *)bytes
  475|       |                                 length:(NSUInteger)length
  476|       |                       compressionLevel:(int)level
  477|      0|                                  error:(NSError **)error{
  478|      0|  return [self gtm_dataByCompressingBytes:bytes
  479|      0|                                   length:length
  480|      0|                         compressionLevel:level
  481|      0|                                     mode:CompressionModeRaw
  482|      0|                                    error:error];
  483|      0|} // gtm_dataByRawDeflatingBytes:length:compressionLevel:error:
  484|       |
  485|       |+ (NSData *)gtm_dataByRawDeflatingData:(NSData *)data
  486|      0|                      compressionLevel:(int)level {
  487|      0|  return [self gtm_dataByRawDeflatingData:data
  488|      0|                         compressionLevel:level
  489|      0|                                    error:NULL];
  490|      0|} // gtm_dataByRawDeflatingData:compressionLevel:
  491|       |
  492|       |+ (NSData *)gtm_dataByRawDeflatingData:(NSData *)data
  493|       |                      compressionLevel:(int)level
  494|      0|                                 error:(NSError **)error {
  495|      0|  return [self gtm_dataByCompressingBytes:[data bytes]
  496|      0|                                   length:[data length]
  497|      0|                         compressionLevel:level
  498|      0|                                     mode:CompressionModeRaw
  499|      0|                                    error:error];
  500|      0|} // gtm_dataByRawDeflatingData:compressionLevel:error:
  501|       |
  502|       |+ (NSData *)gtm_dataByRawInflatingBytes:(const void *)bytes
  503|      0|                                 length:(NSUInteger)length {
  504|      0|  return [self gtm_dataByInflatingBytes:bytes
  505|      0|                                 length:length
  506|      0|                                  error:NULL];
  507|      0|} // gtm_dataByRawInflatingBytes:length:
  508|       |
  509|       |+ (NSData *)gtm_dataByRawInflatingBytes:(const void *)bytes
  510|       |                                 length:(NSUInteger)length
  511|      0|                                  error:(NSError **)error{
  512|      0|  return [self gtm_dataByInflatingBytes:bytes
  513|      0|                                 length:length
  514|      0|                              isRawData:YES
  515|      0|                                  error:error];
  516|      0|} // gtm_dataByRawInflatingBytes:length:error:
  517|       |
  518|      0|+ (NSData *)gtm_dataByRawInflatingData:(NSData *)data {
  519|      0|  return [self gtm_dataByRawInflatingData:data
  520|      0|                                    error:NULL];
  521|      0|} // gtm_dataByRawInflatingData:
  522|       |
  523|       |+ (NSData *)gtm_dataByRawInflatingData:(NSData *)data
  524|      0|                                 error:(NSError **)error {
  525|      0|  return [self gtm_dataByInflatingBytes:[data bytes]
  526|      0|                                 length:[data length]
  527|      0|                              isRawData:YES
  528|      0|                                  error:error];
  529|      0|} // gtm_dataByRawInflatingData:error:
  530|       |
  531|       |@end

/Users/won/IO/Switcher-m-iOS/Pods/GoogleToolboxForMac/GTMDefines.h:
    1|       |//
    2|       |// GTMDefines.h
    3|       |//
    4|       |//  Copyright 2008 Google Inc.
    5|       |//
    6|       |//  Licensed under the Apache License, Version 2.0 (the "License"); you may not
    7|       |//  use this file except in compliance with the License.  You may obtain a copy
    8|       |//  of the License at
    9|       |//
   10|       |//  http://www.apache.org/licenses/LICENSE-2.0
   11|       |//
   12|       |//  Unless required by applicable law or agreed to in writing, software
   13|       |//  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
   14|       |//  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
   15|       |//  License for the specific language governing permissions and limitations under
   16|       |//  the License.
   17|       |//
   18|       |
   19|       |// ============================================================================
   20|       |
   21|       |#include <AvailabilityMacros.h>
   22|       |#include <TargetConditionals.h>
   23|       |
   24|       |#ifdef __OBJC__
   25|       |#include <Foundation/NSObjCRuntime.h>
   26|       |#endif  // __OBJC__
   27|       |
   28|       |#if TARGET_OS_IPHONE
   29|       |#include <Availability.h>
   30|       |#endif  // TARGET_OS_IPHONE
   31|       |
   32|       |// ----------------------------------------------------------------------------
   33|       |// CPP symbols that can be overridden in a prefix to control how the toolbox
   34|       |// is compiled.
   35|       |// ----------------------------------------------------------------------------
   36|       |
   37|       |
   38|       |// By setting the GTM_CONTAINERS_VALIDATION_FAILED_LOG and
   39|       |// GTM_CONTAINERS_VALIDATION_FAILED_ASSERT macros you can control what happens
   40|       |// when a validation fails. If you implement your own validators, you may want
   41|       |// to control their internals using the same macros for consistency.
   42|       |#ifndef GTM_CONTAINERS_VALIDATION_FAILED_ASSERT
   43|       |  #define GTM_CONTAINERS_VALIDATION_FAILED_ASSERT 0
   44|       |#endif
   45|       |
   46|       |// Ensure __has_feature and __has_extension are safe to use.
   47|       |// See http://clang-analyzer.llvm.org/annotations.html
   48|       |#ifndef __has_feature      // Optional.
   49|       |  #define __has_feature(x) 0 // Compatibility with non-clang compilers.
   50|       |#endif
   51|       |
   52|       |#ifndef __has_extension
   53|       |  #define __has_extension __has_feature // Compatibility with pre-3.0 compilers.
   54|       |#endif
   55|       |
   56|       |// Give ourselves a consistent way to do inlines.  Apple's macros even use
   57|       |// a few different actual definitions, so we're based off of the foundation
   58|       |// one.
   59|       |#if !defined(GTM_INLINE)
   60|       |  #if (defined (__GNUC__) && (__GNUC__ == 4)) || defined (__clang__)
   61|       |    #define GTM_INLINE static __inline__ __attribute__((always_inline))
   62|       |  #else
   63|       |    #define GTM_INLINE static __inline__
   64|       |  #endif
   65|       |#endif
   66|       |
   67|       |// Give ourselves a consistent way of doing externs that links up nicely
   68|       |// when mixing objc and objc++
   69|       |#if !defined (GTM_EXTERN)
   70|       |  #if defined __cplusplus
   71|       |    #define GTM_EXTERN extern "C"
   72|       |    #define GTM_EXTERN_C_BEGIN extern "C" {
   73|       |    #define GTM_EXTERN_C_END }
   74|       |  #else
   75|       |    #define GTM_EXTERN extern
   76|       |    #define GTM_EXTERN_C_BEGIN
   77|       |    #define GTM_EXTERN_C_END
   78|       |  #endif
   79|       |#endif
   80|       |
   81|       |// Give ourselves a consistent way of exporting things if we have visibility
   82|       |// set to hidden.
   83|       |#if !defined (GTM_EXPORT)
   84|       |  #define GTM_EXPORT __attribute__((visibility("default")))
   85|       |#endif
   86|       |
   87|       |// Give ourselves a consistent way of declaring something as unused. This
   88|       |// doesn't use __unused because that is only supported in gcc 4.2 and greater.
   89|       |#if !defined (GTM_UNUSED)
   90|       |#define GTM_UNUSED(x) ((void)(x))
   91|       |#endif
   92|       |
   93|       |// _GTMDevLog & _GTMDevAssert
   94|       |//
   95|       |// _GTMDevLog & _GTMDevAssert are meant to be a very lightweight shell for
   96|       |// developer level errors.  This implementation simply macros to NSLog/NSAssert.
   97|       |// It is not intended to be a general logging/reporting system.
   98|       |//
   99|       |// Please see http://code.google.com/p/google-toolbox-for-mac/wiki/DevLogNAssert
  100|       |// for a little more background on the usage of these macros.
  101|       |//
  102|       |//    _GTMDevLog           log some error/problem in debug builds
  103|       |//    _GTMDevAssert        assert if condition isn't met w/in a method/function
  104|       |//                           in all builds.
  105|       |//
  106|       |// To replace this system, just provide different macro definitions in your
  107|       |// prefix header.  Remember, any implementation you provide *must* be thread
  108|       |// safe since this could be called by anything in what ever situtation it has
  109|       |// been placed in.
  110|       |//
  111|       |
  112|       |// We only define the simple macros if nothing else has defined this.
  113|       |#ifndef _GTMDevLog
  114|       |
  115|       |#ifdef DEBUG
  116|       |  #define _GTMDevLog(...) NSLog(__VA_ARGS__)
  117|       |#else
  118|       |  #define _GTMDevLog(...) do { } while (0)
  119|       |#endif
  120|       |
  121|       |#endif // _GTMDevLog
  122|       |
  123|       |#ifndef _GTMDevAssert
  124|       |// we directly invoke the NSAssert handler so we can pass on the varargs
  125|       |// (NSAssert doesn't have a macro we can use that takes varargs)
  126|       |#if !defined(NS_BLOCK_ASSERTIONS)
  127|       |  #define _GTMDevAssert(condition, ...)                                       \
  128|      6|    do {                                                                      \
  129|      6|      if (!(condition)) {                                                     \
  130|      0|        [[NSAssertionHandler currentHandler]                                  \
  131|      0|            handleFailureInFunction:(NSString *)                              \
  132|      0|                                        [NSString stringWithUTF8String:__PRETTY_FUNCTION__] \
  133|      0|                               file:(NSString *)[NSString stringWithUTF8String:__FILE__]  \
  134|      0|                         lineNumber:__LINE__                                  \
  135|      0|                        description:__VA_ARGS__];                             \
  136|      0|      }                                                                       \
  137|      6|    } while(0)
  138|       |#else // !defined(NS_BLOCK_ASSERTIONS)
  139|       |  #define _GTMDevAssert(condition, ...) do { } while (0)
  140|       |#endif // !defined(NS_BLOCK_ASSERTIONS)
  141|       |
  142|       |#endif // _GTMDevAssert
  143|       |
  144|       |// _GTMCompileAssert
  145|       |//
  146|       |// Note:  Software for current compilers should just use _Static_assert directly
  147|       |// instead of this macro.
  148|       |//
  149|       |// _GTMCompileAssert is an assert that is meant to fire at compile time if you
  150|       |// want to check things at compile instead of runtime. For example if you
  151|       |// want to check that a wchar is 4 bytes instead of 2 you would use
  152|       |// _GTMCompileAssert(sizeof(wchar_t) == 4, wchar_t_is_4_bytes_on_OS_X)
  153|       |// Note that the second "arg" is not in quotes, and must be a valid processor
  154|       |// symbol in it's own right (no spaces, punctuation etc).
  155|       |
  156|       |// Wrapping this in an #ifndef allows external groups to define their own
  157|       |// compile time assert scheme.
  158|       |#ifndef _GTMCompileAssert
  159|       |  #if __has_feature(c_static_assert) || __has_extension(c_static_assert)
  160|       |    #define _GTMCompileAssert(test, msg) _Static_assert((test), #msg)
  161|       |  #else
  162|       |    // Pre-Xcode 7 support.
  163|       |    //
  164|       |    // We got this technique from here:
  165|       |    // http://unixjunkie.blogspot.com/2007/10/better-compile-time-asserts_29.html
  166|       |    #define _GTMCompileAssertSymbolInner(line, msg) _GTMCOMPILEASSERT ## line ## __ ## msg
  167|       |    #define _GTMCompileAssertSymbol(line, msg) _GTMCompileAssertSymbolInner(line, msg)
  168|       |    #define _GTMCompileAssert(test, msg) \
  169|       |      typedef char _GTMCompileAssertSymbol(__LINE__, msg) [ ((test) ? 1 : -1) ]
  170|       |  #endif  // __has_feature(c_static_assert) || __has_extension(c_static_assert)
  171|       |#endif // _GTMCompileAssert
  172|       |
  173|       |// ----------------------------------------------------------------------------
  174|       |// CPP symbols defined based on the project settings so the GTM code has
  175|       |// simple things to test against w/o scattering the knowledge of project
  176|       |// setting through all the code.
  177|       |// ----------------------------------------------------------------------------
  178|       |
  179|       |// Provide a single constant CPP symbol that all of GTM uses for ifdefing
  180|       |// iPhone code.
  181|       |#if TARGET_OS_IPHONE // iPhone SDK
  182|       |  // For iPhone specific stuff
  183|       |  #define GTM_IPHONE_SDK 1
  184|       |  #if TARGET_IPHONE_SIMULATOR
  185|       |    #define GTM_IPHONE_DEVICE 0
  186|       |    #define GTM_IPHONE_SIMULATOR 1
  187|       |  #else
  188|       |    #define GTM_IPHONE_DEVICE 1
  189|       |    #define GTM_IPHONE_SIMULATOR 0
  190|       |  #endif  // TARGET_IPHONE_SIMULATOR
  191|       |  // By default, GTM has provided it's own unittesting support, define this
  192|       |  // to use the support provided by Xcode, especially for the Xcode4 support
  193|       |  // for unittesting.
  194|       |  #ifndef GTM_USING_XCTEST
  195|       |    #define GTM_USING_XCTEST 0
  196|       |  #endif
  197|       |  #define GTM_MACOS_SDK 0
  198|       |#else
  199|       |  // For MacOS specific stuff
  200|       |  #define GTM_MACOS_SDK 1
  201|       |  #define GTM_IPHONE_SDK 0
  202|       |  #define GTM_IPHONE_SIMULATOR 0
  203|       |  #define GTM_IPHONE_DEVICE 0
  204|       |  #ifndef GTM_USING_XCTEST
  205|       |    #define GTM_USING_XCTEST 0
  206|       |  #endif
  207|       |#endif
  208|       |
  209|       |// Some of our own availability macros
  210|       |#if GTM_MACOS_SDK
  211|       |#define GTM_AVAILABLE_ONLY_ON_IPHONE UNAVAILABLE_ATTRIBUTE
  212|       |#define GTM_AVAILABLE_ONLY_ON_MACOS
  213|       |#else
  214|       |#define GTM_AVAILABLE_ONLY_ON_IPHONE
  215|       |#define GTM_AVAILABLE_ONLY_ON_MACOS UNAVAILABLE_ATTRIBUTE
  216|       |#endif
  217|       |
  218|       |// GC was dropped by Apple, define the old constant incase anyone still keys
  219|       |// off of it.
  220|       |#ifndef GTM_SUPPORT_GC
  221|       |  #define GTM_SUPPORT_GC 0
  222|       |#endif
  223|       |
  224|       |// Some support for advanced clang static analysis functionality
  225|       |#ifndef NS_RETURNS_RETAINED
  226|       |  #if __has_feature(attribute_ns_returns_retained)
  227|       |    #define NS_RETURNS_RETAINED __attribute__((ns_returns_retained))
  228|       |  #else
  229|       |    #define NS_RETURNS_RETAINED
  230|       |  #endif
  231|       |#endif
  232|       |
  233|       |#ifndef NS_RETURNS_NOT_RETAINED
  234|       |  #if __has_feature(attribute_ns_returns_not_retained)
  235|       |    #define NS_RETURNS_NOT_RETAINED __attribute__((ns_returns_not_retained))
  236|       |  #else
  237|       |    #define NS_RETURNS_NOT_RETAINED
  238|       |  #endif
  239|       |#endif
  240|       |
  241|       |#ifndef CF_RETURNS_RETAINED
  242|       |  #if __has_feature(attribute_cf_returns_retained)
  243|       |    #define CF_RETURNS_RETAINED __attribute__((cf_returns_retained))
  244|       |  #else
  245|       |    #define CF_RETURNS_RETAINED
  246|       |  #endif
  247|       |#endif
  248|       |
  249|       |#ifndef CF_RETURNS_NOT_RETAINED
  250|       |  #if __has_feature(attribute_cf_returns_not_retained)
  251|       |    #define CF_RETURNS_NOT_RETAINED __attribute__((cf_returns_not_retained))
  252|       |  #else
  253|       |    #define CF_RETURNS_NOT_RETAINED
  254|       |  #endif
  255|       |#endif
  256|       |
  257|       |#ifndef NS_CONSUMED
  258|       |  #if __has_feature(attribute_ns_consumed)
  259|       |    #define NS_CONSUMED __attribute__((ns_consumed))
  260|       |  #else
  261|       |    #define NS_CONSUMED
  262|       |  #endif
  263|       |#endif
  264|       |
  265|       |#ifndef CF_CONSUMED
  266|       |  #if __has_feature(attribute_cf_consumed)
  267|       |    #define CF_CONSUMED __attribute__((cf_consumed))
  268|       |  #else
  269|       |    #define CF_CONSUMED
  270|       |  #endif
  271|       |#endif
  272|       |
  273|       |#ifndef NS_CONSUMES_SELF
  274|       |  #if __has_feature(attribute_ns_consumes_self)
  275|       |    #define NS_CONSUMES_SELF __attribute__((ns_consumes_self))
  276|       |  #else
  277|       |    #define NS_CONSUMES_SELF
  278|       |  #endif
  279|       |#endif
  280|       |
  281|       |#ifndef GTM_NONNULL
  282|       |  #if defined(__has_attribute)
  283|       |    #if __has_attribute(nonnull)
  284|       |      #define GTM_NONNULL(x) __attribute__((nonnull x))
  285|       |    #else
  286|       |      #define GTM_NONNULL(x)
  287|       |    #endif
  288|       |  #else
  289|       |    #define GTM_NONNULL(x)
  290|       |  #endif
  291|       |#endif
  292|       |
  293|       |// Invalidates the initializer from which it's called.
  294|       |#ifndef GTMInvalidateInitializer
  295|       |  #if __has_feature(objc_arc)
  296|       |    #define GTMInvalidateInitializer() \
  297|       |      do { \
  298|       |        [self class]; /* Avoid warning of dead store to |self|. */ \
  299|       |        _GTMDevAssert(NO, @"Invalid initializer."); \
  300|       |        return nil; \
  301|       |      } while (0)
  302|       |  #else
  303|       |    #define GTMInvalidateInitializer() \
  304|       |      do { \
  305|       |        [self release]; \
  306|       |        _GTMDevAssert(NO, @"Invalid initializer."); \
  307|       |        return nil; \
  308|       |      } while (0)
  309|       |  #endif
  310|       |#endif
  311|       |
  312|       |#ifndef GTMCFAutorelease
  313|       |  // GTMCFAutorelease returns an id.  In contrast, Apple's CFAutorelease returns
  314|       |  // a CFTypeRef.
  315|       |  #if __has_feature(objc_arc)
  316|       |    #define GTMCFAutorelease(x) CFBridgingRelease(x)
  317|       |  #else
  318|       |    #define GTMCFAutorelease(x) ([(id)x autorelease])
  319|       |  #endif
  320|       |#endif
  321|       |
  322|       |#ifdef __OBJC__
  323|       |
  324|       |
  325|       |// Macro to allow you to create NSStrings out of other macros.
  326|       |// #define FOO foo
  327|       |// NSString *fooString = GTM_NSSTRINGIFY(FOO);
  328|       |#if !defined (GTM_NSSTRINGIFY)
  329|       |  #define GTM_NSSTRINGIFY_INNER(x) @#x
  330|       |  #define GTM_NSSTRINGIFY(x) GTM_NSSTRINGIFY_INNER(x)
  331|       |#endif
  332|       |
  333|       |// Macro to allow fast enumeration when building for 10.5 or later, and
  334|       |// reliance on NSEnumerator for 10.4.  Remember, NSDictionary w/ FastEnumeration
  335|       |// does keys, so pick the right thing, nothing is done on the FastEnumeration
  336|       |// side to be sure you're getting what you wanted.
  337|       |#ifndef GTM_FOREACH_OBJECT
  338|       |  #if TARGET_OS_IPHONE || !(MAC_OS_X_VERSION_MIN_REQUIRED < MAC_OS_X_VERSION_10_5)
  339|       |    #define GTM_FOREACH_ENUMEREE(element, enumeration) \
  340|       |      for (element in enumeration)
  341|       |    #define GTM_FOREACH_OBJECT(element, collection) \
  342|       |      for (element in collection)
  343|       |    #define GTM_FOREACH_KEY(element, collection) \
  344|       |      for (element in collection)
  345|       |  #else
  346|       |    #define GTM_FOREACH_ENUMEREE(element, enumeration) \
  347|       |      for (NSEnumerator *_ ## element ## _enum = enumeration; \
  348|       |           (element = [_ ## element ## _enum nextObject]) != nil; )
  349|       |    #define GTM_FOREACH_OBJECT(element, collection) \
  350|       |      GTM_FOREACH_ENUMEREE(element, [collection objectEnumerator])
  351|       |    #define GTM_FOREACH_KEY(element, collection) \
  352|       |      GTM_FOREACH_ENUMEREE(element, [collection keyEnumerator])
  353|       |  #endif
  354|       |#endif
  355|       |
  356|       |// ============================================================================
  357|       |
  358|       |// GTM_SEL_STRING is for specifying selector (usually property) names to KVC
  359|       |// or KVO methods.
  360|       |// In debug it will generate warnings for undeclared selectors if
  361|       |// -Wunknown-selector is turned on.
  362|       |// In release it will have no runtime overhead.
  363|       |#ifndef GTM_SEL_STRING
  364|       |  #ifdef DEBUG
  365|       |    #define GTM_SEL_STRING(selName) NSStringFromSelector(@selector(selName))
  366|       |  #else
  367|       |    #define GTM_SEL_STRING(selName) @#selName
  368|       |  #endif  // DEBUG
  369|       |#endif  // GTM_SEL_STRING
  370|       |
  371|       |#ifndef GTM_WEAK
  372|       |#if __has_feature(objc_arc_weak)
  373|       |    // With ARC enabled, __weak means a reference that isn't implicitly
  374|       |    // retained.  __weak objects are accessed through runtime functions, so
  375|       |    // they are zeroed out, but this requires OS X 10.7+.
  376|       |    // At clang r251041+, ARC-style zeroing weak references even work in
  377|       |    // non-ARC mode.
  378|       |    #define GTM_WEAK __weak
  379|       |  #elif __has_feature(objc_arc)
  380|       |    // ARC, but targeting 10.6 or older, where zeroing weak references don't
  381|       |    // exist.
  382|       |    #define GTM_WEAK __unsafe_unretained
  383|       |  #else
  384|       |    // With manual reference counting, __weak used to be silently ignored.
  385|       |    // clang r251041 gives it the ARC semantics instead.  This means they
  386|       |    // now require a deployment target of 10.7, while some clients of GTM
  387|       |    // still target 10.6.  In these cases, expand to __unsafe_unretained instead
  388|       |    #define GTM_WEAK
  389|       |  #endif
  390|       |#endif
  391|       |
  392|       |#endif  // __OBJC__

